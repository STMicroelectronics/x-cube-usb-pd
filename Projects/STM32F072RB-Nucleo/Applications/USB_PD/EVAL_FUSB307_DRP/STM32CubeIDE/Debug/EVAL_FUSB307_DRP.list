
EVAL_FUSB307_DRP.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .init         0000000c  00008000  00008000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .text         000171c2  00008010  00008010  00008010  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .fini         0000000c  0001f1d4  0001f1d4  0001f1d4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00000c2b  0001f1e0  0001f1e0  0001f1e0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .ARM.exidx    00000008  0001fe0c  0001fe0c  0001fe0c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .eh_frame     00000004  0001fe14  0001fe14  0001fe14  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .init_array   00000004  0002fe18  0002fe18  0001fe18  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  0002fe1c  0002fe1c  0001fe1c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         000001c0  0002fe20  0002fe20  0001fe20  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          000024a4  0002ffe0  0002ffe0  0001ffe0  2**3
                  ALLOC
 10 .comment      00001857  00000000  00000000  0001ffe0  2**0
                  CONTENTS, READONLY
 11 .iar.rtmodel  000000e2  00000000  00000000  00021837  2**0
                  CONTENTS, READONLY
 12 .iar_vfe_header 0000000c  00000000  00000000  0002191c  2**2
                  CONTENTS, READONLY
 13 .debug_aranges 00001808  00000000  00000000  00021928  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_info   0002e764  00000000  00000000  00023130  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_abbrev 000056b5  00000000  00000000  00051894  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_line   000177da  00000000  00000000  00056f49  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_frame  00007cdc  00000000  00000000  0006e724  2**2
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_str    00092725  00000000  00000000  00076400  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_ranges 000017d8  00000000  00000000  00108b25  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_macro  0001db9e  00000000  00000000  0010a2fd  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .ARM.attributes 0000002e  00000000  00000000  00127e9b  2**0
                  CONTENTS, READONLY

Disassembly of section .init:

00008000 <_init>:
    8000:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    8002:	46c0      	nop			; (mov r8, r8)
    8004:	bcf8      	pop	{r3, r4, r5, r6, r7}
    8006:	bc08      	pop	{r3}
    8008:	469e      	mov	lr, r3
    800a:	4770      	bx	lr

Disassembly of section .text:

00008010 <exit>:
    8010:	4b08      	ldr	r3, [pc, #32]	; (8034 <exit+0x24>)
    8012:	b510      	push	{r4, lr}
    8014:	0004      	movs	r4, r0
    8016:	2b00      	cmp	r3, #0
    8018:	d002      	beq.n	8020 <exit+0x10>
    801a:	2100      	movs	r1, #0
    801c:	e000      	b.n	8020 <exit+0x10>
    801e:	bf00      	nop
    8020:	4b05      	ldr	r3, [pc, #20]	; (8038 <exit+0x28>)
    8022:	6818      	ldr	r0, [r3, #0]
    8024:	6a83      	ldr	r3, [r0, #40]	; 0x28
    8026:	2b00      	cmp	r3, #0
    8028:	d000      	beq.n	802c <exit+0x1c>
    802a:	4798      	blx	r3
    802c:	0020      	movs	r0, r4
    802e:	f017 f8cf 	bl	1f1d0 <_exit>
    8032:	46c0      	nop			; (mov r8, r8)
    8034:	00000000 	.word	0x00000000
    8038:	0001fdd4 	.word	0x0001fdd4

0000803c <__do_global_dtors_aux>:
    803c:	b510      	push	{r4, lr}
    803e:	4c06      	ldr	r4, [pc, #24]	; (8058 <__do_global_dtors_aux+0x1c>)
    8040:	7823      	ldrb	r3, [r4, #0]
    8042:	2b00      	cmp	r3, #0
    8044:	d107      	bne.n	8056 <__do_global_dtors_aux+0x1a>
    8046:	4b05      	ldr	r3, [pc, #20]	; (805c <__do_global_dtors_aux+0x20>)
    8048:	2b00      	cmp	r3, #0
    804a:	d002      	beq.n	8052 <__do_global_dtors_aux+0x16>
    804c:	4804      	ldr	r0, [pc, #16]	; (8060 <__do_global_dtors_aux+0x24>)
    804e:	e000      	b.n	8052 <__do_global_dtors_aux+0x16>
    8050:	bf00      	nop
    8052:	2301      	movs	r3, #1
    8054:	7023      	strb	r3, [r4, #0]
    8056:	bd10      	pop	{r4, pc}
    8058:	0002ffe0 	.word	0x0002ffe0
    805c:	00000000 	.word	0x00000000
    8060:	0001fe14 	.word	0x0001fe14

00008064 <frame_dummy>:
    8064:	4b04      	ldr	r3, [pc, #16]	; (8078 <frame_dummy+0x14>)
    8066:	b510      	push	{r4, lr}
    8068:	2b00      	cmp	r3, #0
    806a:	d003      	beq.n	8074 <frame_dummy+0x10>
    806c:	4903      	ldr	r1, [pc, #12]	; (807c <frame_dummy+0x18>)
    806e:	4804      	ldr	r0, [pc, #16]	; (8080 <frame_dummy+0x1c>)
    8070:	e000      	b.n	8074 <frame_dummy+0x10>
    8072:	bf00      	nop
    8074:	bd10      	pop	{r4, pc}
    8076:	46c0      	nop			; (mov r8, r8)
    8078:	00000000 	.word	0x00000000
    807c:	0002ffe4 	.word	0x0002ffe4
    8080:	0001fe14 	.word	0x0001fe14

00008084 <_mainCRTStartup>:
    8084:	4b16      	ldr	r3, [pc, #88]	; (80e0 <_mainCRTStartup+0x5c>)
    8086:	2b00      	cmp	r3, #0
    8088:	d100      	bne.n	808c <_mainCRTStartup+0x8>
    808a:	4b14      	ldr	r3, [pc, #80]	; (80dc <_mainCRTStartup+0x58>)
    808c:	469d      	mov	sp, r3
    808e:	2240      	movs	r2, #64	; 0x40
    8090:	0292      	lsls	r2, r2, #10
    8092:	1a9a      	subs	r2, r3, r2
    8094:	4692      	mov	sl, r2
    8096:	2100      	movs	r1, #0
    8098:	468b      	mov	fp, r1
    809a:	460f      	mov	r7, r1
    809c:	4813      	ldr	r0, [pc, #76]	; (80ec <_mainCRTStartup+0x68>)
    809e:	4a14      	ldr	r2, [pc, #80]	; (80f0 <_mainCRTStartup+0x6c>)
    80a0:	1a12      	subs	r2, r2, r0
    80a2:	f016 fb00 	bl	1e6a6 <memset>
    80a6:	4b0f      	ldr	r3, [pc, #60]	; (80e4 <_mainCRTStartup+0x60>)
    80a8:	2b00      	cmp	r3, #0
    80aa:	d000      	beq.n	80ae <_mainCRTStartup+0x2a>
    80ac:	4798      	blx	r3
    80ae:	4b0e      	ldr	r3, [pc, #56]	; (80e8 <_mainCRTStartup+0x64>)
    80b0:	2b00      	cmp	r3, #0
    80b2:	d000      	beq.n	80b6 <_mainCRTStartup+0x32>
    80b4:	4798      	blx	r3
    80b6:	2000      	movs	r0, #0
    80b8:	2100      	movs	r1, #0
    80ba:	0004      	movs	r4, r0
    80bc:	000d      	movs	r5, r1
    80be:	480d      	ldr	r0, [pc, #52]	; (80f4 <_mainCRTStartup+0x70>)
    80c0:	2800      	cmp	r0, #0
    80c2:	d002      	beq.n	80ca <_mainCRTStartup+0x46>
    80c4:	480c      	ldr	r0, [pc, #48]	; (80f8 <_mainCRTStartup+0x74>)
    80c6:	e000      	b.n	80ca <_mainCRTStartup+0x46>
    80c8:	bf00      	nop
    80ca:	f016 fab5 	bl	1e638 <__libc_init_array>
    80ce:	0020      	movs	r0, r4
    80d0:	0029      	movs	r1, r5
    80d2:	f000 f8e5 	bl	82a0 <main>
    80d6:	f7ff ff9b 	bl	8010 <exit>
    80da:	46c0      	nop			; (mov r8, r8)
    80dc:	00080000 	.word	0x00080000
	...
    80ec:	0002ffe0 	.word	0x0002ffe0
    80f0:	00032484 	.word	0x00032484
	...

000080fc <LL_FLASH_SetLatency>:
  *         @arg @ref LL_FLASH_LATENCY_0
  *         @arg @ref LL_FLASH_LATENCY_1
  * @retval None
  */
__STATIC_INLINE void LL_FLASH_SetLatency(uint32_t Latency)
{
    80fc:	b580      	push	{r7, lr}
    80fe:	b082      	sub	sp, #8
    8100:	af00      	add	r7, sp, #0
    8102:	6078      	str	r0, [r7, #4]
  MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, Latency);
    8104:	4b06      	ldr	r3, [pc, #24]	; (8120 <LL_FLASH_SetLatency+0x24>)
    8106:	681b      	ldr	r3, [r3, #0]
    8108:	2201      	movs	r2, #1
    810a:	4393      	bics	r3, r2
    810c:	0019      	movs	r1, r3
    810e:	4b04      	ldr	r3, [pc, #16]	; (8120 <LL_FLASH_SetLatency+0x24>)
    8110:	687a      	ldr	r2, [r7, #4]
    8112:	430a      	orrs	r2, r1
    8114:	601a      	str	r2, [r3, #0]
}
    8116:	46c0      	nop			; (mov r8, r8)
    8118:	46bd      	mov	sp, r7
    811a:	b002      	add	sp, #8
    811c:	bd80      	pop	{r7, pc}
    811e:	46c0      	nop			; (mov r8, r8)
    8120:	40022000 	.word	0x40022000

00008124 <LL_RCC_HSI48_Enable>:
  * @brief  Enable HSI48
  * @rmtoll CR2          HSI48ON       LL_RCC_HSI48_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSI48_Enable(void)
{
    8124:	b580      	push	{r7, lr}
    8126:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR2, RCC_CR2_HSI48ON);
    8128:	4b04      	ldr	r3, [pc, #16]	; (813c <LL_RCC_HSI48_Enable+0x18>)
    812a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
    812c:	4b03      	ldr	r3, [pc, #12]	; (813c <LL_RCC_HSI48_Enable+0x18>)
    812e:	2180      	movs	r1, #128	; 0x80
    8130:	0249      	lsls	r1, r1, #9
    8132:	430a      	orrs	r2, r1
    8134:	635a      	str	r2, [r3, #52]	; 0x34
}
    8136:	46c0      	nop			; (mov r8, r8)
    8138:	46bd      	mov	sp, r7
    813a:	bd80      	pop	{r7, pc}
    813c:	40021000 	.word	0x40021000

00008140 <LL_RCC_HSI48_IsReady>:
  * @brief  Check if HSI48 oscillator Ready
  * @rmtoll CR2          HSI48RDY      LL_RCC_HSI48_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_HSI48_IsReady(void)
{
    8140:	b580      	push	{r7, lr}
    8142:	af00      	add	r7, sp, #0
  return (READ_BIT(RCC->CR2, RCC_CR2_HSI48RDY) == (RCC_CR2_HSI48RDY));
    8144:	4b06      	ldr	r3, [pc, #24]	; (8160 <LL_RCC_HSI48_IsReady+0x20>)
    8146:	6b5a      	ldr	r2, [r3, #52]	; 0x34
    8148:	2380      	movs	r3, #128	; 0x80
    814a:	029b      	lsls	r3, r3, #10
    814c:	4013      	ands	r3, r2
    814e:	4a05      	ldr	r2, [pc, #20]	; (8164 <LL_RCC_HSI48_IsReady+0x24>)
    8150:	4694      	mov	ip, r2
    8152:	4463      	add	r3, ip
    8154:	425a      	negs	r2, r3
    8156:	4153      	adcs	r3, r2
    8158:	b2db      	uxtb	r3, r3
}
    815a:	0018      	movs	r0, r3
    815c:	46bd      	mov	sp, r7
    815e:	bd80      	pop	{r7, pc}
    8160:	40021000 	.word	0x40021000
    8164:	fffe0000 	.word	0xfffe0000

00008168 <LL_RCC_SetSysClkSource>:
  *
  *         (*) value not defined in all devices
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetSysClkSource(uint32_t Source)
{
    8168:	b580      	push	{r7, lr}
    816a:	b082      	sub	sp, #8
    816c:	af00      	add	r7, sp, #0
    816e:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, Source);
    8170:	4b06      	ldr	r3, [pc, #24]	; (818c <LL_RCC_SetSysClkSource+0x24>)
    8172:	685b      	ldr	r3, [r3, #4]
    8174:	2203      	movs	r2, #3
    8176:	4393      	bics	r3, r2
    8178:	0019      	movs	r1, r3
    817a:	4b04      	ldr	r3, [pc, #16]	; (818c <LL_RCC_SetSysClkSource+0x24>)
    817c:	687a      	ldr	r2, [r7, #4]
    817e:	430a      	orrs	r2, r1
    8180:	605a      	str	r2, [r3, #4]
}
    8182:	46c0      	nop			; (mov r8, r8)
    8184:	46bd      	mov	sp, r7
    8186:	b002      	add	sp, #8
    8188:	bd80      	pop	{r7, pc}
    818a:	46c0      	nop			; (mov r8, r8)
    818c:	40021000 	.word	0x40021000

00008190 <LL_RCC_GetSysClkSource>:
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_HSI48 (*)
  *
  *         (*) value not defined in all devices
  */
__STATIC_INLINE uint32_t LL_RCC_GetSysClkSource(void)
{
    8190:	b580      	push	{r7, lr}
    8192:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
    8194:	4b03      	ldr	r3, [pc, #12]	; (81a4 <LL_RCC_GetSysClkSource+0x14>)
    8196:	685b      	ldr	r3, [r3, #4]
    8198:	220c      	movs	r2, #12
    819a:	4013      	ands	r3, r2
}
    819c:	0018      	movs	r0, r3
    819e:	46bd      	mov	sp, r7
    81a0:	bd80      	pop	{r7, pc}
    81a2:	46c0      	nop			; (mov r8, r8)
    81a4:	40021000 	.word	0x40021000

000081a8 <LL_RCC_SetAHBPrescaler>:
  *         @arg @ref LL_RCC_SYSCLK_DIV_256
  *         @arg @ref LL_RCC_SYSCLK_DIV_512
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetAHBPrescaler(uint32_t Prescaler)
{
    81a8:	b580      	push	{r7, lr}
    81aa:	b082      	sub	sp, #8
    81ac:	af00      	add	r7, sp, #0
    81ae:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, Prescaler);
    81b0:	4b06      	ldr	r3, [pc, #24]	; (81cc <LL_RCC_SetAHBPrescaler+0x24>)
    81b2:	685b      	ldr	r3, [r3, #4]
    81b4:	22f0      	movs	r2, #240	; 0xf0
    81b6:	4393      	bics	r3, r2
    81b8:	0019      	movs	r1, r3
    81ba:	4b04      	ldr	r3, [pc, #16]	; (81cc <LL_RCC_SetAHBPrescaler+0x24>)
    81bc:	687a      	ldr	r2, [r7, #4]
    81be:	430a      	orrs	r2, r1
    81c0:	605a      	str	r2, [r3, #4]
}
    81c2:	46c0      	nop			; (mov r8, r8)
    81c4:	46bd      	mov	sp, r7
    81c6:	b002      	add	sp, #8
    81c8:	bd80      	pop	{r7, pc}
    81ca:	46c0      	nop			; (mov r8, r8)
    81cc:	40021000 	.word	0x40021000

000081d0 <LL_RCC_SetAPB1Prescaler>:
  *         @arg @ref LL_RCC_APB1_DIV_8
  *         @arg @ref LL_RCC_APB1_DIV_16
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetAPB1Prescaler(uint32_t Prescaler)
{
    81d0:	b580      	push	{r7, lr}
    81d2:	b082      	sub	sp, #8
    81d4:	af00      	add	r7, sp, #0
    81d6:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE, Prescaler);
    81d8:	4b06      	ldr	r3, [pc, #24]	; (81f4 <LL_RCC_SetAPB1Prescaler+0x24>)
    81da:	685b      	ldr	r3, [r3, #4]
    81dc:	4a06      	ldr	r2, [pc, #24]	; (81f8 <LL_RCC_SetAPB1Prescaler+0x28>)
    81de:	4013      	ands	r3, r2
    81e0:	0019      	movs	r1, r3
    81e2:	4b04      	ldr	r3, [pc, #16]	; (81f4 <LL_RCC_SetAPB1Prescaler+0x24>)
    81e4:	687a      	ldr	r2, [r7, #4]
    81e6:	430a      	orrs	r2, r1
    81e8:	605a      	str	r2, [r3, #4]
}
    81ea:	46c0      	nop			; (mov r8, r8)
    81ec:	46bd      	mov	sp, r7
    81ee:	b002      	add	sp, #8
    81f0:	bd80      	pop	{r7, pc}
    81f2:	46c0      	nop			; (mov r8, r8)
    81f4:	40021000 	.word	0x40021000
    81f8:	fffff8ff 	.word	0xfffff8ff

000081fc <LL_RCC_PLL_Enable>:
  * @brief  Enable PLL
  * @rmtoll CR           PLLON         LL_RCC_PLL_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_PLL_Enable(void)
{
    81fc:	b580      	push	{r7, lr}
    81fe:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_PLLON);
    8200:	4b04      	ldr	r3, [pc, #16]	; (8214 <LL_RCC_PLL_Enable+0x18>)
    8202:	681a      	ldr	r2, [r3, #0]
    8204:	4b03      	ldr	r3, [pc, #12]	; (8214 <LL_RCC_PLL_Enable+0x18>)
    8206:	2180      	movs	r1, #128	; 0x80
    8208:	0449      	lsls	r1, r1, #17
    820a:	430a      	orrs	r2, r1
    820c:	601a      	str	r2, [r3, #0]
}
    820e:	46c0      	nop			; (mov r8, r8)
    8210:	46bd      	mov	sp, r7
    8212:	bd80      	pop	{r7, pc}
    8214:	40021000 	.word	0x40021000

00008218 <LL_RCC_PLL_IsReady>:
  * @brief  Check if PLL Ready
  * @rmtoll CR           PLLRDY        LL_RCC_PLL_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_IsReady(void)
{
    8218:	b580      	push	{r7, lr}
    821a:	af00      	add	r7, sp, #0
  return (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY));
    821c:	4b07      	ldr	r3, [pc, #28]	; (823c <LL_RCC_PLL_IsReady+0x24>)
    821e:	681a      	ldr	r2, [r3, #0]
    8220:	2380      	movs	r3, #128	; 0x80
    8222:	049b      	lsls	r3, r3, #18
    8224:	4013      	ands	r3, r2
    8226:	22fe      	movs	r2, #254	; 0xfe
    8228:	0612      	lsls	r2, r2, #24
    822a:	4694      	mov	ip, r2
    822c:	4463      	add	r3, ip
    822e:	425a      	negs	r2, r3
    8230:	4153      	adcs	r3, r2
    8232:	b2db      	uxtb	r3, r3
}
    8234:	0018      	movs	r0, r3
    8236:	46bd      	mov	sp, r7
    8238:	bd80      	pop	{r7, pc}
    823a:	46c0      	nop			; (mov r8, r8)
    823c:	40021000 	.word	0x40021000

00008240 <LL_RCC_PLL_ConfigDomain_SYS>:
  *         @arg @ref LL_RCC_PREDIV_DIV_15
  *         @arg @ref LL_RCC_PREDIV_DIV_16
  * @retval None
  */
__STATIC_INLINE void LL_RCC_PLL_ConfigDomain_SYS(uint32_t Source, uint32_t PLLMul, uint32_t PLLDiv)
{
    8240:	b580      	push	{r7, lr}
    8242:	b084      	sub	sp, #16
    8244:	af00      	add	r7, sp, #0
    8246:	60f8      	str	r0, [r7, #12]
    8248:	60b9      	str	r1, [r7, #8]
    824a:	607a      	str	r2, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PLLSRC | RCC_CFGR_PLLMUL, Source | PLLMul);
    824c:	4b0b      	ldr	r3, [pc, #44]	; (827c <LL_RCC_PLL_ConfigDomain_SYS+0x3c>)
    824e:	685b      	ldr	r3, [r3, #4]
    8250:	4a0b      	ldr	r2, [pc, #44]	; (8280 <LL_RCC_PLL_ConfigDomain_SYS+0x40>)
    8252:	4013      	ands	r3, r2
    8254:	0019      	movs	r1, r3
    8256:	68fa      	ldr	r2, [r7, #12]
    8258:	68bb      	ldr	r3, [r7, #8]
    825a:	431a      	orrs	r2, r3
    825c:	4b07      	ldr	r3, [pc, #28]	; (827c <LL_RCC_PLL_ConfigDomain_SYS+0x3c>)
    825e:	430a      	orrs	r2, r1
    8260:	605a      	str	r2, [r3, #4]
  MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PREDIV, PLLDiv);
    8262:	4b06      	ldr	r3, [pc, #24]	; (827c <LL_RCC_PLL_ConfigDomain_SYS+0x3c>)
    8264:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    8266:	220f      	movs	r2, #15
    8268:	4393      	bics	r3, r2
    826a:	0019      	movs	r1, r3
    826c:	4b03      	ldr	r3, [pc, #12]	; (827c <LL_RCC_PLL_ConfigDomain_SYS+0x3c>)
    826e:	687a      	ldr	r2, [r7, #4]
    8270:	430a      	orrs	r2, r1
    8272:	62da      	str	r2, [r3, #44]	; 0x2c
}
    8274:	46c0      	nop			; (mov r8, r8)
    8276:	46bd      	mov	sp, r7
    8278:	b004      	add	sp, #16
    827a:	bd80      	pop	{r7, pc}
    827c:	40021000 	.word	0x40021000
    8280:	ffc27fff 	.word	0xffc27fff

00008284 <LL_SYSTICK_EnableIT>:
  * @brief  Enable SysTick exception request
  * @rmtoll STK_CTRL     TICKINT       LL_SYSTICK_EnableIT
  * @retval None
  */
__STATIC_INLINE void LL_SYSTICK_EnableIT(void)
{
    8284:	b580      	push	{r7, lr}
    8286:	af00      	add	r7, sp, #0
  SET_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);
    8288:	4b04      	ldr	r3, [pc, #16]	; (829c <LL_SYSTICK_EnableIT+0x18>)
    828a:	681a      	ldr	r2, [r3, #0]
    828c:	4b03      	ldr	r3, [pc, #12]	; (829c <LL_SYSTICK_EnableIT+0x18>)
    828e:	2102      	movs	r1, #2
    8290:	430a      	orrs	r2, r1
    8292:	601a      	str	r2, [r3, #0]
}
    8294:	46c0      	nop			; (mov r8, r8)
    8296:	46bd      	mov	sp, r7
    8298:	bd80      	pop	{r7, pc}
    829a:	46c0      	nop			; (mov r8, r8)
    829c:	e000e010 	.word	0xe000e010

000082a0 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
    82a0:	b580      	push	{r7, lr}
    82a2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN 1 */
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/
  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
    82a4:	f006 f95e 	bl	e564 <HAL_Init>
  /* USER CODE BEGIN Init */
   /* USER CODE END Init */

  /* USER CODE BEGIN SysInit */
 /* Configure the system clock */
  SystemClock_Config();
    82a8:	f000 f82c 	bl	8304 <SystemClock_Config>

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
 /* USER CODE BEGIN 2 */
  HAL_NVIC_SetPriority(SysTick_IRQn, TICK_INT_PRIORITY ,0U);
    82ac:	2301      	movs	r3, #1
    82ae:	425b      	negs	r3, r3
    82b0:	2200      	movs	r2, #0
    82b2:	2103      	movs	r1, #3
    82b4:	0018      	movs	r0, r3
    82b6:	f006 fa69 	bl	e78c <HAL_NVIC_SetPriority>
  LL_SYSTICK_EnableIT();
    82ba:	f7ff ffe3 	bl	8284 <LL_SYSTICK_EnableIT>

  /* USBPD initialisation ---------------------------------*/


  /* Initialize the Device Policy Manager */
  if (USBPD_OK != USBPD_DPM_InitCore())
    82be:	f007 fe95 	bl	ffec <USBPD_DPM_InitCore>
    82c2:	1e03      	subs	r3, r0, #0
    82c4:	d000      	beq.n	82c8 <main+0x28>
  {
    /* error the RTOS can't be started  */
    while(1);
    82c6:	e7fe      	b.n	82c6 <main+0x26>
  }

#if defined(_GUI_INTERFACE)
  /* Initialize GUI before retrieving PDO from RAM */
  GUI_Init(BSP_GetHWBoardVersionName, BSP_GetPDTypeName, HW_IF_PWR_GetVoltage, HW_IF_PWR_GetCurrent);
    82c8:	4b0a      	ldr	r3, [pc, #40]	; (82f4 <main+0x54>)
    82ca:	4a0b      	ldr	r2, [pc, #44]	; (82f8 <main+0x58>)
    82cc:	490b      	ldr	r1, [pc, #44]	; (82fc <main+0x5c>)
    82ce:	480c      	ldr	r0, [pc, #48]	; (8300 <main+0x60>)
    82d0:	f00a ffac 	bl	1322c <GUI_Init>
#endif /* _GUI_INTERFACE */

  /* Initialise the DPM application */
  if (USBPD_OK != USBPD_DPM_UserInit())
    82d4:	f000 f8b6 	bl	8444 <USBPD_DPM_UserInit>
    82d8:	1e03      	subs	r3, r0, #0
    82da:	d000      	beq.n	82de <main+0x3e>
  {
    while(1);
    82dc:	e7fe      	b.n	82dc <main+0x3c>
  }

  /* USER CODE BEGIN RTOS_THREADS */
  /* add threads, ... */
  if (USBPD_OK != USBPD_DPM_InitOS())
    82de:	f007 ff13 	bl	10108 <USBPD_DPM_InitOS>
    82e2:	1e03      	subs	r3, r0, #0
    82e4:	d000      	beq.n	82e8 <main+0x48>
  {
    /* error the RTOS can't be started  */
    while(1);
    82e6:	e7fe      	b.n	82e6 <main+0x46>
  }
  /* USER CODE END RTOS_THREADS */

  USBPD_DPM_Run();
    82e8:	f007 ff64 	bl	101b4 <USBPD_DPM_Run>
    82ec:	2300      	movs	r3, #0
}
    82ee:	0018      	movs	r0, r3
    82f0:	46bd      	mov	sp, r7
    82f2:	bd80      	pop	{r7, pc}
    82f4:	0000e315 	.word	0x0000e315
    82f8:	0000e2f5 	.word	0x0000e2f5
    82fc:	0000de59 	.word	0x0000de59
    8300:	0000de49 	.word	0x0000de49

00008304 <SystemClock_Config>:
  *            Flash Latency(WS)              = 1
  * @param  None
  * @retval None
  */
void SystemClock_Config(void)
{
    8304:	b580      	push	{r7, lr}
    8306:	af00      	add	r7, sp, #0
  /* Set FLASH latency */ 
  LL_FLASH_SetLatency(LL_FLASH_LATENCY_1);
    8308:	2001      	movs	r0, #1
    830a:	f7ff fef7 	bl	80fc <LL_FLASH_SetLatency>

  /* Enable HSI48 and wait for activation*/
  LL_RCC_HSI48_Enable(); 
    830e:	f7ff ff09 	bl	8124 <LL_RCC_HSI48_Enable>
  while(LL_RCC_HSI48_IsReady() != 1) 
    8312:	46c0      	nop			; (mov r8, r8)
    8314:	f7ff ff14 	bl	8140 <LL_RCC_HSI48_IsReady>
    8318:	0003      	movs	r3, r0
    831a:	2b01      	cmp	r3, #1
    831c:	d1fa      	bne.n	8314 <SystemClock_Config+0x10>
  {
  };
  
  /* Main PLL configuration and activation */
  LL_RCC_PLL_ConfigDomain_SYS(LL_RCC_PLLSOURCE_HSI48, LL_RCC_PLL_MUL_2, LL_RCC_PREDIV_DIV_2);
    831e:	23c0      	movs	r3, #192	; 0xc0
    8320:	025b      	lsls	r3, r3, #9
    8322:	2201      	movs	r2, #1
    8324:	2100      	movs	r1, #0
    8326:	0018      	movs	r0, r3
    8328:	f7ff ff8a 	bl	8240 <LL_RCC_PLL_ConfigDomain_SYS>
  
  LL_RCC_PLL_Enable();
    832c:	f7ff ff66 	bl	81fc <LL_RCC_PLL_Enable>
  while(LL_RCC_PLL_IsReady() != 1)
    8330:	46c0      	nop			; (mov r8, r8)
    8332:	f7ff ff71 	bl	8218 <LL_RCC_PLL_IsReady>
    8336:	0003      	movs	r3, r0
    8338:	2b01      	cmp	r3, #1
    833a:	d1fa      	bne.n	8332 <SystemClock_Config+0x2e>
  {
  };
  
  /* Sysclk activation on the main PLL */
  LL_RCC_SetAHBPrescaler(LL_RCC_SYSCLK_DIV_1);
    833c:	2000      	movs	r0, #0
    833e:	f7ff ff33 	bl	81a8 <LL_RCC_SetAHBPrescaler>
  LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_PLL);
    8342:	2002      	movs	r0, #2
    8344:	f7ff ff10 	bl	8168 <LL_RCC_SetSysClkSource>
  while(LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_PLL)
    8348:	46c0      	nop			; (mov r8, r8)
    834a:	f7ff ff21 	bl	8190 <LL_RCC_GetSysClkSource>
    834e:	0003      	movs	r3, r0
    8350:	2b08      	cmp	r3, #8
    8352:	d1fa      	bne.n	834a <SystemClock_Config+0x46>
  {
  };
  
  /* Set APB1 prescaler */
  LL_RCC_SetAPB1Prescaler(LL_RCC_APB1_DIV_1);
    8354:	2000      	movs	r0, #0
    8356:	f7ff ff3b 	bl	81d0 <LL_RCC_SetAPB1Prescaler>
  
  /* Set systick to 1ms in using frequency set to 48MHz */
  /* This frequency can be calculated through LL RCC macro */
  /* ex: __LL_RCC_CALC_PLLCLK_FREQ (HSI48_VALUE, LL_RCC_PLL_MUL_2, LL_RCC_PREDIV_DIV_2) */
  LL_Init1msTick(48000000);
    835a:	4b05      	ldr	r3, [pc, #20]	; (8370 <SystemClock_Config+0x6c>)
    835c:	0018      	movs	r0, r3
    835e:	f007 fe27 	bl	ffb0 <LL_Init1msTick>
  
  /* Update CMSIS variable (which can be updated also through SystemCoreClockUpdate function) */
  LL_SetSystemCoreClock(48000000);
    8362:	4b03      	ldr	r3, [pc, #12]	; (8370 <SystemClock_Config+0x6c>)
    8364:	0018      	movs	r0, r3
    8366:	f007 fe33 	bl	ffd0 <LL_SetSystemCoreClock>
}
    836a:	46c0      	nop			; (mov r8, r8)
    836c:	46bd      	mov	sp, r7
    836e:	bd80      	pop	{r7, pc}
    8370:	02dc6c00 	.word	0x02dc6c00

00008374 <HAL_MspInit>:
  * @note   This function is called from HAL_Init() function to perform system
  *         level initialization (GPIOs, clock, DMA, interrupt).
  * @retval None
  */
void HAL_MspInit(void)
{
    8374:	b580      	push	{r7, lr}
    8376:	b088      	sub	sp, #32
    8378:	af00      	add	r7, sp, #0
  __HAL_RCC_SYSCFG_CLK_ENABLE();
    837a:	4b31      	ldr	r3, [pc, #196]	; (8440 <HAL_MspInit+0xcc>)
    837c:	699a      	ldr	r2, [r3, #24]
    837e:	4b30      	ldr	r3, [pc, #192]	; (8440 <HAL_MspInit+0xcc>)
    8380:	2101      	movs	r1, #1
    8382:	430a      	orrs	r2, r1
    8384:	619a      	str	r2, [r3, #24]
    8386:	4b2e      	ldr	r3, [pc, #184]	; (8440 <HAL_MspInit+0xcc>)
    8388:	699b      	ldr	r3, [r3, #24]
    838a:	2201      	movs	r2, #1
    838c:	4013      	ands	r3, r2
    838e:	61fb      	str	r3, [r7, #28]
    8390:	69fb      	ldr	r3, [r7, #28]
  __HAL_RCC_CRC_CLK_ENABLE();
    8392:	4b2b      	ldr	r3, [pc, #172]	; (8440 <HAL_MspInit+0xcc>)
    8394:	695a      	ldr	r2, [r3, #20]
    8396:	4b2a      	ldr	r3, [pc, #168]	; (8440 <HAL_MspInit+0xcc>)
    8398:	2140      	movs	r1, #64	; 0x40
    839a:	430a      	orrs	r2, r1
    839c:	615a      	str	r2, [r3, #20]
    839e:	4b28      	ldr	r3, [pc, #160]	; (8440 <HAL_MspInit+0xcc>)
    83a0:	695b      	ldr	r3, [r3, #20]
    83a2:	2240      	movs	r2, #64	; 0x40
    83a4:	4013      	ands	r3, r2
    83a6:	61bb      	str	r3, [r7, #24]
    83a8:	69bb      	ldr	r3, [r7, #24]

  /* Enable the RCC peripheral clock associated to all the selected GPIOs */
  __HAL_RCC_GPIOA_CLK_ENABLE();
    83aa:	4b25      	ldr	r3, [pc, #148]	; (8440 <HAL_MspInit+0xcc>)
    83ac:	695a      	ldr	r2, [r3, #20]
    83ae:	4b24      	ldr	r3, [pc, #144]	; (8440 <HAL_MspInit+0xcc>)
    83b0:	2180      	movs	r1, #128	; 0x80
    83b2:	0289      	lsls	r1, r1, #10
    83b4:	430a      	orrs	r2, r1
    83b6:	615a      	str	r2, [r3, #20]
    83b8:	4b21      	ldr	r3, [pc, #132]	; (8440 <HAL_MspInit+0xcc>)
    83ba:	695a      	ldr	r2, [r3, #20]
    83bc:	2380      	movs	r3, #128	; 0x80
    83be:	029b      	lsls	r3, r3, #10
    83c0:	4013      	ands	r3, r2
    83c2:	617b      	str	r3, [r7, #20]
    83c4:	697b      	ldr	r3, [r7, #20]
  __HAL_RCC_GPIOB_CLK_ENABLE();
    83c6:	4b1e      	ldr	r3, [pc, #120]	; (8440 <HAL_MspInit+0xcc>)
    83c8:	695a      	ldr	r2, [r3, #20]
    83ca:	4b1d      	ldr	r3, [pc, #116]	; (8440 <HAL_MspInit+0xcc>)
    83cc:	2180      	movs	r1, #128	; 0x80
    83ce:	02c9      	lsls	r1, r1, #11
    83d0:	430a      	orrs	r2, r1
    83d2:	615a      	str	r2, [r3, #20]
    83d4:	4b1a      	ldr	r3, [pc, #104]	; (8440 <HAL_MspInit+0xcc>)
    83d6:	695a      	ldr	r2, [r3, #20]
    83d8:	2380      	movs	r3, #128	; 0x80
    83da:	02db      	lsls	r3, r3, #11
    83dc:	4013      	ands	r3, r2
    83de:	613b      	str	r3, [r7, #16]
    83e0:	693b      	ldr	r3, [r7, #16]
  __HAL_RCC_GPIOC_CLK_ENABLE();
    83e2:	4b17      	ldr	r3, [pc, #92]	; (8440 <HAL_MspInit+0xcc>)
    83e4:	695a      	ldr	r2, [r3, #20]
    83e6:	4b16      	ldr	r3, [pc, #88]	; (8440 <HAL_MspInit+0xcc>)
    83e8:	2180      	movs	r1, #128	; 0x80
    83ea:	0309      	lsls	r1, r1, #12
    83ec:	430a      	orrs	r2, r1
    83ee:	615a      	str	r2, [r3, #20]
    83f0:	4b13      	ldr	r3, [pc, #76]	; (8440 <HAL_MspInit+0xcc>)
    83f2:	695a      	ldr	r2, [r3, #20]
    83f4:	2380      	movs	r3, #128	; 0x80
    83f6:	031b      	lsls	r3, r3, #12
    83f8:	4013      	ands	r3, r2
    83fa:	60fb      	str	r3, [r7, #12]
    83fc:	68fb      	ldr	r3, [r7, #12]
#if defined(GPIOD)
  __HAL_RCC_GPIOD_CLK_ENABLE();
    83fe:	4b10      	ldr	r3, [pc, #64]	; (8440 <HAL_MspInit+0xcc>)
    8400:	695a      	ldr	r2, [r3, #20]
    8402:	4b0f      	ldr	r3, [pc, #60]	; (8440 <HAL_MspInit+0xcc>)
    8404:	2180      	movs	r1, #128	; 0x80
    8406:	0349      	lsls	r1, r1, #13
    8408:	430a      	orrs	r2, r1
    840a:	615a      	str	r2, [r3, #20]
    840c:	4b0c      	ldr	r3, [pc, #48]	; (8440 <HAL_MspInit+0xcc>)
    840e:	695a      	ldr	r2, [r3, #20]
    8410:	2380      	movs	r3, #128	; 0x80
    8412:	035b      	lsls	r3, r3, #13
    8414:	4013      	ands	r3, r2
    8416:	60bb      	str	r3, [r7, #8]
    8418:	68bb      	ldr	r3, [r7, #8]
#endif /* GPIOD */
#if defined(GPIOF)
  __HAL_RCC_GPIOF_CLK_ENABLE();
    841a:	4b09      	ldr	r3, [pc, #36]	; (8440 <HAL_MspInit+0xcc>)
    841c:	695a      	ldr	r2, [r3, #20]
    841e:	4b08      	ldr	r3, [pc, #32]	; (8440 <HAL_MspInit+0xcc>)
    8420:	2180      	movs	r1, #128	; 0x80
    8422:	03c9      	lsls	r1, r1, #15
    8424:	430a      	orrs	r2, r1
    8426:	615a      	str	r2, [r3, #20]
    8428:	4b05      	ldr	r3, [pc, #20]	; (8440 <HAL_MspInit+0xcc>)
    842a:	695a      	ldr	r2, [r3, #20]
    842c:	2380      	movs	r3, #128	; 0x80
    842e:	03db      	lsls	r3, r3, #15
    8430:	4013      	ands	r3, r2
    8432:	607b      	str	r3, [r7, #4]
    8434:	687b      	ldr	r3, [r7, #4]
#endif /* GPIOD */
}
    8436:	46c0      	nop			; (mov r8, r8)
    8438:	46bd      	mov	sp, r7
    843a:	b008      	add	sp, #32
    843c:	bd80      	pop	{r7, pc}
    843e:	46c0      	nop			; (mov r8, r8)
    8440:	40021000 	.word	0x40021000

00008444 <USBPD_DPM_UserInit>:
/**
  * @brief  Initialize DPM (port power role, PWR_IF, CAD and PE Init procedures)
  * @retval USBPD Status
  */
USBPD_StatusTypeDef USBPD_DPM_UserInit(void)
{
    8444:	b580      	push	{r7, lr}
    8446:	b082      	sub	sp, #8
    8448:	af00      	add	r7, sp, #0
/* USER CODE BEGIN USBPD_DPM_UserInit */

  /* PWR SET UP */
  if(USBPD_OK !=  USBPD_PWR_IF_Init())
    844a:	f002 f9df 	bl	a80c <USBPD_PWR_IF_Init>
    844e:	1e03      	subs	r3, r0, #0
    8450:	d001      	beq.n	8456 <USBPD_DPM_UserInit+0x12>
  {
    return USBPD_ERROR;
    8452:	2302      	movs	r3, #2
    8454:	e01d      	b.n	8492 <USBPD_DPM_UserInit+0x4e>
  }

  if (USBPD_OK != USBPD_VDM_UserInit(USBPD_PORT_0))
    8456:	2000      	movs	r0, #0
    8458:	f002 ff82 	bl	b360 <USBPD_VDM_UserInit>
    845c:	1e03      	subs	r3, r0, #0
    845e:	d001      	beq.n	8464 <USBPD_DPM_UserInit+0x20>
  {
    return USBPD_ERROR;
    8460:	2302      	movs	r3, #2
    8462:	e016      	b.n	8492 <USBPD_DPM_UserInit+0x4e>
  }


#if (osCMSIS < 0x20000U)
  osMessageQDef(MsgBox, DPM_BOX_MESSAGES_MAX, uint32_t);
    8464:	003b      	movs	r3, r7
    8466:	4a0d      	ldr	r2, [pc, #52]	; (849c <USBPD_DPM_UserInit+0x58>)
    8468:	ca03      	ldmia	r2!, {r0, r1}
    846a:	c303      	stmia	r3!, {r0, r1}
  DPMMsgBox = osMessageCreate(osMessageQ(MsgBox), NULL);
    846c:	003b      	movs	r3, r7
    846e:	2100      	movs	r1, #0
    8470:	0018      	movs	r0, r3
    8472:	f008 facf 	bl	10a14 <osMessageCreate>
    8476:	0002      	movs	r2, r0
    8478:	4b09      	ldr	r3, [pc, #36]	; (84a0 <USBPD_DPM_UserInit+0x5c>)
    847a:	601a      	str	r2, [r3, #0]

  if(NULL == osThreadCreate(osThread(DPM), &DPMMsgBox))
    847c:	4a08      	ldr	r2, [pc, #32]	; (84a0 <USBPD_DPM_UserInit+0x5c>)
    847e:	4b09      	ldr	r3, [pc, #36]	; (84a4 <USBPD_DPM_UserInit+0x60>)
    8480:	0011      	movs	r1, r2
    8482:	0018      	movs	r0, r3
    8484:	f008 f9e2 	bl	1084c <osThreadCreate>
    8488:	1e03      	subs	r3, r0, #0
    848a:	d101      	bne.n	8490 <USBPD_DPM_UserInit+0x4c>
#else
  DPMMsgBox = osMessageQueueNew (DPM_BOX_MESSAGES_MAX, sizeof(uint32_t), NULL);
  if (NULL == osThreadNew(USBPD_DPM_UserExecute, &DPMMsgBox, &DPM_Thread_Atrr))
#endif /* osCMSIS < 0x20000U */
  {
    return USBPD_ERROR;
    848c:	2302      	movs	r3, #2
    848e:	e000      	b.n	8492 <USBPD_DPM_UserInit+0x4e>
  }

  return USBPD_OK;
    8490:	2300      	movs	r3, #0
/* USER CODE END USBPD_DPM_UserInit */
}
    8492:	0018      	movs	r0, r3
    8494:	46bd      	mov	sp, r7
    8496:	b002      	add	sp, #8
    8498:	bd80      	pop	{r7, pc}
    849a:	46c0      	nop			; (mov r8, r8)
    849c:	0001f1e4 	.word	0x0001f1e4
    84a0:	0003213c 	.word	0x0003213c
    84a4:	0001f280 	.word	0x0001f280

000084a8 <USBPD_DPM_SetNotification_GUI>:
  * @param  PtrPost       Pointer on function to send GUI notifications
  * @param  PtrSaveInfo   Pointer on function to save information from Port Partner
  * @retval None
  */
void USBPD_DPM_SetNotification_GUI(GUI_NOTIFICATION_FORMAT_SEND PtrFormatSend, GUI_NOTIFICATION_POST PtrPost, GUI_SAVE_INFO PtrSaveInfo)
{
    84a8:	b580      	push	{r7, lr}
    84aa:	b084      	sub	sp, #16
    84ac:	af00      	add	r7, sp, #0
    84ae:	60f8      	str	r0, [r7, #12]
    84b0:	60b9      	str	r1, [r7, #8]
    84b2:	607a      	str	r2, [r7, #4]
  DPM_GUI_PostNotificationMessage   = PtrPost;
    84b4:	4b06      	ldr	r3, [pc, #24]	; (84d0 <USBPD_DPM_SetNotification_GUI+0x28>)
    84b6:	68ba      	ldr	r2, [r7, #8]
    84b8:	601a      	str	r2, [r3, #0]
  DPM_GUI_FormatAndSendNotification = PtrFormatSend;
    84ba:	4b06      	ldr	r3, [pc, #24]	; (84d4 <USBPD_DPM_SetNotification_GUI+0x2c>)
    84bc:	68fa      	ldr	r2, [r7, #12]
    84be:	601a      	str	r2, [r3, #0]
  DPM_GUI_SaveInfo                  = PtrSaveInfo;
    84c0:	4b05      	ldr	r3, [pc, #20]	; (84d8 <USBPD_DPM_SetNotification_GUI+0x30>)
    84c2:	687a      	ldr	r2, [r7, #4]
    84c4:	601a      	str	r2, [r3, #0]
}
    84c6:	46c0      	nop			; (mov r8, r8)
    84c8:	46bd      	mov	sp, r7
    84ca:	b004      	add	sp, #16
    84cc:	bd80      	pop	{r7, pc}
    84ce:	46c0      	nop			; (mov r8, r8)
    84d0:	000300ac 	.word	0x000300ac
    84d4:	000300b0 	.word	0x000300b0
    84d8:	000300b4 	.word	0x000300b4

000084dc <USBPD_DPM_WaitForTime>:
  * @brief  User delay implementation which is OS dependant
  * @param  Time time in ms
  * @retval None
  */
void USBPD_DPM_WaitForTime(uint32_t Time)
{
    84dc:	b580      	push	{r7, lr}
    84de:	b082      	sub	sp, #8
    84e0:	af00      	add	r7, sp, #0
    84e2:	6078      	str	r0, [r7, #4]
/* USER CODE BEGIN USBPD_DPM_WaitForTime */
  osDelay(Time);
    84e4:	687b      	ldr	r3, [r7, #4]
    84e6:	0018      	movs	r0, r3
    84e8:	f008 f9e5 	bl	108b6 <osDelay>
/* USER CODE END USBPD_DPM_WaitForTime */
}
    84ec:	46c0      	nop			; (mov r8, r8)
    84ee:	46bd      	mov	sp, r7
    84f0:	b002      	add	sp, #8
    84f2:	bd80      	pop	{r7, pc}

000084f4 <USBPD_DPM_UserExecute>:
#if (osCMSIS < 0x20000U)
void USBPD_DPM_UserExecute(void const *argument)
#else
void USBPD_DPM_UserExecute(void *argument)
#endif /* osCMSIS < 0x20000U */
{
    84f4:	b590      	push	{r4, r7, lr}
    84f6:	b089      	sub	sp, #36	; 0x24
    84f8:	af00      	add	r7, sp, #0
    84fa:	6078      	str	r0, [r7, #4]
/* USER CODE BEGIN USBPD_DPM_UserExecute */
  /* User code implementation */
  uint32_t _timing = osWaitForever;
    84fc:	2301      	movs	r3, #1
    84fe:	425b      	negs	r3, r3
    8500:	61fb      	str	r3, [r7, #28]
  osMessageQId  queue = *(osMessageQId *)argument;
    8502:	687b      	ldr	r3, [r7, #4]
    8504:	681b      	ldr	r3, [r3, #0]
    8506:	61bb      	str	r3, [r7, #24]

  do
  {
    osEvent event = osMessageGet(queue, _timing);
    8508:	240c      	movs	r4, #12
    850a:	193b      	adds	r3, r7, r4
    850c:	69fa      	ldr	r2, [r7, #28]
    850e:	69b9      	ldr	r1, [r7, #24]
    8510:	0018      	movs	r0, r3
    8512:	f008 facd 	bl	10ab0 <osMessageGet>
    switch (((DPM_USER_EVENT)event.value.v & 0xF))
    8516:	193b      	adds	r3, r7, r4
    8518:	685b      	ldr	r3, [r3, #4]
    851a:	b2db      	uxtb	r3, r3
    851c:	001a      	movs	r2, r3
    851e:	230f      	movs	r3, #15
    8520:	4013      	ands	r3, r2
    8522:	d000      	beq.n	8526 <USBPD_DPM_UserExecute+0x32>

        break;
      }

    default:
      break;
    8524:	e002      	b.n	852c <USBPD_DPM_UserExecute+0x38>
        DPM_ManageAlert();
    8526:	f002 f8bb 	bl	a6a0 <DPM_ManageAlert>
        break;
    852a:	46c0      	nop			; (mov r8, r8)
    }
    _timing = CheckDPMTimers();
    852c:	f002 f884 	bl	a638 <CheckDPMTimers>
    8530:	0003      	movs	r3, r0
    8532:	61fb      	str	r3, [r7, #28]
  {
    8534:	e7e8      	b.n	8508 <USBPD_DPM_UserExecute+0x14>
	...

00008538 <USBPD_DPM_UserCableDetection>:
  * @param  PortNum The handle of the port
  * @param  State CAD state
  * @retval None
  */
void USBPD_DPM_UserCableDetection(uint8_t PortNum, USBPD_CAD_EVENT State)
{
    8538:	b580      	push	{r7, lr}
    853a:	b082      	sub	sp, #8
    853c:	af00      	add	r7, sp, #0
    853e:	0002      	movs	r2, r0
    8540:	1dfb      	adds	r3, r7, #7
    8542:	701a      	strb	r2, [r3, #0]
    8544:	1dbb      	adds	r3, r7, #6
    8546:	1c0a      	adds	r2, r1, #0
    8548:	701a      	strb	r2, [r3, #0]
/* USER CODE BEGIN USBPD_DPM_UserCableDetection */
  switch(State)
    854a:	1dbb      	adds	r3, r7, #6
    854c:	781b      	ldrb	r3, [r3, #0]
    854e:	2b02      	cmp	r3, #2
    8550:	d043      	beq.n	85da <USBPD_DPM_UserCableDetection+0xa2>
    8552:	2b04      	cmp	r3, #4
    8554:	d15e      	bne.n	8614 <USBPD_DPM_UserCableDetection+0xdc>
  {
  case USBPD_CAD_EVENT_ATTEMC:
    /* Save flag to keep information that cable is a EMC. */
    DPM_Ports[PortNum].DPM_CablePDCapable = USBPD_TRUE;
    8556:	1dfb      	adds	r3, r7, #7
    8558:	781b      	ldrb	r3, [r3, #0]
    855a:	4a4e      	ldr	r2, [pc, #312]	; (8694 <USBPD_DPM_UserCableDetection+0x15c>)
    855c:	2160      	movs	r1, #96	; 0x60
    855e:	20b0      	movs	r0, #176	; 0xb0
    8560:	4343      	muls	r3, r0
    8562:	18d3      	adds	r3, r2, r3
    8564:	185b      	adds	r3, r3, r1
    8566:	795a      	ldrb	r2, [r3, #5]
    8568:	2101      	movs	r1, #1
    856a:	430a      	orrs	r2, r1
    856c:	715a      	strb	r2, [r3, #5]
    /* Format and send a notification to GUI if enabled */
    if (NULL != DPM_GUI_FormatAndSendNotification)
    856e:	4b4a      	ldr	r3, [pc, #296]	; (8698 <USBPD_DPM_UserCableDetection+0x160>)
    8570:	681b      	ldr	r3, [r3, #0]
    8572:	2b00      	cmp	r3, #0
    8574:	d006      	beq.n	8584 <USBPD_DPM_UserCableDetection+0x4c>
    {
      DPM_GUI_FormatAndSendNotification(PortNum, DPM_GUI_NOTIF_ISCONNECTED, 0);
    8576:	4b48      	ldr	r3, [pc, #288]	; (8698 <USBPD_DPM_UserCableDetection+0x160>)
    8578:	681b      	ldr	r3, [r3, #0]
    857a:	1dfa      	adds	r2, r7, #7
    857c:	7810      	ldrb	r0, [r2, #0]
    857e:	2200      	movs	r2, #0
    8580:	2120      	movs	r1, #32
    8582:	4798      	blx	r3
    }

    /* Enable VCONN */
    if (USBPD_TRUE == DPM_Params[PortNum].VconnStatus)
    8584:	1dfb      	adds	r3, r7, #7
    8586:	781b      	ldrb	r3, [r3, #0]
    8588:	4a44      	ldr	r2, [pc, #272]	; (869c <USBPD_DPM_UserCableDetection+0x164>)
    858a:	009b      	lsls	r3, r3, #2
    858c:	18d3      	adds	r3, r2, r3
    858e:	785b      	ldrb	r3, [r3, #1]
    8590:	061b      	lsls	r3, r3, #24
    8592:	0fdb      	lsrs	r3, r3, #31
    8594:	b2db      	uxtb	r3, r3
    8596:	2b01      	cmp	r3, #1
    8598:	d108      	bne.n	85ac <USBPD_DPM_UserCableDetection+0x74>
    {
      if (USBPD_OK != USBPD_TCPM_set_vconn(PortNum, USBPD_ENABLE))
    859a:	1dfb      	adds	r3, r7, #7
    859c:	781b      	ldrb	r3, [r3, #0]
    859e:	2101      	movs	r1, #1
    85a0:	0018      	movs	r0, r3
    85a2:	f015 fe6f 	bl	1e284 <USBPD_TCPM_set_vconn>
    85a6:	1e03      	subs	r3, r0, #0
    85a8:	d000      	beq.n	85ac <USBPD_DPM_UserCableDetection+0x74>
      {
        /* Should not occurr */
        while(1);
    85aa:	e7fe      	b.n	85aa <USBPD_DPM_UserCableDetection+0x72>
      }
    }
    /* Save flag to keep information that cable is a EMC. */
    DPM_Ports[PortNum].DPM_CablePDCapable = USBPD_TRUE;
    85ac:	1dfb      	adds	r3, r7, #7
    85ae:	781b      	ldrb	r3, [r3, #0]
    85b0:	4a38      	ldr	r2, [pc, #224]	; (8694 <USBPD_DPM_UserCableDetection+0x15c>)
    85b2:	2160      	movs	r1, #96	; 0x60
    85b4:	20b0      	movs	r0, #176	; 0xb0
    85b6:	4343      	muls	r3, r0
    85b8:	18d3      	adds	r3, r2, r3
    85ba:	185b      	adds	r3, r3, r1
    85bc:	795a      	ldrb	r2, [r3, #5]
    85be:	2101      	movs	r1, #1
    85c0:	430a      	orrs	r2, r1
    85c2:	715a      	strb	r2, [r3, #5]

    DPM_Ports[PortNum].DPM_IsConnected = 1;
    85c4:	1dfb      	adds	r3, r7, #7
    85c6:	781b      	ldrb	r3, [r3, #0]
    85c8:	4a32      	ldr	r2, [pc, #200]	; (8694 <USBPD_DPM_UserCableDetection+0x15c>)
    85ca:	2164      	movs	r1, #100	; 0x64
    85cc:	20b0      	movs	r0, #176	; 0xb0
    85ce:	4343      	muls	r3, r0
    85d0:	18d3      	adds	r3, r2, r3
    85d2:	185b      	adds	r3, r3, r1
    85d4:	2201      	movs	r2, #1
    85d6:	701a      	strb	r2, [r3, #0]
    break;
    85d8:	e058      	b.n	868c <USBPD_DPM_UserCableDetection+0x154>

  case USBPD_CAD_EVENT_ATTACHED:
    /* Format and send a notification to GUI if enabled */
    if (NULL != DPM_GUI_FormatAndSendNotification)
    85da:	4b2f      	ldr	r3, [pc, #188]	; (8698 <USBPD_DPM_UserCableDetection+0x160>)
    85dc:	681b      	ldr	r3, [r3, #0]
    85de:	2b00      	cmp	r3, #0
    85e0:	d006      	beq.n	85f0 <USBPD_DPM_UserCableDetection+0xb8>
    {
      DPM_GUI_FormatAndSendNotification(PortNum, DPM_GUI_NOTIF_ISCONNECTED | DPM_GUI_NOTIF_POWER_EVENT, 0);
    85e2:	4b2d      	ldr	r3, [pc, #180]	; (8698 <USBPD_DPM_UserCableDetection+0x160>)
    85e4:	681b      	ldr	r3, [r3, #0]
    85e6:	1dfa      	adds	r2, r7, #7
    85e8:	7810      	ldrb	r0, [r2, #0]
    85ea:	492d      	ldr	r1, [pc, #180]	; (86a0 <USBPD_DPM_UserCableDetection+0x168>)
    85ec:	2200      	movs	r2, #0
    85ee:	4798      	blx	r3
    }
    if(USBPD_PORTPOWERROLE_SRC == DPM_Params[PortNum].PE_PowerRole)
    85f0:	1dfb      	adds	r3, r7, #7
    85f2:	781a      	ldrb	r2, [r3, #0]
    85f4:	4b29      	ldr	r3, [pc, #164]	; (869c <USBPD_DPM_UserCableDetection+0x164>)
    85f6:	0092      	lsls	r2, r2, #2
    85f8:	5cd3      	ldrb	r3, [r2, r3]
    85fa:	075b      	lsls	r3, r3, #29
    85fc:	0fdb      	lsrs	r3, r3, #31
    {
    }

    DPM_Ports[PortNum].DPM_IsConnected = 1;
    85fe:	1dfb      	adds	r3, r7, #7
    8600:	781b      	ldrb	r3, [r3, #0]
    8602:	4a24      	ldr	r2, [pc, #144]	; (8694 <USBPD_DPM_UserCableDetection+0x15c>)
    8604:	2164      	movs	r1, #100	; 0x64
    8606:	20b0      	movs	r0, #176	; 0xb0
    8608:	4343      	muls	r3, r0
    860a:	18d3      	adds	r3, r2, r3
    860c:	185b      	adds	r3, r3, r1
    860e:	2201      	movs	r2, #1
    8610:	701a      	strb	r2, [r3, #0]
    break;
    8612:	e03b      	b.n	868c <USBPD_DPM_UserCableDetection+0x154>

  case USBPD_CAD_EVENT_DETACHED :
  case USBPD_CAD_EVENT_EMC :
  default :
    /* reset all values received from port partner */
    memset(&DPM_Ports[PortNum], 0, sizeof(DPM_Ports[PortNum]));
    8614:	1dfb      	adds	r3, r7, #7
    8616:	781b      	ldrb	r3, [r3, #0]
    8618:	22b0      	movs	r2, #176	; 0xb0
    861a:	435a      	muls	r2, r3
    861c:	4b1d      	ldr	r3, [pc, #116]	; (8694 <USBPD_DPM_UserCableDetection+0x15c>)
    861e:	18d3      	adds	r3, r2, r3
    8620:	22b0      	movs	r2, #176	; 0xb0
    8622:	2100      	movs	r1, #0
    8624:	0018      	movs	r0, r3
    8626:	f016 f83e 	bl	1e6a6 <memset>
    /* Format and send a notification to GUI if enabled */
    if (NULL != DPM_GUI_FormatAndSendNotification)
    862a:	4b1b      	ldr	r3, [pc, #108]	; (8698 <USBPD_DPM_UserCableDetection+0x160>)
    862c:	681b      	ldr	r3, [r3, #0]
    862e:	2b00      	cmp	r3, #0
    8630:	d006      	beq.n	8640 <USBPD_DPM_UserCableDetection+0x108>
    {
      DPM_GUI_FormatAndSendNotification(PortNum, DPM_GUI_NOTIF_ISCONNECTED | DPM_GUI_NOTIF_POWER_EVENT, 0);
    8632:	4b19      	ldr	r3, [pc, #100]	; (8698 <USBPD_DPM_UserCableDetection+0x160>)
    8634:	681b      	ldr	r3, [r3, #0]
    8636:	1dfa      	adds	r2, r7, #7
    8638:	7810      	ldrb	r0, [r2, #0]
    863a:	4919      	ldr	r1, [pc, #100]	; (86a0 <USBPD_DPM_UserCableDetection+0x168>)
    863c:	2200      	movs	r2, #0
    863e:	4798      	blx	r3
    }
    /* Disable VCONN */
    if (1 == DPM_Params[PortNum].VconnStatus)
    8640:	1dfb      	adds	r3, r7, #7
    8642:	781b      	ldrb	r3, [r3, #0]
    8644:	4a15      	ldr	r2, [pc, #84]	; (869c <USBPD_DPM_UserCableDetection+0x164>)
    8646:	009b      	lsls	r3, r3, #2
    8648:	18d3      	adds	r3, r2, r3
    864a:	785b      	ldrb	r3, [r3, #1]
    864c:	061b      	lsls	r3, r3, #24
    864e:	0fdb      	lsrs	r3, r3, #31
    8650:	b2db      	uxtb	r3, r3
    8652:	2b01      	cmp	r3, #1
    8654:	d108      	bne.n	8668 <USBPD_DPM_UserCableDetection+0x130>
    {
      if (USBPD_OK != USBPD_TCPM_set_vconn(PortNum, USBPD_DISABLE))
    8656:	1dfb      	adds	r3, r7, #7
    8658:	781b      	ldrb	r3, [r3, #0]
    865a:	2100      	movs	r1, #0
    865c:	0018      	movs	r0, r3
    865e:	f015 fe11 	bl	1e284 <USBPD_TCPM_set_vconn>
    8662:	1e03      	subs	r3, r0, #0
    8664:	d000      	beq.n	8668 <USBPD_DPM_UserCableDetection+0x130>
      {
        /* Should not occurr */
        while(1);
    8666:	e7fe      	b.n	8666 <USBPD_DPM_UserCableDetection+0x12e>
      }
    }

    if(USBPD_TRUE == DPM_Params[PortNum].VconnStatus)
    8668:	1dfb      	adds	r3, r7, #7
    866a:	781b      	ldrb	r3, [r3, #0]
    866c:	4a0b      	ldr	r2, [pc, #44]	; (869c <USBPD_DPM_UserCableDetection+0x164>)
    866e:	009b      	lsls	r3, r3, #2
    8670:	18d3      	adds	r3, r2, r3
    8672:	785b      	ldrb	r3, [r3, #1]
    8674:	061b      	lsls	r3, r3, #24
    8676:	0fdb      	lsrs	r3, r3, #31
    8678:	b2db      	uxtb	r3, r3
    867a:	2b01      	cmp	r3, #1
    867c:	d105      	bne.n	868a <USBPD_DPM_UserCableDetection+0x152>
    {
      /* Switch Off Vconn */
      USBPD_DPM_PE_VconnPwr(PortNum, USBPD_DISABLE);
    867e:	1dfb      	adds	r3, r7, #7
    8680:	781b      	ldrb	r3, [r3, #0]
    8682:	2100      	movs	r1, #0
    8684:	0018      	movs	r0, r3
    8686:	f000 fe9d 	bl	93c4 <USBPD_DPM_PE_VconnPwr>
    }
    break;
    868a:	46c0      	nop			; (mov r8, r8)
  }
/* USER CODE END USBPD_DPM_UserCableDetection */
}
    868c:	46c0      	nop			; (mov r8, r8)
    868e:	46bd      	mov	sp, r7
    8690:	b002      	add	sp, #8
    8692:	bd80      	pop	{r7, pc}
    8694:	0002fffc 	.word	0x0002fffc
    8698:	000300b0 	.word	0x000300b0
    869c:	000321d4 	.word	0x000321d4
    86a0:	00008020 	.word	0x00008020

000086a4 <USBPD_DPM_HardReset>:
  * @param  CurrentRole the current role
  * @param  Status      status on hard reset event
  * @retval None
  */
void USBPD_DPM_HardReset(uint8_t PortNum, USBPD_PortPowerRole_TypeDef CurrentRole, USBPD_HR_Status_TypeDef Status)
{
    86a4:	b580      	push	{r7, lr}
    86a6:	b082      	sub	sp, #8
    86a8:	af00      	add	r7, sp, #0
    86aa:	6039      	str	r1, [r7, #0]
    86ac:	0011      	movs	r1, r2
    86ae:	1dfb      	adds	r3, r7, #7
    86b0:	1c02      	adds	r2, r0, #0
    86b2:	701a      	strb	r2, [r3, #0]
    86b4:	1dbb      	adds	r3, r7, #6
    86b6:	1c0a      	adds	r2, r1, #0
    86b8:	701a      	strb	r2, [r3, #0]
/* USER CODE BEGIN USBPD_DPM_HardReset */
  /* Stop Alert timer */
  DPM_Ports[PortNum].DPM_TimerAlert    = 0;
    86ba:	1dfb      	adds	r3, r7, #7
    86bc:	781b      	ldrb	r3, [r3, #0]
    86be:	4a34      	ldr	r2, [pc, #208]	; (8790 <USBPD_DPM_HardReset+0xec>)
    86c0:	218a      	movs	r1, #138	; 0x8a
    86c2:	20b0      	movs	r0, #176	; 0xb0
    86c4:	4343      	muls	r3, r0
    86c6:	18d3      	adds	r3, r2, r3
    86c8:	185b      	adds	r3, r3, r1
    86ca:	2200      	movs	r2, #0
    86cc:	801a      	strh	r2, [r3, #0]
  DPM_Ports[PortNum].DPM_SendAlert.d32 = 0;
    86ce:	1dfb      	adds	r3, r7, #7
    86d0:	781b      	ldrb	r3, [r3, #0]
    86d2:	4a2f      	ldr	r2, [pc, #188]	; (8790 <USBPD_DPM_HardReset+0xec>)
    86d4:	218c      	movs	r1, #140	; 0x8c
    86d6:	20b0      	movs	r0, #176	; 0xb0
    86d8:	4343      	muls	r3, r0
    86da:	18d3      	adds	r3, r2, r3
    86dc:	185b      	adds	r3, r3, r1
    86de:	2200      	movs	r2, #0
    86e0:	601a      	str	r2, [r3, #0]
  /* Reset flag DPM_CableResetOnGoing */
  DPM_Ports[PortNum].DPM_CableResetOnGoing = USBPD_FALSE;
    86e2:	1dfb      	adds	r3, r7, #7
    86e4:	781b      	ldrb	r3, [r3, #0]
    86e6:	4a2a      	ldr	r2, [pc, #168]	; (8790 <USBPD_DPM_HardReset+0xec>)
    86e8:	2160      	movs	r1, #96	; 0x60
    86ea:	20b0      	movs	r0, #176	; 0xb0
    86ec:	4343      	muls	r3, r0
    86ee:	18d3      	adds	r3, r2, r3
    86f0:	185b      	adds	r3, r3, r1
    86f2:	795a      	ldrb	r2, [r3, #5]
    86f4:	2102      	movs	r1, #2
    86f6:	438a      	bics	r2, r1
    86f8:	715a      	strb	r2, [r3, #5]
  switch (Status)
    86fa:	1dbb      	adds	r3, r7, #6
    86fc:	781b      	ldrb	r3, [r3, #0]
    86fe:	2b04      	cmp	r3, #4
    8700:	d017      	beq.n	8732 <USBPD_DPM_HardReset+0x8e>
    8702:	dc02      	bgt.n	870a <USBPD_DPM_HardReset+0x66>
    8704:	2b03      	cmp	r3, #3
    8706:	d005      	beq.n	8714 <USBPD_DPM_HardReset+0x70>
  case USBPD_HR_STATUS_COMPLETED:
    break;
  case USBPD_HR_STATUS_FAILED:
    break;
  default:
      break;
    8708:	e03d      	b.n	8786 <USBPD_DPM_HardReset+0xe2>
  switch (Status)
    870a:	2b05      	cmp	r3, #5
    870c:	d034      	beq.n	8778 <USBPD_DPM_HardReset+0xd4>
    870e:	2b06      	cmp	r3, #6
    8710:	d034      	beq.n	877c <USBPD_DPM_HardReset+0xd8>
      break;
    8712:	e038      	b.n	8786 <USBPD_DPM_HardReset+0xe2>
    if (USBPD_PORTPOWERROLE_SRC == CurrentRole)
    8714:	683b      	ldr	r3, [r7, #0]
    8716:	2b01      	cmp	r3, #1
    8718:	d132      	bne.n	8780 <USBPD_DPM_HardReset+0xdc>
      DPM_AssertRp(PortNum);
    871a:	1dfb      	adds	r3, r7, #7
    871c:	781b      	ldrb	r3, [r3, #0]
    871e:	0018      	movs	r0, r3
    8720:	f001 ff68 	bl	a5f4 <DPM_AssertRp>
      DPM_TurnOffPower(PortNum, USBPD_PORTPOWERROLE_SRC);
    8724:	1dfb      	adds	r3, r7, #7
    8726:	781b      	ldrb	r3, [r3, #0]
    8728:	2101      	movs	r1, #1
    872a:	0018      	movs	r0, r3
    872c:	f001 ff30 	bl	a590 <DPM_TurnOffPower>
    break;
    8730:	e026      	b.n	8780 <USBPD_DPM_HardReset+0xdc>
    if (CurrentRole == USBPD_PORTPOWERROLE_SRC)
    8732:	683b      	ldr	r3, [r7, #0]
    8734:	2b01      	cmp	r3, #1
    8736:	d125      	bne.n	8784 <USBPD_DPM_HardReset+0xe0>
      if (USBPD_TRUE == DPM_Ports[PortNum].DPM_CablePDCapable)
    8738:	1dfb      	adds	r3, r7, #7
    873a:	781b      	ldrb	r3, [r3, #0]
    873c:	4a14      	ldr	r2, [pc, #80]	; (8790 <USBPD_DPM_HardReset+0xec>)
    873e:	2160      	movs	r1, #96	; 0x60
    8740:	20b0      	movs	r0, #176	; 0xb0
    8742:	4343      	muls	r3, r0
    8744:	18d3      	adds	r3, r2, r3
    8746:	185b      	adds	r3, r3, r1
    8748:	795b      	ldrb	r3, [r3, #5]
    874a:	07db      	lsls	r3, r3, #31
    874c:	0fdb      	lsrs	r3, r3, #31
    874e:	b2db      	uxtb	r3, r3
    8750:	2b01      	cmp	r3, #1
    8752:	d109      	bne.n	8768 <USBPD_DPM_HardReset+0xc4>
        DPM_Params[PortNum].VconnStatus = USBPD_TRUE;
    8754:	1dfb      	adds	r3, r7, #7
    8756:	781b      	ldrb	r3, [r3, #0]
    8758:	4a0e      	ldr	r2, [pc, #56]	; (8794 <USBPD_DPM_HardReset+0xf0>)
    875a:	009b      	lsls	r3, r3, #2
    875c:	18d3      	adds	r3, r2, r3
    875e:	785a      	ldrb	r2, [r3, #1]
    8760:	2180      	movs	r1, #128	; 0x80
    8762:	4249      	negs	r1, r1
    8764:	430a      	orrs	r2, r1
    8766:	705a      	strb	r2, [r3, #1]
      DPM_TurnOnPower(PortNum, CurrentRole);
    8768:	683a      	ldr	r2, [r7, #0]
    876a:	1dfb      	adds	r3, r7, #7
    876c:	781b      	ldrb	r3, [r3, #0]
    876e:	0011      	movs	r1, r2
    8770:	0018      	movs	r0, r3
    8772:	f001 ff26 	bl	a5c2 <DPM_TurnOnPower>
    break;
    8776:	e005      	b.n	8784 <USBPD_DPM_HardReset+0xe0>
    break;
    8778:	46c0      	nop			; (mov r8, r8)
    877a:	e004      	b.n	8786 <USBPD_DPM_HardReset+0xe2>
    break;
    877c:	46c0      	nop			; (mov r8, r8)
    877e:	e002      	b.n	8786 <USBPD_DPM_HardReset+0xe2>
    break;
    8780:	46c0      	nop			; (mov r8, r8)
    8782:	e000      	b.n	8786 <USBPD_DPM_HardReset+0xe2>
    break;
    8784:	46c0      	nop			; (mov r8, r8)
  }
/* USER CODE END USBPD_DPM_HardReset */
}
    8786:	46c0      	nop			; (mov r8, r8)
    8788:	46bd      	mov	sp, r7
    878a:	b002      	add	sp, #8
    878c:	bd80      	pop	{r7, pc}
    878e:	46c0      	nop			; (mov r8, r8)
    8790:	0002fffc 	.word	0x0002fffc
    8794:	000321d4 	.word	0x000321d4

00008798 <USBPD_DPM_SetupNewPower>:
  * @brief  Request the DPM to setup the new power level.
  * @param  PortNum The current port number
  * @retval USBPD status
  */
USBPD_StatusTypeDef USBPD_DPM_SetupNewPower(uint8_t PortNum)
{
    8798:	b590      	push	{r4, r7, lr}
    879a:	b085      	sub	sp, #20
    879c:	af00      	add	r7, sp, #0
    879e:	0002      	movs	r2, r0
    87a0:	1dfb      	adds	r3, r7, #7
    87a2:	701a      	strb	r2, [r3, #0]
/* USER CODE BEGIN USBPD_DPM_SetupNewPower */
  USBPD_StatusTypeDef status;
  uint8_t rdoposition, previous_rdoposition;

  /* Retrieve Request DO position from DPM handle : RDO position in the table of PDO (possible value from 1 to 7) */
  rdoposition = DPM_Ports[PortNum].DPM_RDOPosition;
    87a4:	1dfb      	adds	r3, r7, #7
    87a6:	781b      	ldrb	r3, [r3, #0]
    87a8:	4a1d      	ldr	r2, [pc, #116]	; (8820 <USBPD_DPM_SetupNewPower+0x88>)
    87aa:	21b0      	movs	r1, #176	; 0xb0
    87ac:	434b      	muls	r3, r1
    87ae:	18d3      	adds	r3, r2, r3
    87b0:	3340      	adds	r3, #64	; 0x40
    87b2:	681a      	ldr	r2, [r3, #0]
    87b4:	200e      	movs	r0, #14
    87b6:	183b      	adds	r3, r7, r0
    87b8:	701a      	strb	r2, [r3, #0]
  previous_rdoposition = DPM_Ports[PortNum].DPM_RDOPositionPrevious;
    87ba:	1dfb      	adds	r3, r7, #7
    87bc:	781b      	ldrb	r3, [r3, #0]
    87be:	4a18      	ldr	r2, [pc, #96]	; (8820 <USBPD_DPM_SetupNewPower+0x88>)
    87c0:	21b0      	movs	r1, #176	; 0xb0
    87c2:	434b      	muls	r3, r1
    87c4:	18d3      	adds	r3, r2, r3
    87c6:	3350      	adds	r3, #80	; 0x50
    87c8:	681a      	ldr	r2, [r3, #0]
    87ca:	230d      	movs	r3, #13
    87cc:	18fb      	adds	r3, r7, r3
    87ce:	701a      	strb	r2, [r3, #0]

  /* Check if get the right pdo position */
  if (rdoposition > 0)
    87d0:	183b      	adds	r3, r7, r0
    87d2:	781b      	ldrb	r3, [r3, #0]
    87d4:	2b00      	cmp	r3, #0
    87d6:	d011      	beq.n	87fc <USBPD_DPM_SetupNewPower+0x64>
  {
    status = USBPD_PWR_IF_SetProfile(PortNum, rdoposition-1, previous_rdoposition);
    87d8:	230e      	movs	r3, #14
    87da:	18fb      	adds	r3, r7, r3
    87dc:	781b      	ldrb	r3, [r3, #0]
    87de:	3b01      	subs	r3, #1
    87e0:	b2d9      	uxtb	r1, r3
    87e2:	230f      	movs	r3, #15
    87e4:	18fc      	adds	r4, r7, r3
    87e6:	230d      	movs	r3, #13
    87e8:	18fb      	adds	r3, r7, r3
    87ea:	781a      	ldrb	r2, [r3, #0]
    87ec:	1dfb      	adds	r3, r7, #7
    87ee:	781b      	ldrb	r3, [r3, #0]
    87f0:	0018      	movs	r0, r3
    87f2:	f002 f83b 	bl	a86c <USBPD_PWR_IF_SetProfile>
    87f6:	0003      	movs	r3, r0
    87f8:	7023      	strb	r3, [r4, #0]
    87fa:	e00a      	b.n	8812 <USBPD_DPM_SetupNewPower+0x7a>
  }
  else
  {
    /* Put it to VSafe5V */
    status = USBPD_PWR_IF_SetProfile(PortNum, 0, 0);
    87fc:	230f      	movs	r3, #15
    87fe:	18fc      	adds	r4, r7, r3
    8800:	1dfb      	adds	r3, r7, #7
    8802:	781b      	ldrb	r3, [r3, #0]
    8804:	2200      	movs	r2, #0
    8806:	2100      	movs	r1, #0
    8808:	0018      	movs	r0, r3
    880a:	f002 f82f 	bl	a86c <USBPD_PWR_IF_SetProfile>
    880e:	0003      	movs	r3, r0
    8810:	7023      	strb	r3, [r4, #0]
  }

  return status;
    8812:	230f      	movs	r3, #15
    8814:	18fb      	adds	r3, r7, r3
    8816:	781b      	ldrb	r3, [r3, #0]
/* USER CODE END USBPD_DPM_SetupNewPower */
}
    8818:	0018      	movs	r0, r3
    881a:	46bd      	mov	sp, r7
    881c:	b005      	add	sp, #20
    881e:	bd90      	pop	{r4, r7, pc}
    8820:	0002fffc 	.word	0x0002fffc

00008824 <USBPD_DPM_EvaluatePowerRoleSwap>:
  * @brief  Evaluate the swap request from PE.
  * @param  PortNum The current port number
  * @retval USBPD_ACCEPT, USBPD_WAIT, USBPD_REJECT
  */
USBPD_StatusTypeDef USBPD_DPM_EvaluatePowerRoleSwap(uint8_t PortNum)
{
    8824:	b580      	push	{r7, lr}
    8826:	b082      	sub	sp, #8
    8828:	af00      	add	r7, sp, #0
    882a:	0002      	movs	r2, r0
    882c:	1dfb      	adds	r3, r7, #7
    882e:	701a      	strb	r2, [r3, #0]
/* USER CODE BEGIN USBPD_DPM_EvaluatePowerRoleSwap */
  return USBPD_ACCEPT;
    8830:	230a      	movs	r3, #10
/* USER CODE END USBPD_DPM_EvaluatePowerRoleSwap */
}
    8832:	0018      	movs	r0, r3
    8834:	46bd      	mov	sp, r7
    8836:	b002      	add	sp, #8
    8838:	bd80      	pop	{r7, pc}
	...

0000883c <USBPD_DPM_Notification>:
  * @param  PortNum The current port number
  * @param  EventVal @ref USBPD_NotifyEventValue_TypeDef
  * @retval None
  */
void USBPD_DPM_Notification(uint8_t PortNum, USBPD_NotifyEventValue_TypeDef EventVal)
{
    883c:	b590      	push	{r4, r7, lr}
    883e:	b085      	sub	sp, #20
    8840:	af00      	add	r7, sp, #0
    8842:	0002      	movs	r2, r0
    8844:	1dfb      	adds	r3, r7, #7
    8846:	701a      	strb	r2, [r3, #0]
    8848:	1dbb      	adds	r3, r7, #6
    884a:	1c0a      	adds	r2, r1, #0
    884c:	701a      	strb	r2, [r3, #0]
/* USER CODE BEGIN USBPD_DPM_Notification */
  switch(EventVal)
    884e:	1dbb      	adds	r3, r7, #6
    8850:	781b      	ldrb	r3, [r3, #0]
    8852:	2b20      	cmp	r3, #32
    8854:	d100      	bne.n	8858 <USBPD_DPM_Notification+0x1c>
    8856:	e192      	b.n	8b7e <USBPD_DPM_Notification+0x342>
    8858:	dc07      	bgt.n	886a <USBPD_DPM_Notification+0x2e>
    885a:	2b10      	cmp	r3, #16
    885c:	d00e      	beq.n	887c <USBPD_DPM_Notification+0x40>
    885e:	2b1a      	cmp	r3, #26
    8860:	d100      	bne.n	8864 <USBPD_DPM_Notification+0x28>
    8862:	e13a      	b.n	8ada <USBPD_DPM_Notification+0x29e>
    8864:	2b01      	cmp	r3, #1
    8866:	d031      	beq.n	88cc <USBPD_DPM_Notification+0x90>
          DPM_Ports[PortNum].DPM_CableResetOnGoing = USBPD_FALSE;
        }
      }
      break;
    default :
      break;
    8868:	e194      	b.n	8b94 <USBPD_DPM_Notification+0x358>
  switch(EventVal)
    886a:	2b42      	cmp	r3, #66	; 0x42
    886c:	d100      	bne.n	8870 <USBPD_DPM_Notification+0x34>
    886e:	e15b      	b.n	8b28 <USBPD_DPM_Notification+0x2ec>
    8870:	2b50      	cmp	r3, #80	; 0x50
    8872:	d063      	beq.n	893c <USBPD_DPM_Notification+0x100>
    8874:	2b21      	cmp	r3, #33	; 0x21
    8876:	d100      	bne.n	887a <USBPD_DPM_Notification+0x3e>
    8878:	e183      	b.n	8b82 <USBPD_DPM_Notification+0x346>
      break;
    887a:	e18b      	b.n	8b94 <USBPD_DPM_Notification+0x358>
      if ((USBPD_SPECIFICATION_REV3 == DPM_Params[PortNum].PE_SpecRevision)
    887c:	1dfb      	adds	r3, r7, #7
    887e:	781a      	ldrb	r2, [r3, #0]
    8880:	4bcd      	ldr	r3, [pc, #820]	; (8bb8 <USBPD_DPM_Notification+0x37c>)
    8882:	0092      	lsls	r2, r2, #2
    8884:	5cd3      	ldrb	r3, [r2, r3]
    8886:	079b      	lsls	r3, r3, #30
    8888:	0f9b      	lsrs	r3, r3, #30
    888a:	b2db      	uxtb	r3, r3
    888c:	2b02      	cmp	r3, #2
    888e:	d000      	beq.n	8892 <USBPD_DPM_Notification+0x56>
    8890:	e179      	b.n	8b86 <USBPD_DPM_Notification+0x34a>
       && (USBPD_PORTPOWERROLE_SRC == DPM_Params[PortNum].PE_PowerRole))
    8892:	1dfb      	adds	r3, r7, #7
    8894:	781a      	ldrb	r2, [r3, #0]
    8896:	4bc8      	ldr	r3, [pc, #800]	; (8bb8 <USBPD_DPM_Notification+0x37c>)
    8898:	0092      	lsls	r2, r2, #2
    889a:	5cd3      	ldrb	r3, [r2, r3]
    889c:	075b      	lsls	r3, r3, #29
    889e:	0fdb      	lsrs	r3, r3, #31
    88a0:	b2db      	uxtb	r3, r3
    88a2:	2b01      	cmp	r3, #1
    88a4:	d000      	beq.n	88a8 <USBPD_DPM_Notification+0x6c>
    88a6:	e16e      	b.n	8b86 <USBPD_DPM_Notification+0x34a>
        DPM_START_TIMER(PortNum, DPM_TimerAlert, DPM_TIMER_ALERT);
    88a8:	1dfb      	adds	r3, r7, #7
    88aa:	781b      	ldrb	r3, [r3, #0]
    88ac:	4ac3      	ldr	r2, [pc, #780]	; (8bbc <USBPD_DPM_Notification+0x380>)
    88ae:	218a      	movs	r1, #138	; 0x8a
    88b0:	20b0      	movs	r0, #176	; 0xb0
    88b2:	4343      	muls	r3, r0
    88b4:	18d3      	adds	r3, r2, r3
    88b6:	185b      	adds	r3, r3, r1
    88b8:	4ac1      	ldr	r2, [pc, #772]	; (8bc0 <USBPD_DPM_Notification+0x384>)
    88ba:	801a      	strh	r2, [r3, #0]
    88bc:	4bc1      	ldr	r3, [pc, #772]	; (8bc4 <USBPD_DPM_Notification+0x388>)
    88be:	681b      	ldr	r3, [r3, #0]
    88c0:	2200      	movs	r2, #0
    88c2:	2100      	movs	r1, #0
    88c4:	0018      	movs	r0, r3
    88c6:	f008 f8b7 	bl	10a38 <osMessagePut>
      break;
    88ca:	e15c      	b.n	8b86 <USBPD_DPM_Notification+0x34a>
      if (USBPD_PORTPOWERROLE_SNK == DPM_Params[PortNum].PE_PowerRole)
    88cc:	1dfb      	adds	r3, r7, #7
    88ce:	781a      	ldrb	r2, [r3, #0]
    88d0:	4bb9      	ldr	r3, [pc, #740]	; (8bb8 <USBPD_DPM_Notification+0x37c>)
    88d2:	0092      	lsls	r2, r2, #2
    88d4:	5cd3      	ldrb	r3, [r2, r3]
    88d6:	075b      	lsls	r3, r3, #29
    88d8:	0fdb      	lsrs	r3, r3, #31
    88da:	b2db      	uxtb	r3, r3
    88dc:	2b00      	cmp	r3, #0
    88de:	d000      	beq.n	88e2 <USBPD_DPM_Notification+0xa6>
    88e0:	e153      	b.n	8b8a <USBPD_DPM_Notification+0x34e>
        rdo.d32                             = DPM_Ports[PortNum].DPM_RequestDOMsg;
    88e2:	1dfb      	adds	r3, r7, #7
    88e4:	781b      	ldrb	r3, [r3, #0]
    88e6:	4ab5      	ldr	r2, [pc, #724]	; (8bbc <USBPD_DPM_Notification+0x380>)
    88e8:	21b0      	movs	r1, #176	; 0xb0
    88ea:	434b      	muls	r3, r1
    88ec:	18d3      	adds	r3, r2, r3
    88ee:	3354      	adds	r3, #84	; 0x54
    88f0:	681b      	ldr	r3, [r3, #0]
    88f2:	60fb      	str	r3, [r7, #12]
        DPM_Ports[PortNum].DPM_RDOPosition  = rdo.GenericRDO.ObjectPosition;
    88f4:	230f      	movs	r3, #15
    88f6:	18fb      	adds	r3, r7, r3
    88f8:	781b      	ldrb	r3, [r3, #0]
    88fa:	065b      	lsls	r3, r3, #25
    88fc:	0f5b      	lsrs	r3, r3, #29
    88fe:	b2da      	uxtb	r2, r3
    8900:	1dfb      	adds	r3, r7, #7
    8902:	781b      	ldrb	r3, [r3, #0]
    8904:	0010      	movs	r0, r2
    8906:	4aad      	ldr	r2, [pc, #692]	; (8bbc <USBPD_DPM_Notification+0x380>)
    8908:	21b0      	movs	r1, #176	; 0xb0
    890a:	434b      	muls	r3, r1
    890c:	18d3      	adds	r3, r2, r3
    890e:	3340      	adds	r3, #64	; 0x40
    8910:	6018      	str	r0, [r3, #0]
        if (NULL != DPM_GUI_SaveInfo)
    8912:	4bad      	ldr	r3, [pc, #692]	; (8bc8 <USBPD_DPM_Notification+0x38c>)
    8914:	681b      	ldr	r3, [r3, #0]
    8916:	2b00      	cmp	r3, #0
    8918:	d100      	bne.n	891c <USBPD_DPM_Notification+0xe0>
    891a:	e136      	b.n	8b8a <USBPD_DPM_Notification+0x34e>
          DPM_GUI_SaveInfo(PortNum, USBPD_CORE_DATATYPE_RDO_POSITION, (uint8_t*)&DPM_Ports[PortNum].DPM_RDOPosition, 4);
    891c:	4baa      	ldr	r3, [pc, #680]	; (8bc8 <USBPD_DPM_Notification+0x38c>)
    891e:	681c      	ldr	r4, [r3, #0]
    8920:	1dfb      	adds	r3, r7, #7
    8922:	781b      	ldrb	r3, [r3, #0]
    8924:	22b0      	movs	r2, #176	; 0xb0
    8926:	4353      	muls	r3, r2
    8928:	3340      	adds	r3, #64	; 0x40
    892a:	001a      	movs	r2, r3
    892c:	4ba3      	ldr	r3, [pc, #652]	; (8bbc <USBPD_DPM_Notification+0x380>)
    892e:	18d2      	adds	r2, r2, r3
    8930:	1dfb      	adds	r3, r7, #7
    8932:	7818      	ldrb	r0, [r3, #0]
    8934:	2304      	movs	r3, #4
    8936:	2102      	movs	r1, #2
    8938:	47a0      	blx	r4
    break;
    893a:	e126      	b.n	8b8a <USBPD_DPM_Notification+0x34e>
        if ((USBPD_PORTPOWERROLE_SNK == DPM_Params[PortNum].PE_PowerRole)
    893c:	1dfb      	adds	r3, r7, #7
    893e:	781a      	ldrb	r2, [r3, #0]
    8940:	4b9d      	ldr	r3, [pc, #628]	; (8bb8 <USBPD_DPM_Notification+0x37c>)
    8942:	0092      	lsls	r2, r2, #2
    8944:	5cd3      	ldrb	r3, [r2, r3]
    8946:	075b      	lsls	r3, r3, #29
    8948:	0fdb      	lsrs	r3, r3, #31
    894a:	b2db      	uxtb	r3, r3
    894c:	2b00      	cmp	r3, #0
    894e:	d123      	bne.n	8998 <USBPD_DPM_Notification+0x15c>
                 && (USBPD_ADO_TYPE_ALERT_OCP == (DPM_Ports[PortNum].DPM_RcvAlert.b.TypeAlert & USBPD_ADO_TYPE_ALERT_OCP)))
    8950:	1dfb      	adds	r3, r7, #7
    8952:	781b      	ldrb	r3, [r3, #0]
    8954:	4a99      	ldr	r2, [pc, #612]	; (8bbc <USBPD_DPM_Notification+0x380>)
    8956:	2193      	movs	r1, #147	; 0x93
    8958:	20b0      	movs	r0, #176	; 0xb0
    895a:	4343      	muls	r3, r0
    895c:	18d3      	adds	r3, r2, r3
    895e:	185b      	adds	r3, r3, r1
    8960:	781b      	ldrb	r3, [r3, #0]
    8962:	001a      	movs	r2, r3
    8964:	2304      	movs	r3, #4
    8966:	4013      	ands	r3, r2
    8968:	d016      	beq.n	8998 <USBPD_DPM_Notification+0x15c>
          DPM_Ports[PortNum].DPM_RcvAlert.b.TypeAlert &= ~USBPD_ADO_TYPE_ALERT_OCP;
    896a:	1dfb      	adds	r3, r7, #7
    896c:	781b      	ldrb	r3, [r3, #0]
    896e:	4a93      	ldr	r2, [pc, #588]	; (8bbc <USBPD_DPM_Notification+0x380>)
    8970:	2193      	movs	r1, #147	; 0x93
    8972:	20b0      	movs	r0, #176	; 0xb0
    8974:	4343      	muls	r3, r0
    8976:	18d3      	adds	r3, r2, r3
    8978:	185b      	adds	r3, r3, r1
    897a:	781a      	ldrb	r2, [r3, #0]
    897c:	1dfb      	adds	r3, r7, #7
    897e:	781b      	ldrb	r3, [r3, #0]
    8980:	2104      	movs	r1, #4
    8982:	438a      	bics	r2, r1
    8984:	b2d4      	uxtb	r4, r2
    8986:	4a8d      	ldr	r2, [pc, #564]	; (8bbc <USBPD_DPM_Notification+0x380>)
    8988:	2193      	movs	r1, #147	; 0x93
    898a:	20b0      	movs	r0, #176	; 0xb0
    898c:	4343      	muls	r3, r0
    898e:	18d3      	adds	r3, r2, r3
    8990:	185b      	adds	r3, r3, r1
    8992:	1c22      	adds	r2, r4, #0
    8994:	701a      	strb	r2, [r3, #0]
          goto _ctrl_msg;
    8996:	e09a      	b.n	8ace <USBPD_DPM_Notification+0x292>
        else if (USBPD_ADO_TYPE_ALERT_OTP == (DPM_Ports[PortNum].DPM_RcvAlert.b.TypeAlert & USBPD_ADO_TYPE_ALERT_OTP))
    8998:	1dfb      	adds	r3, r7, #7
    899a:	781b      	ldrb	r3, [r3, #0]
    899c:	4a87      	ldr	r2, [pc, #540]	; (8bbc <USBPD_DPM_Notification+0x380>)
    899e:	2193      	movs	r1, #147	; 0x93
    89a0:	20b0      	movs	r0, #176	; 0xb0
    89a2:	4343      	muls	r3, r0
    89a4:	18d3      	adds	r3, r2, r3
    89a6:	185b      	adds	r3, r3, r1
    89a8:	781b      	ldrb	r3, [r3, #0]
    89aa:	001a      	movs	r2, r3
    89ac:	2308      	movs	r3, #8
    89ae:	4013      	ands	r3, r2
    89b0:	d016      	beq.n	89e0 <USBPD_DPM_Notification+0x1a4>
          DPM_Ports[PortNum].DPM_RcvAlert.b.TypeAlert &= ~USBPD_ADO_TYPE_ALERT_OTP;
    89b2:	1dfb      	adds	r3, r7, #7
    89b4:	781b      	ldrb	r3, [r3, #0]
    89b6:	4a81      	ldr	r2, [pc, #516]	; (8bbc <USBPD_DPM_Notification+0x380>)
    89b8:	2193      	movs	r1, #147	; 0x93
    89ba:	20b0      	movs	r0, #176	; 0xb0
    89bc:	4343      	muls	r3, r0
    89be:	18d3      	adds	r3, r2, r3
    89c0:	185b      	adds	r3, r3, r1
    89c2:	781a      	ldrb	r2, [r3, #0]
    89c4:	1dfb      	adds	r3, r7, #7
    89c6:	781b      	ldrb	r3, [r3, #0]
    89c8:	2108      	movs	r1, #8
    89ca:	438a      	bics	r2, r1
    89cc:	b2d4      	uxtb	r4, r2
    89ce:	4a7b      	ldr	r2, [pc, #492]	; (8bbc <USBPD_DPM_Notification+0x380>)
    89d0:	2193      	movs	r1, #147	; 0x93
    89d2:	20b0      	movs	r0, #176	; 0xb0
    89d4:	4343      	muls	r3, r0
    89d6:	18d3      	adds	r3, r2, r3
    89d8:	185b      	adds	r3, r3, r1
    89da:	1c22      	adds	r2, r4, #0
    89dc:	701a      	strb	r2, [r3, #0]
          goto _ctrl_msg;
    89de:	e076      	b.n	8ace <USBPD_DPM_Notification+0x292>
        else if (USBPD_ADO_TYPE_ALERT_OPERATING_COND == (DPM_Ports[PortNum].DPM_RcvAlert.b.TypeAlert & USBPD_ADO_TYPE_ALERT_OPERATING_COND))
    89e0:	1dfb      	adds	r3, r7, #7
    89e2:	781b      	ldrb	r3, [r3, #0]
    89e4:	4a75      	ldr	r2, [pc, #468]	; (8bbc <USBPD_DPM_Notification+0x380>)
    89e6:	2193      	movs	r1, #147	; 0x93
    89e8:	20b0      	movs	r0, #176	; 0xb0
    89ea:	4343      	muls	r3, r0
    89ec:	18d3      	adds	r3, r2, r3
    89ee:	185b      	adds	r3, r3, r1
    89f0:	781b      	ldrb	r3, [r3, #0]
    89f2:	001a      	movs	r2, r3
    89f4:	2310      	movs	r3, #16
    89f6:	4013      	ands	r3, r2
    89f8:	d016      	beq.n	8a28 <USBPD_DPM_Notification+0x1ec>
          DPM_Ports[PortNum].DPM_RcvAlert.b.TypeAlert &= ~USBPD_ADO_TYPE_ALERT_OPERATING_COND;
    89fa:	1dfb      	adds	r3, r7, #7
    89fc:	781b      	ldrb	r3, [r3, #0]
    89fe:	4a6f      	ldr	r2, [pc, #444]	; (8bbc <USBPD_DPM_Notification+0x380>)
    8a00:	2193      	movs	r1, #147	; 0x93
    8a02:	20b0      	movs	r0, #176	; 0xb0
    8a04:	4343      	muls	r3, r0
    8a06:	18d3      	adds	r3, r2, r3
    8a08:	185b      	adds	r3, r3, r1
    8a0a:	781a      	ldrb	r2, [r3, #0]
    8a0c:	1dfb      	adds	r3, r7, #7
    8a0e:	781b      	ldrb	r3, [r3, #0]
    8a10:	2110      	movs	r1, #16
    8a12:	438a      	bics	r2, r1
    8a14:	b2d4      	uxtb	r4, r2
    8a16:	4a69      	ldr	r2, [pc, #420]	; (8bbc <USBPD_DPM_Notification+0x380>)
    8a18:	2193      	movs	r1, #147	; 0x93
    8a1a:	20b0      	movs	r0, #176	; 0xb0
    8a1c:	4343      	muls	r3, r0
    8a1e:	18d3      	adds	r3, r2, r3
    8a20:	185b      	adds	r3, r3, r1
    8a22:	1c22      	adds	r2, r4, #0
    8a24:	701a      	strb	r2, [r3, #0]
          goto _ctrl_msg;
    8a26:	e052      	b.n	8ace <USBPD_DPM_Notification+0x292>
        else if (USBPD_ADO_TYPE_ALERT_SRC_INPUT == (DPM_Ports[PortNum].DPM_RcvAlert.b.TypeAlert & USBPD_ADO_TYPE_ALERT_SRC_INPUT))
    8a28:	1dfb      	adds	r3, r7, #7
    8a2a:	781b      	ldrb	r3, [r3, #0]
    8a2c:	4a63      	ldr	r2, [pc, #396]	; (8bbc <USBPD_DPM_Notification+0x380>)
    8a2e:	2193      	movs	r1, #147	; 0x93
    8a30:	20b0      	movs	r0, #176	; 0xb0
    8a32:	4343      	muls	r3, r0
    8a34:	18d3      	adds	r3, r2, r3
    8a36:	185b      	adds	r3, r3, r1
    8a38:	781b      	ldrb	r3, [r3, #0]
    8a3a:	001a      	movs	r2, r3
    8a3c:	2320      	movs	r3, #32
    8a3e:	4013      	ands	r3, r2
    8a40:	d016      	beq.n	8a70 <USBPD_DPM_Notification+0x234>
          DPM_Ports[PortNum].DPM_RcvAlert.b.TypeAlert &= ~USBPD_ADO_TYPE_ALERT_SRC_INPUT;
    8a42:	1dfb      	adds	r3, r7, #7
    8a44:	781b      	ldrb	r3, [r3, #0]
    8a46:	4a5d      	ldr	r2, [pc, #372]	; (8bbc <USBPD_DPM_Notification+0x380>)
    8a48:	2193      	movs	r1, #147	; 0x93
    8a4a:	20b0      	movs	r0, #176	; 0xb0
    8a4c:	4343      	muls	r3, r0
    8a4e:	18d3      	adds	r3, r2, r3
    8a50:	185b      	adds	r3, r3, r1
    8a52:	781a      	ldrb	r2, [r3, #0]
    8a54:	1dfb      	adds	r3, r7, #7
    8a56:	781b      	ldrb	r3, [r3, #0]
    8a58:	2120      	movs	r1, #32
    8a5a:	438a      	bics	r2, r1
    8a5c:	b2d4      	uxtb	r4, r2
    8a5e:	4a57      	ldr	r2, [pc, #348]	; (8bbc <USBPD_DPM_Notification+0x380>)
    8a60:	2193      	movs	r1, #147	; 0x93
    8a62:	20b0      	movs	r0, #176	; 0xb0
    8a64:	4343      	muls	r3, r0
    8a66:	18d3      	adds	r3, r2, r3
    8a68:	185b      	adds	r3, r3, r1
    8a6a:	1c22      	adds	r2, r4, #0
    8a6c:	701a      	strb	r2, [r3, #0]
          goto _ctrl_msg;
    8a6e:	e02e      	b.n	8ace <USBPD_DPM_Notification+0x292>
          if ((USBPD_PORTPOWERROLE_SRC == DPM_Params[PortNum].PE_PowerRole)
    8a70:	1dfb      	adds	r3, r7, #7
    8a72:	781a      	ldrb	r2, [r3, #0]
    8a74:	4b50      	ldr	r3, [pc, #320]	; (8bb8 <USBPD_DPM_Notification+0x37c>)
    8a76:	0092      	lsls	r2, r2, #2
    8a78:	5cd3      	ldrb	r3, [r2, r3]
    8a7a:	075b      	lsls	r3, r3, #29
    8a7c:	0fdb      	lsrs	r3, r3, #31
    8a7e:	b2db      	uxtb	r3, r3
    8a80:	2b01      	cmp	r3, #1
    8a82:	d123      	bne.n	8acc <USBPD_DPM_Notification+0x290>
                 && (USBPD_ADO_TYPE_ALERT_OVP == (DPM_Ports[PortNum].DPM_RcvAlert.b.TypeAlert & USBPD_ADO_TYPE_ALERT_OVP)))
    8a84:	1dfb      	adds	r3, r7, #7
    8a86:	781b      	ldrb	r3, [r3, #0]
    8a88:	4a4c      	ldr	r2, [pc, #304]	; (8bbc <USBPD_DPM_Notification+0x380>)
    8a8a:	2193      	movs	r1, #147	; 0x93
    8a8c:	20b0      	movs	r0, #176	; 0xb0
    8a8e:	4343      	muls	r3, r0
    8a90:	18d3      	adds	r3, r2, r3
    8a92:	185b      	adds	r3, r3, r1
    8a94:	781b      	ldrb	r3, [r3, #0]
    8a96:	001a      	movs	r2, r3
    8a98:	2340      	movs	r3, #64	; 0x40
    8a9a:	4013      	ands	r3, r2
    8a9c:	d016      	beq.n	8acc <USBPD_DPM_Notification+0x290>
            DPM_Ports[PortNum].DPM_RcvAlert.b.TypeAlert &= ~USBPD_ADO_TYPE_ALERT_OVP;
    8a9e:	1dfb      	adds	r3, r7, #7
    8aa0:	781b      	ldrb	r3, [r3, #0]
    8aa2:	4a46      	ldr	r2, [pc, #280]	; (8bbc <USBPD_DPM_Notification+0x380>)
    8aa4:	2193      	movs	r1, #147	; 0x93
    8aa6:	20b0      	movs	r0, #176	; 0xb0
    8aa8:	4343      	muls	r3, r0
    8aaa:	18d3      	adds	r3, r2, r3
    8aac:	185b      	adds	r3, r3, r1
    8aae:	781a      	ldrb	r2, [r3, #0]
    8ab0:	1dfb      	adds	r3, r7, #7
    8ab2:	781b      	ldrb	r3, [r3, #0]
    8ab4:	2140      	movs	r1, #64	; 0x40
    8ab6:	438a      	bics	r2, r1
    8ab8:	b2d4      	uxtb	r4, r2
    8aba:	4a40      	ldr	r2, [pc, #256]	; (8bbc <USBPD_DPM_Notification+0x380>)
    8abc:	2193      	movs	r1, #147	; 0x93
    8abe:	20b0      	movs	r0, #176	; 0xb0
    8ac0:	4343      	muls	r3, r0
    8ac2:	18d3      	adds	r3, r2, r3
    8ac4:	185b      	adds	r3, r3, r1
    8ac6:	1c22      	adds	r2, r4, #0
    8ac8:	701a      	strb	r2, [r3, #0]
            goto _ctrl_msg;
    8aca:	e000      	b.n	8ace <USBPD_DPM_Notification+0x292>
        _ctrl_msg:
    8acc:	46c0      	nop			; (mov r8, r8)
          USBPD_DPM_RequestGetStatus(PortNum);
    8ace:	1dfb      	adds	r3, r7, #7
    8ad0:	781b      	ldrb	r3, [r3, #0]
    8ad2:	0018      	movs	r0, r3
    8ad4:	f000 ffbc 	bl	9a50 <USBPD_DPM_RequestGetStatus>
      break;
    8ad8:	e05c      	b.n	8b94 <USBPD_DPM_Notification+0x358>
        if ((USBPD_PORTDATAROLE_DFP == DPM_Params[PortNum].PE_DataRole) && (USBPD_FALSE == DPM_Params[PortNum].VconnStatus))
    8ada:	1dfb      	adds	r3, r7, #7
    8adc:	781a      	ldrb	r2, [r3, #0]
    8ade:	4b36      	ldr	r3, [pc, #216]	; (8bb8 <USBPD_DPM_Notification+0x37c>)
    8ae0:	0092      	lsls	r2, r2, #2
    8ae2:	5cd3      	ldrb	r3, [r2, r3]
    8ae4:	071b      	lsls	r3, r3, #28
    8ae6:	0fdb      	lsrs	r3, r3, #31
    8ae8:	b2db      	uxtb	r3, r3
    8aea:	2b01      	cmp	r3, #1
    8aec:	d14f      	bne.n	8b8e <USBPD_DPM_Notification+0x352>
    8aee:	1dfb      	adds	r3, r7, #7
    8af0:	781b      	ldrb	r3, [r3, #0]
    8af2:	4a31      	ldr	r2, [pc, #196]	; (8bb8 <USBPD_DPM_Notification+0x37c>)
    8af4:	009b      	lsls	r3, r3, #2
    8af6:	18d3      	adds	r3, r2, r3
    8af8:	785b      	ldrb	r3, [r3, #1]
    8afa:	061b      	lsls	r3, r3, #24
    8afc:	0fdb      	lsrs	r3, r3, #31
    8afe:	b2db      	uxtb	r3, r3
    8b00:	2b00      	cmp	r3, #0
    8b02:	d144      	bne.n	8b8e <USBPD_DPM_Notification+0x352>
          USBPD_DPM_RequestVconnSwap(PortNum);
    8b04:	1dfb      	adds	r3, r7, #7
    8b06:	781b      	ldrb	r3, [r3, #0]
    8b08:	0018      	movs	r0, r3
    8b0a:	f000 fe65 	bl	97d8 <USBPD_DPM_RequestVconnSwap>
          DPM_Ports[PortNum].DPM_CableResetOnGoing = USBPD_TRUE;
    8b0e:	1dfb      	adds	r3, r7, #7
    8b10:	781b      	ldrb	r3, [r3, #0]
    8b12:	4a2a      	ldr	r2, [pc, #168]	; (8bbc <USBPD_DPM_Notification+0x380>)
    8b14:	2160      	movs	r1, #96	; 0x60
    8b16:	20b0      	movs	r0, #176	; 0xb0
    8b18:	4343      	muls	r3, r0
    8b1a:	18d3      	adds	r3, r2, r3
    8b1c:	185b      	adds	r3, r3, r1
    8b1e:	795a      	ldrb	r2, [r3, #5]
    8b20:	2102      	movs	r1, #2
    8b22:	430a      	orrs	r2, r1
    8b24:	715a      	strb	r2, [r3, #5]
      break;
    8b26:	e032      	b.n	8b8e <USBPD_DPM_Notification+0x352>
        if ((USBPD_TRUE == DPM_Ports[PortNum].DPM_CableResetOnGoing) && (USBPD_TRUE == DPM_Params[PortNum].VconnStatus))
    8b28:	1dfb      	adds	r3, r7, #7
    8b2a:	781b      	ldrb	r3, [r3, #0]
    8b2c:	4a23      	ldr	r2, [pc, #140]	; (8bbc <USBPD_DPM_Notification+0x380>)
    8b2e:	2160      	movs	r1, #96	; 0x60
    8b30:	20b0      	movs	r0, #176	; 0xb0
    8b32:	4343      	muls	r3, r0
    8b34:	18d3      	adds	r3, r2, r3
    8b36:	185b      	adds	r3, r3, r1
    8b38:	795b      	ldrb	r3, [r3, #5]
    8b3a:	079b      	lsls	r3, r3, #30
    8b3c:	0fdb      	lsrs	r3, r3, #31
    8b3e:	b2db      	uxtb	r3, r3
    8b40:	2b01      	cmp	r3, #1
    8b42:	d126      	bne.n	8b92 <USBPD_DPM_Notification+0x356>
    8b44:	1dfb      	adds	r3, r7, #7
    8b46:	781b      	ldrb	r3, [r3, #0]
    8b48:	4a1b      	ldr	r2, [pc, #108]	; (8bb8 <USBPD_DPM_Notification+0x37c>)
    8b4a:	009b      	lsls	r3, r3, #2
    8b4c:	18d3      	adds	r3, r2, r3
    8b4e:	785b      	ldrb	r3, [r3, #1]
    8b50:	061b      	lsls	r3, r3, #24
    8b52:	0fdb      	lsrs	r3, r3, #31
    8b54:	b2db      	uxtb	r3, r3
    8b56:	2b01      	cmp	r3, #1
    8b58:	d11b      	bne.n	8b92 <USBPD_DPM_Notification+0x356>
          USBPD_DPM_RequestCableReset(PortNum);
    8b5a:	1dfb      	adds	r3, r7, #7
    8b5c:	781b      	ldrb	r3, [r3, #0]
    8b5e:	0018      	movs	r0, r3
    8b60:	f000 fd2b 	bl	95ba <USBPD_DPM_RequestCableReset>
          DPM_Ports[PortNum].DPM_CableResetOnGoing = USBPD_FALSE;
    8b64:	1dfb      	adds	r3, r7, #7
    8b66:	781b      	ldrb	r3, [r3, #0]
    8b68:	4a14      	ldr	r2, [pc, #80]	; (8bbc <USBPD_DPM_Notification+0x380>)
    8b6a:	2160      	movs	r1, #96	; 0x60
    8b6c:	20b0      	movs	r0, #176	; 0xb0
    8b6e:	4343      	muls	r3, r0
    8b70:	18d3      	adds	r3, r2, r3
    8b72:	185b      	adds	r3, r3, r1
    8b74:	795a      	ldrb	r2, [r3, #5]
    8b76:	2102      	movs	r1, #2
    8b78:	438a      	bics	r2, r1
    8b7a:	715a      	strb	r2, [r3, #5]
      break;
    8b7c:	e009      	b.n	8b92 <USBPD_DPM_Notification+0x356>
      break;
    8b7e:	46c0      	nop			; (mov r8, r8)
    8b80:	e008      	b.n	8b94 <USBPD_DPM_Notification+0x358>
      break;
    8b82:	46c0      	nop			; (mov r8, r8)
    8b84:	e006      	b.n	8b94 <USBPD_DPM_Notification+0x358>
      break;
    8b86:	46c0      	nop			; (mov r8, r8)
    8b88:	e004      	b.n	8b94 <USBPD_DPM_Notification+0x358>
    break;
    8b8a:	46c0      	nop			; (mov r8, r8)
    8b8c:	e002      	b.n	8b94 <USBPD_DPM_Notification+0x358>
      break;
    8b8e:	46c0      	nop			; (mov r8, r8)
    8b90:	e000      	b.n	8b94 <USBPD_DPM_Notification+0x358>
      break;
    8b92:	46c0      	nop			; (mov r8, r8)
  }

  /* Forward PE notifications to GUI if enabled */
  if (NULL != DPM_GUI_PostNotificationMessage)
    8b94:	4b0d      	ldr	r3, [pc, #52]	; (8bcc <USBPD_DPM_Notification+0x390>)
    8b96:	681b      	ldr	r3, [r3, #0]
    8b98:	2b00      	cmp	r3, #0
    8b9a:	d008      	beq.n	8bae <USBPD_DPM_Notification+0x372>
  {
    DPM_GUI_PostNotificationMessage(PortNum, EventVal);
    8b9c:	4b0b      	ldr	r3, [pc, #44]	; (8bcc <USBPD_DPM_Notification+0x390>)
    8b9e:	681b      	ldr	r3, [r3, #0]
    8ba0:	1dba      	adds	r2, r7, #6
    8ba2:	7812      	ldrb	r2, [r2, #0]
    8ba4:	b291      	uxth	r1, r2
    8ba6:	1dfa      	adds	r2, r7, #7
    8ba8:	7812      	ldrb	r2, [r2, #0]
    8baa:	0010      	movs	r0, r2
    8bac:	4798      	blx	r3
  }
/* USER CODE END USBPD_DPM_Notification */
}
    8bae:	46c0      	nop			; (mov r8, r8)
    8bb0:	46bd      	mov	sp, r7
    8bb2:	b005      	add	sp, #20
    8bb4:	bd90      	pop	{r4, r7, pc}
    8bb6:	46c0      	nop			; (mov r8, r8)
    8bb8:	000321d4 	.word	0x000321d4
    8bbc:	0002fffc 	.word	0x0002fffc
    8bc0:	ffff8064 	.word	0xffff8064
    8bc4:	0003213c 	.word	0x0003213c
    8bc8:	000300b4 	.word	0x000300b4
    8bcc:	000300ac 	.word	0x000300ac

00008bd0 <USBPD_DPM_GetDataInfo>:
  * @param  Ptr     Pointer on address where DPM data should be written (u8 pointer)
  * @param  Size    Pointer on nb of u8 written by DPM
  * @retval None
  */
void USBPD_DPM_GetDataInfo(uint8_t PortNum, USBPD_CORE_DataInfoType_TypeDef DataId, uint8_t *Ptr, uint32_t *Size)
{
    8bd0:	b590      	push	{r4, r7, lr}
    8bd2:	b08b      	sub	sp, #44	; 0x2c
    8bd4:	af00      	add	r7, sp, #0
    8bd6:	60ba      	str	r2, [r7, #8]
    8bd8:	607b      	str	r3, [r7, #4]
    8bda:	230f      	movs	r3, #15
    8bdc:	18fb      	adds	r3, r7, r3
    8bde:	1c02      	adds	r2, r0, #0
    8be0:	701a      	strb	r2, [r3, #0]
    8be2:	200e      	movs	r0, #14
    8be4:	183b      	adds	r3, r7, r0
    8be6:	1c0a      	adds	r2, r1, #0
    8be8:	701a      	strb	r2, [r3, #0]
/* USER CODE BEGIN USBPD_DPM_GetDataInfo */
  /* Check type of information targeted by request */
  switch (DataId)
    8bea:	183b      	adds	r3, r7, r0
    8bec:	781b      	ldrb	r3, [r3, #0]
    8bee:	2b13      	cmp	r3, #19
    8bf0:	d900      	bls.n	8bf4 <USBPD_DPM_GetDataInfo+0x24>
    8bf2:	e0d3      	b.n	8d9c <USBPD_DPM_GetDataInfo+0x1cc>
    8bf4:	009a      	lsls	r2, r3, #2
    8bf6:	4b6d      	ldr	r3, [pc, #436]	; (8dac <USBPD_DPM_GetDataInfo+0x1dc>)
    8bf8:	18d3      	adds	r3, r2, r3
    8bfa:	681b      	ldr	r3, [r3, #0]
    8bfc:	469f      	mov	pc, r3
    Case Port SINK PDO Data information :
    Call PWR_IF PDO reading request.
    */
  case USBPD_CORE_DATATYPE_SRC_PDO :
  case USBPD_CORE_DATATYPE_SNK_PDO :
    USBPD_PWR_IF_GetPortPDOs(PortNum, DataId, Ptr, Size);
    8bfe:	687c      	ldr	r4, [r7, #4]
    8c00:	68ba      	ldr	r2, [r7, #8]
    8c02:	230e      	movs	r3, #14
    8c04:	18fb      	adds	r3, r7, r3
    8c06:	7819      	ldrb	r1, [r3, #0]
    8c08:	230f      	movs	r3, #15
    8c0a:	18fb      	adds	r3, r7, r3
    8c0c:	7818      	ldrb	r0, [r3, #0]
    8c0e:	0023      	movs	r3, r4
    8c10:	f002 f824 	bl	ac5c <USBPD_PWR_IF_GetPortPDOs>
    *Size *= 4;
    8c14:	687b      	ldr	r3, [r7, #4]
    8c16:	681b      	ldr	r3, [r3, #0]
    8c18:	009a      	lsls	r2, r3, #2
    8c1a:	687b      	ldr	r3, [r7, #4]
    8c1c:	601a      	str	r2, [r3, #0]
    break;
    8c1e:	e0c1      	b.n	8da4 <USBPD_DPM_GetDataInfo+0x1d4>

    /* Case Requested voltage value Data information */
  case USBPD_CORE_DATATYPE_REQ_VOLTAGE :
    *Size = 4;
    8c20:	687b      	ldr	r3, [r7, #4]
    8c22:	2204      	movs	r2, #4
    8c24:	601a      	str	r2, [r3, #0]
    (void)memcpy((uint8_t*)Ptr, (uint8_t *)&DPM_Ports[PortNum].DPM_RequestedVoltage, *Size);
    8c26:	230f      	movs	r3, #15
    8c28:	18fb      	adds	r3, r7, r3
    8c2a:	781b      	ldrb	r3, [r3, #0]
    8c2c:	22b0      	movs	r2, #176	; 0xb0
    8c2e:	4353      	muls	r3, r2
    8c30:	3340      	adds	r3, #64	; 0x40
    8c32:	001a      	movs	r2, r3
    8c34:	4b5e      	ldr	r3, [pc, #376]	; (8db0 <USBPD_DPM_GetDataInfo+0x1e0>)
    8c36:	18d3      	adds	r3, r2, r3
    8c38:	1d19      	adds	r1, r3, #4
    8c3a:	687b      	ldr	r3, [r7, #4]
    8c3c:	681a      	ldr	r2, [r3, #0]
    8c3e:	68bb      	ldr	r3, [r7, #8]
    8c40:	0018      	movs	r0, r3
    8c42:	f015 fd27 	bl	1e694 <memcpy>
    break;
    8c46:	e0ad      	b.n	8da4 <USBPD_DPM_GetDataInfo+0x1d4>

#if defined(USBPDCORE_SNK_CAPA_EXT)
  case USBPD_CORE_SNK_EXTENDED_CAPA :
    {
      *Size = sizeof(USBPD_SKEDB_TypeDef);
    8c48:	687b      	ldr	r3, [r7, #4]
    8c4a:	2218      	movs	r2, #24
    8c4c:	601a      	str	r2, [r3, #0]
      memcpy((uint8_t*)Ptr, (uint8_t *)&DPM_USER_Settings[PortNum].DPM_SNKExtendedCapa, *Size);
    8c4e:	230f      	movs	r3, #15
    8c50:	18fb      	adds	r3, r7, r3
    8c52:	781b      	ldrb	r3, [r3, #0]
    8c54:	2274      	movs	r2, #116	; 0x74
    8c56:	4353      	muls	r3, r2
    8c58:	3350      	adds	r3, #80	; 0x50
    8c5a:	001a      	movs	r2, r3
    8c5c:	4b55      	ldr	r3, [pc, #340]	; (8db4 <USBPD_DPM_GetDataInfo+0x1e4>)
    8c5e:	18d1      	adds	r1, r2, r3
    8c60:	687b      	ldr	r3, [r7, #4]
    8c62:	681a      	ldr	r2, [r3, #0]
    8c64:	68bb      	ldr	r3, [r7, #8]
    8c66:	0018      	movs	r0, r3
    8c68:	f015 fd14 	bl	1e694 <memcpy>
     }
     break;
    8c6c:	e09a      	b.n	8da4 <USBPD_DPM_GetDataInfo+0x1d4>
#endif /* USBPDCORE_SNK_CAPA_EXT */
  case USBPD_CORE_INFO_STATUS :
    {
      USBPD_SDB_TypeDef  infostatus = {
    8c6e:	2414      	movs	r4, #20
    8c70:	193b      	adds	r3, r7, r4
    8c72:	0018      	movs	r0, r3
    8c74:	2306      	movs	r3, #6
    8c76:	001a      	movs	r2, r3
    8c78:	2100      	movs	r1, #0
    8c7a:	f015 fd14 	bl	1e6a6 <memset>
          .EventFlags = 0,            /*!< Event Flags                                               */
          .TemperatureStatus = 0,     /*!< Temperature                                               */
          .PowerStatus = 0,           /*!< Power Status based on combination of @ref USBPD_SDB_POWER_STATUS*/
      };

      *Size = sizeof(USBPD_SDB_TypeDef);
    8c7e:	687b      	ldr	r3, [r7, #4]
    8c80:	2206      	movs	r2, #6
    8c82:	601a      	str	r2, [r3, #0]
      memcpy((uint8_t *)Ptr, &infostatus, *Size);
    8c84:	687b      	ldr	r3, [r7, #4]
    8c86:	681a      	ldr	r2, [r3, #0]
    8c88:	1939      	adds	r1, r7, r4
    8c8a:	68bb      	ldr	r3, [r7, #8]
    8c8c:	0018      	movs	r0, r3
    8c8e:	f015 fd01 	bl	1e694 <memcpy>
    }
    break;
    8c92:	e087      	b.n	8da4 <USBPD_DPM_GetDataInfo+0x1d4>
    case USBPD_CORE_MANUFACTURER_INFO :
      {
        USBPD_MIDB_TypeDef* manu_info;
        /* Manufacturer Info Target must be a range 0..1 */
        /* Manufacturer Info Ref must be a range 0..7    */
        if((DPM_Ports[PortNum].DPM_GetManufacturerInfo.ManufacturerInfoTarget > USBPD_MANUFINFO_TARGET_BATTERY)
    8c94:	230f      	movs	r3, #15
    8c96:	18fb      	adds	r3, r7, r3
    8c98:	781b      	ldrb	r3, [r3, #0]
    8c9a:	4a45      	ldr	r2, [pc, #276]	; (8db0 <USBPD_DPM_GetDataInfo+0x1e0>)
    8c9c:	2188      	movs	r1, #136	; 0x88
    8c9e:	20b0      	movs	r0, #176	; 0xb0
    8ca0:	4343      	muls	r3, r0
    8ca2:	18d3      	adds	r3, r2, r3
    8ca4:	185b      	adds	r3, r3, r1
    8ca6:	781b      	ldrb	r3, [r3, #0]
    8ca8:	2b01      	cmp	r3, #1
    8caa:	d80b      	bhi.n	8cc4 <USBPD_DPM_GetDataInfo+0xf4>
        || (DPM_Ports[PortNum].DPM_GetManufacturerInfo.ManufacturerInfoRef > USBPD_MANUFINFO_REF_MAX_VALUES))
    8cac:	230f      	movs	r3, #15
    8cae:	18fb      	adds	r3, r7, r3
    8cb0:	781b      	ldrb	r3, [r3, #0]
    8cb2:	4a3f      	ldr	r2, [pc, #252]	; (8db0 <USBPD_DPM_GetDataInfo+0x1e0>)
    8cb4:	2189      	movs	r1, #137	; 0x89
    8cb6:	20b0      	movs	r0, #176	; 0xb0
    8cb8:	4343      	muls	r3, r0
    8cba:	18d3      	adds	r3, r2, r3
    8cbc:	185b      	adds	r3, r3, r1
    8cbe:	781b      	ldrb	r3, [r3, #0]
    8cc0:	2b07      	cmp	r3, #7
    8cc2:	d91e      	bls.n	8d02 <USBPD_DPM_GetDataInfo+0x132>
        {
          /* If the Manufacturer Info Target field or Manufacturer Info Ref field in the Get_Manufacturer_Info Message is
             unrecognized the field Shall return a null terminated ascii text string Not Supported.*/
          char *_notsupported = "Not Supported\0";
    8cc4:	4b3c      	ldr	r3, [pc, #240]	; (8db8 <USBPD_DPM_GetDataInfo+0x1e8>)
    8cc6:	61fb      	str	r3, [r7, #28]
          *Size = 4 + 14; /* VID (2) + .PID(2) + sizeof("Not Supported\0")*/
    8cc8:	687b      	ldr	r3, [r7, #4]
    8cca:	2212      	movs	r2, #18
    8ccc:	601a      	str	r2, [r3, #0]
          /* Copy Manufacturer Info into data area for transmission */
          manu_info = (USBPD_MIDB_TypeDef*)&DPM_USER_Settings[PortNum].DPM_ManuInfoPort;
    8cce:	230f      	movs	r3, #15
    8cd0:	18fb      	adds	r3, r7, r3
    8cd2:	781b      	ldrb	r3, [r3, #0]
    8cd4:	2274      	movs	r2, #116	; 0x74
    8cd6:	4353      	muls	r3, r2
    8cd8:	3318      	adds	r3, #24
    8cda:	001a      	movs	r2, r3
    8cdc:	4b35      	ldr	r3, [pc, #212]	; (8db4 <USBPD_DPM_GetDataInfo+0x1e4>)
    8cde:	18d3      	adds	r3, r2, r3
    8ce0:	3304      	adds	r3, #4
    8ce2:	623b      	str	r3, [r7, #32]
          memcpy((uint8_t*)Ptr, (uint8_t *)manu_info, 4);
    8ce4:	6a39      	ldr	r1, [r7, #32]
    8ce6:	68bb      	ldr	r3, [r7, #8]
    8ce8:	2204      	movs	r2, #4
    8cea:	0018      	movs	r0, r3
    8cec:	f015 fcd2 	bl	1e694 <memcpy>
          memcpy((uint8_t*)(Ptr + 4), (uint8_t *)_notsupported, 14);
    8cf0:	68bb      	ldr	r3, [r7, #8]
    8cf2:	3304      	adds	r3, #4
    8cf4:	69f9      	ldr	r1, [r7, #28]
    8cf6:	220e      	movs	r2, #14
    8cf8:	0018      	movs	r0, r3
    8cfa:	f015 fccb 	bl	1e694 <memcpy>
        {
    8cfe:	46c0      	nop			; (mov r8, r8)
            memcpy((uint8_t*)Ptr, (uint8_t *)manu_info, 4);
            memcpy((uint8_t*)(Ptr + 4), (uint8_t *)_notsupported, 14);
          }
        }
      }
      break;
    8d00:	e050      	b.n	8da4 <USBPD_DPM_GetDataInfo+0x1d4>
          if (USBPD_MANUFINFO_TARGET_PORT_CABLE_PLUG == DPM_Ports[PortNum].DPM_GetManufacturerInfo.ManufacturerInfoTarget)
    8d02:	230f      	movs	r3, #15
    8d04:	18fb      	adds	r3, r7, r3
    8d06:	781b      	ldrb	r3, [r3, #0]
    8d08:	4a29      	ldr	r2, [pc, #164]	; (8db0 <USBPD_DPM_GetDataInfo+0x1e0>)
    8d0a:	2188      	movs	r1, #136	; 0x88
    8d0c:	20b0      	movs	r0, #176	; 0xb0
    8d0e:	4343      	muls	r3, r0
    8d10:	18d3      	adds	r3, r2, r3
    8d12:	185b      	adds	r3, r3, r1
    8d14:	781b      	ldrb	r3, [r3, #0]
    8d16:	2b00      	cmp	r3, #0
    8d18:	d122      	bne.n	8d60 <USBPD_DPM_GetDataInfo+0x190>
            *Size = 4 + strlen((char*)(DPM_USER_Settings[PortNum].DPM_ManuInfoPort.ManuString));
    8d1a:	240f      	movs	r4, #15
    8d1c:	193b      	adds	r3, r7, r4
    8d1e:	781b      	ldrb	r3, [r3, #0]
    8d20:	2274      	movs	r2, #116	; 0x74
    8d22:	4353      	muls	r3, r2
    8d24:	3318      	adds	r3, #24
    8d26:	001a      	movs	r2, r3
    8d28:	4b22      	ldr	r3, [pc, #136]	; (8db4 <USBPD_DPM_GetDataInfo+0x1e4>)
    8d2a:	18d3      	adds	r3, r2, r3
    8d2c:	3308      	adds	r3, #8
    8d2e:	0018      	movs	r0, r3
    8d30:	f015 fd9c 	bl	1e86c <strlen>
    8d34:	0003      	movs	r3, r0
    8d36:	1d1a      	adds	r2, r3, #4
    8d38:	687b      	ldr	r3, [r7, #4]
    8d3a:	601a      	str	r2, [r3, #0]
            manu_info = (USBPD_MIDB_TypeDef*)&DPM_USER_Settings[PortNum].DPM_ManuInfoPort;
    8d3c:	193b      	adds	r3, r7, r4
    8d3e:	781b      	ldrb	r3, [r3, #0]
    8d40:	2274      	movs	r2, #116	; 0x74
    8d42:	4353      	muls	r3, r2
    8d44:	3318      	adds	r3, #24
    8d46:	001a      	movs	r2, r3
    8d48:	4b1a      	ldr	r3, [pc, #104]	; (8db4 <USBPD_DPM_GetDataInfo+0x1e4>)
    8d4a:	18d3      	adds	r3, r2, r3
    8d4c:	3304      	adds	r3, #4
    8d4e:	623b      	str	r3, [r7, #32]
            memcpy((uint8_t*)Ptr, (uint8_t *)manu_info, *Size);
    8d50:	687b      	ldr	r3, [r7, #4]
    8d52:	681a      	ldr	r2, [r3, #0]
    8d54:	6a39      	ldr	r1, [r7, #32]
    8d56:	68bb      	ldr	r3, [r7, #8]
    8d58:	0018      	movs	r0, r3
    8d5a:	f015 fc9b 	bl	1e694 <memcpy>
      break;
    8d5e:	e021      	b.n	8da4 <USBPD_DPM_GetDataInfo+0x1d4>
            char *_notsupported = "Not Supported\0";
    8d60:	4b15      	ldr	r3, [pc, #84]	; (8db8 <USBPD_DPM_GetDataInfo+0x1e8>)
    8d62:	627b      	str	r3, [r7, #36]	; 0x24
            *Size = 4 + 14; /* VID (2) + .PID(2) + sizeof("Not Supported\0")*/
    8d64:	687b      	ldr	r3, [r7, #4]
    8d66:	2212      	movs	r2, #18
    8d68:	601a      	str	r2, [r3, #0]
            manu_info = (USBPD_MIDB_TypeDef*)&DPM_USER_Settings[PortNum].DPM_ManuInfoPort;
    8d6a:	230f      	movs	r3, #15
    8d6c:	18fb      	adds	r3, r7, r3
    8d6e:	781b      	ldrb	r3, [r3, #0]
    8d70:	2274      	movs	r2, #116	; 0x74
    8d72:	4353      	muls	r3, r2
    8d74:	3318      	adds	r3, #24
    8d76:	001a      	movs	r2, r3
    8d78:	4b0e      	ldr	r3, [pc, #56]	; (8db4 <USBPD_DPM_GetDataInfo+0x1e4>)
    8d7a:	18d3      	adds	r3, r2, r3
    8d7c:	3304      	adds	r3, #4
    8d7e:	623b      	str	r3, [r7, #32]
            memcpy((uint8_t*)Ptr, (uint8_t *)manu_info, 4);
    8d80:	6a39      	ldr	r1, [r7, #32]
    8d82:	68bb      	ldr	r3, [r7, #8]
    8d84:	2204      	movs	r2, #4
    8d86:	0018      	movs	r0, r3
    8d88:	f015 fc84 	bl	1e694 <memcpy>
            memcpy((uint8_t*)(Ptr + 4), (uint8_t *)_notsupported, 14);
    8d8c:	68bb      	ldr	r3, [r7, #8]
    8d8e:	3304      	adds	r3, #4
    8d90:	6a79      	ldr	r1, [r7, #36]	; 0x24
    8d92:	220e      	movs	r2, #14
    8d94:	0018      	movs	r0, r3
    8d96:	f015 fc7d 	bl	1e694 <memcpy>
      break;
    8d9a:	e003      	b.n	8da4 <USBPD_DPM_GetDataInfo+0x1d4>
  default :
    *Size = 0;
    8d9c:	687b      	ldr	r3, [r7, #4]
    8d9e:	2200      	movs	r2, #0
    8da0:	601a      	str	r2, [r3, #0]
    break;
    8da2:	46c0      	nop			; (mov r8, r8)
  }
/* USER CODE END USBPD_DPM_GetDataInfo */
}
    8da4:	46c0      	nop			; (mov r8, r8)
    8da6:	46bd      	mov	sp, r7
    8da8:	b00b      	add	sp, #44	; 0x2c
    8daa:	bd90      	pop	{r4, r7, pc}
    8dac:	0001f294 	.word	0x0001f294
    8db0:	0002fffc 	.word	0x0002fffc
    8db4:	0002fedc 	.word	0x0002fedc
    8db8:	0001f1ec 	.word	0x0001f1ec

00008dbc <USBPD_DPM_SetDataInfo>:
  * @param  Ptr     Pointer on the data
  * @param  Size    Nb of bytes to be updated in DPM
  * @retval None
  */
void USBPD_DPM_SetDataInfo(uint8_t PortNum, USBPD_CORE_DataInfoType_TypeDef DataId, uint8_t *Ptr, uint32_t Size)
{
    8dbc:	b5b0      	push	{r4, r5, r7, lr}
    8dbe:	b08e      	sub	sp, #56	; 0x38
    8dc0:	af00      	add	r7, sp, #0
    8dc2:	60ba      	str	r2, [r7, #8]
    8dc4:	607b      	str	r3, [r7, #4]
    8dc6:	230f      	movs	r3, #15
    8dc8:	18fb      	adds	r3, r7, r3
    8dca:	1c02      	adds	r2, r0, #0
    8dcc:	701a      	strb	r2, [r3, #0]
    8dce:	200e      	movs	r0, #14
    8dd0:	183b      	adds	r3, r7, r0
    8dd2:	1c0a      	adds	r2, r1, #0
    8dd4:	701a      	strb	r2, [r3, #0]
/* USER CODE BEGIN USBPD_DPM_SetDataInfo */
  uint32_t index;

  /* Check type of information targeted by request */
  switch (DataId)
    8dd6:	183b      	adds	r3, r7, r0
    8dd8:	781b      	ldrb	r3, [r3, #0]
    8dda:	2b13      	cmp	r3, #19
    8ddc:	d900      	bls.n	8de0 <USBPD_DPM_SetDataInfo+0x24>
    8dde:	e0f6      	b.n	8fce <USBPD_DPM_SetDataInfo+0x212>
    8de0:	009a      	lsls	r2, r3, #2
    8de2:	4b89      	ldr	r3, [pc, #548]	; (9008 <USBPD_DPM_SetDataInfo+0x24c>)
    8de4:	18d3      	adds	r3, r2, r3
    8de6:	681b      	ldr	r3, [r3, #0]
    8de8:	469f      	mov	pc, r3
  {
    /* Case requested DO position Data information :
    */
  case USBPD_CORE_DATATYPE_RDO_POSITION :
    if (Size == 4)
    8dea:	687b      	ldr	r3, [r7, #4]
    8dec:	2b04      	cmp	r3, #4
    8dee:	d000      	beq.n	8df2 <USBPD_DPM_SetDataInfo+0x36>
    8df0:	e0ef      	b.n	8fd2 <USBPD_DPM_SetDataInfo+0x216>
    {
      uint8_t* temp;
      temp = (uint8_t*)&DPM_Ports[PortNum].DPM_RDOPosition;
    8df2:	240f      	movs	r4, #15
    8df4:	193b      	adds	r3, r7, r4
    8df6:	781b      	ldrb	r3, [r3, #0]
    8df8:	22b0      	movs	r2, #176	; 0xb0
    8dfa:	4353      	muls	r3, r2
    8dfc:	3340      	adds	r3, #64	; 0x40
    8dfe:	001a      	movs	r2, r3
    8e00:	4b82      	ldr	r3, [pc, #520]	; (900c <USBPD_DPM_SetDataInfo+0x250>)
    8e02:	18d3      	adds	r3, r2, r3
    8e04:	617b      	str	r3, [r7, #20]
      (void)memcpy(temp, Ptr, Size);
    8e06:	687a      	ldr	r2, [r7, #4]
    8e08:	68b9      	ldr	r1, [r7, #8]
    8e0a:	697b      	ldr	r3, [r7, #20]
    8e0c:	0018      	movs	r0, r3
    8e0e:	f015 fc41 	bl	1e694 <memcpy>
      DPM_Ports[PortNum].DPM_RDOPositionPrevious = *Ptr;
    8e12:	68bb      	ldr	r3, [r7, #8]
    8e14:	781a      	ldrb	r2, [r3, #0]
    8e16:	193b      	adds	r3, r7, r4
    8e18:	781b      	ldrb	r3, [r3, #0]
    8e1a:	0010      	movs	r0, r2
    8e1c:	4a7b      	ldr	r2, [pc, #492]	; (900c <USBPD_DPM_SetDataInfo+0x250>)
    8e1e:	21b0      	movs	r1, #176	; 0xb0
    8e20:	434b      	muls	r3, r1
    8e22:	18d3      	adds	r3, r2, r3
    8e24:	3350      	adds	r3, #80	; 0x50
    8e26:	6018      	str	r0, [r3, #0]
      temp = (uint8_t*)&DPM_Ports[PortNum].DPM_RDOPositionPrevious;
    8e28:	193b      	adds	r3, r7, r4
    8e2a:	781b      	ldrb	r3, [r3, #0]
    8e2c:	22b0      	movs	r2, #176	; 0xb0
    8e2e:	4353      	muls	r3, r2
    8e30:	3350      	adds	r3, #80	; 0x50
    8e32:	001a      	movs	r2, r3
    8e34:	4b75      	ldr	r3, [pc, #468]	; (900c <USBPD_DPM_SetDataInfo+0x250>)
    8e36:	18d3      	adds	r3, r2, r3
    8e38:	617b      	str	r3, [r7, #20]
      (void)memcpy(temp, Ptr, Size);
    8e3a:	687a      	ldr	r2, [r7, #4]
    8e3c:	68b9      	ldr	r1, [r7, #8]
    8e3e:	697b      	ldr	r3, [r7, #20]
    8e40:	0018      	movs	r0, r3
    8e42:	f015 fc27 	bl	1e694 <memcpy>
    }
    break;
    8e46:	e0c4      	b.n	8fd2 <USBPD_DPM_SetDataInfo+0x216>

    /* Case Received Source PDO values Data information :
    */
  case USBPD_CORE_DATATYPE_RCV_SRC_PDO :
    if (Size <= (USBPD_MAX_NB_PDO * 4))
    8e48:	687b      	ldr	r3, [r7, #4]
    8e4a:	2b1c      	cmp	r3, #28
    8e4c:	d900      	bls.n	8e50 <USBPD_DPM_SetDataInfo+0x94>
    8e4e:	e0c2      	b.n	8fd6 <USBPD_DPM_SetDataInfo+0x21a>
    {
      uint8_t* rdo;
      DPM_Ports[PortNum].DPM_NumberOfRcvSRCPDO = (Size / 4);
    8e50:	230f      	movs	r3, #15
    8e52:	18fb      	adds	r3, r7, r3
    8e54:	781b      	ldrb	r3, [r3, #0]
    8e56:	687a      	ldr	r2, [r7, #4]
    8e58:	0892      	lsrs	r2, r2, #2
    8e5a:	496c      	ldr	r1, [pc, #432]	; (900c <USBPD_DPM_SetDataInfo+0x250>)
    8e5c:	20b0      	movs	r0, #176	; 0xb0
    8e5e:	4343      	muls	r3, r0
    8e60:	18cb      	adds	r3, r1, r3
    8e62:	331c      	adds	r3, #28
    8e64:	601a      	str	r2, [r3, #0]
      /* Copy PDO data in DPM Handle field */
      for (index = 0; index < (Size / 4); index++)
    8e66:	2300      	movs	r3, #0
    8e68:	637b      	str	r3, [r7, #52]	; 0x34
    8e6a:	e016      	b.n	8e9a <USBPD_DPM_SetDataInfo+0xde>
      {
        rdo = (uint8_t*)&DPM_Ports[PortNum].DPM_ListOfRcvSRCPDO[index];
    8e6c:	230f      	movs	r3, #15
    8e6e:	18fb      	adds	r3, r7, r3
    8e70:	781b      	ldrb	r3, [r3, #0]
    8e72:	222c      	movs	r2, #44	; 0x2c
    8e74:	435a      	muls	r2, r3
    8e76:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    8e78:	18d3      	adds	r3, r2, r3
    8e7a:	009a      	lsls	r2, r3, #2
    8e7c:	4b63      	ldr	r3, [pc, #396]	; (900c <USBPD_DPM_SetDataInfo+0x250>)
    8e7e:	18d3      	adds	r3, r2, r3
    8e80:	61bb      	str	r3, [r7, #24]
        (void)memcpy(rdo, (Ptr + (index * 4u)), (4u * sizeof(uint8_t)));
    8e82:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    8e84:	009b      	lsls	r3, r3, #2
    8e86:	68ba      	ldr	r2, [r7, #8]
    8e88:	18d1      	adds	r1, r2, r3
    8e8a:	69bb      	ldr	r3, [r7, #24]
    8e8c:	2204      	movs	r2, #4
    8e8e:	0018      	movs	r0, r3
    8e90:	f015 fc00 	bl	1e694 <memcpy>
      for (index = 0; index < (Size / 4); index++)
    8e94:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    8e96:	3301      	adds	r3, #1
    8e98:	637b      	str	r3, [r7, #52]	; 0x34
    8e9a:	687b      	ldr	r3, [r7, #4]
    8e9c:	089b      	lsrs	r3, r3, #2
    8e9e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
    8ea0:	429a      	cmp	r2, r3
    8ea2:	d3e3      	bcc.n	8e6c <USBPD_DPM_SetDataInfo+0xb0>
      }
    }
    break;
    8ea4:	e097      	b.n	8fd6 <USBPD_DPM_SetDataInfo+0x21a>

    /* Case Received Sink PDO values Data information :
    */
  case USBPD_CORE_DATATYPE_RCV_SNK_PDO :
    if (Size <= (USBPD_MAX_NB_PDO * 4))
    8ea6:	687b      	ldr	r3, [r7, #4]
    8ea8:	2b1c      	cmp	r3, #28
    8eaa:	d900      	bls.n	8eae <USBPD_DPM_SetDataInfo+0xf2>
    8eac:	e095      	b.n	8fda <USBPD_DPM_SetDataInfo+0x21e>
    {
      uint8_t* rdo;
      DPM_Ports[PortNum].DPM_NumberOfRcvSNKPDO = (Size / 4);
    8eae:	230f      	movs	r3, #15
    8eb0:	18fb      	adds	r3, r7, r3
    8eb2:	781b      	ldrb	r3, [r3, #0]
    8eb4:	687a      	ldr	r2, [r7, #4]
    8eb6:	0892      	lsrs	r2, r2, #2
    8eb8:	4954      	ldr	r1, [pc, #336]	; (900c <USBPD_DPM_SetDataInfo+0x250>)
    8eba:	20b0      	movs	r0, #176	; 0xb0
    8ebc:	4343      	muls	r3, r0
    8ebe:	18cb      	adds	r3, r1, r3
    8ec0:	333c      	adds	r3, #60	; 0x3c
    8ec2:	601a      	str	r2, [r3, #0]
      /* Copy PDO data in DPM Handle field */
      for (index = 0; index < (Size / 4); index++)
    8ec4:	2300      	movs	r3, #0
    8ec6:	637b      	str	r3, [r7, #52]	; 0x34
    8ec8:	e017      	b.n	8efa <USBPD_DPM_SetDataInfo+0x13e>
      {
        rdo = (uint8_t*)&DPM_Ports[PortNum].DPM_ListOfRcvSNKPDO[index];
    8eca:	230f      	movs	r3, #15
    8ecc:	18fb      	adds	r3, r7, r3
    8ece:	781b      	ldrb	r3, [r3, #0]
    8ed0:	222c      	movs	r2, #44	; 0x2c
    8ed2:	435a      	muls	r2, r3
    8ed4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    8ed6:	18d3      	adds	r3, r2, r3
    8ed8:	3308      	adds	r3, #8
    8eda:	009a      	lsls	r2, r3, #2
    8edc:	4b4b      	ldr	r3, [pc, #300]	; (900c <USBPD_DPM_SetDataInfo+0x250>)
    8ede:	18d3      	adds	r3, r2, r3
    8ee0:	61fb      	str	r3, [r7, #28]
        (void)memcpy(rdo, (Ptr + (index * 4u)), (4u * sizeof(uint8_t)));
    8ee2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    8ee4:	009b      	lsls	r3, r3, #2
    8ee6:	68ba      	ldr	r2, [r7, #8]
    8ee8:	18d1      	adds	r1, r2, r3
    8eea:	69fb      	ldr	r3, [r7, #28]
    8eec:	2204      	movs	r2, #4
    8eee:	0018      	movs	r0, r3
    8ef0:	f015 fbd0 	bl	1e694 <memcpy>
      for (index = 0; index < (Size / 4); index++)
    8ef4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    8ef6:	3301      	adds	r3, #1
    8ef8:	637b      	str	r3, [r7, #52]	; 0x34
    8efa:	687b      	ldr	r3, [r7, #4]
    8efc:	089b      	lsrs	r3, r3, #2
    8efe:	6b7a      	ldr	r2, [r7, #52]	; 0x34
    8f00:	429a      	cmp	r2, r3
    8f02:	d3e2      	bcc.n	8eca <USBPD_DPM_SetDataInfo+0x10e>
      }
    }
    break;
    8f04:	e069      	b.n	8fda <USBPD_DPM_SetDataInfo+0x21e>

    /* Case Received Request PDO Data information :
    */
  case USBPD_CORE_DATATYPE_RCV_REQ_PDO :
    if (Size == 4)
    8f06:	687b      	ldr	r3, [r7, #4]
    8f08:	2b04      	cmp	r3, #4
    8f0a:	d168      	bne.n	8fde <USBPD_DPM_SetDataInfo+0x222>
    {
      uint8_t* rdo;
      rdo = (uint8_t*)&DPM_Ports[PortNum].DPM_RcvRequestDOMsg;
    8f0c:	230f      	movs	r3, #15
    8f0e:	18fb      	adds	r3, r7, r3
    8f10:	781b      	ldrb	r3, [r3, #0]
    8f12:	22b0      	movs	r2, #176	; 0xb0
    8f14:	4353      	muls	r3, r2
    8f16:	3358      	adds	r3, #88	; 0x58
    8f18:	001a      	movs	r2, r3
    8f1a:	4b3c      	ldr	r3, [pc, #240]	; (900c <USBPD_DPM_SetDataInfo+0x250>)
    8f1c:	18d3      	adds	r3, r2, r3
    8f1e:	3304      	adds	r3, #4
    8f20:	623b      	str	r3, [r7, #32]
      (void)memcpy(rdo, Ptr, Size);
    8f22:	687a      	ldr	r2, [r7, #4]
    8f24:	68b9      	ldr	r1, [r7, #8]
    8f26:	6a3b      	ldr	r3, [r7, #32]
    8f28:	0018      	movs	r0, r3
    8f2a:	f015 fbb3 	bl	1e694 <memcpy>
    }
    break;
    8f2e:	e056      	b.n	8fde <USBPD_DPM_SetDataInfo+0x222>

  case USBPD_CORE_INFO_STATUS :
    {
      uint8_t* info_status;
      info_status = (uint8_t*)&DPM_Ports[PortNum].DPM_RcvStatus;
    8f30:	230f      	movs	r3, #15
    8f32:	18fb      	adds	r3, r7, r3
    8f34:	781b      	ldrb	r3, [r3, #0]
    8f36:	22b0      	movs	r2, #176	; 0xb0
    8f38:	4353      	muls	r3, r2
    8f3a:	3368      	adds	r3, #104	; 0x68
    8f3c:	001a      	movs	r2, r3
    8f3e:	4b33      	ldr	r3, [pc, #204]	; (900c <USBPD_DPM_SetDataInfo+0x250>)
    8f40:	18d3      	adds	r3, r2, r3
    8f42:	627b      	str	r3, [r7, #36]	; 0x24
      memcpy(info_status, Ptr, Size);
    8f44:	687a      	ldr	r2, [r7, #4]
    8f46:	68b9      	ldr	r1, [r7, #8]
    8f48:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    8f4a:	0018      	movs	r0, r3
    8f4c:	f015 fba2 	bl	1e694 <memcpy>
    }
    break;
    8f50:	e046      	b.n	8fe0 <USBPD_DPM_SetDataInfo+0x224>
#if defined(USBPDCORE_SNK_CAPA_EXT)
  case USBPD_CORE_SNK_EXTENDED_CAPA :
    {
      uint8_t*  _snk_ext_capa;
      _snk_ext_capa = (uint8_t*)&DPM_Ports[PortNum].DPM_RcvSNKExtendedCapa;
    8f52:	230f      	movs	r3, #15
    8f54:	18fb      	adds	r3, r7, r3
    8f56:	781b      	ldrb	r3, [r3, #0]
    8f58:	22b0      	movs	r2, #176	; 0xb0
    8f5a:	4353      	muls	r3, r2
    8f5c:	3370      	adds	r3, #112	; 0x70
    8f5e:	001a      	movs	r2, r3
    8f60:	4b2a      	ldr	r3, [pc, #168]	; (900c <USBPD_DPM_SetDataInfo+0x250>)
    8f62:	18d3      	adds	r3, r2, r3
    8f64:	633b      	str	r3, [r7, #48]	; 0x30
      memcpy(_snk_ext_capa, Ptr, Size);
    8f66:	687a      	ldr	r2, [r7, #4]
    8f68:	68b9      	ldr	r1, [r7, #8]
    8f6a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    8f6c:	0018      	movs	r0, r3
    8f6e:	f015 fb91 	bl	1e694 <memcpy>
    }
    break;
    8f72:	e035      	b.n	8fe0 <USBPD_DPM_SetDataInfo+0x224>
#endif /* USBPDCORE_SNK_CAPA_EXT */
  case USBPD_CORE_GET_MANUFACTURER_INFO:
    {
      uint8_t* temp = (uint8_t*)Ptr;
    8f74:	68bb      	ldr	r3, [r7, #8]
    8f76:	62fb      	str	r3, [r7, #44]	; 0x2c
      DPM_Ports[PortNum].DPM_GetManufacturerInfo.ManufacturerInfoTarget = *temp;
    8f78:	250f      	movs	r5, #15
    8f7a:	197b      	adds	r3, r7, r5
    8f7c:	781b      	ldrb	r3, [r3, #0]
    8f7e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    8f80:	7814      	ldrb	r4, [r2, #0]
    8f82:	4a22      	ldr	r2, [pc, #136]	; (900c <USBPD_DPM_SetDataInfo+0x250>)
    8f84:	2188      	movs	r1, #136	; 0x88
    8f86:	20b0      	movs	r0, #176	; 0xb0
    8f88:	4343      	muls	r3, r0
    8f8a:	18d3      	adds	r3, r2, r3
    8f8c:	185b      	adds	r3, r3, r1
    8f8e:	1c22      	adds	r2, r4, #0
    8f90:	701a      	strb	r2, [r3, #0]
      DPM_Ports[PortNum].DPM_GetManufacturerInfo.ManufacturerInfoRef    = *(temp + 1);
    8f92:	197b      	adds	r3, r7, r5
    8f94:	781b      	ldrb	r3, [r3, #0]
    8f96:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    8f98:	7854      	ldrb	r4, [r2, #1]
    8f9a:	4a1c      	ldr	r2, [pc, #112]	; (900c <USBPD_DPM_SetDataInfo+0x250>)
    8f9c:	2189      	movs	r1, #137	; 0x89
    8f9e:	20b0      	movs	r0, #176	; 0xb0
    8fa0:	4343      	muls	r3, r0
    8fa2:	18d3      	adds	r3, r2, r3
    8fa4:	185b      	adds	r3, r3, r1
    8fa6:	1c22      	adds	r2, r4, #0
    8fa8:	701a      	strb	r2, [r3, #0]
    }
    break;
    8faa:	e019      	b.n	8fe0 <USBPD_DPM_SetDataInfo+0x224>
    case USBPD_CORE_ALERT:
      {
        uint8_t*  alert;
        alert = (uint8_t*)&DPM_Ports[PortNum].DPM_RcvAlert.d32;
    8fac:	230f      	movs	r3, #15
    8fae:	18fb      	adds	r3, r7, r3
    8fb0:	781b      	ldrb	r3, [r3, #0]
    8fb2:	22b0      	movs	r2, #176	; 0xb0
    8fb4:	4353      	muls	r3, r2
    8fb6:	3390      	adds	r3, #144	; 0x90
    8fb8:	001a      	movs	r2, r3
    8fba:	4b14      	ldr	r3, [pc, #80]	; (900c <USBPD_DPM_SetDataInfo+0x250>)
    8fbc:	18d3      	adds	r3, r2, r3
    8fbe:	62bb      	str	r3, [r7, #40]	; 0x28
        memcpy(alert, Ptr, Size);
    8fc0:	687a      	ldr	r2, [r7, #4]
    8fc2:	68b9      	ldr	r1, [r7, #8]
    8fc4:	6abb      	ldr	r3, [r7, #40]	; 0x28
    8fc6:	0018      	movs	r0, r3
    8fc8:	f015 fb64 	bl	1e694 <memcpy>
      }
      break;
    8fcc:	e008      	b.n	8fe0 <USBPD_DPM_SetDataInfo+0x224>

    /* In case of unexpected data type (Set request could not be fulfilled) :
    */
  default :
    break;
    8fce:	46c0      	nop			; (mov r8, r8)
    8fd0:	e006      	b.n	8fe0 <USBPD_DPM_SetDataInfo+0x224>
    break;
    8fd2:	46c0      	nop			; (mov r8, r8)
    8fd4:	e004      	b.n	8fe0 <USBPD_DPM_SetDataInfo+0x224>
    break;
    8fd6:	46c0      	nop			; (mov r8, r8)
    8fd8:	e002      	b.n	8fe0 <USBPD_DPM_SetDataInfo+0x224>
    break;
    8fda:	46c0      	nop			; (mov r8, r8)
    8fdc:	e000      	b.n	8fe0 <USBPD_DPM_SetDataInfo+0x224>
    break;
    8fde:	46c0      	nop			; (mov r8, r8)
  }
  /* Forward info to GUI if enabled */
  if (NULL != DPM_GUI_SaveInfo)
    8fe0:	4b0b      	ldr	r3, [pc, #44]	; (9010 <USBPD_DPM_SetDataInfo+0x254>)
    8fe2:	681b      	ldr	r3, [r3, #0]
    8fe4:	2b00      	cmp	r3, #0
    8fe6:	d00b      	beq.n	9000 <USBPD_DPM_SetDataInfo+0x244>
  {
    DPM_GUI_SaveInfo(PortNum, DataId, Ptr, Size);
    8fe8:	4b09      	ldr	r3, [pc, #36]	; (9010 <USBPD_DPM_SetDataInfo+0x254>)
    8fea:	681c      	ldr	r4, [r3, #0]
    8fec:	687d      	ldr	r5, [r7, #4]
    8fee:	68ba      	ldr	r2, [r7, #8]
    8ff0:	230e      	movs	r3, #14
    8ff2:	18fb      	adds	r3, r7, r3
    8ff4:	7819      	ldrb	r1, [r3, #0]
    8ff6:	230f      	movs	r3, #15
    8ff8:	18fb      	adds	r3, r7, r3
    8ffa:	7818      	ldrb	r0, [r3, #0]
    8ffc:	002b      	movs	r3, r5
    8ffe:	47a0      	blx	r4
  }
/* USER CODE END USBPD_DPM_SetDataInfo */
}
    9000:	46c0      	nop			; (mov r8, r8)
    9002:	46bd      	mov	sp, r7
    9004:	b00e      	add	sp, #56	; 0x38
    9006:	bdb0      	pop	{r4, r5, r7, pc}
    9008:	0001f2e4 	.word	0x0001f2e4
    900c:	0002fffc 	.word	0x0002fffc
    9010:	000300b4 	.word	0x000300b4

00009014 <USBPD_DPM_EvaluateRequest>:
  * @param  PortNum Port number
  * @param  PtrPowerObject  Pointer on the power data object
  * @retval USBPD status : USBPD_ACCEPT, USBPD_REJECT, USBPD_WAIT, USBPD_GOTOMIN
  */
USBPD_StatusTypeDef USBPD_DPM_EvaluateRequest(uint8_t PortNum, USBPD_CORE_PDO_Type_TypeDef *PtrPowerObject)
{
    9014:	b580      	push	{r7, lr}
    9016:	b08a      	sub	sp, #40	; 0x28
    9018:	af00      	add	r7, sp, #0
    901a:	0002      	movs	r2, r0
    901c:	6039      	str	r1, [r7, #0]
    901e:	1dfb      	adds	r3, r7, #7
    9020:	701a      	strb	r2, [r3, #0]
/* USER CODE BEGIN USBPD_DPM_EvaluateRequest */
  USBPD_SNKRDO_TypeDef rdo;
  USBPD_PDO_TypeDef pdo;
  uint32_t pdomaxcurrent = 0;
    9022:	2300      	movs	r3, #0
    9024:	627b      	str	r3, [r7, #36]	; 0x24
  uint32_t rdomaxcurrent = 0, rdoopcurrent = 0, rdoobjposition = 0;
    9026:	2300      	movs	r3, #0
    9028:	623b      	str	r3, [r7, #32]
    902a:	2300      	movs	r3, #0
    902c:	61fb      	str	r3, [r7, #28]
    902e:	2300      	movs	r3, #0
    9030:	61bb      	str	r3, [r7, #24]
  USBPD_HandleTypeDef *pdhandle = &DPM_Ports[PortNum];
    9032:	1dfb      	adds	r3, r7, #7
    9034:	781b      	ldrb	r3, [r3, #0]
    9036:	22b0      	movs	r2, #176	; 0xb0
    9038:	435a      	muls	r2, r3
    903a:	4b39      	ldr	r3, [pc, #228]	; (9120 <USBPD_DPM_EvaluateRequest+0x10c>)
    903c:	18d3      	adds	r3, r2, r3
    903e:	617b      	str	r3, [r7, #20]

  rdo.d32 = pdhandle->DPM_RcvRequestDOMsg;
    9040:	697b      	ldr	r3, [r7, #20]
    9042:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    9044:	613b      	str	r3, [r7, #16]
  rdoobjposition  = rdo.GenericRDO.ObjectPosition;
    9046:	2313      	movs	r3, #19
    9048:	18fb      	adds	r3, r7, r3
    904a:	781b      	ldrb	r3, [r3, #0]
    904c:	065b      	lsls	r3, r3, #25
    904e:	0f5b      	lsrs	r3, r3, #29
    9050:	b2db      	uxtb	r3, r3
    9052:	61bb      	str	r3, [r7, #24]
  pdhandle->DPM_RDOPosition = 0;
    9054:	697b      	ldr	r3, [r7, #20]
    9056:	2200      	movs	r2, #0
    9058:	641a      	str	r2, [r3, #64]	; 0x40
  /* Check if RDP can be met within the supported PDOs by the Source port */
  /* USBPD_DPM_EvaluateRequest: Evaluate Sink Request\r */
  /* USBPD_DPM_EvaluateRequest: Check if RDP can be met within the supported PDOs by the Source port\r */

  /* Search PDO in Port Source PDO list, that corresponds to Position provided in Request RDO */
  if (USBPD_PWR_IF_SearchRequestedPDO(PortNum, rdoobjposition, &pdo.d32) != USBPD_OK)
    905a:	230c      	movs	r3, #12
    905c:	18fa      	adds	r2, r7, r3
    905e:	69b9      	ldr	r1, [r7, #24]
    9060:	1dfb      	adds	r3, r7, #7
    9062:	781b      	ldrb	r3, [r3, #0]
    9064:	0018      	movs	r0, r3
    9066:	f001 fe97 	bl	ad98 <USBPD_PWR_IF_SearchRequestedPDO>
    906a:	1e03      	subs	r3, r0, #0
    906c:	d001      	beq.n	9072 <USBPD_DPM_EvaluateRequest+0x5e>
  {
    /* Invalid PDO index */
    /* USBPD_DPM_EvaluateRequest: Invalid PDOs index */
    return USBPD_REJECT;
    906e:	230c      	movs	r3, #12
    9070:	e052      	b.n	9118 <USBPD_DPM_EvaluateRequest+0x104>
  }

  switch(pdo.GenericPDO.PowerObject)
    9072:	230f      	movs	r3, #15
    9074:	18fb      	adds	r3, r7, r3
    9076:	781b      	ldrb	r3, [r3, #0]
    9078:	061b      	lsls	r3, r3, #24
    907a:	0f9b      	lsrs	r3, r3, #30
    907c:	b2db      	uxtb	r3, r3
    907e:	2b00      	cmp	r3, #0
    9080:	d12c      	bne.n	90dc <USBPD_DPM_EvaluateRequest+0xc8>
  {
  case USBPD_CORE_PDO_TYPE_FIXED:
    {
      pdomaxcurrent = pdo.SRCFixedPDO.MaxCurrentIn10mAunits;
    9082:	230c      	movs	r3, #12
    9084:	18fb      	adds	r3, r7, r3
    9086:	881b      	ldrh	r3, [r3, #0]
    9088:	059b      	lsls	r3, r3, #22
    908a:	0d9b      	lsrs	r3, r3, #22
    908c:	b29b      	uxth	r3, r3
    908e:	627b      	str	r3, [r7, #36]	; 0x24
      rdomaxcurrent = rdo.FixedVariableRDO.MaxOperatingCurrent10mAunits;
    9090:	2310      	movs	r3, #16
    9092:	18fb      	adds	r3, r7, r3
    9094:	881b      	ldrh	r3, [r3, #0]
    9096:	059b      	lsls	r3, r3, #22
    9098:	0d9b      	lsrs	r3, r3, #22
    909a:	b29b      	uxth	r3, r3
    909c:	623b      	str	r3, [r7, #32]
      rdoopcurrent  = rdo.FixedVariableRDO.OperatingCurrentIn10mAunits;
    909e:	693b      	ldr	r3, [r7, #16]
    90a0:	031b      	lsls	r3, r3, #12
    90a2:	0d9b      	lsrs	r3, r3, #22
    90a4:	b29b      	uxth	r3, r3
    90a6:	61fb      	str	r3, [r7, #28]
      DPM_Ports[PortNum].DPM_RequestedCurrent = rdoopcurrent * 10;
    90a8:	1dfb      	adds	r3, r7, #7
    90aa:	7819      	ldrb	r1, [r3, #0]
    90ac:	69fa      	ldr	r2, [r7, #28]
    90ae:	0013      	movs	r3, r2
    90b0:	009b      	lsls	r3, r3, #2
    90b2:	189b      	adds	r3, r3, r2
    90b4:	005b      	lsls	r3, r3, #1
    90b6:	0018      	movs	r0, r3
    90b8:	4a19      	ldr	r2, [pc, #100]	; (9120 <USBPD_DPM_EvaluateRequest+0x10c>)
    90ba:	23b0      	movs	r3, #176	; 0xb0
    90bc:	434b      	muls	r3, r1
    90be:	18d3      	adds	r3, r2, r3
    90c0:	3348      	adds	r3, #72	; 0x48
    90c2:	6018      	str	r0, [r3, #0]
      if(rdoopcurrent > pdomaxcurrent)
    90c4:	69fa      	ldr	r2, [r7, #28]
    90c6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    90c8:	429a      	cmp	r2, r3
    90ca:	d901      	bls.n	90d0 <USBPD_DPM_EvaluateRequest+0xbc>
      {
        /* Sink requests too much operating current */
        /* USBPD_DPM_EvaluateRequest: Sink requests too much operating current*/
        return USBPD_REJECT;
    90cc:	230c      	movs	r3, #12
    90ce:	e023      	b.n	9118 <USBPD_DPM_EvaluateRequest+0x104>
      }

      if(rdomaxcurrent > pdomaxcurrent)
    90d0:	6a3a      	ldr	r2, [r7, #32]
    90d2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    90d4:	429a      	cmp	r2, r3
    90d6:	d903      	bls.n	90e0 <USBPD_DPM_EvaluateRequest+0xcc>
      {
        /* Sink requests too much maximum operating current */
        /* USBPD_DPM_EvaluateRequest: Sink requests too much maximum operating current */
        return USBPD_REJECT;
    90d8:	230c      	movs	r3, #12
    90da:	e01d      	b.n	9118 <USBPD_DPM_EvaluateRequest+0x104>
    break;
  case USBPD_CORE_PDO_TYPE_BATTERY:
  case USBPD_CORE_PDO_TYPE_VARIABLE:
  default:
    {
      return USBPD_REJECT;
    90dc:	230c      	movs	r3, #12
    90de:	e01b      	b.n	9118 <USBPD_DPM_EvaluateRequest+0x104>
    break;
    90e0:	46c0      	nop			; (mov r8, r8)
    }
  }

  /* Set RDO position and requested voltage in DPM port structure */
  pdhandle->DPM_RequestedVoltage = pdo.SRCFixedPDO.VoltageIn50mVunits * 50;
    90e2:	68fb      	ldr	r3, [r7, #12]
    90e4:	031b      	lsls	r3, r3, #12
    90e6:	0d9b      	lsrs	r3, r3, #22
    90e8:	b29b      	uxth	r3, r3
    90ea:	001a      	movs	r2, r3
    90ec:	2332      	movs	r3, #50	; 0x32
    90ee:	4353      	muls	r3, r2
    90f0:	001a      	movs	r2, r3
    90f2:	697b      	ldr	r3, [r7, #20]
    90f4:	645a      	str	r2, [r3, #68]	; 0x44
  pdhandle->DPM_RDOPositionPrevious = pdhandle->DPM_RDOPosition;
    90f6:	697b      	ldr	r3, [r7, #20]
    90f8:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    90fa:	697b      	ldr	r3, [r7, #20]
    90fc:	651a      	str	r2, [r3, #80]	; 0x50
  pdhandle->DPM_RDOPosition = rdoobjposition;
    90fe:	697b      	ldr	r3, [r7, #20]
    9100:	69ba      	ldr	r2, [r7, #24]
    9102:	641a      	str	r2, [r3, #64]	; 0x40

  /* Save the power object */
  *PtrPowerObject = pdo.GenericPDO.PowerObject;
    9104:	230f      	movs	r3, #15
    9106:	18fb      	adds	r3, r7, r3
    9108:	781b      	ldrb	r3, [r3, #0]
    910a:	061b      	lsls	r3, r3, #24
    910c:	0f9b      	lsrs	r3, r3, #30
    910e:	b2db      	uxtb	r3, r3
    9110:	001a      	movs	r2, r3
    9112:	683b      	ldr	r3, [r7, #0]
    9114:	601a      	str	r2, [r3, #0]
  /* Accept the requested power */
  /* USBPD_DPM_EvaluateRequest: Sink requested %d mV %d mA for operating current from %d to %d mA\r",
               pdo.SRCFixedPDO.VoltageIn50mVunits * 50, pdo.SRCFixedPDO.MaxCurrentIn10mAunits * 10,
               rdo.FixedVariableRDO.MaxOperatingCurrent10mAunits * 10, rdo.FixedVariableRDO.OperatingCurrentIn10mAunits * 10 */
  /* USBPD_DPM_EvaluateRequest: Source accepts the requested power */
  return USBPD_ACCEPT;
    9116:	230a      	movs	r3, #10
/* USER CODE END USBPD_DPM_EvaluateRequest */
}
    9118:	0018      	movs	r0, r3
    911a:	46bd      	mov	sp, r7
    911c:	b00a      	add	sp, #40	; 0x28
    911e:	bd80      	pop	{r7, pc}
    9120:	0002fffc 	.word	0x0002fffc

00009124 <USBPD_DPM_SNK_EvaluateCapabilities>:
  * @param  PtrRequestData      Pointer on selected request data object
  * @param  PtrPowerObjectType  Pointer on the power data object
  * @retval None
  */
void USBPD_DPM_SNK_EvaluateCapabilities(uint8_t PortNum, uint32_t *PtrRequestData, USBPD_CORE_PDO_Type_TypeDef *PtrPowerObjectType)
{
    9124:	b5b0      	push	{r4, r5, r7, lr}
    9126:	b09a      	sub	sp, #104	; 0x68
    9128:	af02      	add	r7, sp, #8
    912a:	60b9      	str	r1, [r7, #8]
    912c:	607a      	str	r2, [r7, #4]
    912e:	210f      	movs	r1, #15
    9130:	187b      	adds	r3, r7, r1
    9132:	1c02      	adds	r2, r0, #0
    9134:	701a      	strb	r2, [r3, #0]
/* USER CODE BEGIN USBPD_DPM_SNK_EvaluateCapabilities */
  USBPD_PDO_TypeDef  fixed_pdo;
  USBPD_SNKRDO_TypeDef rdo;
  USBPD_HandleTypeDef *pdhandle = &DPM_Ports[PortNum];
    9136:	187b      	adds	r3, r7, r1
    9138:	781b      	ldrb	r3, [r3, #0]
    913a:	22b0      	movs	r2, #176	; 0xb0
    913c:	435a      	muls	r2, r3
    913e:	4b52      	ldr	r3, [pc, #328]	; (9288 <USBPD_DPM_SNK_EvaluateCapabilities+0x164>)
    9140:	18d3      	adds	r3, r2, r3
    9142:	65fb      	str	r3, [r7, #92]	; 0x5c
  USBPD_USER_SettingsTypeDef *puser = (USBPD_USER_SettingsTypeDef *)&DPM_USER_Settings[PortNum];
    9144:	187b      	adds	r3, r7, r1
    9146:	781b      	ldrb	r3, [r3, #0]
    9148:	2274      	movs	r2, #116	; 0x74
    914a:	435a      	muls	r2, r3
    914c:	4b4f      	ldr	r3, [pc, #316]	; (928c <USBPD_DPM_SNK_EvaluateCapabilities+0x168>)
    914e:	18d3      	adds	r3, r2, r3
    9150:	65bb      	str	r3, [r7, #88]	; 0x58
  USBPD_PDO_TypeDef snk_fixed_pdo;

  /* USBPD_DPM_EvaluateCapabilities: Port Partner Requests Max Voltage */

  /* Find the Pdo index for the requested voltage */
  pdoindex = DPM_FindVoltageIndex(PortNum, &snkpowerrequestdetails);
    9152:	187b      	adds	r3, r7, r1
    9154:	781b      	ldrb	r3, [r3, #0]
    9156:	2238      	movs	r2, #56	; 0x38
    9158:	18ba      	adds	r2, r7, r2
    915a:	0011      	movs	r1, r2
    915c:	0018      	movs	r0, r3
    915e:	f000 ffc5 	bl	a0ec <DPM_FindVoltageIndex>
    9162:	0003      	movs	r3, r0
    9164:	657b      	str	r3, [r7, #84]	; 0x54

  /* Initialize RDO */
  rdo.d32 = 0;
    9166:	2300      	movs	r3, #0
    9168:	64fb      	str	r3, [r7, #76]	; 0x4c

  /* If no valid SNK PDO or if no SRC PDO match found (index>=nb of valid received SRC PDOs or function returned DPM_NO_SRC_PDO_FOUND*/
  if (pdoindex >= pdhandle->DPM_NumberOfRcvSRCPDO)
    916a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    916c:	69db      	ldr	r3, [r3, #28]
    916e:	6d7a      	ldr	r2, [r7, #84]	; 0x54
    9170:	429a      	cmp	r2, r3
    9172:	d373      	bcc.n	925c <USBPD_DPM_SNK_EvaluateCapabilities+0x138>
  {
#if defined(_TRACE)
    USBPD_TRACE_Add(USBPD_TRACE_DEBUG, PortNum, 0, (uint8_t *) "PE_EvaluateCapability: could not find desired voltage", sizeof("PE_EvaluateCapability: could not find desired voltage"));
    9174:	4a46      	ldr	r2, [pc, #280]	; (9290 <USBPD_DPM_SNK_EvaluateCapabilities+0x16c>)
    9176:	240f      	movs	r4, #15
    9178:	193b      	adds	r3, r7, r4
    917a:	7819      	ldrb	r1, [r3, #0]
    917c:	2336      	movs	r3, #54	; 0x36
    917e:	9300      	str	r3, [sp, #0]
    9180:	0013      	movs	r3, r2
    9182:	2200      	movs	r2, #0
    9184:	2006      	movs	r0, #6
    9186:	f007 f9ed 	bl	10564 <USBPD_TRACE_Add>
#endif /* _TRACE */
    fixed_pdo.d32 = pdhandle->DPM_ListOfRcvSRCPDO[0];
    918a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    918c:	681b      	ldr	r3, [r3, #0]
    918e:	653b      	str	r3, [r7, #80]	; 0x50
    /* Read SNK PDO list for retrieving useful data to fill in RDO */
    USBPD_PWR_IF_GetPortPDOs(PortNum, USBPD_CORE_DATATYPE_SNK_PDO, (uint8_t*)&snkpdolist[0], &size);
    9190:	2334      	movs	r3, #52	; 0x34
    9192:	18f9      	adds	r1, r7, r3
    9194:	2518      	movs	r5, #24
    9196:	197a      	adds	r2, r7, r5
    9198:	193b      	adds	r3, r7, r4
    919a:	7818      	ldrb	r0, [r3, #0]
    919c:	000b      	movs	r3, r1
    919e:	2101      	movs	r1, #1
    91a0:	f001 fd5c 	bl	ac5c <USBPD_PWR_IF_GetPortPDOs>
    /* Store value of 1st SNK PDO (Fixed) in local variable */
    snk_fixed_pdo.d32 = snkpdolist[0];
    91a4:	197b      	adds	r3, r7, r5
    91a6:	681b      	ldr	r3, [r3, #0]
    91a8:	617b      	str	r3, [r7, #20]
    rdo.FixedVariableRDO.ObjectPosition = 1;
    91aa:	254f      	movs	r5, #79	; 0x4f
    91ac:	197b      	adds	r3, r7, r5
    91ae:	781a      	ldrb	r2, [r3, #0]
    91b0:	2170      	movs	r1, #112	; 0x70
    91b2:	438a      	bics	r2, r1
    91b4:	1c11      	adds	r1, r2, #0
    91b6:	2210      	movs	r2, #16
    91b8:	430a      	orrs	r2, r1
    91ba:	701a      	strb	r2, [r3, #0]
    rdo.FixedVariableRDO.OperatingCurrentIn10mAunits  =  fixed_pdo.SRCFixedPDO.MaxCurrentIn10mAunits;
    91bc:	2350      	movs	r3, #80	; 0x50
    91be:	18fb      	adds	r3, r7, r3
    91c0:	881b      	ldrh	r3, [r3, #0]
    91c2:	059b      	lsls	r3, r3, #22
    91c4:	0d9b      	lsrs	r3, r3, #22
    91c6:	b29b      	uxth	r3, r3
    91c8:	059b      	lsls	r3, r3, #22
    91ca:	0d9b      	lsrs	r3, r3, #22
    91cc:	029b      	lsls	r3, r3, #10
    91ce:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
    91d0:	4930      	ldr	r1, [pc, #192]	; (9294 <USBPD_DPM_SNK_EvaluateCapabilities+0x170>)
    91d2:	400a      	ands	r2, r1
    91d4:	4313      	orrs	r3, r2
    91d6:	64fb      	str	r3, [r7, #76]	; 0x4c
    rdo.FixedVariableRDO.MaxOperatingCurrent10mAunits = puser->DPM_SNKRequestedPower.MaxOperatingCurrentInmAunits / 10;
    91d8:	6dbb      	ldr	r3, [r7, #88]	; 0x58
    91da:	685b      	ldr	r3, [r3, #4]
    91dc:	210a      	movs	r1, #10
    91de:	0018      	movs	r0, r3
    91e0:	f015 fe70 	bl	1eec4 <__udivsi3>
    91e4:	0003      	movs	r3, r0
    91e6:	059b      	lsls	r3, r3, #22
    91e8:	0d9b      	lsrs	r3, r3, #22
    91ea:	b29a      	uxth	r2, r3
    91ec:	234c      	movs	r3, #76	; 0x4c
    91ee:	18fb      	adds	r3, r7, r3
    91f0:	0592      	lsls	r2, r2, #22
    91f2:	0d90      	lsrs	r0, r2, #22
    91f4:	881a      	ldrh	r2, [r3, #0]
    91f6:	0a92      	lsrs	r2, r2, #10
    91f8:	0292      	lsls	r2, r2, #10
    91fa:	1c11      	adds	r1, r2, #0
    91fc:	1c02      	adds	r2, r0, #0
    91fe:	430a      	orrs	r2, r1
    9200:	801a      	strh	r2, [r3, #0]
    rdo.FixedVariableRDO.CapabilityMismatch = 1;
    9202:	197b      	adds	r3, r7, r5
    9204:	781a      	ldrb	r2, [r3, #0]
    9206:	2104      	movs	r1, #4
    9208:	430a      	orrs	r2, r1
    920a:	701a      	strb	r2, [r3, #0]
    rdo.FixedVariableRDO.USBCommunicationsCapable = snk_fixed_pdo.SNKFixedPDO.USBCommunicationsCapable;
    920c:	2317      	movs	r3, #23
    920e:	18fb      	adds	r3, r7, r3
    9210:	781b      	ldrb	r3, [r3, #0]
    9212:	075b      	lsls	r3, r3, #29
    9214:	0fdb      	lsrs	r3, r3, #31
    9216:	b2da      	uxtb	r2, r3
    9218:	197b      	adds	r3, r7, r5
    921a:	2101      	movs	r1, #1
    921c:	400a      	ands	r2, r1
    921e:	1890      	adds	r0, r2, r2
    9220:	781a      	ldrb	r2, [r3, #0]
    9222:	2102      	movs	r1, #2
    9224:	438a      	bics	r2, r1
    9226:	1c11      	adds	r1, r2, #0
    9228:	1c02      	adds	r2, r0, #0
    922a:	430a      	orrs	r2, r1
    922c:	701a      	strb	r2, [r3, #0]
    DPM_Ports[PortNum].DPM_RequestedCurrent = puser->DPM_SNKRequestedPower.MaxOperatingCurrentInmAunits;
    922e:	193b      	adds	r3, r7, r4
    9230:	7818      	ldrb	r0, [r3, #0]
    9232:	6dbb      	ldr	r3, [r7, #88]	; 0x58
    9234:	685a      	ldr	r2, [r3, #4]
    9236:	4914      	ldr	r1, [pc, #80]	; (9288 <USBPD_DPM_SNK_EvaluateCapabilities+0x164>)
    9238:	23b0      	movs	r3, #176	; 0xb0
    923a:	4343      	muls	r3, r0
    923c:	18cb      	adds	r3, r1, r3
    923e:	3348      	adds	r3, #72	; 0x48
    9240:	601a      	str	r2, [r3, #0]

    pdhandle->DPM_RequestDOMsg = rdo.d32;
    9242:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
    9244:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    9246:	655a      	str	r2, [r3, #84]	; 0x54
    *PtrPowerObjectType = USBPD_CORE_PDO_TYPE_FIXED;
    9248:	687b      	ldr	r3, [r7, #4]
    924a:	2200      	movs	r2, #0
    924c:	601a      	str	r2, [r3, #0]
    *PtrRequestData     = rdo.d32;
    924e:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
    9250:	68bb      	ldr	r3, [r7, #8]
    9252:	601a      	str	r2, [r3, #0]
    pdhandle->DPM_RequestedVoltage = 5000;
    9254:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    9256:	4a10      	ldr	r2, [pc, #64]	; (9298 <USBPD_DPM_SNK_EvaluateCapabilities+0x174>)
    9258:	645a      	str	r2, [r3, #68]	; 0x44
    925a:	e011      	b.n	9280 <USBPD_DPM_SNK_EvaluateCapabilities+0x15c>
    return;
  }

  DPM_SNK_BuildRDOfromSelectedPDO(PortNum, pdoindex, &snkpowerrequestdetails,&rdo, PtrPowerObjectType);
    925c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    925e:	b2d9      	uxtb	r1, r3
    9260:	234c      	movs	r3, #76	; 0x4c
    9262:	18fc      	adds	r4, r7, r3
    9264:	2338      	movs	r3, #56	; 0x38
    9266:	18fa      	adds	r2, r7, r3
    9268:	230f      	movs	r3, #15
    926a:	18fb      	adds	r3, r7, r3
    926c:	7818      	ldrb	r0, [r3, #0]
    926e:	687b      	ldr	r3, [r7, #4]
    9270:	9300      	str	r3, [sp, #0]
    9272:	0023      	movs	r3, r4
    9274:	f000 ffc0 	bl	a1f8 <DPM_SNK_BuildRDOfromSelectedPDO>


  *PtrRequestData = pdhandle->DPM_RequestDOMsg;
    9278:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    927a:	6d5a      	ldr	r2, [r3, #84]	; 0x54
    927c:	68bb      	ldr	r3, [r7, #8]
    927e:	601a      	str	r2, [r3, #0]
/* USER CODE END USBPD_DPM_SNK_EvaluateCapabilities */
}
    9280:	46bd      	mov	sp, r7
    9282:	b018      	add	sp, #96	; 0x60
    9284:	bdb0      	pop	{r4, r5, r7, pc}
    9286:	46c0      	nop			; (mov r8, r8)
    9288:	0002fffc 	.word	0x0002fffc
    928c:	0002fedc 	.word	0x0002fedc
    9290:	0001f1fc 	.word	0x0001f1fc
    9294:	fff003ff 	.word	0xfff003ff
    9298:	00001388 	.word	0x00001388

0000929c <USBPD_DPM_PowerRoleSwap>:
  * @param  CurrentRole the current role
  * @param  Status status on power role swap event
  * @retval None
  */
void USBPD_DPM_PowerRoleSwap(uint8_t PortNum, USBPD_PortPowerRole_TypeDef CurrentRole, USBPD_PRS_Status_TypeDef Status)
{
    929c:	b580      	push	{r7, lr}
    929e:	b084      	sub	sp, #16
    92a0:	af00      	add	r7, sp, #0
    92a2:	6039      	str	r1, [r7, #0]
    92a4:	0011      	movs	r1, r2
    92a6:	1dfb      	adds	r3, r7, #7
    92a8:	1c02      	adds	r2, r0, #0
    92aa:	701a      	strb	r2, [r3, #0]
    92ac:	1dbb      	adds	r3, r7, #6
    92ae:	1c0a      	adds	r2, r1, #0
    92b0:	701a      	strb	r2, [r3, #0]
/* USER CODE BEGIN USBPD_DPM_PowerRoleSwap */
    switch (Status)
    92b2:	1dbb      	adds	r3, r7, #6
    92b4:	781b      	ldrb	r3, [r3, #0]
    92b6:	2b07      	cmp	r3, #7
    92b8:	d038      	beq.n	932c <USBPD_DPM_PowerRoleSwap+0x90>
    92ba:	dc02      	bgt.n	92c2 <USBPD_DPM_PowerRoleSwap+0x26>
    92bc:	2b06      	cmp	r3, #6
    92be:	d005      	beq.n	92cc <USBPD_DPM_PowerRoleSwap+0x30>
      uint32_t event = (PortNum << 8 | 1);
      (void)osMessageQueuePut(AlarmMsgBox, &event, 0U, osWaitForever);
#endif /* osCMSIS < 0x20000U */
      break;
    default:
      break;
    92c0:	e056      	b.n	9370 <USBPD_DPM_PowerRoleSwap+0xd4>
    switch (Status)
    92c2:	2b0a      	cmp	r3, #10
    92c4:	d038      	beq.n	9338 <USBPD_DPM_PowerRoleSwap+0x9c>
    92c6:	2b0b      	cmp	r3, #11
    92c8:	d03c      	beq.n	9344 <USBPD_DPM_PowerRoleSwap+0xa8>
      break;
    92ca:	e051      	b.n	9370 <USBPD_DPM_PowerRoleSwap+0xd4>
      if (CurrentRole == USBPD_PORTPOWERROLE_SRC)
    92cc:	683b      	ldr	r3, [r7, #0]
    92ce:	2b01      	cmp	r3, #1
    92d0:	d14d      	bne.n	936e <USBPD_DPM_PowerRoleSwap+0xd2>
        uint32_t _vconnstate = DPM_Params[PortNum].VconnStatus;
    92d2:	1dfb      	adds	r3, r7, #7
    92d4:	781b      	ldrb	r3, [r3, #0]
    92d6:	4a28      	ldr	r2, [pc, #160]	; (9378 <USBPD_DPM_PowerRoleSwap+0xdc>)
    92d8:	009b      	lsls	r3, r3, #2
    92da:	18d3      	adds	r3, r2, r3
    92dc:	785b      	ldrb	r3, [r3, #1]
    92de:	061b      	lsls	r3, r3, #24
    92e0:	0fdb      	lsrs	r3, r3, #31
    92e2:	b2db      	uxtb	r3, r3
    92e4:	60fb      	str	r3, [r7, #12]
        DPM_Params[PortNum].VconnStatus = USBPD_FALSE;
    92e6:	1dfb      	adds	r3, r7, #7
    92e8:	781b      	ldrb	r3, [r3, #0]
    92ea:	4a23      	ldr	r2, [pc, #140]	; (9378 <USBPD_DPM_PowerRoleSwap+0xdc>)
    92ec:	009b      	lsls	r3, r3, #2
    92ee:	18d3      	adds	r3, r2, r3
    92f0:	785a      	ldrb	r2, [r3, #1]
    92f2:	217f      	movs	r1, #127	; 0x7f
    92f4:	400a      	ands	r2, r1
    92f6:	705a      	strb	r2, [r3, #1]
        DPM_TurnOffPower(PortNum, CurrentRole);
    92f8:	683a      	ldr	r2, [r7, #0]
    92fa:	1dfb      	adds	r3, r7, #7
    92fc:	781b      	ldrb	r3, [r3, #0]
    92fe:	0011      	movs	r1, r2
    9300:	0018      	movs	r0, r3
    9302:	f001 f945 	bl	a590 <DPM_TurnOffPower>
        DPM_Params[PortNum].VconnStatus = _vconnstate;
    9306:	1dfb      	adds	r3, r7, #7
    9308:	781b      	ldrb	r3, [r3, #0]
    930a:	68fa      	ldr	r2, [r7, #12]
    930c:	1c11      	adds	r1, r2, #0
    930e:	2201      	movs	r2, #1
    9310:	400a      	ands	r2, r1
    9312:	b2d2      	uxtb	r2, r2
    9314:	4918      	ldr	r1, [pc, #96]	; (9378 <USBPD_DPM_PowerRoleSwap+0xdc>)
    9316:	009b      	lsls	r3, r3, #2
    9318:	18cb      	adds	r3, r1, r3
    931a:	01d0      	lsls	r0, r2, #7
    931c:	785a      	ldrb	r2, [r3, #1]
    931e:	217f      	movs	r1, #127	; 0x7f
    9320:	400a      	ands	r2, r1
    9322:	1c11      	adds	r1, r2, #0
    9324:	1c02      	adds	r2, r0, #0
    9326:	430a      	orrs	r2, r1
    9328:	705a      	strb	r2, [r3, #1]
      break;
    932a:	e020      	b.n	936e <USBPD_DPM_PowerRoleSwap+0xd2>
      DPM_AssertRd(PortNum);
    932c:	1dfb      	adds	r3, r7, #7
    932e:	781b      	ldrb	r3, [r3, #0]
    9330:	0018      	movs	r0, r3
    9332:	f001 f970 	bl	a616 <DPM_AssertRd>
      break;
    9336:	e01b      	b.n	9370 <USBPD_DPM_PowerRoleSwap+0xd4>
      DPM_AssertRp(PortNum);
    9338:	1dfb      	adds	r3, r7, #7
    933a:	781b      	ldrb	r3, [r3, #0]
    933c:	0018      	movs	r0, r3
    933e:	f001 f959 	bl	a5f4 <DPM_AssertRp>
      break;
    9342:	e015      	b.n	9370 <USBPD_DPM_PowerRoleSwap+0xd4>
      DPM_TurnOnPower(PortNum, CurrentRole);
    9344:	683a      	ldr	r2, [r7, #0]
    9346:	1dfb      	adds	r3, r7, #7
    9348:	781b      	ldrb	r3, [r3, #0]
    934a:	0011      	movs	r1, r2
    934c:	0018      	movs	r0, r3
    934e:	f001 f938 	bl	a5c2 <DPM_TurnOnPower>
      osMessagePut(AlarmMsgBox, (PortNum << 8 | 1), osWaitForever);
    9352:	4b0a      	ldr	r3, [pc, #40]	; (937c <USBPD_DPM_PowerRoleSwap+0xe0>)
    9354:	6818      	ldr	r0, [r3, #0]
    9356:	1dfb      	adds	r3, r7, #7
    9358:	781b      	ldrb	r3, [r3, #0]
    935a:	021b      	lsls	r3, r3, #8
    935c:	2201      	movs	r2, #1
    935e:	4313      	orrs	r3, r2
    9360:	0019      	movs	r1, r3
    9362:	2301      	movs	r3, #1
    9364:	425b      	negs	r3, r3
    9366:	001a      	movs	r2, r3
    9368:	f007 fb66 	bl	10a38 <osMessagePut>
      break;
    936c:	e000      	b.n	9370 <USBPD_DPM_PowerRoleSwap+0xd4>
      break;
    936e:	46c0      	nop			; (mov r8, r8)
    }
/* USER CODE END USBPD_DPM_PowerRoleSwap */
}
    9370:	46c0      	nop			; (mov r8, r8)
    9372:	46bd      	mov	sp, r7
    9374:	b004      	add	sp, #16
    9376:	bd80      	pop	{r7, pc}
    9378:	000321d4 	.word	0x000321d4
    937c:	000321d0 	.word	0x000321d0

00009380 <USBPD_DPM_EvaluateVconnSwap>:
  * @brief  Callback to be used by PE to evaluate a Vconn swap
  * @param  PortNum Port number
  * @retval USBPD_ACCEPT, USBPD_REJECT, USBPD_WAIT
  */
USBPD_StatusTypeDef USBPD_DPM_EvaluateVconnSwap(uint8_t PortNum)
{
    9380:	b580      	push	{r7, lr}
    9382:	b084      	sub	sp, #16
    9384:	af00      	add	r7, sp, #0
    9386:	0002      	movs	r2, r0
    9388:	1dfb      	adds	r3, r7, #7
    938a:	701a      	strb	r2, [r3, #0]
/* USER CODE BEGIN USBPD_DPM_EvaluateVconnSwap */
  USBPD_StatusTypeDef status = USBPD_REJECT;
    938c:	230f      	movs	r3, #15
    938e:	18fb      	adds	r3, r7, r3
    9390:	220c      	movs	r2, #12
    9392:	701a      	strb	r2, [r3, #0]
  if (USBPD_TRUE == DPM_USER_Settings[PortNum].PE_VconnSwap)
    9394:	1dfb      	adds	r3, r7, #7
    9396:	781a      	ldrb	r2, [r3, #0]
    9398:	4b09      	ldr	r3, [pc, #36]	; (93c0 <USBPD_DPM_EvaluateVconnSwap+0x40>)
    939a:	2174      	movs	r1, #116	; 0x74
    939c:	434a      	muls	r2, r1
    939e:	5cd3      	ldrb	r3, [r2, r3]
    93a0:	079b      	lsls	r3, r3, #30
    93a2:	0fdb      	lsrs	r3, r3, #31
    93a4:	b2db      	uxtb	r3, r3
    93a6:	2b01      	cmp	r3, #1
    93a8:	d103      	bne.n	93b2 <USBPD_DPM_EvaluateVconnSwap+0x32>
  {
    status = USBPD_ACCEPT;
    93aa:	230f      	movs	r3, #15
    93ac:	18fb      	adds	r3, r7, r3
    93ae:	220a      	movs	r2, #10
    93b0:	701a      	strb	r2, [r3, #0]
  }

  return status;
    93b2:	230f      	movs	r3, #15
    93b4:	18fb      	adds	r3, r7, r3
    93b6:	781b      	ldrb	r3, [r3, #0]
/* USER CODE END USBPD_DPM_EvaluateVconnSwap */
}
    93b8:	0018      	movs	r0, r3
    93ba:	46bd      	mov	sp, r7
    93bc:	b004      	add	sp, #16
    93be:	bd80      	pop	{r7, pc}
    93c0:	0002fedc 	.word	0x0002fedc

000093c4 <USBPD_DPM_PE_VconnPwr>:
  * @param  PortNum Port number
  * @param  State  Enable or Disable VConn on CC lines
  * @retval USBPD_ACCEPT, USBPD_REJECT
  */
USBPD_StatusTypeDef USBPD_DPM_PE_VconnPwr(uint8_t PortNum, USBPD_FunctionalState State)
{
    93c4:	b590      	push	{r4, r7, lr}
    93c6:	b085      	sub	sp, #20
    93c8:	af00      	add	r7, sp, #0
    93ca:	0002      	movs	r2, r0
    93cc:	1dfb      	adds	r3, r7, #7
    93ce:	701a      	strb	r2, [r3, #0]
    93d0:	1dbb      	adds	r3, r7, #6
    93d2:	1c0a      	adds	r2, r1, #0
    93d4:	701a      	strb	r2, [r3, #0]
/* USER CODE BEGIN USBPD_DPM_PE_VconnPwr */
  USBPD_StatusTypeDef status = USBPD_ERROR;
    93d6:	230f      	movs	r3, #15
    93d8:	18fb      	adds	r3, r7, r3
    93da:	2202      	movs	r2, #2
    93dc:	701a      	strb	r2, [r3, #0]
  if((USBPD_ENABLE == State) && (CCNONE != DPM_Params[PortNum].VconnCCIs))
    93de:	1dbb      	adds	r3, r7, #6
    93e0:	781b      	ldrb	r3, [r3, #0]
    93e2:	2b01      	cmp	r3, #1
    93e4:	d12a      	bne.n	943c <USBPD_DPM_PE_VconnPwr+0x78>
    93e6:	1dfb      	adds	r3, r7, #7
    93e8:	781b      	ldrb	r3, [r3, #0]
    93ea:	4a29      	ldr	r2, [pc, #164]	; (9490 <USBPD_DPM_PE_VconnPwr+0xcc>)
    93ec:	009b      	lsls	r3, r3, #2
    93ee:	18d3      	adds	r3, r2, r3
    93f0:	785b      	ldrb	r3, [r3, #1]
    93f2:	065b      	lsls	r3, r3, #25
    93f4:	0f9b      	lsrs	r3, r3, #30
    93f6:	b2db      	uxtb	r3, r3
    93f8:	2b00      	cmp	r3, #0
    93fa:	d01f      	beq.n	943c <USBPD_DPM_PE_VconnPwr+0x78>
  {
    /* In case of VCONN Swap SRC -> SNK. Keep information that CABLE is EMC */
    DPM_Ports[PortNum].DPM_CablePDCapable = USBPD_TRUE;
    93fc:	1dfb      	adds	r3, r7, #7
    93fe:	781b      	ldrb	r3, [r3, #0]
    9400:	4a24      	ldr	r2, [pc, #144]	; (9494 <USBPD_DPM_PE_VconnPwr+0xd0>)
    9402:	2160      	movs	r1, #96	; 0x60
    9404:	20b0      	movs	r0, #176	; 0xb0
    9406:	4343      	muls	r3, r0
    9408:	18d3      	adds	r3, r2, r3
    940a:	185b      	adds	r3, r3, r1
    940c:	795a      	ldrb	r2, [r3, #5]
    940e:	2101      	movs	r1, #1
    9410:	430a      	orrs	r2, r1
    9412:	715a      	strb	r2, [r3, #5]
    status = USBPD_PWR_IF_Enable_VConn(PortNum,DPM_Params[PortNum].VconnCCIs);
    9414:	1dfb      	adds	r3, r7, #7
    9416:	781b      	ldrb	r3, [r3, #0]
    9418:	4a1d      	ldr	r2, [pc, #116]	; (9490 <USBPD_DPM_PE_VconnPwr+0xcc>)
    941a:	009b      	lsls	r3, r3, #2
    941c:	18d3      	adds	r3, r2, r3
    941e:	785b      	ldrb	r3, [r3, #1]
    9420:	065b      	lsls	r3, r3, #25
    9422:	0f9b      	lsrs	r3, r3, #30
    9424:	b2db      	uxtb	r3, r3
    9426:	001a      	movs	r2, r3
    9428:	230f      	movs	r3, #15
    942a:	18fc      	adds	r4, r7, r3
    942c:	1dfb      	adds	r3, r7, #7
    942e:	781b      	ldrb	r3, [r3, #0]
    9430:	0011      	movs	r1, r2
    9432:	0018      	movs	r0, r3
    9434:	f001 fbaa 	bl	ab8c <USBPD_PWR_IF_Enable_VConn>
    9438:	0003      	movs	r3, r0
    943a:	7023      	strb	r3, [r4, #0]
  }
  if((USBPD_DISABLE == State) && (CCNONE != DPM_Params[PortNum].VconnCCIs))
    943c:	1dbb      	adds	r3, r7, #6
    943e:	781b      	ldrb	r3, [r3, #0]
    9440:	2b00      	cmp	r3, #0
    9442:	d11e      	bne.n	9482 <USBPD_DPM_PE_VconnPwr+0xbe>
    9444:	1dfb      	adds	r3, r7, #7
    9446:	781b      	ldrb	r3, [r3, #0]
    9448:	4a11      	ldr	r2, [pc, #68]	; (9490 <USBPD_DPM_PE_VconnPwr+0xcc>)
    944a:	009b      	lsls	r3, r3, #2
    944c:	18d3      	adds	r3, r2, r3
    944e:	785b      	ldrb	r3, [r3, #1]
    9450:	065b      	lsls	r3, r3, #25
    9452:	0f9b      	lsrs	r3, r3, #30
    9454:	b2db      	uxtb	r3, r3
    9456:	2b00      	cmp	r3, #0
    9458:	d013      	beq.n	9482 <USBPD_DPM_PE_VconnPwr+0xbe>
  {
    status = USBPD_PWR_IF_Disable_VConn(PortNum,DPM_Params[PortNum].VconnCCIs);
    945a:	1dfb      	adds	r3, r7, #7
    945c:	781b      	ldrb	r3, [r3, #0]
    945e:	4a0c      	ldr	r2, [pc, #48]	; (9490 <USBPD_DPM_PE_VconnPwr+0xcc>)
    9460:	009b      	lsls	r3, r3, #2
    9462:	18d3      	adds	r3, r2, r3
    9464:	785b      	ldrb	r3, [r3, #1]
    9466:	065b      	lsls	r3, r3, #25
    9468:	0f9b      	lsrs	r3, r3, #30
    946a:	b2db      	uxtb	r3, r3
    946c:	001a      	movs	r2, r3
    946e:	230f      	movs	r3, #15
    9470:	18fc      	adds	r4, r7, r3
    9472:	1dfb      	adds	r3, r7, #7
    9474:	781b      	ldrb	r3, [r3, #0]
    9476:	0011      	movs	r1, r2
    9478:	0018      	movs	r0, r3
    947a:	f001 fbbb 	bl	abf4 <USBPD_PWR_IF_Disable_VConn>
    947e:	0003      	movs	r3, r0
    9480:	7023      	strb	r3, [r4, #0]
  }
  return status;
    9482:	230f      	movs	r3, #15
    9484:	18fb      	adds	r3, r7, r3
    9486:	781b      	ldrb	r3, [r3, #0]
/* USER CODE END USBPD_DPM_PE_VconnPwr */
}
    9488:	0018      	movs	r0, r3
    948a:	46bd      	mov	sp, r7
    948c:	b005      	add	sp, #20
    948e:	bd90      	pop	{r4, r7, pc}
    9490:	000321d4 	.word	0x000321d4
    9494:	0002fffc 	.word	0x0002fffc

00009498 <USBPD_DPM_ExtendedMessageReceived>:
  * @param  ptrData   Pointer on address Extended Message data could be read (u8 pointer)
  * @param  DataSize  Nb of u8 that compose Extended message
  * @retval None
  */
void USBPD_DPM_ExtendedMessageReceived(uint8_t PortNum, USBPD_ExtendedMsg_TypeDef MsgType, uint8_t *ptrData, uint16_t DataSize)
{
    9498:	b590      	push	{r4, r7, lr}
    949a:	b083      	sub	sp, #12
    949c:	af00      	add	r7, sp, #0
    949e:	0004      	movs	r4, r0
    94a0:	0008      	movs	r0, r1
    94a2:	603a      	str	r2, [r7, #0]
    94a4:	0019      	movs	r1, r3
    94a6:	1dfb      	adds	r3, r7, #7
    94a8:	1c22      	adds	r2, r4, #0
    94aa:	701a      	strb	r2, [r3, #0]
    94ac:	1dbb      	adds	r3, r7, #6
    94ae:	1c02      	adds	r2, r0, #0
    94b0:	701a      	strb	r2, [r3, #0]
    94b2:	1d3b      	adds	r3, r7, #4
    94b4:	1c0a      	adds	r2, r1, #0
    94b6:	801a      	strh	r2, [r3, #0]
/* USER CODE BEGIN USBPD_DPM_ExtendedMessageReceived */
  if (DataSize == 0)
    94b8:	1d3b      	adds	r3, r7, #4
    94ba:	881b      	ldrh	r3, [r3, #0]
    94bc:	2b00      	cmp	r3, #0
    94be:	d001      	beq.n	94c4 <USBPD_DPM_ExtendedMessageReceived+0x2c>
  }

  switch(MsgType)
  {
    default:
      break;
    94c0:	46c0      	nop			; (mov r8, r8)
    94c2:	e000      	b.n	94c6 <USBPD_DPM_ExtendedMessageReceived+0x2e>
    return;
    94c4:	46c0      	nop			; (mov r8, r8)
  }
/* USER CODE END USBPD_DPM_ExtendedMessageReceived */
}
    94c6:	46bd      	mov	sp, r7
    94c8:	b003      	add	sp, #12
    94ca:	bd90      	pop	{r4, r7, pc}

000094cc <USBPD_DPM_EvaluateDataRoleSwap>:
  * @brief  DPM callback used to know user choice about Data Role Swap.
  * @param  PortNum Port number
  * @retval USBPD_REJECT, UBPD_ACCEPT
  */
USBPD_StatusTypeDef USBPD_DPM_EvaluateDataRoleSwap(uint8_t PortNum)
{
    94cc:	b580      	push	{r7, lr}
    94ce:	b084      	sub	sp, #16
    94d0:	af00      	add	r7, sp, #0
    94d2:	0002      	movs	r2, r0
    94d4:	1dfb      	adds	r3, r7, #7
    94d6:	701a      	strb	r2, [r3, #0]
/* USER CODE BEGIN USBPD_DPM_EvaluateDataRoleSwap */
  USBPD_StatusTypeDef status = USBPD_REJECT;
    94d8:	230f      	movs	r3, #15
    94da:	18fb      	adds	r3, r7, r3
    94dc:	220c      	movs	r2, #12
    94de:	701a      	strb	r2, [r3, #0]
  if ((USBPD_TRUE == DPM_USER_Settings[PortNum].PE_DataSwap)
    94e0:	1dfb      	adds	r3, r7, #7
    94e2:	781a      	ldrb	r2, [r3, #0]
    94e4:	4b1e      	ldr	r3, [pc, #120]	; (9560 <USBPD_DPM_EvaluateDataRoleSwap+0x94>)
    94e6:	2174      	movs	r1, #116	; 0x74
    94e8:	434a      	muls	r2, r1
    94ea:	5cd3      	ldrb	r3, [r2, r3]
    94ec:	07db      	lsls	r3, r3, #31
    94ee:	0fdb      	lsrs	r3, r3, #31
    94f0:	b2db      	uxtb	r3, r3
    94f2:	2b01      	cmp	r3, #1
    94f4:	d12d      	bne.n	9552 <USBPD_DPM_EvaluateDataRoleSwap+0x86>
    && (((USBPD_TRUE == DPM_USER_Settings[PortNum].PE_DR_Swap_To_DFP) && (USBPD_PORTDATAROLE_UFP == DPM_Params[PortNum].PE_DataRole))
    94f6:	1dfb      	adds	r3, r7, #7
    94f8:	781a      	ldrb	r2, [r3, #0]
    94fa:	4b19      	ldr	r3, [pc, #100]	; (9560 <USBPD_DPM_EvaluateDataRoleSwap+0x94>)
    94fc:	2174      	movs	r1, #116	; 0x74
    94fe:	434a      	muls	r2, r1
    9500:	5cd3      	ldrb	r3, [r2, r3]
    9502:	075b      	lsls	r3, r3, #29
    9504:	0fdb      	lsrs	r3, r3, #31
    9506:	b2db      	uxtb	r3, r3
    9508:	2b01      	cmp	r3, #1
    950a:	d109      	bne.n	9520 <USBPD_DPM_EvaluateDataRoleSwap+0x54>
    950c:	1dfb      	adds	r3, r7, #7
    950e:	781a      	ldrb	r2, [r3, #0]
    9510:	4b14      	ldr	r3, [pc, #80]	; (9564 <USBPD_DPM_EvaluateDataRoleSwap+0x98>)
    9512:	0092      	lsls	r2, r2, #2
    9514:	5cd3      	ldrb	r3, [r2, r3]
    9516:	071b      	lsls	r3, r3, #28
    9518:	0fdb      	lsrs	r3, r3, #31
    951a:	b2db      	uxtb	r3, r3
    951c:	2b00      	cmp	r3, #0
    951e:	d014      	beq.n	954a <USBPD_DPM_EvaluateDataRoleSwap+0x7e>
     || ((USBPD_TRUE == DPM_USER_Settings[PortNum].PE_DR_Swap_To_UFP) && (USBPD_PORTDATAROLE_DFP == DPM_Params[PortNum].PE_DataRole))))
    9520:	1dfb      	adds	r3, r7, #7
    9522:	781a      	ldrb	r2, [r3, #0]
    9524:	4b0e      	ldr	r3, [pc, #56]	; (9560 <USBPD_DPM_EvaluateDataRoleSwap+0x94>)
    9526:	2174      	movs	r1, #116	; 0x74
    9528:	434a      	muls	r2, r1
    952a:	5cd3      	ldrb	r3, [r2, r3]
    952c:	071b      	lsls	r3, r3, #28
    952e:	0fdb      	lsrs	r3, r3, #31
    9530:	b2db      	uxtb	r3, r3
    9532:	2b01      	cmp	r3, #1
    9534:	d10d      	bne.n	9552 <USBPD_DPM_EvaluateDataRoleSwap+0x86>
    9536:	1dfb      	adds	r3, r7, #7
    9538:	781a      	ldrb	r2, [r3, #0]
    953a:	4b0a      	ldr	r3, [pc, #40]	; (9564 <USBPD_DPM_EvaluateDataRoleSwap+0x98>)
    953c:	0092      	lsls	r2, r2, #2
    953e:	5cd3      	ldrb	r3, [r2, r3]
    9540:	071b      	lsls	r3, r3, #28
    9542:	0fdb      	lsrs	r3, r3, #31
    9544:	b2db      	uxtb	r3, r3
    9546:	2b01      	cmp	r3, #1
    9548:	d103      	bne.n	9552 <USBPD_DPM_EvaluateDataRoleSwap+0x86>
  {
    status = USBPD_ACCEPT;
    954a:	230f      	movs	r3, #15
    954c:	18fb      	adds	r3, r7, r3
    954e:	220a      	movs	r2, #10
    9550:	701a      	strb	r2, [r3, #0]
  }
  return status;
    9552:	230f      	movs	r3, #15
    9554:	18fb      	adds	r3, r7, r3
    9556:	781b      	ldrb	r3, [r3, #0]
/* USER CODE END USBPD_DPM_EvaluateDataRoleSwap */
}
    9558:	0018      	movs	r0, r3
    955a:	46bd      	mov	sp, r7
    955c:	b004      	add	sp, #16
    955e:	bd80      	pop	{r7, pc}
    9560:	0002fedc 	.word	0x0002fedc
    9564:	000321d4 	.word	0x000321d4

00009568 <USBPD_DPM_IsPowerReady>:
  * @param  PortNum Port number
  * @param  Vsafe   Vsafe status based on @ref USBPD_VSAFE_StatusTypeDef
  * @retval USBPD_DISABLE or USBPD_ENABLE
  */
USBPD_FunctionalState USBPD_DPM_IsPowerReady(uint8_t PortNum, USBPD_VSAFE_StatusTypeDef Vsafe)
{
    9568:	b580      	push	{r7, lr}
    956a:	b082      	sub	sp, #8
    956c:	af00      	add	r7, sp, #0
    956e:	0002      	movs	r2, r0
    9570:	1dfb      	adds	r3, r7, #7
    9572:	701a      	strb	r2, [r3, #0]
    9574:	1dbb      	adds	r3, r7, #6
    9576:	1c0a      	adds	r2, r1, #0
    9578:	701a      	strb	r2, [r3, #0]
/* USER CODE BEGIN USBPD_DPM_IsPowerReady */
  return ((USBPD_OK == USBPD_PWR_IF_SupplyReady(PortNum, Vsafe)) ? USBPD_ENABLE : USBPD_DISABLE);
    957a:	1dbb      	adds	r3, r7, #6
    957c:	781a      	ldrb	r2, [r3, #0]
    957e:	1dfb      	adds	r3, r7, #7
    9580:	781b      	ldrb	r3, [r3, #0]
    9582:	0011      	movs	r1, r2
    9584:	0018      	movs	r0, r3
    9586:	f001 f9fd 	bl	a984 <USBPD_PWR_IF_SupplyReady>
    958a:	0003      	movs	r3, r0
    958c:	425a      	negs	r2, r3
    958e:	4153      	adcs	r3, r2
    9590:	b2db      	uxtb	r3, r3
/* USER CODE END USBPD_DPM_IsPowerReady */
}
    9592:	0018      	movs	r0, r3
    9594:	46bd      	mov	sp, r7
    9596:	b002      	add	sp, #8
    9598:	bd80      	pop	{r7, pc}

0000959a <USBPD_DPM_RequestHardReset>:
  * @brief  Request the PE to send a hard reset
  * @param  PortNum The current port number
  * @retval USBPD Status
  */
USBPD_StatusTypeDef USBPD_DPM_RequestHardReset(uint8_t PortNum)
{
    959a:	b580      	push	{r7, lr}
    959c:	b082      	sub	sp, #8
    959e:	af00      	add	r7, sp, #0
    95a0:	0002      	movs	r2, r0
    95a2:	1dfb      	adds	r3, r7, #7
    95a4:	701a      	strb	r2, [r3, #0]
  __DPM_DEBUG_CALLBACK(PortNum, "USBPD_PE_Request_HardReset");
  return USBPD_PE_Request_HardReset(PortNum);
    95a6:	1dfb      	adds	r3, r7, #7
    95a8:	781b      	ldrb	r3, [r3, #0]
    95aa:	0018      	movs	r0, r3
    95ac:	f010 ff65 	bl	1a47a <USBPD_PE_Request_HardReset>
    95b0:	0003      	movs	r3, r0
}
    95b2:	0018      	movs	r0, r3
    95b4:	46bd      	mov	sp, r7
    95b6:	b002      	add	sp, #8
    95b8:	bd80      	pop	{r7, pc}

000095ba <USBPD_DPM_RequestCableReset>:
            The DFP has to be supplying VCONN prior to a Cable Reset
  * @param  PortNum The current port number
  * @retval USBPD Status
  */
USBPD_StatusTypeDef USBPD_DPM_RequestCableReset(uint8_t PortNum)
{
    95ba:	b580      	push	{r7, lr}
    95bc:	b082      	sub	sp, #8
    95be:	af00      	add	r7, sp, #0
    95c0:	0002      	movs	r2, r0
    95c2:	1dfb      	adds	r3, r7, #7
    95c4:	701a      	strb	r2, [r3, #0]
  __DPM_DEBUG_CALLBACK(PortNum, "USBPD_PE_Request_CableReset");
  return USBPD_PE_Request_CableReset(PortNum);
    95c6:	1dfb      	adds	r3, r7, #7
    95c8:	781b      	ldrb	r3, [r3, #0]
    95ca:	0018      	movs	r0, r3
    95cc:	f010 ff64 	bl	1a498 <USBPD_PE_Request_CableReset>
    95d0:	0003      	movs	r3, r0
}
    95d2:	0018      	movs	r0, r3
    95d4:	46bd      	mov	sp, r7
    95d6:	b002      	add	sp, #8
    95d8:	bd80      	pop	{r7, pc}

000095da <USBPD_DPM_RequestGotoMin>:
  * @brief  Request the PE to send a GOTOMIN message
  * @param  PortNum The current port number
  * @retval USBPD Status
  */
USBPD_StatusTypeDef USBPD_DPM_RequestGotoMin(uint8_t PortNum)
{
    95da:	b580      	push	{r7, lr}
    95dc:	b082      	sub	sp, #8
    95de:	af00      	add	r7, sp, #0
    95e0:	0002      	movs	r2, r0
    95e2:	1dfb      	adds	r3, r7, #7
    95e4:	701a      	strb	r2, [r3, #0]
  __DPM_DEBUG_CALLBACK(PortNum, "USBPD_PE_Request_CtrlMessage(GOTOMIN)");
  return USBPD_PE_Request_CtrlMessage(PortNum, USBPD_CONTROLMSG_GOTOMIN, USBPD_SOPTYPE_SOP);
    95e6:	1dfb      	adds	r3, r7, #7
    95e8:	781b      	ldrb	r3, [r3, #0]
    95ea:	2200      	movs	r2, #0
    95ec:	2102      	movs	r1, #2
    95ee:	0018      	movs	r0, r3
    95f0:	f010 ff66 	bl	1a4c0 <USBPD_PE_Request_CtrlMessage>
    95f4:	0003      	movs	r3, r0
}
    95f6:	0018      	movs	r0, r3
    95f8:	46bd      	mov	sp, r7
    95fa:	b002      	add	sp, #8
    95fc:	bd80      	pop	{r7, pc}

000095fe <USBPD_DPM_RequestPing>:
  *         If PD2.0 is used, PING timer needs to be implemented on user side.
  * @param  PortNum The current port number
  * @retval USBPD Status
  */
USBPD_StatusTypeDef USBPD_DPM_RequestPing(uint8_t PortNum)
{
    95fe:	b580      	push	{r7, lr}
    9600:	b082      	sub	sp, #8
    9602:	af00      	add	r7, sp, #0
    9604:	0002      	movs	r2, r0
    9606:	1dfb      	adds	r3, r7, #7
    9608:	701a      	strb	r2, [r3, #0]
  __DPM_DEBUG_CALLBACK(PortNum, "USBPD_PE_Request_CtrlMessage(PING)");
  return USBPD_PE_Request_CtrlMessage(PortNum, USBPD_CONTROLMSG_PING, USBPD_SOPTYPE_SOP);
    960a:	1dfb      	adds	r3, r7, #7
    960c:	781b      	ldrb	r3, [r3, #0]
    960e:	2200      	movs	r2, #0
    9610:	2105      	movs	r1, #5
    9612:	0018      	movs	r0, r3
    9614:	f010 ff54 	bl	1a4c0 <USBPD_PE_Request_CtrlMessage>
    9618:	0003      	movs	r3, r0
}
    961a:	0018      	movs	r0, r3
    961c:	46bd      	mov	sp, r7
    961e:	b002      	add	sp, #8
    9620:	bd80      	pop	{r7, pc}
	...

00009624 <USBPD_DPM_RequestMessageRequest>:
  * @param  IndexSrcPDO Index on the selected SRC PDO (value between 1 to 7)
  * @param  RequestedVoltage Requested voltage (in MV and use mainly for APDO)
  * @retval USBPD Status
  */
USBPD_StatusTypeDef USBPD_DPM_RequestMessageRequest(uint8_t PortNum, uint8_t IndexSrcPDO, uint16_t RequestedVoltage)
{
    9624:	b590      	push	{r4, r7, lr}
    9626:	b091      	sub	sp, #68	; 0x44
    9628:	af02      	add	r7, sp, #8
    962a:	0004      	movs	r4, r0
    962c:	0008      	movs	r0, r1
    962e:	0011      	movs	r1, r2
    9630:	1dfb      	adds	r3, r7, #7
    9632:	1c22      	adds	r2, r4, #0
    9634:	701a      	strb	r2, [r3, #0]
    9636:	1dbb      	adds	r3, r7, #6
    9638:	1c02      	adds	r2, r0, #0
    963a:	701a      	strb	r2, [r3, #0]
    963c:	1d3b      	adds	r3, r7, #4
    963e:	1c0a      	adds	r2, r1, #0
    9640:	801a      	strh	r2, [r3, #0]
  USBPD_StatusTypeDef status = USBPD_ERROR;
    9642:	2337      	movs	r3, #55	; 0x37
    9644:	18fb      	adds	r3, r7, r3
    9646:	2202      	movs	r2, #2
    9648:	701a      	strb	r2, [r3, #0]
  __DPM_DEBUG_CALLBACK(PortNum, "USBPD_PE_Request_CtrlMessage(REQUEST)");
  uint32_t voltage, allowablepower;
  USBPD_SNKRDO_TypeDef rdo;
  USBPD_PDO_TypeDef  pdo;
  USBPD_CORE_PDO_Type_TypeDef pdo_object;
  USBPD_USER_SettingsTypeDef *puser = (USBPD_USER_SettingsTypeDef *)&DPM_USER_Settings[PortNum];
    964a:	1dfb      	adds	r3, r7, #7
    964c:	781b      	ldrb	r3, [r3, #0]
    964e:	2274      	movs	r2, #116	; 0x74
    9650:	435a      	muls	r2, r3
    9652:	4b3b      	ldr	r3, [pc, #236]	; (9740 <USBPD_DPM_RequestMessageRequest+0x11c>)
    9654:	18d3      	adds	r3, r2, r3
    9656:	633b      	str	r3, [r7, #48]	; 0x30
  USBPD_DPM_SNKPowerRequestDetails_TypeDef request_details;
  rdo.d32 = 0;
    9658:	2300      	movs	r3, #0
    965a:	627b      	str	r3, [r7, #36]	; 0x24

  /* selected SRC PDO */
  pdo.d32 = DPM_Ports[PortNum].DPM_ListOfRcvSRCPDO[(IndexSrcPDO - 1)];
    965c:	1dfb      	adds	r3, r7, #7
    965e:	7819      	ldrb	r1, [r3, #0]
    9660:	1dbb      	adds	r3, r7, #6
    9662:	781b      	ldrb	r3, [r3, #0]
    9664:	1e5a      	subs	r2, r3, #1
    9666:	4b37      	ldr	r3, [pc, #220]	; (9744 <USBPD_DPM_RequestMessageRequest+0x120>)
    9668:	202c      	movs	r0, #44	; 0x2c
    966a:	4341      	muls	r1, r0
    966c:	188a      	adds	r2, r1, r2
    966e:	0092      	lsls	r2, r2, #2
    9670:	58d3      	ldr	r3, [r2, r3]
    9672:	623b      	str	r3, [r7, #32]
  voltage = RequestedVoltage;
    9674:	1d3b      	adds	r3, r7, #4
    9676:	881b      	ldrh	r3, [r3, #0]
    9678:	62fb      	str	r3, [r7, #44]	; 0x2c
  allowablepower = (puser->DPM_SNKRequestedPower.MaxOperatingCurrentInmAunits * RequestedVoltage) / 1000;
    967a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    967c:	685b      	ldr	r3, [r3, #4]
    967e:	1d3a      	adds	r2, r7, #4
    9680:	8812      	ldrh	r2, [r2, #0]
    9682:	435a      	muls	r2, r3
    9684:	23fa      	movs	r3, #250	; 0xfa
    9686:	0099      	lsls	r1, r3, #2
    9688:	0010      	movs	r0, r2
    968a:	f015 fc1b 	bl	1eec4 <__udivsi3>
    968e:	0003      	movs	r3, r0
    9690:	62bb      	str	r3, [r7, #40]	; 0x28

  if (USBPD_TRUE == USBPD_DPM_SNK_EvaluateMatchWithSRCPDO(PortNum, pdo.d32, &voltage, &allowablepower))
    9692:	6a39      	ldr	r1, [r7, #32]
    9694:	2328      	movs	r3, #40	; 0x28
    9696:	18fc      	adds	r4, r7, r3
    9698:	232c      	movs	r3, #44	; 0x2c
    969a:	18fa      	adds	r2, r7, r3
    969c:	1dfb      	adds	r3, r7, #7
    969e:	7818      	ldrb	r0, [r3, #0]
    96a0:	0023      	movs	r3, r4
    96a2:	f000 fa43 	bl	9b2c <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO>
    96a6:	0003      	movs	r3, r0
    96a8:	2b01      	cmp	r3, #1
    96aa:	d142      	bne.n	9732 <USBPD_DPM_RequestMessageRequest+0x10e>
  {
    /* Check that voltage has been correctly selected */
    if (RequestedVoltage == voltage)
    96ac:	1d3b      	adds	r3, r7, #4
    96ae:	881a      	ldrh	r2, [r3, #0]
    96b0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    96b2:	429a      	cmp	r2, r3
    96b4:	d13d      	bne.n	9732 <USBPD_DPM_RequestMessageRequest+0x10e>
    {
      request_details.RequestedVoltageInmVunits    = RequestedVoltage;
    96b6:	1d3b      	adds	r3, r7, #4
    96b8:	881a      	ldrh	r2, [r3, #0]
    96ba:	2408      	movs	r4, #8
    96bc:	193b      	adds	r3, r7, r4
    96be:	601a      	str	r2, [r3, #0]
      request_details.OperatingCurrentInmAunits    = (1000 * allowablepower)/RequestedVoltage;
    96c0:	6aba      	ldr	r2, [r7, #40]	; 0x28
    96c2:	0013      	movs	r3, r2
    96c4:	015b      	lsls	r3, r3, #5
    96c6:	1a9b      	subs	r3, r3, r2
    96c8:	009b      	lsls	r3, r3, #2
    96ca:	189b      	adds	r3, r3, r2
    96cc:	00db      	lsls	r3, r3, #3
    96ce:	001a      	movs	r2, r3
    96d0:	1d3b      	adds	r3, r7, #4
    96d2:	881b      	ldrh	r3, [r3, #0]
    96d4:	0019      	movs	r1, r3
    96d6:	0010      	movs	r0, r2
    96d8:	f015 fbf4 	bl	1eec4 <__udivsi3>
    96dc:	0003      	movs	r3, r0
    96de:	001a      	movs	r2, r3
    96e0:	0020      	movs	r0, r4
    96e2:	183b      	adds	r3, r7, r0
    96e4:	609a      	str	r2, [r3, #8]
      request_details.MaxOperatingCurrentInmAunits = puser->DPM_SNKRequestedPower.MaxOperatingCurrentInmAunits;
    96e6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    96e8:	685a      	ldr	r2, [r3, #4]
    96ea:	183b      	adds	r3, r7, r0
    96ec:	605a      	str	r2, [r3, #4]
      request_details.MaxOperatingPowerInmWunits   = puser->DPM_SNKRequestedPower.MaxOperatingPowerInmWunits;
    96ee:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    96f0:	699a      	ldr	r2, [r3, #24]
    96f2:	183b      	adds	r3, r7, r0
    96f4:	60da      	str	r2, [r3, #12]
      request_details.OperatingPowerInmWunits      = puser->DPM_SNKRequestedPower.OperatingPowerInmWunits;
    96f6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    96f8:	695a      	ldr	r2, [r3, #20]
    96fa:	183b      	adds	r3, r7, r0
    96fc:	611a      	str	r2, [r3, #16]

      DPM_SNK_BuildRDOfromSelectedPDO(PortNum, (IndexSrcPDO - 1), &request_details, &rdo, &pdo_object);
    96fe:	1dbb      	adds	r3, r7, #6
    9700:	781b      	ldrb	r3, [r3, #0]
    9702:	3b01      	subs	r3, #1
    9704:	b2d9      	uxtb	r1, r3
    9706:	2324      	movs	r3, #36	; 0x24
    9708:	18fc      	adds	r4, r7, r3
    970a:	183a      	adds	r2, r7, r0
    970c:	1dfb      	adds	r3, r7, #7
    970e:	7818      	ldrb	r0, [r3, #0]
    9710:	231c      	movs	r3, #28
    9712:	18fb      	adds	r3, r7, r3
    9714:	9300      	str	r3, [sp, #0]
    9716:	0023      	movs	r3, r4
    9718:	f000 fd6e 	bl	a1f8 <DPM_SNK_BuildRDOfromSelectedPDO>

      status = USBPD_PE_Send_Request(PortNum, rdo.d32, pdo_object);
    971c:	6a79      	ldr	r1, [r7, #36]	; 0x24
    971e:	69fa      	ldr	r2, [r7, #28]
    9720:	2337      	movs	r3, #55	; 0x37
    9722:	18fc      	adds	r4, r7, r3
    9724:	1dfb      	adds	r3, r7, #7
    9726:	781b      	ldrb	r3, [r3, #0]
    9728:	0018      	movs	r0, r3
    972a:	f011 f821 	bl	1a770 <USBPD_PE_Send_Request>
    972e:	0003      	movs	r3, r0
    9730:	7023      	strb	r3, [r4, #0]
    }
  }

  return status;
    9732:	2337      	movs	r3, #55	; 0x37
    9734:	18fb      	adds	r3, r7, r3
    9736:	781b      	ldrb	r3, [r3, #0]
}
    9738:	0018      	movs	r0, r3
    973a:	46bd      	mov	sp, r7
    973c:	b00f      	add	sp, #60	; 0x3c
    973e:	bd90      	pop	{r4, r7, pc}
    9740:	0002fedc 	.word	0x0002fedc
    9744:	0002fffc 	.word	0x0002fffc

00009748 <USBPD_DPM_RequestGetSourceCapability>:
  * @brief  Request the PE to send a GET_SRC_CAPA message
  * @param  PortNum The current port number
  * @retval USBPD Status
  */
USBPD_StatusTypeDef USBPD_DPM_RequestGetSourceCapability(uint8_t PortNum)
{
    9748:	b580      	push	{r7, lr}
    974a:	b082      	sub	sp, #8
    974c:	af00      	add	r7, sp, #0
    974e:	0002      	movs	r2, r0
    9750:	1dfb      	adds	r3, r7, #7
    9752:	701a      	strb	r2, [r3, #0]
  __DPM_DEBUG_CALLBACK(PortNum, "USBPD_PE_Request_CtrlMessage(GET_SRC CAP)");
  return USBPD_PE_Request_CtrlMessage(PortNum, USBPD_CONTROLMSG_GET_SRC_CAP, USBPD_SOPTYPE_SOP);
    9754:	1dfb      	adds	r3, r7, #7
    9756:	781b      	ldrb	r3, [r3, #0]
    9758:	2200      	movs	r2, #0
    975a:	2107      	movs	r1, #7
    975c:	0018      	movs	r0, r3
    975e:	f010 feaf 	bl	1a4c0 <USBPD_PE_Request_CtrlMessage>
    9762:	0003      	movs	r3, r0
}
    9764:	0018      	movs	r0, r3
    9766:	46bd      	mov	sp, r7
    9768:	b002      	add	sp, #8
    976a:	bd80      	pop	{r7, pc}

0000976c <USBPD_DPM_RequestGetSinkCapability>:
  * @brief  Request the PE to send a GET_SNK_CAPA message
  * @param  PortNum The current port number
  * @retval USBPD Status
  */
USBPD_StatusTypeDef USBPD_DPM_RequestGetSinkCapability(uint8_t PortNum)
{
    976c:	b580      	push	{r7, lr}
    976e:	b082      	sub	sp, #8
    9770:	af00      	add	r7, sp, #0
    9772:	0002      	movs	r2, r0
    9774:	1dfb      	adds	r3, r7, #7
    9776:	701a      	strb	r2, [r3, #0]
  __DPM_DEBUG_CALLBACK(PortNum, "USBPD_PE_Request_CtrlMessage(GOTOMIN)");
  return USBPD_PE_Request_CtrlMessage(PortNum, USBPD_CONTROLMSG_GET_SNK_CAP, USBPD_SOPTYPE_SOP);
    9778:	1dfb      	adds	r3, r7, #7
    977a:	781b      	ldrb	r3, [r3, #0]
    977c:	2200      	movs	r2, #0
    977e:	2108      	movs	r1, #8
    9780:	0018      	movs	r0, r3
    9782:	f010 fe9d 	bl	1a4c0 <USBPD_PE_Request_CtrlMessage>
    9786:	0003      	movs	r3, r0
}
    9788:	0018      	movs	r0, r3
    978a:	46bd      	mov	sp, r7
    978c:	b002      	add	sp, #8
    978e:	bd80      	pop	{r7, pc}

00009790 <USBPD_DPM_RequestDataRoleSwap>:
  * @brief  Request the PE to perform a Data Role Swap.
  * @param  PortNum The current port number
  * @retval USBPD Status
  */
USBPD_StatusTypeDef USBPD_DPM_RequestDataRoleSwap(uint8_t PortNum)
{
    9790:	b580      	push	{r7, lr}
    9792:	b082      	sub	sp, #8
    9794:	af00      	add	r7, sp, #0
    9796:	0002      	movs	r2, r0
    9798:	1dfb      	adds	r3, r7, #7
    979a:	701a      	strb	r2, [r3, #0]
  __DPM_DEBUG_CALLBACK(PortNum, "USBPD_PE_Request_CtrlMessage(DR SWAP)");
  return USBPD_PE_Request_CtrlMessage(PortNum, USBPD_CONTROLMSG_DR_SWAP, USBPD_SOPTYPE_SOP);
    979c:	1dfb      	adds	r3, r7, #7
    979e:	781b      	ldrb	r3, [r3, #0]
    97a0:	2200      	movs	r2, #0
    97a2:	2109      	movs	r1, #9
    97a4:	0018      	movs	r0, r3
    97a6:	f010 fe8b 	bl	1a4c0 <USBPD_PE_Request_CtrlMessage>
    97aa:	0003      	movs	r3, r0
}
    97ac:	0018      	movs	r0, r3
    97ae:	46bd      	mov	sp, r7
    97b0:	b002      	add	sp, #8
    97b2:	bd80      	pop	{r7, pc}

000097b4 <USBPD_DPM_RequestPowerRoleSwap>:
  * @brief  Request the PE to perform a Power Role Swap.
  * @param  PortNum The current port number
  * @retval USBPD Status
  */
USBPD_StatusTypeDef USBPD_DPM_RequestPowerRoleSwap(uint8_t PortNum)
{
    97b4:	b580      	push	{r7, lr}
    97b6:	b082      	sub	sp, #8
    97b8:	af00      	add	r7, sp, #0
    97ba:	0002      	movs	r2, r0
    97bc:	1dfb      	adds	r3, r7, #7
    97be:	701a      	strb	r2, [r3, #0]
  __DPM_DEBUG_CALLBACK(PortNum, "USBPD_PE_Request_CtrlMessage(PR SWAP)");
  return USBPD_PE_Request_CtrlMessage(PortNum, USBPD_CONTROLMSG_PR_SWAP, USBPD_SOPTYPE_SOP);
    97c0:	1dfb      	adds	r3, r7, #7
    97c2:	781b      	ldrb	r3, [r3, #0]
    97c4:	2200      	movs	r2, #0
    97c6:	210a      	movs	r1, #10
    97c8:	0018      	movs	r0, r3
    97ca:	f010 fe79 	bl	1a4c0 <USBPD_PE_Request_CtrlMessage>
    97ce:	0003      	movs	r3, r0

}
    97d0:	0018      	movs	r0, r3
    97d2:	46bd      	mov	sp, r7
    97d4:	b002      	add	sp, #8
    97d6:	bd80      	pop	{r7, pc}

000097d8 <USBPD_DPM_RequestVconnSwap>:
  * @brief  Request the PE to perform a VCONN Swap.
  * @param  PortNum The current port number
  * @retval USBPD Status
  */
USBPD_StatusTypeDef USBPD_DPM_RequestVconnSwap(uint8_t PortNum)
{
    97d8:	b580      	push	{r7, lr}
    97da:	b082      	sub	sp, #8
    97dc:	af00      	add	r7, sp, #0
    97de:	0002      	movs	r2, r0
    97e0:	1dfb      	adds	r3, r7, #7
    97e2:	701a      	strb	r2, [r3, #0]
  __DPM_DEBUG_CALLBACK(PortNum, "USBPD_PE_Request_CtrlMessage(VCONN SWAP)");
  return USBPD_PE_Request_CtrlMessage(PortNum, USBPD_CONTROLMSG_VCONN_SWAP, USBPD_SOPTYPE_SOP);
    97e4:	1dfb      	adds	r3, r7, #7
    97e6:	781b      	ldrb	r3, [r3, #0]
    97e8:	2200      	movs	r2, #0
    97ea:	210b      	movs	r1, #11
    97ec:	0018      	movs	r0, r3
    97ee:	f010 fe67 	bl	1a4c0 <USBPD_PE_Request_CtrlMessage>
    97f2:	0003      	movs	r3, r0
}
    97f4:	0018      	movs	r0, r3
    97f6:	46bd      	mov	sp, r7
    97f8:	b002      	add	sp, #8
    97fa:	bd80      	pop	{r7, pc}

000097fc <USBPD_DPM_RequestSoftReset>:
  * @param  PortNum The current port number
  * @param  SOPType SOP Type based on @ref USBPD_SOPType_TypeDef
  * @retval USBPD Status
  */
USBPD_StatusTypeDef USBPD_DPM_RequestSoftReset(uint8_t PortNum, USBPD_SOPType_TypeDef SOPType)
{
    97fc:	b580      	push	{r7, lr}
    97fe:	b082      	sub	sp, #8
    9800:	af00      	add	r7, sp, #0
    9802:	0002      	movs	r2, r0
    9804:	1dfb      	adds	r3, r7, #7
    9806:	701a      	strb	r2, [r3, #0]
    9808:	1dbb      	adds	r3, r7, #6
    980a:	1c0a      	adds	r2, r1, #0
    980c:	701a      	strb	r2, [r3, #0]
  __DPM_DEBUG_CALLBACK(PortNum, "USBPD_PE_Request_CtrlMessage(SOFT RESET)");
  return USBPD_PE_Request_CtrlMessage(PortNum, USBPD_CONTROLMSG_SOFT_RESET, SOPType);
    980e:	1dbb      	adds	r3, r7, #6
    9810:	781a      	ldrb	r2, [r3, #0]
    9812:	1dfb      	adds	r3, r7, #7
    9814:	781b      	ldrb	r3, [r3, #0]
    9816:	210d      	movs	r1, #13
    9818:	0018      	movs	r0, r3
    981a:	f010 fe51 	bl	1a4c0 <USBPD_PE_Request_CtrlMessage>
    981e:	0003      	movs	r3, r0
}
    9820:	0018      	movs	r0, r3
    9822:	46bd      	mov	sp, r7
    9824:	b002      	add	sp, #8
    9826:	bd80      	pop	{r7, pc}

00009828 <USBPD_DPM_RequestSourceCapability>:
  * @brief  Request the PE to send a Source Capability message.
  * @param  PortNum The current port number
  * @retval USBPD Status
  */
USBPD_StatusTypeDef USBPD_DPM_RequestSourceCapability(uint8_t PortNum)
{
    9828:	b580      	push	{r7, lr}
    982a:	b082      	sub	sp, #8
    982c:	af00      	add	r7, sp, #0
    982e:	0002      	movs	r2, r0
    9830:	1dfb      	adds	r3, r7, #7
    9832:	701a      	strb	r2, [r3, #0]
  /* PE will directly get the PDO saved in structure @ref PWR_Port_PDO_Storage */
  __DPM_DEBUG_CALLBACK(PortNum, "USBPD_PE_Request_DataMessage(SRC CAPA)");
  return USBPD_PE_Request_DataMessage(PortNum, USBPD_DATAMSG_SRC_CAPABILITIES, NULL);
    9834:	1dfb      	adds	r3, r7, #7
    9836:	781b      	ldrb	r3, [r3, #0]
    9838:	2200      	movs	r2, #0
    983a:	2101      	movs	r1, #1
    983c:	0018      	movs	r0, r3
    983e:	f010 ff3f 	bl	1a6c0 <USBPD_PE_Request_DataMessage>
    9842:	0003      	movs	r3, r0
}
    9844:	0018      	movs	r0, r3
    9846:	46bd      	mov	sp, r7
    9848:	b002      	add	sp, #8
    984a:	bd80      	pop	{r7, pc}

0000984c <USBPD_DPM_RequestVDM_DiscoveryIdentify>:
  * @param  PortNum The current port number
  * @param  SOPType SOP Type
  * @retval USBPD Status
  */
USBPD_StatusTypeDef USBPD_DPM_RequestVDM_DiscoveryIdentify(uint8_t PortNum, USBPD_SOPType_TypeDef SOPType)
{
    984c:	b590      	push	{r4, r7, lr}
    984e:	b085      	sub	sp, #20
    9850:	af00      	add	r7, sp, #0
    9852:	0002      	movs	r2, r0
    9854:	1dfb      	adds	r3, r7, #7
    9856:	701a      	strb	r2, [r3, #0]
    9858:	1dbb      	adds	r3, r7, #6
    985a:	1c0a      	adds	r2, r1, #0
    985c:	701a      	strb	r2, [r3, #0]
  USBPD_StatusTypeDef _status = USBPD_ERROR;
    985e:	230f      	movs	r3, #15
    9860:	18fb      	adds	r3, r7, r3
    9862:	2202      	movs	r2, #2
    9864:	701a      	strb	r2, [r3, #0]
  __DPM_DEBUG_CALLBACK(PortNum, "USBPD_PE_SVDM_RequestIdentity");

  if ((USBPD_SOPTYPE_SOP == SOPType)
    9866:	1dbb      	adds	r3, r7, #6
    9868:	781b      	ldrb	r3, [r3, #0]
    986a:	2b00      	cmp	r3, #0
    986c:	d00d      	beq.n	988a <USBPD_DPM_RequestVDM_DiscoveryIdentify+0x3e>
    || (USBPD_TRUE == DPM_Ports[PortNum].DPM_CablePDCapable)
    986e:	1dfb      	adds	r3, r7, #7
    9870:	781b      	ldrb	r3, [r3, #0]
    9872:	4a0f      	ldr	r2, [pc, #60]	; (98b0 <USBPD_DPM_RequestVDM_DiscoveryIdentify+0x64>)
    9874:	2160      	movs	r1, #96	; 0x60
    9876:	20b0      	movs	r0, #176	; 0xb0
    9878:	4343      	muls	r3, r0
    987a:	18d3      	adds	r3, r2, r3
    987c:	185b      	adds	r3, r3, r1
    987e:	795b      	ldrb	r3, [r3, #5]
    9880:	07db      	lsls	r3, r3, #31
    9882:	0fdb      	lsrs	r3, r3, #31
    9884:	b2db      	uxtb	r3, r3
    9886:	2b01      	cmp	r3, #1
    9888:	d10b      	bne.n	98a2 <USBPD_DPM_RequestVDM_DiscoveryIdentify+0x56>
    )
  {
    _status = USBPD_PE_SVDM_RequestIdentity(PortNum, SOPType);
    988a:	230f      	movs	r3, #15
    988c:	18fc      	adds	r4, r7, r3
    988e:	1dbb      	adds	r3, r7, #6
    9890:	781a      	ldrb	r2, [r3, #0]
    9892:	1dfb      	adds	r3, r7, #7
    9894:	781b      	ldrb	r3, [r3, #0]
    9896:	0011      	movs	r1, r2
    9898:	0018      	movs	r0, r3
    989a:	f010 fc77 	bl	1a18c <USBPD_PE_SVDM_RequestIdentity>
    989e:	0003      	movs	r3, r0
    98a0:	7023      	strb	r3, [r4, #0]
  }

  return _status;
    98a2:	230f      	movs	r3, #15
    98a4:	18fb      	adds	r3, r7, r3
    98a6:	781b      	ldrb	r3, [r3, #0]
}
    98a8:	0018      	movs	r0, r3
    98aa:	46bd      	mov	sp, r7
    98ac:	b005      	add	sp, #20
    98ae:	bd90      	pop	{r4, r7, pc}
    98b0:	0002fffc 	.word	0x0002fffc

000098b4 <USBPD_DPM_RequestVDM_DiscoverySVID>:
  * @param  PortNum The current port number
  * @param  SOPType SOP Type
  * @retval USBPD Status
  */
USBPD_StatusTypeDef USBPD_DPM_RequestVDM_DiscoverySVID(uint8_t PortNum, USBPD_SOPType_TypeDef SOPType)
{
    98b4:	b580      	push	{r7, lr}
    98b6:	b082      	sub	sp, #8
    98b8:	af00      	add	r7, sp, #0
    98ba:	0002      	movs	r2, r0
    98bc:	1dfb      	adds	r3, r7, #7
    98be:	701a      	strb	r2, [r3, #0]
    98c0:	1dbb      	adds	r3, r7, #6
    98c2:	1c0a      	adds	r2, r1, #0
    98c4:	701a      	strb	r2, [r3, #0]
  __DPM_DEBUG_CALLBACK(PortNum, "USBPD_PE_SVDM_RequestSVID");
  return USBPD_PE_SVDM_RequestSVID(PortNum, SOPType);
    98c6:	1dbb      	adds	r3, r7, #6
    98c8:	781a      	ldrb	r2, [r3, #0]
    98ca:	1dfb      	adds	r3, r7, #7
    98cc:	781b      	ldrb	r3, [r3, #0]
    98ce:	0011      	movs	r1, r2
    98d0:	0018      	movs	r0, r3
    98d2:	f010 fc8f 	bl	1a1f4 <USBPD_PE_SVDM_RequestSVID>
    98d6:	0003      	movs	r3, r0
}
    98d8:	0018      	movs	r0, r3
    98da:	46bd      	mov	sp, r7
    98dc:	b002      	add	sp, #8
    98de:	bd80      	pop	{r7, pc}

000098e0 <USBPD_DPM_RequestVDM_DiscoveryMode>:
  * @param  SOPType SOP Type
  * @param  SVID    SVID used for discovery mode message
  * @retval USBPD Status
  */
USBPD_StatusTypeDef USBPD_DPM_RequestVDM_DiscoveryMode(uint8_t PortNum, USBPD_SOPType_TypeDef SOPType, uint16_t SVID)
{
    98e0:	b590      	push	{r4, r7, lr}
    98e2:	b083      	sub	sp, #12
    98e4:	af00      	add	r7, sp, #0
    98e6:	0004      	movs	r4, r0
    98e8:	0008      	movs	r0, r1
    98ea:	0011      	movs	r1, r2
    98ec:	1dfb      	adds	r3, r7, #7
    98ee:	1c22      	adds	r2, r4, #0
    98f0:	701a      	strb	r2, [r3, #0]
    98f2:	1dbb      	adds	r3, r7, #6
    98f4:	1c02      	adds	r2, r0, #0
    98f6:	701a      	strb	r2, [r3, #0]
    98f8:	1d3b      	adds	r3, r7, #4
    98fa:	1c0a      	adds	r2, r1, #0
    98fc:	801a      	strh	r2, [r3, #0]
  __DPM_DEBUG_CALLBACK(PortNum, "USBPD_PE_SVDM_RequestMode");
  return USBPD_PE_SVDM_RequestMode(PortNum, SOPType, SVID);
    98fe:	1d3b      	adds	r3, r7, #4
    9900:	881a      	ldrh	r2, [r3, #0]
    9902:	1dbb      	adds	r3, r7, #6
    9904:	7819      	ldrb	r1, [r3, #0]
    9906:	1dfb      	adds	r3, r7, #7
    9908:	781b      	ldrb	r3, [r3, #0]
    990a:	0018      	movs	r0, r3
    990c:	f010 fca3 	bl	1a256 <USBPD_PE_SVDM_RequestMode>
    9910:	0003      	movs	r3, r0
}
    9912:	0018      	movs	r0, r3
    9914:	46bd      	mov	sp, r7
    9916:	b003      	add	sp, #12
    9918:	bd90      	pop	{r4, r7, pc}

0000991a <USBPD_DPM_RequestVDM_EnterMode>:
  * @param  SVID      SVID used for discovery mode message
  * @param  ModeIndex Index of the mode to be entered
  * @retval USBPD Status
  */
USBPD_StatusTypeDef USBPD_DPM_RequestVDM_EnterMode(uint8_t PortNum, USBPD_SOPType_TypeDef SOPType, uint16_t SVID, uint8_t ModeIndex)
{
    991a:	b5b0      	push	{r4, r5, r7, lr}
    991c:	b082      	sub	sp, #8
    991e:	af00      	add	r7, sp, #0
    9920:	0005      	movs	r5, r0
    9922:	000c      	movs	r4, r1
    9924:	0010      	movs	r0, r2
    9926:	0019      	movs	r1, r3
    9928:	1dfb      	adds	r3, r7, #7
    992a:	1c2a      	adds	r2, r5, #0
    992c:	701a      	strb	r2, [r3, #0]
    992e:	1dbb      	adds	r3, r7, #6
    9930:	1c22      	adds	r2, r4, #0
    9932:	701a      	strb	r2, [r3, #0]
    9934:	1d3b      	adds	r3, r7, #4
    9936:	1c02      	adds	r2, r0, #0
    9938:	801a      	strh	r2, [r3, #0]
    993a:	1cfb      	adds	r3, r7, #3
    993c:	1c0a      	adds	r2, r1, #0
    993e:	701a      	strb	r2, [r3, #0]
  __DPM_DEBUG_CALLBACK(PortNum, "USBPD_PE_SVDM_RequestModeEnter");
  return USBPD_PE_SVDM_RequestModeEnter(PortNum, SOPType, SVID, ModeIndex);
    9940:	1cfb      	adds	r3, r7, #3
    9942:	781c      	ldrb	r4, [r3, #0]
    9944:	1d3b      	adds	r3, r7, #4
    9946:	881a      	ldrh	r2, [r3, #0]
    9948:	1dbb      	adds	r3, r7, #6
    994a:	7819      	ldrb	r1, [r3, #0]
    994c:	1dfb      	adds	r3, r7, #7
    994e:	7818      	ldrb	r0, [r3, #0]
    9950:	0023      	movs	r3, r4
    9952:	f010 fcb3 	bl	1a2bc <USBPD_PE_SVDM_RequestModeEnter>
    9956:	0003      	movs	r3, r0
}
    9958:	0018      	movs	r0, r3
    995a:	46bd      	mov	sp, r7
    995c:	b002      	add	sp, #8
    995e:	bdb0      	pop	{r4, r5, r7, pc}

00009960 <USBPD_DPM_RequestVDM_ExitMode>:
  * @param  SVID      SVID used for discovery mode message
  * @param  ModeIndex Index of the mode to be exit
  * @retval USBPD Status
  */
USBPD_StatusTypeDef USBPD_DPM_RequestVDM_ExitMode(uint8_t PortNum, USBPD_SOPType_TypeDef SOPType, uint16_t SVID, uint8_t ModeIndex)
{
    9960:	b5b0      	push	{r4, r5, r7, lr}
    9962:	b082      	sub	sp, #8
    9964:	af00      	add	r7, sp, #0
    9966:	0005      	movs	r5, r0
    9968:	000c      	movs	r4, r1
    996a:	0010      	movs	r0, r2
    996c:	0019      	movs	r1, r3
    996e:	1dfb      	adds	r3, r7, #7
    9970:	1c2a      	adds	r2, r5, #0
    9972:	701a      	strb	r2, [r3, #0]
    9974:	1dbb      	adds	r3, r7, #6
    9976:	1c22      	adds	r2, r4, #0
    9978:	701a      	strb	r2, [r3, #0]
    997a:	1d3b      	adds	r3, r7, #4
    997c:	1c02      	adds	r2, r0, #0
    997e:	801a      	strh	r2, [r3, #0]
    9980:	1cfb      	adds	r3, r7, #3
    9982:	1c0a      	adds	r2, r1, #0
    9984:	701a      	strb	r2, [r3, #0]
  __DPM_DEBUG_CALLBACK(PortNum, "USBPD_PE_SVDM_RequestModeExit");
  return USBPD_PE_SVDM_RequestModeExit(PortNum, SOPType, SVID, ModeIndex);
    9986:	1cfb      	adds	r3, r7, #3
    9988:	781c      	ldrb	r4, [r3, #0]
    998a:	1d3b      	adds	r3, r7, #4
    998c:	881a      	ldrh	r2, [r3, #0]
    998e:	1dbb      	adds	r3, r7, #6
    9990:	7819      	ldrb	r1, [r3, #0]
    9992:	1dfb      	adds	r3, r7, #7
    9994:	7818      	ldrb	r0, [r3, #0]
    9996:	0023      	movs	r3, r4
    9998:	f010 fcce 	bl	1a338 <USBPD_PE_SVDM_RequestModeExit>
    999c:	0003      	movs	r3, r0
}
    999e:	0018      	movs	r0, r3
    99a0:	46bd      	mov	sp, r7
    99a2:	b002      	add	sp, #8
    99a4:	bdb0      	pop	{r4, r5, r7, pc}

000099a6 <USBPD_DPM_RequestAlert>:
  * @param  PortNum The current port number
  * @param  Alert   Alert based on @ref USBPD_ADO_TypeDef
  * @retval USBPD Status
  */
USBPD_StatusTypeDef USBPD_DPM_RequestAlert(uint8_t PortNum, USBPD_ADO_TypeDef Alert)
{
    99a6:	b580      	push	{r7, lr}
    99a8:	b082      	sub	sp, #8
    99aa:	af00      	add	r7, sp, #0
    99ac:	0002      	movs	r2, r0
    99ae:	6039      	str	r1, [r7, #0]
    99b0:	1dfb      	adds	r3, r7, #7
    99b2:	701a      	strb	r2, [r3, #0]
  __DPM_DEBUG_CALLBACK(PortNum, "USBPD_PE_Request_DataMessage(ALERT)");
  return USBPD_PE_Request_DataMessage(PortNum, USBPD_DATAMSG_ALERT, (uint32_t*)&Alert.d32);
    99b4:	003a      	movs	r2, r7
    99b6:	1dfb      	adds	r3, r7, #7
    99b8:	781b      	ldrb	r3, [r3, #0]
    99ba:	2106      	movs	r1, #6
    99bc:	0018      	movs	r0, r3
    99be:	f010 fe7f 	bl	1a6c0 <USBPD_PE_Request_DataMessage>
    99c2:	0003      	movs	r3, r0
}
    99c4:	0018      	movs	r0, r3
    99c6:	46bd      	mov	sp, r7
    99c8:	b002      	add	sp, #8
    99ca:	bd80      	pop	{r7, pc}

000099cc <USBPD_DPM_RequestGetSourceCapabilityExt>:
  * @brief  Request the PE to get a source capability extended
  * @param  PortNum The current port number
  * @retval USBPD Status
  */
USBPD_StatusTypeDef USBPD_DPM_RequestGetSourceCapabilityExt(uint8_t PortNum)
{
    99cc:	b580      	push	{r7, lr}
    99ce:	b082      	sub	sp, #8
    99d0:	af00      	add	r7, sp, #0
    99d2:	0002      	movs	r2, r0
    99d4:	1dfb      	adds	r3, r7, #7
    99d6:	701a      	strb	r2, [r3, #0]
  __DPM_DEBUG_CALLBACK(PortNum, "USBPD_PE_Request_CtrlMessage(GET SRC CAPEXT)");
  return USBPD_ERROR;
    99d8:	2302      	movs	r3, #2
}
    99da:	0018      	movs	r0, r3
    99dc:	46bd      	mov	sp, r7
    99de:	b002      	add	sp, #8
    99e0:	bd80      	pop	{r7, pc}

000099e2 <USBPD_DPM_RequestGetSinkCapabilityExt>:
  * @brief  Request the PE to get a sink capability extended
  * @param  PortNum The current port number
  * @retval USBPD Status
  */
USBPD_StatusTypeDef USBPD_DPM_RequestGetSinkCapabilityExt(uint8_t PortNum)
{
    99e2:	b580      	push	{r7, lr}
    99e4:	b082      	sub	sp, #8
    99e6:	af00      	add	r7, sp, #0
    99e8:	0002      	movs	r2, r0
    99ea:	1dfb      	adds	r3, r7, #7
    99ec:	701a      	strb	r2, [r3, #0]
#if defined(USBPDCORE_SNK_CAPA_EXT)
  __DPM_DEBUG_CALLBACK(PortNum, "USBPD_PE_Request_CtrlMessage(GET SNK CAPEXT)");
  return USBPD_PE_Request_CtrlMessage(PortNum, USBPD_CONTROLMSG_GET_SNK_CAPEXT, USBPD_SOPTYPE_SOP);
    99ee:	1dfb      	adds	r3, r7, #7
    99f0:	781b      	ldrb	r3, [r3, #0]
    99f2:	2200      	movs	r2, #0
    99f4:	2116      	movs	r1, #22
    99f6:	0018      	movs	r0, r3
    99f8:	f010 fd62 	bl	1a4c0 <USBPD_PE_Request_CtrlMessage>
    99fc:	0003      	movs	r3, r0
#else
  return USBPD_ERROR;
#endif /* USBPDCORE_SNK_CAPA_EXT */
}
    99fe:	0018      	movs	r0, r3
    9a00:	46bd      	mov	sp, r7
    9a02:	b002      	add	sp, #8
    9a04:	bd80      	pop	{r7, pc}

00009a06 <USBPD_DPM_RequestGetManufacturerInfo>:
  * @param  SOPType SOP Type
  * @param  pManuInfoData Pointer on manufacturer info based on @ref USBPD_GMIDB_TypeDef
  * @retval USBPD Status
  */
USBPD_StatusTypeDef USBPD_DPM_RequestGetManufacturerInfo(uint8_t PortNum, USBPD_SOPType_TypeDef SOPType, uint8_t* pManuInfoData)
{
    9a06:	b580      	push	{r7, lr}
    9a08:	b084      	sub	sp, #16
    9a0a:	af02      	add	r7, sp, #8
    9a0c:	603a      	str	r2, [r7, #0]
    9a0e:	1dfb      	adds	r3, r7, #7
    9a10:	1c02      	adds	r2, r0, #0
    9a12:	701a      	strb	r2, [r3, #0]
    9a14:	1dbb      	adds	r3, r7, #6
    9a16:	1c0a      	adds	r2, r1, #0
    9a18:	701a      	strb	r2, [r3, #0]
  __DPM_DEBUG_CALLBACK(PortNum, "USBPD_PE_SendExtendedMessage(GET MANU INFO)");
  return USBPD_PE_SendExtendedMessage(PortNum, SOPType, USBPD_EXT_GET_MANUFACTURER_INFO, (uint8_t*)pManuInfoData, sizeof(USBPD_GMIDB_TypeDef));
    9a1a:	683a      	ldr	r2, [r7, #0]
    9a1c:	1dbb      	adds	r3, r7, #6
    9a1e:	7819      	ldrb	r1, [r3, #0]
    9a20:	1dfb      	adds	r3, r7, #7
    9a22:	7818      	ldrb	r0, [r3, #0]
    9a24:	2302      	movs	r3, #2
    9a26:	9300      	str	r3, [sp, #0]
    9a28:	0013      	movs	r3, r2
    9a2a:	2206      	movs	r2, #6
    9a2c:	f010 fec8 	bl	1a7c0 <USBPD_PE_SendExtendedMessage>
    9a30:	0003      	movs	r3, r0
}
    9a32:	0018      	movs	r0, r3
    9a34:	46bd      	mov	sp, r7
    9a36:	b002      	add	sp, #8
    9a38:	bd80      	pop	{r7, pc}

00009a3a <USBPD_DPM_RequestGetPPS_Status>:
  * @brief  Request the PE to request a GET_PPS_STATUS
  * @param  PortNum The current port number
  * @retval USBPD Status
  */
USBPD_StatusTypeDef USBPD_DPM_RequestGetPPS_Status(uint8_t PortNum)
{
    9a3a:	b580      	push	{r7, lr}
    9a3c:	b082      	sub	sp, #8
    9a3e:	af00      	add	r7, sp, #0
    9a40:	0002      	movs	r2, r0
    9a42:	1dfb      	adds	r3, r7, #7
    9a44:	701a      	strb	r2, [r3, #0]
  __DPM_DEBUG_CALLBACK(PortNum, "USBPD_PE_Request_CtrlMessage(GET PPS STATUS)");
  return USBPD_ERROR;
    9a46:	2302      	movs	r3, #2
}
    9a48:	0018      	movs	r0, r3
    9a4a:	46bd      	mov	sp, r7
    9a4c:	b002      	add	sp, #8
    9a4e:	bd80      	pop	{r7, pc}

00009a50 <USBPD_DPM_RequestGetStatus>:
  * @brief  Request the PE to request a GET_STATUS
  * @param  PortNum The current port number
  * @retval USBPD Status
  */
USBPD_StatusTypeDef USBPD_DPM_RequestGetStatus(uint8_t PortNum)
{
    9a50:	b580      	push	{r7, lr}
    9a52:	b082      	sub	sp, #8
    9a54:	af00      	add	r7, sp, #0
    9a56:	0002      	movs	r2, r0
    9a58:	1dfb      	adds	r3, r7, #7
    9a5a:	701a      	strb	r2, [r3, #0]
  __DPM_DEBUG_CALLBACK(PortNum, "USBPD_PE_Request_CtrlMessage(GET STATUS)");
  return USBPD_PE_Request_CtrlMessage(PortNum, USBPD_CONTROLMSG_GET_STATUS, USBPD_SOPTYPE_SOP);
    9a5c:	1dfb      	adds	r3, r7, #7
    9a5e:	781b      	ldrb	r3, [r3, #0]
    9a60:	2200      	movs	r2, #0
    9a62:	2112      	movs	r1, #18
    9a64:	0018      	movs	r0, r3
    9a66:	f010 fd2b 	bl	1a4c0 <USBPD_PE_Request_CtrlMessage>
    9a6a:	0003      	movs	r3, r0
}
    9a6c:	0018      	movs	r0, r3
    9a6e:	46bd      	mov	sp, r7
    9a70:	b002      	add	sp, #8
    9a72:	bd80      	pop	{r7, pc}

00009a74 <USBPD_DPM_RequestFastRoleSwap>:
  * @brief  Request the PE to perform a Fast Role Swap.
  * @param  PortNum The current port number
  * @retval USBPD Status
  */
USBPD_StatusTypeDef USBPD_DPM_RequestFastRoleSwap(uint8_t PortNum)
{
    9a74:	b580      	push	{r7, lr}
    9a76:	b082      	sub	sp, #8
    9a78:	af00      	add	r7, sp, #0
    9a7a:	0002      	movs	r2, r0
    9a7c:	1dfb      	adds	r3, r7, #7
    9a7e:	701a      	strb	r2, [r3, #0]
  __DPM_DEBUG_CALLBACK(PortNum, "USBPD_PE_Request_CtrlMessage(FR SWAP)");
  return USBPD_PE_Request_CtrlMessage(PortNum, USBPD_CONTROLMSG_FR_SWAP, USBPD_SOPTYPE_SOP);
    9a80:	1dfb      	adds	r3, r7, #7
    9a82:	781b      	ldrb	r3, [r3, #0]
    9a84:	2200      	movs	r2, #0
    9a86:	2113      	movs	r1, #19
    9a88:	0018      	movs	r0, r3
    9a8a:	f010 fd19 	bl	1a4c0 <USBPD_PE_Request_CtrlMessage>
    9a8e:	0003      	movs	r3, r0
}
    9a90:	0018      	movs	r0, r3
    9a92:	46bd      	mov	sp, r7
    9a94:	b002      	add	sp, #8
    9a96:	bd80      	pop	{r7, pc}

00009a98 <USBPD_DPM_RequestGetCountryCodes>:
  * @brief  Request the PE to send a GET_COUNTRY_CODES message
  * @param  PortNum The current port number
  * @retval USBPD Status
  */
USBPD_StatusTypeDef USBPD_DPM_RequestGetCountryCodes(uint8_t PortNum)
{
    9a98:	b580      	push	{r7, lr}
    9a9a:	b082      	sub	sp, #8
    9a9c:	af00      	add	r7, sp, #0
    9a9e:	0002      	movs	r2, r0
    9aa0:	1dfb      	adds	r3, r7, #7
    9aa2:	701a      	strb	r2, [r3, #0]
  __DPM_DEBUG_CALLBACK(PortNum, "USBPD_PE_Request_CtrlMessage(GET COUNTRY CODES)");
  return USBPD_PE_Request_CtrlMessage(PortNum, USBPD_CONTROLMSG_GET_COUNTRY_CODES, USBPD_SOPTYPE_SOP);
    9aa4:	1dfb      	adds	r3, r7, #7
    9aa6:	781b      	ldrb	r3, [r3, #0]
    9aa8:	2200      	movs	r2, #0
    9aaa:	2115      	movs	r1, #21
    9aac:	0018      	movs	r0, r3
    9aae:	f010 fd07 	bl	1a4c0 <USBPD_PE_Request_CtrlMessage>
    9ab2:	0003      	movs	r3, r0
}
    9ab4:	0018      	movs	r0, r3
    9ab6:	46bd      	mov	sp, r7
    9ab8:	b002      	add	sp, #8
    9aba:	bd80      	pop	{r7, pc}

00009abc <USBPD_DPM_RequestGetCountryInfo>:
  * @param  PortNum     The current port number
  * @param  CountryCode Country code (1st character and 2nd of the Alpha-2 Country)
  * @retval USBPD Status
  */
USBPD_StatusTypeDef USBPD_DPM_RequestGetCountryInfo(uint8_t PortNum, uint16_t CountryCode)
{
    9abc:	b580      	push	{r7, lr}
    9abe:	b082      	sub	sp, #8
    9ac0:	af00      	add	r7, sp, #0
    9ac2:	0002      	movs	r2, r0
    9ac4:	1dfb      	adds	r3, r7, #7
    9ac6:	701a      	strb	r2, [r3, #0]
    9ac8:	1d3b      	adds	r3, r7, #4
    9aca:	1c0a      	adds	r2, r1, #0
    9acc:	801a      	strh	r2, [r3, #0]
  __DPM_DEBUG_CALLBACK(PortNum, "USBPD_PE_Request_DataMessage(GET COUNTRY INFO)");
  return USBPD_PE_Request_DataMessage(PortNum, USBPD_DATAMSG_GET_COUNTRY_INFO, (uint32_t*)&CountryCode);
    9ace:	1d3a      	adds	r2, r7, #4
    9ad0:	1dfb      	adds	r3, r7, #7
    9ad2:	781b      	ldrb	r3, [r3, #0]
    9ad4:	2107      	movs	r1, #7
    9ad6:	0018      	movs	r0, r3
    9ad8:	f010 fdf2 	bl	1a6c0 <USBPD_PE_Request_DataMessage>
    9adc:	0003      	movs	r3, r0
}
    9ade:	0018      	movs	r0, r3
    9ae0:	46bd      	mov	sp, r7
    9ae2:	b002      	add	sp, #8
    9ae4:	bd80      	pop	{r7, pc}

00009ae6 <USBPD_DPM_RequestGetBatteryCapability>:
  * @param  PortNum         The current port number
  * @param  pBatteryCapRef  Pointer on the Battery Capability reference
  * @retval USBPD Status
  */
USBPD_StatusTypeDef USBPD_DPM_RequestGetBatteryCapability(uint8_t PortNum, uint8_t *pBatteryCapRef)
{
    9ae6:	b580      	push	{r7, lr}
    9ae8:	b082      	sub	sp, #8
    9aea:	af00      	add	r7, sp, #0
    9aec:	0002      	movs	r2, r0
    9aee:	6039      	str	r1, [r7, #0]
    9af0:	1dfb      	adds	r3, r7, #7
    9af2:	701a      	strb	r2, [r3, #0]
  __DPM_DEBUG_CALLBACK(PortNum, "USBPD_PE_SendExtendedMessage(GET BATTERY CAP)");
  return USBPD_ERROR;
    9af4:	2302      	movs	r3, #2
}
    9af6:	0018      	movs	r0, r3
    9af8:	46bd      	mov	sp, r7
    9afa:	b002      	add	sp, #8
    9afc:	bd80      	pop	{r7, pc}

00009afe <USBPD_DPM_RequestGetBatteryStatus>:
  * @param  PortNum           The current port number
  * @param  pBatteryStatusRef Pointer on the Battery Status reference
  * @retval USBPD Status
  */
USBPD_StatusTypeDef USBPD_DPM_RequestGetBatteryStatus(uint8_t PortNum, uint8_t *pBatteryStatusRef)
{
    9afe:	b580      	push	{r7, lr}
    9b00:	b082      	sub	sp, #8
    9b02:	af00      	add	r7, sp, #0
    9b04:	0002      	movs	r2, r0
    9b06:	6039      	str	r1, [r7, #0]
    9b08:	1dfb      	adds	r3, r7, #7
    9b0a:	701a      	strb	r2, [r3, #0]
  __DPM_DEBUG_CALLBACK(PortNum, "USBPD_PE_SendExtendedMessage(GET BATTERY STATUS)");
  return USBPD_ERROR;
    9b0c:	2302      	movs	r3, #2
}
    9b0e:	0018      	movs	r0, r3
    9b10:	46bd      	mov	sp, r7
    9b12:	b002      	add	sp, #8
    9b14:	bd80      	pop	{r7, pc}

00009b16 <USBPD_DPM_RequestSecurityRequest>:
  * @brief  Request the PE to send a SECURITY_REQUEST
  * @param  PortNum The current port number
  * @retval USBPD Status
  */
USBPD_StatusTypeDef USBPD_DPM_RequestSecurityRequest(uint8_t PortNum)
{
    9b16:	b580      	push	{r7, lr}
    9b18:	b082      	sub	sp, #8
    9b1a:	af00      	add	r7, sp, #0
    9b1c:	0002      	movs	r2, r0
    9b1e:	1dfb      	adds	r3, r7, #7
    9b20:	701a      	strb	r2, [r3, #0]
  __DPM_DEBUG_CALLBACK(PortNum, "USBPD_PE_SendExtendedMessage(SECURITY REQUEST)");
  return USBPD_OK;
    9b22:	2300      	movs	r3, #0
}
    9b24:	0018      	movs	r0, r3
    9b26:	46bd      	mov	sp, r7
    9b28:	b002      	add	sp, #8
    9b2a:	bd80      	pop	{r7, pc}

00009b2c <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO>:
  * @param  PtrRequestedVoltage Pointer on Voltage value that could be reached if SRC PDO is requested (only valid if USBPD_TRUE is returned) in mV
  * @param  PtrRequestedPower   Pointer on Power value that could be reached if SRC PDO is requested (only valid if USBPD_TRUE is returned) in mW
  * @retval USBPD_FALSE of USBPD_TRUE (USBPD_TRUE returned in SRC PDO is considered matching with SNK profile)
  */
uint32_t USBPD_DPM_SNK_EvaluateMatchWithSRCPDO(uint8_t PortNum, uint32_t SrcPDO, uint32_t* PtrRequestedVoltage, uint32_t* PtrRequestedPower)
{
    9b2c:	b590      	push	{r4, r7, lr}
    9b2e:	b09b      	sub	sp, #108	; 0x6c
    9b30:	af00      	add	r7, sp, #0
    9b32:	60b9      	str	r1, [r7, #8]
    9b34:	607a      	str	r2, [r7, #4]
    9b36:	603b      	str	r3, [r7, #0]
    9b38:	240f      	movs	r4, #15
    9b3a:	193b      	adds	r3, r7, r4
    9b3c:	1c02      	adds	r2, r0, #0
    9b3e:	701a      	strb	r2, [r3, #0]
  USBPD_PDO_TypeDef  srcpdo, snkpdo;
  uint32_t match = USBPD_FALSE;
    9b40:	2300      	movs	r3, #0
    9b42:	667b      	str	r3, [r7, #100]	; 0x64
  uint32_t maxrequestedpower, currentrequestedpower;
  uint32_t maxrequestedvoltage, currentrequestedvoltage;
  uint32_t snkoppower250mw, srcmaxpower250mw;

  /* Retrieve SNK PDO list from PWR_IF storage : PDO values + nb of u32 written by PWR_IF (nb of PDOs) */
  USBPD_PWR_IF_GetPortPDOs(PortNum, USBPD_CORE_DATATYPE_SNK_PDO, (uint8_t*)snkpdo_array, &nbsnkpdo);
    9b44:	232c      	movs	r3, #44	; 0x2c
    9b46:	18f9      	adds	r1, r7, r3
    9b48:	2310      	movs	r3, #16
    9b4a:	18fa      	adds	r2, r7, r3
    9b4c:	193b      	adds	r3, r7, r4
    9b4e:	7818      	ldrb	r0, [r3, #0]
    9b50:	000b      	movs	r3, r1
    9b52:	2101      	movs	r1, #1
    9b54:	f001 f882 	bl	ac5c <USBPD_PWR_IF_GetPortPDOs>

  if (0 == nbsnkpdo)
    9b58:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    9b5a:	2b00      	cmp	r3, #0
    9b5c:	d101      	bne.n	9b62 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x36>
  {
    return(USBPD_FALSE);
    9b5e:	2300      	movs	r3, #0
    9b60:	e2c0      	b.n	a0e4 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x5b8>
  }

  /* Set default output values */
  maxrequestedpower    = 0;
    9b62:	2300      	movs	r3, #0
    9b64:	65fb      	str	r3, [r7, #92]	; 0x5c
  maxrequestedvoltage  = 0;
    9b66:	2300      	movs	r3, #0
    9b68:	657b      	str	r3, [r7, #84]	; 0x54

  /* Check SRC PDO value according to its type */
  srcpdo.d32 = SrcPDO;
    9b6a:	68bb      	ldr	r3, [r7, #8]
    9b6c:	637b      	str	r3, [r7, #52]	; 0x34
  switch(srcpdo.GenericPDO.PowerObject)
    9b6e:	2337      	movs	r3, #55	; 0x37
    9b70:	18fb      	adds	r3, r7, r3
    9b72:	781b      	ldrb	r3, [r3, #0]
    9b74:	061b      	lsls	r3, r3, #24
    9b76:	0f9b      	lsrs	r3, r3, #30
    9b78:	b2db      	uxtb	r3, r3
    9b7a:	2b01      	cmp	r3, #1
    9b7c:	d100      	bne.n	9b80 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x54>
    9b7e:	e1d9      	b.n	9f34 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x408>
    9b80:	2b02      	cmp	r3, #2
    9b82:	d100      	bne.n	9b86 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x5a>
    9b84:	e0ff      	b.n	9d86 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x25a>
    9b86:	2b00      	cmp	r3, #0
    9b88:	d000      	beq.n	9b8c <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x60>
    9b8a:	e29d      	b.n	a0c8 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x59c>
  {
    /* SRC Fixed Supply PDO */
    case USBPD_CORE_PDO_TYPE_FIXED:
      srcvoltage50mv = srcpdo.SRCFixedPDO.VoltageIn50mVunits;
    9b8c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    9b8e:	031b      	lsls	r3, r3, #12
    9b90:	0d9b      	lsrs	r3, r3, #22
    9b92:	b29a      	uxth	r2, r3
    9b94:	233a      	movs	r3, #58	; 0x3a
    9b96:	18fb      	adds	r3, r7, r3
    9b98:	801a      	strh	r2, [r3, #0]
      srcmaxcurrent10ma = srcpdo.SRCFixedPDO.MaxCurrentIn10mAunits;
    9b9a:	2334      	movs	r3, #52	; 0x34
    9b9c:	18fb      	adds	r3, r7, r3
    9b9e:	881b      	ldrh	r3, [r3, #0]
    9ba0:	059b      	lsls	r3, r3, #22
    9ba2:	0d9b      	lsrs	r3, r3, #22
    9ba4:	b29a      	uxth	r2, r3
    9ba6:	234a      	movs	r3, #74	; 0x4a
    9ba8:	18fb      	adds	r3, r7, r3
    9baa:	801a      	strh	r2, [r3, #0]

      /* Loop through SNK PDO list */
      for (i=0; i<nbsnkpdo; i++)
    9bac:	2362      	movs	r3, #98	; 0x62
    9bae:	18fb      	adds	r3, r7, r3
    9bb0:	2200      	movs	r2, #0
    9bb2:	801a      	strh	r2, [r3, #0]
    9bb4:	e0df      	b.n	9d76 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x24a>
      {
        currentrequestedpower = 0;
    9bb6:	2300      	movs	r3, #0
    9bb8:	65bb      	str	r3, [r7, #88]	; 0x58
        currentrequestedvoltage = 0;
    9bba:	2300      	movs	r3, #0
    9bbc:	653b      	str	r3, [r7, #80]	; 0x50

        /* Retrieve SNK PDO value according to its type */
        snkpdo.d32 = snkpdo_array[i];
    9bbe:	2362      	movs	r3, #98	; 0x62
    9bc0:	18fb      	adds	r3, r7, r3
    9bc2:	881a      	ldrh	r2, [r3, #0]
    9bc4:	2310      	movs	r3, #16
    9bc6:	18fb      	adds	r3, r7, r3
    9bc8:	0092      	lsls	r2, r2, #2
    9bca:	58d3      	ldr	r3, [r2, r3]
    9bcc:	633b      	str	r3, [r7, #48]	; 0x30
        switch(snkpdo.GenericPDO.PowerObject)
    9bce:	2333      	movs	r3, #51	; 0x33
    9bd0:	18fb      	adds	r3, r7, r3
    9bd2:	781b      	ldrb	r3, [r3, #0]
    9bd4:	061b      	lsls	r3, r3, #24
    9bd6:	0f9b      	lsrs	r3, r3, #30
    9bd8:	b2db      	uxtb	r3, r3
    9bda:	2b01      	cmp	r3, #1
    9bdc:	d100      	bne.n	9be0 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0xb4>
    9bde:	e077      	b.n	9cd0 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x1a4>
    9be0:	2b02      	cmp	r3, #2
    9be2:	d034      	beq.n	9c4e <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x122>
    9be4:	2b00      	cmp	r3, #0
    9be6:	d000      	beq.n	9bea <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0xbe>
            }
            break;


          default:
            break;
    9be8:	e0b5      	b.n	9d56 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x22a>
            snkvoltage50mv = snkpdo.SNKFixedPDO.VoltageIn50mVunits;
    9bea:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    9bec:	031b      	lsls	r3, r3, #12
    9bee:	0d9b      	lsrs	r3, r3, #22
    9bf0:	b29a      	uxth	r2, r3
    9bf2:	2138      	movs	r1, #56	; 0x38
    9bf4:	187b      	adds	r3, r7, r1
    9bf6:	801a      	strh	r2, [r3, #0]
            snkopcurrent10ma = snkpdo.SNKFixedPDO.OperationalCurrentIn10mAunits;
    9bf8:	2330      	movs	r3, #48	; 0x30
    9bfa:	18fb      	adds	r3, r7, r3
    9bfc:	881b      	ldrh	r3, [r3, #0]
    9bfe:	059b      	lsls	r3, r3, #22
    9c00:	0d9b      	lsrs	r3, r3, #22
    9c02:	b29a      	uxth	r2, r3
    9c04:	2344      	movs	r3, #68	; 0x44
    9c06:	18fb      	adds	r3, r7, r3
    9c08:	801a      	strh	r2, [r3, #0]
            if (  (snkvoltage50mv == srcvoltage50mv)
    9c0a:	187a      	adds	r2, r7, r1
    9c0c:	233a      	movs	r3, #58	; 0x3a
    9c0e:	18fb      	adds	r3, r7, r3
    9c10:	8812      	ldrh	r2, [r2, #0]
    9c12:	881b      	ldrh	r3, [r3, #0]
    9c14:	429a      	cmp	r2, r3
    9c16:	d000      	beq.n	9c1a <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0xee>
    9c18:	e098      	b.n	9d4c <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x220>
                &&(snkopcurrent10ma <= srcmaxcurrent10ma))
    9c1a:	2344      	movs	r3, #68	; 0x44
    9c1c:	18fa      	adds	r2, r7, r3
    9c1e:	234a      	movs	r3, #74	; 0x4a
    9c20:	18fb      	adds	r3, r7, r3
    9c22:	8812      	ldrh	r2, [r2, #0]
    9c24:	881b      	ldrh	r3, [r3, #0]
    9c26:	429a      	cmp	r2, r3
    9c28:	d900      	bls.n	9c2c <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x100>
    9c2a:	e08f      	b.n	9d4c <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x220>
              currentrequestedpower = (snkvoltage50mv * snkopcurrent10ma) / 2; /* to get value in mw */
    9c2c:	2338      	movs	r3, #56	; 0x38
    9c2e:	18fb      	adds	r3, r7, r3
    9c30:	881b      	ldrh	r3, [r3, #0]
    9c32:	2244      	movs	r2, #68	; 0x44
    9c34:	18ba      	adds	r2, r7, r2
    9c36:	8812      	ldrh	r2, [r2, #0]
    9c38:	4353      	muls	r3, r2
    9c3a:	2b00      	cmp	r3, #0
    9c3c:	da00      	bge.n	9c40 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x114>
    9c3e:	3301      	adds	r3, #1
    9c40:	105b      	asrs	r3, r3, #1
    9c42:	65bb      	str	r3, [r7, #88]	; 0x58
              currentrequestedvoltage = snkvoltage50mv;
    9c44:	2338      	movs	r3, #56	; 0x38
    9c46:	18fb      	adds	r3, r7, r3
    9c48:	881b      	ldrh	r3, [r3, #0]
    9c4a:	653b      	str	r3, [r7, #80]	; 0x50
            break;
    9c4c:	e07e      	b.n	9d4c <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x220>
            snkmaxvoltage50mv = snkpdo.SNKVariablePDO.MaxVoltageIn50mVunits;
    9c4e:	2332      	movs	r3, #50	; 0x32
    9c50:	18fb      	adds	r3, r7, r3
    9c52:	881b      	ldrh	r3, [r3, #0]
    9c54:	049b      	lsls	r3, r3, #18
    9c56:	0d9b      	lsrs	r3, r3, #22
    9c58:	b29a      	uxth	r2, r3
    9c5a:	2148      	movs	r1, #72	; 0x48
    9c5c:	187b      	adds	r3, r7, r1
    9c5e:	801a      	strh	r2, [r3, #0]
            snkminvoltage50mv = snkpdo.SNKVariablePDO.MinVoltageIn50mVunits;
    9c60:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    9c62:	031b      	lsls	r3, r3, #12
    9c64:	0d9b      	lsrs	r3, r3, #22
    9c66:	b29a      	uxth	r2, r3
    9c68:	2346      	movs	r3, #70	; 0x46
    9c6a:	18fb      	adds	r3, r7, r3
    9c6c:	801a      	strh	r2, [r3, #0]
            snkopcurrent10ma  = snkpdo.SNKVariablePDO.OperationalCurrentIn10mAunits;
    9c6e:	2330      	movs	r3, #48	; 0x30
    9c70:	18fb      	adds	r3, r7, r3
    9c72:	881b      	ldrh	r3, [r3, #0]
    9c74:	059b      	lsls	r3, r3, #22
    9c76:	0d9b      	lsrs	r3, r3, #22
    9c78:	b29a      	uxth	r2, r3
    9c7a:	2344      	movs	r3, #68	; 0x44
    9c7c:	18fb      	adds	r3, r7, r3
    9c7e:	801a      	strh	r2, [r3, #0]
            if (  (snkmaxvoltage50mv >= srcvoltage50mv)
    9c80:	187a      	adds	r2, r7, r1
    9c82:	233a      	movs	r3, #58	; 0x3a
    9c84:	18fb      	adds	r3, r7, r3
    9c86:	8812      	ldrh	r2, [r2, #0]
    9c88:	881b      	ldrh	r3, [r3, #0]
    9c8a:	429a      	cmp	r2, r3
    9c8c:	d360      	bcc.n	9d50 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x224>
                &&(snkminvoltage50mv <= srcvoltage50mv)
    9c8e:	2346      	movs	r3, #70	; 0x46
    9c90:	18fa      	adds	r2, r7, r3
    9c92:	233a      	movs	r3, #58	; 0x3a
    9c94:	18fb      	adds	r3, r7, r3
    9c96:	8812      	ldrh	r2, [r2, #0]
    9c98:	881b      	ldrh	r3, [r3, #0]
    9c9a:	429a      	cmp	r2, r3
    9c9c:	d858      	bhi.n	9d50 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x224>
                &&(snkopcurrent10ma  <= srcmaxcurrent10ma))
    9c9e:	2344      	movs	r3, #68	; 0x44
    9ca0:	18fa      	adds	r2, r7, r3
    9ca2:	234a      	movs	r3, #74	; 0x4a
    9ca4:	18fb      	adds	r3, r7, r3
    9ca6:	8812      	ldrh	r2, [r2, #0]
    9ca8:	881b      	ldrh	r3, [r3, #0]
    9caa:	429a      	cmp	r2, r3
    9cac:	d850      	bhi.n	9d50 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x224>
              currentrequestedpower = (srcvoltage50mv * snkopcurrent10ma) / 2; /* to get value in mw */
    9cae:	233a      	movs	r3, #58	; 0x3a
    9cb0:	18fb      	adds	r3, r7, r3
    9cb2:	881b      	ldrh	r3, [r3, #0]
    9cb4:	2244      	movs	r2, #68	; 0x44
    9cb6:	18ba      	adds	r2, r7, r2
    9cb8:	8812      	ldrh	r2, [r2, #0]
    9cba:	4353      	muls	r3, r2
    9cbc:	2b00      	cmp	r3, #0
    9cbe:	da00      	bge.n	9cc2 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x196>
    9cc0:	3301      	adds	r3, #1
    9cc2:	105b      	asrs	r3, r3, #1
    9cc4:	65bb      	str	r3, [r7, #88]	; 0x58
              currentrequestedvoltage = srcvoltage50mv;
    9cc6:	233a      	movs	r3, #58	; 0x3a
    9cc8:	18fb      	adds	r3, r7, r3
    9cca:	881b      	ldrh	r3, [r3, #0]
    9ccc:	653b      	str	r3, [r7, #80]	; 0x50
            break;
    9cce:	e03f      	b.n	9d50 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x224>
            snkmaxvoltage50mv = snkpdo.SNKBatteryPDO.MaxVoltageIn50mVunits;
    9cd0:	2332      	movs	r3, #50	; 0x32
    9cd2:	18fb      	adds	r3, r7, r3
    9cd4:	881b      	ldrh	r3, [r3, #0]
    9cd6:	049b      	lsls	r3, r3, #18
    9cd8:	0d9b      	lsrs	r3, r3, #22
    9cda:	b29a      	uxth	r2, r3
    9cdc:	2148      	movs	r1, #72	; 0x48
    9cde:	187b      	adds	r3, r7, r1
    9ce0:	801a      	strh	r2, [r3, #0]
            snkminvoltage50mv = snkpdo.SNKBatteryPDO.MinVoltageIn50mVunits;
    9ce2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    9ce4:	031b      	lsls	r3, r3, #12
    9ce6:	0d9b      	lsrs	r3, r3, #22
    9ce8:	b29a      	uxth	r2, r3
    9cea:	2346      	movs	r3, #70	; 0x46
    9cec:	18fb      	adds	r3, r7, r3
    9cee:	801a      	strh	r2, [r3, #0]
            snkoppower250mw   = snkpdo.SNKBatteryPDO.OperationalPowerIn250mWunits;
    9cf0:	2330      	movs	r3, #48	; 0x30
    9cf2:	18fb      	adds	r3, r7, r3
    9cf4:	881b      	ldrh	r3, [r3, #0]
    9cf6:	059b      	lsls	r3, r3, #22
    9cf8:	0d9b      	lsrs	r3, r3, #22
    9cfa:	b29b      	uxth	r3, r3
    9cfc:	643b      	str	r3, [r7, #64]	; 0x40
            if (  (snkmaxvoltage50mv >= srcvoltage50mv)
    9cfe:	187a      	adds	r2, r7, r1
    9d00:	233a      	movs	r3, #58	; 0x3a
    9d02:	18fb      	adds	r3, r7, r3
    9d04:	8812      	ldrh	r2, [r2, #0]
    9d06:	881b      	ldrh	r3, [r3, #0]
    9d08:	429a      	cmp	r2, r3
    9d0a:	d323      	bcc.n	9d54 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x228>
                &&(snkminvoltage50mv <= srcvoltage50mv)
    9d0c:	2346      	movs	r3, #70	; 0x46
    9d0e:	18fa      	adds	r2, r7, r3
    9d10:	233a      	movs	r3, #58	; 0x3a
    9d12:	18fb      	adds	r3, r7, r3
    9d14:	8812      	ldrh	r2, [r2, #0]
    9d16:	881b      	ldrh	r3, [r3, #0]
    9d18:	429a      	cmp	r2, r3
    9d1a:	d81b      	bhi.n	9d54 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x228>
                &&(snkoppower250mw <= ((srcvoltage50mv * srcmaxcurrent10ma)/500)))  /* to get value in 250 mw units */
    9d1c:	233a      	movs	r3, #58	; 0x3a
    9d1e:	18fb      	adds	r3, r7, r3
    9d20:	881b      	ldrh	r3, [r3, #0]
    9d22:	224a      	movs	r2, #74	; 0x4a
    9d24:	18ba      	adds	r2, r7, r2
    9d26:	8812      	ldrh	r2, [r2, #0]
    9d28:	435a      	muls	r2, r3
    9d2a:	23fa      	movs	r3, #250	; 0xfa
    9d2c:	0059      	lsls	r1, r3, #1
    9d2e:	0010      	movs	r0, r2
    9d30:	f015 f952 	bl	1efd8 <__divsi3>
    9d34:	0003      	movs	r3, r0
    9d36:	001a      	movs	r2, r3
    9d38:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    9d3a:	4293      	cmp	r3, r2
    9d3c:	d80a      	bhi.n	9d54 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x228>
              currentrequestedvoltage = srcvoltage50mv;
    9d3e:	233a      	movs	r3, #58	; 0x3a
    9d40:	18fb      	adds	r3, r7, r3
    9d42:	881b      	ldrh	r3, [r3, #0]
    9d44:	653b      	str	r3, [r7, #80]	; 0x50
              currentrequestedpower = snkoppower250mw;
    9d46:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    9d48:	65bb      	str	r3, [r7, #88]	; 0x58
            break;
    9d4a:	e003      	b.n	9d54 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x228>
            break;
    9d4c:	46c0      	nop			; (mov r8, r8)
    9d4e:	e002      	b.n	9d56 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x22a>
            break;
    9d50:	46c0      	nop			; (mov r8, r8)
    9d52:	e000      	b.n	9d56 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x22a>
            break;
    9d54:	46c0      	nop			; (mov r8, r8)
        }

        if (currentrequestedpower > maxrequestedpower)
    9d56:	6dba      	ldr	r2, [r7, #88]	; 0x58
    9d58:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    9d5a:	429a      	cmp	r2, r3
    9d5c:	d905      	bls.n	9d6a <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x23e>
        {
          match = USBPD_TRUE;
    9d5e:	2301      	movs	r3, #1
    9d60:	667b      	str	r3, [r7, #100]	; 0x64
          maxrequestedpower   = currentrequestedpower;
    9d62:	6dbb      	ldr	r3, [r7, #88]	; 0x58
    9d64:	65fb      	str	r3, [r7, #92]	; 0x5c
          maxrequestedvoltage = currentrequestedvoltage;
    9d66:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    9d68:	657b      	str	r3, [r7, #84]	; 0x54
      for (i=0; i<nbsnkpdo; i++)
    9d6a:	2162      	movs	r1, #98	; 0x62
    9d6c:	187b      	adds	r3, r7, r1
    9d6e:	881a      	ldrh	r2, [r3, #0]
    9d70:	187b      	adds	r3, r7, r1
    9d72:	3201      	adds	r2, #1
    9d74:	801a      	strh	r2, [r3, #0]
    9d76:	2362      	movs	r3, #98	; 0x62
    9d78:	18fb      	adds	r3, r7, r3
    9d7a:	881a      	ldrh	r2, [r3, #0]
    9d7c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    9d7e:	429a      	cmp	r2, r3
    9d80:	d200      	bcs.n	9d84 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x258>
    9d82:	e718      	b.n	9bb6 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x8a>
        }
      }
      break;
    9d84:	e1a2      	b.n	a0cc <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x5a0>

    /* SRC Variable Supply (non-battery) PDO */
    case USBPD_CORE_PDO_TYPE_VARIABLE:
      srcmaxvoltage50mv = srcpdo.SRCVariablePDO.MaxVoltageIn50mVunits;
    9d86:	2336      	movs	r3, #54	; 0x36
    9d88:	18fb      	adds	r3, r7, r3
    9d8a:	881b      	ldrh	r3, [r3, #0]
    9d8c:	049b      	lsls	r3, r3, #18
    9d8e:	0d9b      	lsrs	r3, r3, #22
    9d90:	b29a      	uxth	r2, r3
    9d92:	234e      	movs	r3, #78	; 0x4e
    9d94:	18fb      	adds	r3, r7, r3
    9d96:	801a      	strh	r2, [r3, #0]
      srcminvoltage50mv = srcpdo.SRCVariablePDO.MinVoltageIn50mVunits;
    9d98:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    9d9a:	031b      	lsls	r3, r3, #12
    9d9c:	0d9b      	lsrs	r3, r3, #22
    9d9e:	b29a      	uxth	r2, r3
    9da0:	234c      	movs	r3, #76	; 0x4c
    9da2:	18fb      	adds	r3, r7, r3
    9da4:	801a      	strh	r2, [r3, #0]
      srcmaxcurrent10ma = srcpdo.SRCVariablePDO.MaxCurrentIn10mAunits;
    9da6:	2334      	movs	r3, #52	; 0x34
    9da8:	18fb      	adds	r3, r7, r3
    9daa:	881b      	ldrh	r3, [r3, #0]
    9dac:	059b      	lsls	r3, r3, #22
    9dae:	0d9b      	lsrs	r3, r3, #22
    9db0:	b29a      	uxth	r2, r3
    9db2:	234a      	movs	r3, #74	; 0x4a
    9db4:	18fb      	adds	r3, r7, r3
    9db6:	801a      	strh	r2, [r3, #0]

      /* Loop through SNK PDO list */
      for (i=0; i<nbsnkpdo; i++)
    9db8:	2362      	movs	r3, #98	; 0x62
    9dba:	18fb      	adds	r3, r7, r3
    9dbc:	2200      	movs	r2, #0
    9dbe:	801a      	strh	r2, [r3, #0]
    9dc0:	e0b0      	b.n	9f24 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x3f8>
      {
        currentrequestedpower = 0;
    9dc2:	2300      	movs	r3, #0
    9dc4:	65bb      	str	r3, [r7, #88]	; 0x58
        currentrequestedvoltage = 0;
    9dc6:	2300      	movs	r3, #0
    9dc8:	653b      	str	r3, [r7, #80]	; 0x50

        /* Retrieve SNK PDO value according to its type */
        snkpdo.d32 = snkpdo_array[i];
    9dca:	2362      	movs	r3, #98	; 0x62
    9dcc:	18fb      	adds	r3, r7, r3
    9dce:	881a      	ldrh	r2, [r3, #0]
    9dd0:	2310      	movs	r3, #16
    9dd2:	18fb      	adds	r3, r7, r3
    9dd4:	0092      	lsls	r2, r2, #2
    9dd6:	58d3      	ldr	r3, [r2, r3]
    9dd8:	633b      	str	r3, [r7, #48]	; 0x30
        switch(snkpdo.GenericPDO.PowerObject)
    9dda:	2333      	movs	r3, #51	; 0x33
    9ddc:	18fb      	adds	r3, r7, r3
    9dde:	781b      	ldrb	r3, [r3, #0]
    9de0:	061b      	lsls	r3, r3, #24
    9de2:	0f9b      	lsrs	r3, r3, #30
    9de4:	b2db      	uxtb	r3, r3
    9de6:	2b01      	cmp	r3, #1
    9de8:	d047      	beq.n	9e7a <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x34e>
    9dea:	2b02      	cmp	r3, #2
    9dec:	d003      	beq.n	9df6 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x2ca>
    9dee:	2b00      	cmp	r3, #0
    9df0:	d100      	bne.n	9df4 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x2c8>
    9df2:	e082      	b.n	9efa <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x3ce>
            }
            break;


          default:
            break;
    9df4:	e086      	b.n	9f04 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x3d8>
            snkmaxvoltage50mv = snkpdo.SNKVariablePDO.MaxVoltageIn50mVunits;
    9df6:	2332      	movs	r3, #50	; 0x32
    9df8:	18fb      	adds	r3, r7, r3
    9dfa:	881b      	ldrh	r3, [r3, #0]
    9dfc:	049b      	lsls	r3, r3, #18
    9dfe:	0d9b      	lsrs	r3, r3, #22
    9e00:	b29a      	uxth	r2, r3
    9e02:	2148      	movs	r1, #72	; 0x48
    9e04:	187b      	adds	r3, r7, r1
    9e06:	801a      	strh	r2, [r3, #0]
            snkminvoltage50mv = snkpdo.SNKVariablePDO.MinVoltageIn50mVunits;
    9e08:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    9e0a:	031b      	lsls	r3, r3, #12
    9e0c:	0d9b      	lsrs	r3, r3, #22
    9e0e:	b29a      	uxth	r2, r3
    9e10:	2346      	movs	r3, #70	; 0x46
    9e12:	18fb      	adds	r3, r7, r3
    9e14:	801a      	strh	r2, [r3, #0]
            snkopcurrent10ma  = snkpdo.SNKVariablePDO.OperationalCurrentIn10mAunits;
    9e16:	2330      	movs	r3, #48	; 0x30
    9e18:	18fb      	adds	r3, r7, r3
    9e1a:	881b      	ldrh	r3, [r3, #0]
    9e1c:	059b      	lsls	r3, r3, #22
    9e1e:	0d9b      	lsrs	r3, r3, #22
    9e20:	b29a      	uxth	r2, r3
    9e22:	2344      	movs	r3, #68	; 0x44
    9e24:	18fb      	adds	r3, r7, r3
    9e26:	801a      	strh	r2, [r3, #0]
            if (  (snkmaxvoltage50mv >= srcmaxvoltage50mv)
    9e28:	187a      	adds	r2, r7, r1
    9e2a:	234e      	movs	r3, #78	; 0x4e
    9e2c:	18fb      	adds	r3, r7, r3
    9e2e:	8812      	ldrh	r2, [r2, #0]
    9e30:	881b      	ldrh	r3, [r3, #0]
    9e32:	429a      	cmp	r2, r3
    9e34:	d200      	bcs.n	9e38 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x30c>
    9e36:	e062      	b.n	9efe <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x3d2>
                &&(snkminvoltage50mv <= srcminvoltage50mv)
    9e38:	2346      	movs	r3, #70	; 0x46
    9e3a:	18fa      	adds	r2, r7, r3
    9e3c:	234c      	movs	r3, #76	; 0x4c
    9e3e:	18fb      	adds	r3, r7, r3
    9e40:	8812      	ldrh	r2, [r2, #0]
    9e42:	881b      	ldrh	r3, [r3, #0]
    9e44:	429a      	cmp	r2, r3
    9e46:	d85a      	bhi.n	9efe <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x3d2>
                &&(snkopcurrent10ma <= srcmaxcurrent10ma))
    9e48:	2344      	movs	r3, #68	; 0x44
    9e4a:	18fa      	adds	r2, r7, r3
    9e4c:	234a      	movs	r3, #74	; 0x4a
    9e4e:	18fb      	adds	r3, r7, r3
    9e50:	8812      	ldrh	r2, [r2, #0]
    9e52:	881b      	ldrh	r3, [r3, #0]
    9e54:	429a      	cmp	r2, r3
    9e56:	d852      	bhi.n	9efe <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x3d2>
              currentrequestedpower = (srcmaxvoltage50mv * snkopcurrent10ma) / 2; /* to get value in mw */
    9e58:	234e      	movs	r3, #78	; 0x4e
    9e5a:	18fb      	adds	r3, r7, r3
    9e5c:	881b      	ldrh	r3, [r3, #0]
    9e5e:	2244      	movs	r2, #68	; 0x44
    9e60:	18ba      	adds	r2, r7, r2
    9e62:	8812      	ldrh	r2, [r2, #0]
    9e64:	4353      	muls	r3, r2
    9e66:	2b00      	cmp	r3, #0
    9e68:	da00      	bge.n	9e6c <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x340>
    9e6a:	3301      	adds	r3, #1
    9e6c:	105b      	asrs	r3, r3, #1
    9e6e:	65bb      	str	r3, [r7, #88]	; 0x58
              currentrequestedvoltage = srcmaxvoltage50mv;
    9e70:	234e      	movs	r3, #78	; 0x4e
    9e72:	18fb      	adds	r3, r7, r3
    9e74:	881b      	ldrh	r3, [r3, #0]
    9e76:	653b      	str	r3, [r7, #80]	; 0x50
            break;
    9e78:	e041      	b.n	9efe <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x3d2>
            snkmaxvoltage50mv = snkpdo.SNKBatteryPDO.MaxVoltageIn50mVunits;
    9e7a:	2332      	movs	r3, #50	; 0x32
    9e7c:	18fb      	adds	r3, r7, r3
    9e7e:	881b      	ldrh	r3, [r3, #0]
    9e80:	049b      	lsls	r3, r3, #18
    9e82:	0d9b      	lsrs	r3, r3, #22
    9e84:	b29a      	uxth	r2, r3
    9e86:	2148      	movs	r1, #72	; 0x48
    9e88:	187b      	adds	r3, r7, r1
    9e8a:	801a      	strh	r2, [r3, #0]
            snkminvoltage50mv = snkpdo.SNKBatteryPDO.MinVoltageIn50mVunits;
    9e8c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    9e8e:	031b      	lsls	r3, r3, #12
    9e90:	0d9b      	lsrs	r3, r3, #22
    9e92:	b29a      	uxth	r2, r3
    9e94:	2346      	movs	r3, #70	; 0x46
    9e96:	18fb      	adds	r3, r7, r3
    9e98:	801a      	strh	r2, [r3, #0]
            snkoppower250mw   = snkpdo.SNKBatteryPDO.OperationalPowerIn250mWunits;
    9e9a:	2330      	movs	r3, #48	; 0x30
    9e9c:	18fb      	adds	r3, r7, r3
    9e9e:	881b      	ldrh	r3, [r3, #0]
    9ea0:	059b      	lsls	r3, r3, #22
    9ea2:	0d9b      	lsrs	r3, r3, #22
    9ea4:	b29b      	uxth	r3, r3
    9ea6:	643b      	str	r3, [r7, #64]	; 0x40
            if (  (snkmaxvoltage50mv >= srcmaxvoltage50mv)
    9ea8:	187a      	adds	r2, r7, r1
    9eaa:	234e      	movs	r3, #78	; 0x4e
    9eac:	18fb      	adds	r3, r7, r3
    9eae:	8812      	ldrh	r2, [r2, #0]
    9eb0:	881b      	ldrh	r3, [r3, #0]
    9eb2:	429a      	cmp	r2, r3
    9eb4:	d325      	bcc.n	9f02 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x3d6>
                &&(snkminvoltage50mv <= srcminvoltage50mv)
    9eb6:	2346      	movs	r3, #70	; 0x46
    9eb8:	18fa      	adds	r2, r7, r3
    9eba:	234c      	movs	r3, #76	; 0x4c
    9ebc:	18fb      	adds	r3, r7, r3
    9ebe:	8812      	ldrh	r2, [r2, #0]
    9ec0:	881b      	ldrh	r3, [r3, #0]
    9ec2:	429a      	cmp	r2, r3
    9ec4:	d81d      	bhi.n	9f02 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x3d6>
                &&(snkoppower250mw <= ((srcmaxvoltage50mv * srcmaxcurrent10ma)/500)))  /* to get value in 250 mw units */
    9ec6:	234e      	movs	r3, #78	; 0x4e
    9ec8:	18fb      	adds	r3, r7, r3
    9eca:	881b      	ldrh	r3, [r3, #0]
    9ecc:	224a      	movs	r2, #74	; 0x4a
    9ece:	18ba      	adds	r2, r7, r2
    9ed0:	8812      	ldrh	r2, [r2, #0]
    9ed2:	435a      	muls	r2, r3
    9ed4:	23fa      	movs	r3, #250	; 0xfa
    9ed6:	0059      	lsls	r1, r3, #1
    9ed8:	0010      	movs	r0, r2
    9eda:	f015 f87d 	bl	1efd8 <__divsi3>
    9ede:	0003      	movs	r3, r0
    9ee0:	001a      	movs	r2, r3
    9ee2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    9ee4:	4293      	cmp	r3, r2
    9ee6:	d80c      	bhi.n	9f02 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x3d6>
              currentrequestedpower   = snkoppower250mw * 250; /* to get value in mw */
    9ee8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    9eea:	22fa      	movs	r2, #250	; 0xfa
    9eec:	4353      	muls	r3, r2
    9eee:	65bb      	str	r3, [r7, #88]	; 0x58
              currentrequestedvoltage = srcmaxvoltage50mv;
    9ef0:	234e      	movs	r3, #78	; 0x4e
    9ef2:	18fb      	adds	r3, r7, r3
    9ef4:	881b      	ldrh	r3, [r3, #0]
    9ef6:	653b      	str	r3, [r7, #80]	; 0x50
            break;
    9ef8:	e003      	b.n	9f02 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x3d6>
            break;
    9efa:	46c0      	nop			; (mov r8, r8)
    9efc:	e002      	b.n	9f04 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x3d8>
            break;
    9efe:	46c0      	nop			; (mov r8, r8)
    9f00:	e000      	b.n	9f04 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x3d8>
            break;
    9f02:	46c0      	nop			; (mov r8, r8)
        }

        if (currentrequestedpower > maxrequestedpower)
    9f04:	6dba      	ldr	r2, [r7, #88]	; 0x58
    9f06:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    9f08:	429a      	cmp	r2, r3
    9f0a:	d905      	bls.n	9f18 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x3ec>
        {
          match = USBPD_TRUE;
    9f0c:	2301      	movs	r3, #1
    9f0e:	667b      	str	r3, [r7, #100]	; 0x64
          maxrequestedpower   = currentrequestedpower;
    9f10:	6dbb      	ldr	r3, [r7, #88]	; 0x58
    9f12:	65fb      	str	r3, [r7, #92]	; 0x5c
          maxrequestedvoltage = currentrequestedvoltage;
    9f14:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    9f16:	657b      	str	r3, [r7, #84]	; 0x54
      for (i=0; i<nbsnkpdo; i++)
    9f18:	2162      	movs	r1, #98	; 0x62
    9f1a:	187b      	adds	r3, r7, r1
    9f1c:	881a      	ldrh	r2, [r3, #0]
    9f1e:	187b      	adds	r3, r7, r1
    9f20:	3201      	adds	r2, #1
    9f22:	801a      	strh	r2, [r3, #0]
    9f24:	2362      	movs	r3, #98	; 0x62
    9f26:	18fb      	adds	r3, r7, r3
    9f28:	881a      	ldrh	r2, [r3, #0]
    9f2a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    9f2c:	429a      	cmp	r2, r3
    9f2e:	d200      	bcs.n	9f32 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x406>
    9f30:	e747      	b.n	9dc2 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x296>
        }
      }
      break;
    9f32:	e0cb      	b.n	a0cc <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x5a0>

    /* SRC Battery Supply PDO */
    case USBPD_CORE_PDO_TYPE_BATTERY:
      srcmaxvoltage50mv = srcpdo.SRCBatteryPDO.MaxVoltageIn50mVunits;
    9f34:	2336      	movs	r3, #54	; 0x36
    9f36:	18fb      	adds	r3, r7, r3
    9f38:	881b      	ldrh	r3, [r3, #0]
    9f3a:	049b      	lsls	r3, r3, #18
    9f3c:	0d9b      	lsrs	r3, r3, #22
    9f3e:	b29a      	uxth	r2, r3
    9f40:	234e      	movs	r3, #78	; 0x4e
    9f42:	18fb      	adds	r3, r7, r3
    9f44:	801a      	strh	r2, [r3, #0]
      srcminvoltage50mv = srcpdo.SRCBatteryPDO.MinVoltageIn50mVunits;
    9f46:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    9f48:	031b      	lsls	r3, r3, #12
    9f4a:	0d9b      	lsrs	r3, r3, #22
    9f4c:	b29a      	uxth	r2, r3
    9f4e:	234c      	movs	r3, #76	; 0x4c
    9f50:	18fb      	adds	r3, r7, r3
    9f52:	801a      	strh	r2, [r3, #0]
      srcmaxpower250mw  = srcpdo.SRCBatteryPDO.MaxAllowablePowerIn250mWunits;
    9f54:	2334      	movs	r3, #52	; 0x34
    9f56:	18fb      	adds	r3, r7, r3
    9f58:	881b      	ldrh	r3, [r3, #0]
    9f5a:	059b      	lsls	r3, r3, #22
    9f5c:	0d9b      	lsrs	r3, r3, #22
    9f5e:	b29b      	uxth	r3, r3
    9f60:	63fb      	str	r3, [r7, #60]	; 0x3c

      /* Loop through SNK PDO list */
      for (i=0; i<nbsnkpdo; i++)
    9f62:	2362      	movs	r3, #98	; 0x62
    9f64:	18fb      	adds	r3, r7, r3
    9f66:	2200      	movs	r2, #0
    9f68:	801a      	strh	r2, [r3, #0]
    9f6a:	e0a5      	b.n	a0b8 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x58c>
      {
        currentrequestedpower = 0;
    9f6c:	2300      	movs	r3, #0
    9f6e:	65bb      	str	r3, [r7, #88]	; 0x58
        currentrequestedvoltage = 0;
    9f70:	2300      	movs	r3, #0
    9f72:	653b      	str	r3, [r7, #80]	; 0x50

        /* Retrieve SNK PDO value according to its type */
        snkpdo.d32 = snkpdo_array[i];
    9f74:	2362      	movs	r3, #98	; 0x62
    9f76:	18fb      	adds	r3, r7, r3
    9f78:	881a      	ldrh	r2, [r3, #0]
    9f7a:	2310      	movs	r3, #16
    9f7c:	18fb      	adds	r3, r7, r3
    9f7e:	0092      	lsls	r2, r2, #2
    9f80:	58d3      	ldr	r3, [r2, r3]
    9f82:	633b      	str	r3, [r7, #48]	; 0x30
        switch(snkpdo.GenericPDO.PowerObject)
    9f84:	2333      	movs	r3, #51	; 0x33
    9f86:	18fb      	adds	r3, r7, r3
    9f88:	781b      	ldrb	r3, [r3, #0]
    9f8a:	061b      	lsls	r3, r3, #24
    9f8c:	0f9b      	lsrs	r3, r3, #30
    9f8e:	b2db      	uxtb	r3, r3
    9f90:	2b01      	cmp	r3, #1
    9f92:	d049      	beq.n	a028 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x4fc>
    9f94:	2b02      	cmp	r3, #2
    9f96:	d003      	beq.n	9fa0 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x474>
    9f98:	2b00      	cmp	r3, #0
    9f9a:	d100      	bne.n	9f9e <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x472>
    9f9c:	e077      	b.n	a08e <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x562>
            }
            break;


          default:
            break;
    9f9e:	e07b      	b.n	a098 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x56c>
            snkmaxvoltage50mv = snkpdo.SNKVariablePDO.MaxVoltageIn50mVunits;
    9fa0:	2332      	movs	r3, #50	; 0x32
    9fa2:	18fb      	adds	r3, r7, r3
    9fa4:	881b      	ldrh	r3, [r3, #0]
    9fa6:	049b      	lsls	r3, r3, #18
    9fa8:	0d9b      	lsrs	r3, r3, #22
    9faa:	b29a      	uxth	r2, r3
    9fac:	2148      	movs	r1, #72	; 0x48
    9fae:	187b      	adds	r3, r7, r1
    9fb0:	801a      	strh	r2, [r3, #0]
            snkminvoltage50mv = snkpdo.SNKVariablePDO.MinVoltageIn50mVunits;
    9fb2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    9fb4:	031b      	lsls	r3, r3, #12
    9fb6:	0d9b      	lsrs	r3, r3, #22
    9fb8:	b29a      	uxth	r2, r3
    9fba:	2346      	movs	r3, #70	; 0x46
    9fbc:	18fb      	adds	r3, r7, r3
    9fbe:	801a      	strh	r2, [r3, #0]
            snkopcurrent10ma  = snkpdo.SNKVariablePDO.OperationalCurrentIn10mAunits;
    9fc0:	2330      	movs	r3, #48	; 0x30
    9fc2:	18fb      	adds	r3, r7, r3
    9fc4:	881b      	ldrh	r3, [r3, #0]
    9fc6:	059b      	lsls	r3, r3, #22
    9fc8:	0d9b      	lsrs	r3, r3, #22
    9fca:	b29a      	uxth	r2, r3
    9fcc:	2344      	movs	r3, #68	; 0x44
    9fce:	18fb      	adds	r3, r7, r3
    9fd0:	801a      	strh	r2, [r3, #0]
            if (  (snkmaxvoltage50mv >= srcmaxvoltage50mv)
    9fd2:	187a      	adds	r2, r7, r1
    9fd4:	234e      	movs	r3, #78	; 0x4e
    9fd6:	18fb      	adds	r3, r7, r3
    9fd8:	8812      	ldrh	r2, [r2, #0]
    9fda:	881b      	ldrh	r3, [r3, #0]
    9fdc:	429a      	cmp	r2, r3
    9fde:	d358      	bcc.n	a092 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x566>
                &&(snkminvoltage50mv <= srcminvoltage50mv)
    9fe0:	2346      	movs	r3, #70	; 0x46
    9fe2:	18fa      	adds	r2, r7, r3
    9fe4:	234c      	movs	r3, #76	; 0x4c
    9fe6:	18fb      	adds	r3, r7, r3
    9fe8:	8812      	ldrh	r2, [r2, #0]
    9fea:	881b      	ldrh	r3, [r3, #0]
    9fec:	429a      	cmp	r2, r3
    9fee:	d850      	bhi.n	a092 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x566>
                &&(srcmaxvoltage50mv * snkopcurrent10ma <= srcmaxpower250mw))
    9ff0:	234e      	movs	r3, #78	; 0x4e
    9ff2:	18fb      	adds	r3, r7, r3
    9ff4:	881b      	ldrh	r3, [r3, #0]
    9ff6:	2244      	movs	r2, #68	; 0x44
    9ff8:	18ba      	adds	r2, r7, r2
    9ffa:	8812      	ldrh	r2, [r2, #0]
    9ffc:	4353      	muls	r3, r2
    9ffe:	001a      	movs	r2, r3
    a000:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    a002:	4293      	cmp	r3, r2
    a004:	d345      	bcc.n	a092 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x566>
              currentrequestedpower = (srcmaxvoltage50mv * snkopcurrent10ma) / 2; /* to get value in mw */
    a006:	234e      	movs	r3, #78	; 0x4e
    a008:	18fb      	adds	r3, r7, r3
    a00a:	881b      	ldrh	r3, [r3, #0]
    a00c:	2244      	movs	r2, #68	; 0x44
    a00e:	18ba      	adds	r2, r7, r2
    a010:	8812      	ldrh	r2, [r2, #0]
    a012:	4353      	muls	r3, r2
    a014:	2b00      	cmp	r3, #0
    a016:	da00      	bge.n	a01a <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x4ee>
    a018:	3301      	adds	r3, #1
    a01a:	105b      	asrs	r3, r3, #1
    a01c:	65bb      	str	r3, [r7, #88]	; 0x58
              currentrequestedvoltage = srcmaxvoltage50mv;
    a01e:	234e      	movs	r3, #78	; 0x4e
    a020:	18fb      	adds	r3, r7, r3
    a022:	881b      	ldrh	r3, [r3, #0]
    a024:	653b      	str	r3, [r7, #80]	; 0x50
            break;
    a026:	e034      	b.n	a092 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x566>
            snkmaxvoltage50mv = snkpdo.SNKBatteryPDO.MaxVoltageIn50mVunits;
    a028:	2332      	movs	r3, #50	; 0x32
    a02a:	18fb      	adds	r3, r7, r3
    a02c:	881b      	ldrh	r3, [r3, #0]
    a02e:	049b      	lsls	r3, r3, #18
    a030:	0d9b      	lsrs	r3, r3, #22
    a032:	b29a      	uxth	r2, r3
    a034:	2148      	movs	r1, #72	; 0x48
    a036:	187b      	adds	r3, r7, r1
    a038:	801a      	strh	r2, [r3, #0]
            snkminvoltage50mv = snkpdo.SNKBatteryPDO.MinVoltageIn50mVunits;
    a03a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    a03c:	031b      	lsls	r3, r3, #12
    a03e:	0d9b      	lsrs	r3, r3, #22
    a040:	b29a      	uxth	r2, r3
    a042:	2346      	movs	r3, #70	; 0x46
    a044:	18fb      	adds	r3, r7, r3
    a046:	801a      	strh	r2, [r3, #0]
            snkoppower250mw   = snkpdo.SNKBatteryPDO.OperationalPowerIn250mWunits;
    a048:	2330      	movs	r3, #48	; 0x30
    a04a:	18fb      	adds	r3, r7, r3
    a04c:	881b      	ldrh	r3, [r3, #0]
    a04e:	059b      	lsls	r3, r3, #22
    a050:	0d9b      	lsrs	r3, r3, #22
    a052:	b29b      	uxth	r3, r3
    a054:	643b      	str	r3, [r7, #64]	; 0x40
            if (  (snkmaxvoltage50mv >= srcmaxvoltage50mv)
    a056:	187a      	adds	r2, r7, r1
    a058:	234e      	movs	r3, #78	; 0x4e
    a05a:	18fb      	adds	r3, r7, r3
    a05c:	8812      	ldrh	r2, [r2, #0]
    a05e:	881b      	ldrh	r3, [r3, #0]
    a060:	429a      	cmp	r2, r3
    a062:	d318      	bcc.n	a096 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x56a>
                &&(snkminvoltage50mv <= srcminvoltage50mv)
    a064:	2346      	movs	r3, #70	; 0x46
    a066:	18fa      	adds	r2, r7, r3
    a068:	234c      	movs	r3, #76	; 0x4c
    a06a:	18fb      	adds	r3, r7, r3
    a06c:	8812      	ldrh	r2, [r2, #0]
    a06e:	881b      	ldrh	r3, [r3, #0]
    a070:	429a      	cmp	r2, r3
    a072:	d810      	bhi.n	a096 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x56a>
                &&(snkoppower250mw <= srcmaxpower250mw))
    a074:	6c3a      	ldr	r2, [r7, #64]	; 0x40
    a076:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    a078:	429a      	cmp	r2, r3
    a07a:	d80c      	bhi.n	a096 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x56a>
              currentrequestedpower   = snkoppower250mw * 250; /* to get value in mw */
    a07c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    a07e:	22fa      	movs	r2, #250	; 0xfa
    a080:	4353      	muls	r3, r2
    a082:	65bb      	str	r3, [r7, #88]	; 0x58
              currentrequestedvoltage = srcmaxvoltage50mv;
    a084:	234e      	movs	r3, #78	; 0x4e
    a086:	18fb      	adds	r3, r7, r3
    a088:	881b      	ldrh	r3, [r3, #0]
    a08a:	653b      	str	r3, [r7, #80]	; 0x50
            break;
    a08c:	e003      	b.n	a096 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x56a>
            break;
    a08e:	46c0      	nop			; (mov r8, r8)
    a090:	e002      	b.n	a098 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x56c>
            break;
    a092:	46c0      	nop			; (mov r8, r8)
    a094:	e000      	b.n	a098 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x56c>
            break;
    a096:	46c0      	nop			; (mov r8, r8)
        }

        if (currentrequestedpower > maxrequestedpower)
    a098:	6dba      	ldr	r2, [r7, #88]	; 0x58
    a09a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    a09c:	429a      	cmp	r2, r3
    a09e:	d905      	bls.n	a0ac <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x580>
        {
          match = USBPD_TRUE;
    a0a0:	2301      	movs	r3, #1
    a0a2:	667b      	str	r3, [r7, #100]	; 0x64
          maxrequestedpower   = currentrequestedpower;
    a0a4:	6dbb      	ldr	r3, [r7, #88]	; 0x58
    a0a6:	65fb      	str	r3, [r7, #92]	; 0x5c
          maxrequestedvoltage = currentrequestedvoltage;
    a0a8:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    a0aa:	657b      	str	r3, [r7, #84]	; 0x54
      for (i=0; i<nbsnkpdo; i++)
    a0ac:	2162      	movs	r1, #98	; 0x62
    a0ae:	187b      	adds	r3, r7, r1
    a0b0:	881a      	ldrh	r2, [r3, #0]
    a0b2:	187b      	adds	r3, r7, r1
    a0b4:	3201      	adds	r2, #1
    a0b6:	801a      	strh	r2, [r3, #0]
    a0b8:	2362      	movs	r3, #98	; 0x62
    a0ba:	18fb      	adds	r3, r7, r3
    a0bc:	881a      	ldrh	r2, [r3, #0]
    a0be:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    a0c0:	429a      	cmp	r2, r3
    a0c2:	d200      	bcs.n	a0c6 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x59a>
    a0c4:	e752      	b.n	9f6c <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x440>
        }
      }
      break;
    a0c6:	e001      	b.n	a0cc <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x5a0>


    default:
      return(USBPD_FALSE);
    a0c8:	2300      	movs	r3, #0
    a0ca:	e00b      	b.n	a0e4 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x5b8>
  }

  if (maxrequestedpower > 0)
    a0cc:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    a0ce:	2b00      	cmp	r3, #0
    a0d0:	d007      	beq.n	a0e2 <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO+0x5b6>
  {
    *PtrRequestedPower   = maxrequestedpower;
    a0d2:	683b      	ldr	r3, [r7, #0]
    a0d4:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
    a0d6:	601a      	str	r2, [r3, #0]
    *PtrRequestedVoltage = maxrequestedvoltage * 50; /* value in mV */
    a0d8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    a0da:	2232      	movs	r2, #50	; 0x32
    a0dc:	435a      	muls	r2, r3
    a0de:	687b      	ldr	r3, [r7, #4]
    a0e0:	601a      	str	r2, [r3, #0]
  }
  return(match);
    a0e2:	6e7b      	ldr	r3, [r7, #100]	; 0x64
}
    a0e4:	0018      	movs	r0, r3
    a0e6:	46bd      	mov	sp, r7
    a0e8:	b01b      	add	sp, #108	; 0x6c
    a0ea:	bd90      	pop	{r4, r7, pc}

0000a0ec <DPM_FindVoltageIndex>:
  * @param  PortNum Port number
  * @param  PtrRequestPowerDetails  Sink requested power details structure pointer
  * @retval Index of PDO within source capabilities message (DPM_NO_SRC_PDO_FOUND indicating not found)
  */
static uint32_t DPM_FindVoltageIndex(uint32_t PortNum, USBPD_DPM_SNKPowerRequestDetails_TypeDef* PtrRequestPowerDetails)
{
    a0ec:	b580      	push	{r7, lr}
    a0ee:	b08c      	sub	sp, #48	; 0x30
    a0f0:	af00      	add	r7, sp, #0
    a0f2:	6078      	str	r0, [r7, #4]
    a0f4:	6039      	str	r1, [r7, #0]
  uint32_t *ptpdoarray;
  USBPD_PDO_TypeDef  pdo;
  uint32_t voltage, reqvoltage, nbpdo, allowablepower, maxpower;
  uint32_t curr_index = DPM_NO_SRC_PDO_FOUND, temp_index;
    a0f6:	23ff      	movs	r3, #255	; 0xff
    a0f8:	627b      	str	r3, [r7, #36]	; 0x24
  USBPD_USER_SettingsTypeDef *puser = (USBPD_USER_SettingsTypeDef *)&DPM_USER_Settings[PortNum];
    a0fa:	687b      	ldr	r3, [r7, #4]
    a0fc:	2274      	movs	r2, #116	; 0x74
    a0fe:	435a      	muls	r2, r3
    a100:	4b3b      	ldr	r3, [pc, #236]	; (a1f0 <DPM_FindVoltageIndex+0x104>)
    a102:	18d3      	adds	r3, r2, r3
    a104:	61fb      	str	r3, [r7, #28]

  allowablepower = 0;
    a106:	2300      	movs	r3, #0
    a108:	60bb      	str	r3, [r7, #8]
  maxpower       = 0;
    a10a:	2300      	movs	r3, #0
    a10c:	62bb      	str	r3, [r7, #40]	; 0x28
  reqvoltage     = 0;
    a10e:	2300      	movs	r3, #0
    a110:	62fb      	str	r3, [r7, #44]	; 0x2c
  voltage        = 0;
    a112:	2300      	movs	r3, #0
    a114:	60fb      	str	r3, [r7, #12]

  /* Search PDO index among Source PDO of Port */
  nbpdo = DPM_Ports[PortNum].DPM_NumberOfRcvSRCPDO;
    a116:	4a37      	ldr	r2, [pc, #220]	; (a1f4 <DPM_FindVoltageIndex+0x108>)
    a118:	687b      	ldr	r3, [r7, #4]
    a11a:	21b0      	movs	r1, #176	; 0xb0
    a11c:	434b      	muls	r3, r1
    a11e:	18d3      	adds	r3, r2, r3
    a120:	331c      	adds	r3, #28
    a122:	681b      	ldr	r3, [r3, #0]
    a124:	61bb      	str	r3, [r7, #24]
  ptpdoarray = DPM_Ports[PortNum].DPM_ListOfRcvSRCPDO;
    a126:	687b      	ldr	r3, [r7, #4]
    a128:	22b0      	movs	r2, #176	; 0xb0
    a12a:	435a      	muls	r2, r3
    a12c:	4b31      	ldr	r3, [pc, #196]	; (a1f4 <DPM_FindVoltageIndex+0x108>)
    a12e:	18d3      	adds	r3, r2, r3
    a130:	617b      	str	r3, [r7, #20]

  /* search the better PDO in the list of source PDOs */
  for(temp_index = 0; temp_index < nbpdo; temp_index++)
    a132:	2300      	movs	r3, #0
    a134:	623b      	str	r3, [r7, #32]
    a136:	e02f      	b.n	a198 <DPM_FindVoltageIndex+0xac>
  {
    pdo.d32 = ptpdoarray[temp_index];
    a138:	6a3b      	ldr	r3, [r7, #32]
    a13a:	009b      	lsls	r3, r3, #2
    a13c:	697a      	ldr	r2, [r7, #20]
    a13e:	18d3      	adds	r3, r2, r3
    a140:	681b      	ldr	r3, [r3, #0]
    a142:	613b      	str	r3, [r7, #16]
      /* check if the received source PDO is matching any of the SNK PDO */
    allowablepower = 0;
    a144:	2300      	movs	r3, #0
    a146:	60bb      	str	r3, [r7, #8]
      if (USBPD_TRUE == USBPD_DPM_SNK_EvaluateMatchWithSRCPDO(PortNum, pdo.d32, &voltage, &allowablepower))
    a148:	687b      	ldr	r3, [r7, #4]
    a14a:	b2d8      	uxtb	r0, r3
    a14c:	6939      	ldr	r1, [r7, #16]
    a14e:	2308      	movs	r3, #8
    a150:	18fb      	adds	r3, r7, r3
    a152:	220c      	movs	r2, #12
    a154:	18ba      	adds	r2, r7, r2
    a156:	f7ff fce9 	bl	9b2c <USBPD_DPM_SNK_EvaluateMatchWithSRCPDO>
    a15a:	0003      	movs	r3, r0
    a15c:	2b01      	cmp	r3, #1
    a15e:	d118      	bne.n	a192 <DPM_FindVoltageIndex+0xa6>
      {
        /* choose the "better" PDO, in this case only the distance in absolute value from the target voltage */
      if (allowablepower >= maxpower)
    a160:	68bb      	ldr	r3, [r7, #8]
    a162:	6aba      	ldr	r2, [r7, #40]	; 0x28
    a164:	429a      	cmp	r2, r3
    a166:	d814      	bhi.n	a192 <DPM_FindVoltageIndex+0xa6>
        {
          /* Add additional check for compatibility of this SRC PDO with port characteristics (defined in DPM_USER_Settings) */
          if (  (voltage >= puser->DPM_SNKRequestedPower.MinOperatingVoltageInmVunits)
    a168:	69fb      	ldr	r3, [r7, #28]
    a16a:	691a      	ldr	r2, [r3, #16]
    a16c:	68fb      	ldr	r3, [r7, #12]
    a16e:	429a      	cmp	r2, r3
    a170:	d80f      	bhi.n	a192 <DPM_FindVoltageIndex+0xa6>
              &&(voltage <= puser->DPM_SNKRequestedPower.MaxOperatingVoltageInmVunits)
    a172:	69fb      	ldr	r3, [r7, #28]
    a174:	68da      	ldr	r2, [r3, #12]
    a176:	68fb      	ldr	r3, [r7, #12]
    a178:	429a      	cmp	r2, r3
    a17a:	d30a      	bcc.n	a192 <DPM_FindVoltageIndex+0xa6>
              &&(allowablepower <= puser->DPM_SNKRequestedPower.MaxOperatingPowerInmWunits))
    a17c:	69fb      	ldr	r3, [r7, #28]
    a17e:	699a      	ldr	r2, [r3, #24]
    a180:	68bb      	ldr	r3, [r7, #8]
    a182:	429a      	cmp	r2, r3
    a184:	d305      	bcc.n	a192 <DPM_FindVoltageIndex+0xa6>
          {
            /* consider the current PDO the better one until now */
            curr_index = temp_index;
    a186:	6a3b      	ldr	r3, [r7, #32]
    a188:	627b      	str	r3, [r7, #36]	; 0x24
            maxpower   = allowablepower;
    a18a:	68bb      	ldr	r3, [r7, #8]
    a18c:	62bb      	str	r3, [r7, #40]	; 0x28
            reqvoltage = voltage;
    a18e:	68fb      	ldr	r3, [r7, #12]
    a190:	62fb      	str	r3, [r7, #44]	; 0x2c
  for(temp_index = 0; temp_index < nbpdo; temp_index++)
    a192:	6a3b      	ldr	r3, [r7, #32]
    a194:	3301      	adds	r3, #1
    a196:	623b      	str	r3, [r7, #32]
    a198:	6a3a      	ldr	r2, [r7, #32]
    a19a:	69bb      	ldr	r3, [r7, #24]
    a19c:	429a      	cmp	r2, r3
    a19e:	d3cb      	bcc.n	a138 <DPM_FindVoltageIndex+0x4c>
          }
        }
      }
  }

  if (curr_index != DPM_NO_SRC_PDO_FOUND)
    a1a0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    a1a2:	2bff      	cmp	r3, #255	; 0xff
    a1a4:	d01e      	beq.n	a1e4 <DPM_FindVoltageIndex+0xf8>
  {
    PtrRequestPowerDetails->MaxOperatingCurrentInmAunits = puser->DPM_SNKRequestedPower.MaxOperatingCurrentInmAunits;
    a1a6:	69fb      	ldr	r3, [r7, #28]
    a1a8:	685a      	ldr	r2, [r3, #4]
    a1aa:	683b      	ldr	r3, [r7, #0]
    a1ac:	605a      	str	r2, [r3, #4]
    PtrRequestPowerDetails->OperatingCurrentInmAunits    = (1000 * maxpower)/voltage;
    a1ae:	6aba      	ldr	r2, [r7, #40]	; 0x28
    a1b0:	0013      	movs	r3, r2
    a1b2:	015b      	lsls	r3, r3, #5
    a1b4:	1a9b      	subs	r3, r3, r2
    a1b6:	009b      	lsls	r3, r3, #2
    a1b8:	189b      	adds	r3, r3, r2
    a1ba:	00db      	lsls	r3, r3, #3
    a1bc:	001a      	movs	r2, r3
    a1be:	68fb      	ldr	r3, [r7, #12]
    a1c0:	0019      	movs	r1, r3
    a1c2:	0010      	movs	r0, r2
    a1c4:	f014 fe7e 	bl	1eec4 <__udivsi3>
    a1c8:	0003      	movs	r3, r0
    a1ca:	001a      	movs	r2, r3
    a1cc:	683b      	ldr	r3, [r7, #0]
    a1ce:	609a      	str	r2, [r3, #8]
    PtrRequestPowerDetails->MaxOperatingPowerInmWunits   = puser->DPM_SNKRequestedPower.MaxOperatingPowerInmWunits;
    a1d0:	69fb      	ldr	r3, [r7, #28]
    a1d2:	699a      	ldr	r2, [r3, #24]
    a1d4:	683b      	ldr	r3, [r7, #0]
    a1d6:	60da      	str	r2, [r3, #12]
    PtrRequestPowerDetails->OperatingPowerInmWunits      = maxpower;
    a1d8:	683b      	ldr	r3, [r7, #0]
    a1da:	6aba      	ldr	r2, [r7, #40]	; 0x28
    a1dc:	611a      	str	r2, [r3, #16]
    PtrRequestPowerDetails->RequestedVoltageInmVunits    = reqvoltage;
    a1de:	683b      	ldr	r3, [r7, #0]
    a1e0:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    a1e2:	601a      	str	r2, [r3, #0]
  }

  return curr_index;
    a1e4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
    a1e6:	0018      	movs	r0, r3
    a1e8:	46bd      	mov	sp, r7
    a1ea:	b00c      	add	sp, #48	; 0x30
    a1ec:	bd80      	pop	{r7, pc}
    a1ee:	46c0      	nop			; (mov r8, r8)
    a1f0:	0002fedc 	.word	0x0002fedc
    a1f4:	0002fffc 	.word	0x0002fffc

0000a1f8 <DPM_SNK_BuildRDOfromSelectedPDO>:
  * @param  PtrPowerObject    Pointer on the selected power object
  * @retval None
  */
void DPM_SNK_BuildRDOfromSelectedPDO(uint8_t PortNum, uint8_t IndexSrcPDO, USBPD_DPM_SNKPowerRequestDetails_TypeDef* PtrRequestPowerDetails,
                                     USBPD_SNKRDO_TypeDef* Rdo, USBPD_CORE_PDO_Type_TypeDef *PtrPowerObject)
{
    a1f8:	b5b0      	push	{r4, r5, r7, lr}
    a1fa:	b096      	sub	sp, #88	; 0x58
    a1fc:	af02      	add	r7, sp, #8
    a1fe:	60ba      	str	r2, [r7, #8]
    a200:	607b      	str	r3, [r7, #4]
    a202:	240f      	movs	r4, #15
    a204:	193b      	adds	r3, r7, r4
    a206:	1c02      	adds	r2, r0, #0
    a208:	701a      	strb	r2, [r3, #0]
    a20a:	230e      	movs	r3, #14
    a20c:	18fb      	adds	r3, r7, r3
    a20e:	1c0a      	adds	r2, r1, #0
    a210:	701a      	strb	r2, [r3, #0]
  uint32_t mv = 0, mw = 0, ma = 0, size;
    a212:	2300      	movs	r3, #0
    a214:	64fb      	str	r3, [r7, #76]	; 0x4c
    a216:	2300      	movs	r3, #0
    a218:	64bb      	str	r3, [r7, #72]	; 0x48
    a21a:	2300      	movs	r3, #0
    a21c:	647b      	str	r3, [r7, #68]	; 0x44
  USBPD_PDO_TypeDef  pdo;
  USBPD_SNKRDO_TypeDef rdo;
  USBPD_HandleTypeDef *pdhandle = &DPM_Ports[PortNum];
    a21e:	0020      	movs	r0, r4
    a220:	183b      	adds	r3, r7, r0
    a222:	781b      	ldrb	r3, [r3, #0]
    a224:	22b0      	movs	r2, #176	; 0xb0
    a226:	435a      	muls	r2, r3
    a228:	4bd5      	ldr	r3, [pc, #852]	; (a580 <DPM_SNK_BuildRDOfromSelectedPDO+0x388>)
    a22a:	18d3      	adds	r3, r2, r3
    a22c:	643b      	str	r3, [r7, #64]	; 0x40
  USBPD_USER_SettingsTypeDef *puser = (USBPD_USER_SettingsTypeDef *)&DPM_USER_Settings[PortNum];
    a22e:	183b      	adds	r3, r7, r0
    a230:	781b      	ldrb	r3, [r3, #0]
    a232:	2274      	movs	r2, #116	; 0x74
    a234:	435a      	muls	r2, r3
    a236:	4bd3      	ldr	r3, [pc, #844]	; (a584 <DPM_SNK_BuildRDOfromSelectedPDO+0x38c>)
    a238:	18d3      	adds	r3, r2, r3
    a23a:	63fb      	str	r3, [r7, #60]	; 0x3c
  uint32_t snkpdolist[USBPD_MAX_NB_PDO];
  USBPD_PDO_TypeDef snk_fixed_pdo;

  /* Initialize RDO */
  rdo.d32 = 0;
    a23c:	2300      	movs	r3, #0
    a23e:	633b      	str	r3, [r7, #48]	; 0x30

  /* Read SNK PDO list for retrieving useful data to fill in RDO */
  USBPD_PWR_IF_GetPortPDOs(PortNum, USBPD_CORE_DATATYPE_SNK_PDO, (uint8_t*)&snkpdolist[0], &size);
    a240:	2338      	movs	r3, #56	; 0x38
    a242:	18f9      	adds	r1, r7, r3
    a244:	2414      	movs	r4, #20
    a246:	193a      	adds	r2, r7, r4
    a248:	183b      	adds	r3, r7, r0
    a24a:	7818      	ldrb	r0, [r3, #0]
    a24c:	000b      	movs	r3, r1
    a24e:	2101      	movs	r1, #1
    a250:	f000 fd04 	bl	ac5c <USBPD_PWR_IF_GetPortPDOs>

  /* Store value of 1st SNK PDO (Fixed) in local variable */
  snk_fixed_pdo.d32 = snkpdolist[0];
    a254:	193b      	adds	r3, r7, r4
    a256:	681b      	ldr	r3, [r3, #0]
    a258:	613b      	str	r3, [r7, #16]

  /* Set common fields in RDO */
  pdo.d32 = pdhandle->DPM_ListOfRcvSRCPDO[0];
    a25a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    a25c:	681b      	ldr	r3, [r3, #0]
    a25e:	637b      	str	r3, [r7, #52]	; 0x34
  rdo.GenericRDO.USBCommunicationsCapable     = snk_fixed_pdo.SNKFixedPDO.USBCommunicationsCapable;
    a260:	2313      	movs	r3, #19
    a262:	18fb      	adds	r3, r7, r3
    a264:	781b      	ldrb	r3, [r3, #0]
    a266:	075b      	lsls	r3, r3, #29
    a268:	0fdb      	lsrs	r3, r3, #31
    a26a:	b2da      	uxtb	r2, r3
    a26c:	2333      	movs	r3, #51	; 0x33
    a26e:	18fb      	adds	r3, r7, r3
    a270:	2101      	movs	r1, #1
    a272:	400a      	ands	r2, r1
    a274:	1890      	adds	r0, r2, r2
    a276:	781a      	ldrb	r2, [r3, #0]
    a278:	2102      	movs	r1, #2
    a27a:	438a      	bics	r2, r1
    a27c:	1c11      	adds	r1, r2, #0
    a27e:	1c02      	adds	r2, r0, #0
    a280:	430a      	orrs	r2, r1
    a282:	701a      	strb	r2, [r3, #0]

  /* If no valid SNK PDO or if no SRC PDO match found (index>=nb of valid received SRC PDOs */
  if ((size < 1) || (IndexSrcPDO >= pdhandle->DPM_NumberOfRcvSRCPDO))
    a284:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    a286:	2b00      	cmp	r3, #0
    a288:	d006      	beq.n	a298 <DPM_SNK_BuildRDOfromSelectedPDO+0xa0>
    a28a:	230e      	movs	r3, #14
    a28c:	18fb      	adds	r3, r7, r3
    a28e:	781a      	ldrb	r2, [r3, #0]
    a290:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    a292:	69db      	ldr	r3, [r3, #28]
    a294:	429a      	cmp	r2, r3
    a296:	d35a      	bcc.n	a34e <DPM_SNK_BuildRDOfromSelectedPDO+0x156>
  {
    /* USBPD_DPM_EvaluateCapabilities: Mismatch, could not find desired pdo index */
#ifdef _TRACE
    USBPD_TRACE_Add(USBPD_TRACE_DEBUG, PortNum, 0, (uint8_t*)"DPM_SNK_BuildRDOfromSelectedPDO: Pb in SRC PDO selection", sizeof("DPM_SNK_BuildRDOfromSelectedPDO: Pb in SRC PDO selection"));
    a298:	4abb      	ldr	r2, [pc, #748]	; (a588 <DPM_SNK_BuildRDOfromSelectedPDO+0x390>)
    a29a:	250f      	movs	r5, #15
    a29c:	197b      	adds	r3, r7, r5
    a29e:	7819      	ldrb	r1, [r3, #0]
    a2a0:	2339      	movs	r3, #57	; 0x39
    a2a2:	9300      	str	r3, [sp, #0]
    a2a4:	0013      	movs	r3, r2
    a2a6:	2200      	movs	r2, #0
    a2a8:	2006      	movs	r0, #6
    a2aa:	f006 f95b 	bl	10564 <USBPD_TRACE_Add>
#endif /* _TRACE */
    rdo.FixedVariableRDO.ObjectPosition = 1;
    a2ae:	2433      	movs	r4, #51	; 0x33
    a2b0:	193b      	adds	r3, r7, r4
    a2b2:	781a      	ldrb	r2, [r3, #0]
    a2b4:	2170      	movs	r1, #112	; 0x70
    a2b6:	438a      	bics	r2, r1
    a2b8:	1c11      	adds	r1, r2, #0
    a2ba:	2210      	movs	r2, #16
    a2bc:	430a      	orrs	r2, r1
    a2be:	701a      	strb	r2, [r3, #0]
    rdo.FixedVariableRDO.OperatingCurrentIn10mAunits  = pdo.SRCFixedPDO.MaxCurrentIn10mAunits;
    a2c0:	2334      	movs	r3, #52	; 0x34
    a2c2:	18fb      	adds	r3, r7, r3
    a2c4:	881b      	ldrh	r3, [r3, #0]
    a2c6:	059b      	lsls	r3, r3, #22
    a2c8:	0d9b      	lsrs	r3, r3, #22
    a2ca:	b29b      	uxth	r3, r3
    a2cc:	059b      	lsls	r3, r3, #22
    a2ce:	0d9b      	lsrs	r3, r3, #22
    a2d0:	029b      	lsls	r3, r3, #10
    a2d2:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    a2d4:	49ad      	ldr	r1, [pc, #692]	; (a58c <DPM_SNK_BuildRDOfromSelectedPDO+0x394>)
    a2d6:	400a      	ands	r2, r1
    a2d8:	4313      	orrs	r3, r2
    a2da:	633b      	str	r3, [r7, #48]	; 0x30
    rdo.FixedVariableRDO.MaxOperatingCurrent10mAunits = puser->DPM_SNKRequestedPower.MaxOperatingCurrentInmAunits / 10;
    a2dc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    a2de:	685b      	ldr	r3, [r3, #4]
    a2e0:	210a      	movs	r1, #10
    a2e2:	0018      	movs	r0, r3
    a2e4:	f014 fdee 	bl	1eec4 <__udivsi3>
    a2e8:	0003      	movs	r3, r0
    a2ea:	059b      	lsls	r3, r3, #22
    a2ec:	0d9b      	lsrs	r3, r3, #22
    a2ee:	b29a      	uxth	r2, r3
    a2f0:	2330      	movs	r3, #48	; 0x30
    a2f2:	18fb      	adds	r3, r7, r3
    a2f4:	0592      	lsls	r2, r2, #22
    a2f6:	0d90      	lsrs	r0, r2, #22
    a2f8:	881a      	ldrh	r2, [r3, #0]
    a2fa:	0a92      	lsrs	r2, r2, #10
    a2fc:	0292      	lsls	r2, r2, #10
    a2fe:	1c11      	adds	r1, r2, #0
    a300:	1c02      	adds	r2, r0, #0
    a302:	430a      	orrs	r2, r1
    a304:	801a      	strh	r2, [r3, #0]
    rdo.FixedVariableRDO.CapabilityMismatch           = 1;
    a306:	193b      	adds	r3, r7, r4
    a308:	781a      	ldrb	r2, [r3, #0]
    a30a:	2104      	movs	r1, #4
    a30c:	430a      	orrs	r2, r1
    a30e:	701a      	strb	r2, [r3, #0]
    rdo.FixedVariableRDO.USBCommunicationsCapable     = snk_fixed_pdo.SNKFixedPDO.USBCommunicationsCapable;
    a310:	2313      	movs	r3, #19
    a312:	18fb      	adds	r3, r7, r3
    a314:	781b      	ldrb	r3, [r3, #0]
    a316:	075b      	lsls	r3, r3, #29
    a318:	0fdb      	lsrs	r3, r3, #31
    a31a:	b2da      	uxtb	r2, r3
    a31c:	193b      	adds	r3, r7, r4
    a31e:	2101      	movs	r1, #1
    a320:	400a      	ands	r2, r1
    a322:	1890      	adds	r0, r2, r2
    a324:	781a      	ldrb	r2, [r3, #0]
    a326:	2102      	movs	r1, #2
    a328:	438a      	bics	r2, r1
    a32a:	1c11      	adds	r1, r2, #0
    a32c:	1c02      	adds	r2, r0, #0
    a32e:	430a      	orrs	r2, r1
    a330:	701a      	strb	r2, [r3, #0]
    DPM_Ports[PortNum].DPM_RequestedCurrent           = puser->DPM_SNKRequestedPower.MaxOperatingCurrentInmAunits;
    a332:	197b      	adds	r3, r7, r5
    a334:	7818      	ldrb	r0, [r3, #0]
    a336:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    a338:	685a      	ldr	r2, [r3, #4]
    a33a:	4991      	ldr	r1, [pc, #580]	; (a580 <DPM_SNK_BuildRDOfromSelectedPDO+0x388>)
    a33c:	23b0      	movs	r3, #176	; 0xb0
    a33e:	4343      	muls	r3, r0
    a340:	18cb      	adds	r3, r1, r3
    a342:	3348      	adds	r3, #72	; 0x48
    a344:	601a      	str	r2, [r3, #0]
    /* USBPD_DPM_EvaluateCapabilities: Mismatch, could not find desired pdo index */

    pdhandle->DPM_RequestDOMsg = rdo.d32;
    a346:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    a348:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    a34a:	655a      	str	r2, [r3, #84]	; 0x54
    a34c:	e114      	b.n	a578 <DPM_SNK_BuildRDOfromSelectedPDO+0x380>
    return;
  }

  /* Set the Object position */
  rdo.GenericRDO.ObjectPosition               = IndexSrcPDO + 1;
    a34e:	240e      	movs	r4, #14
    a350:	193b      	adds	r3, r7, r4
    a352:	781b      	ldrb	r3, [r3, #0]
    a354:	3301      	adds	r3, #1
    a356:	b2db      	uxtb	r3, r3
    a358:	1c1a      	adds	r2, r3, #0
    a35a:	2307      	movs	r3, #7
    a35c:	4013      	ands	r3, r2
    a35e:	b2da      	uxtb	r2, r3
    a360:	2533      	movs	r5, #51	; 0x33
    a362:	197b      	adds	r3, r7, r5
    a364:	2107      	movs	r1, #7
    a366:	400a      	ands	r2, r1
    a368:	0110      	lsls	r0, r2, #4
    a36a:	781a      	ldrb	r2, [r3, #0]
    a36c:	2170      	movs	r1, #112	; 0x70
    a36e:	438a      	bics	r2, r1
    a370:	1c11      	adds	r1, r2, #0
    a372:	1c02      	adds	r2, r0, #0
    a374:	430a      	orrs	r2, r1
    a376:	701a      	strb	r2, [r3, #0]
  rdo.GenericRDO.NoUSBSuspend                 = 1;
    a378:	197b      	adds	r3, r7, r5
    a37a:	781a      	ldrb	r2, [r3, #0]
    a37c:	2101      	movs	r1, #1
    a37e:	430a      	orrs	r2, r1
    a380:	701a      	strb	r2, [r3, #0]

  /* Extract power information from Power Data Object */
  pdo.d32 = pdhandle->DPM_ListOfRcvSRCPDO[IndexSrcPDO];
    a382:	193b      	adds	r3, r7, r4
    a384:	781a      	ldrb	r2, [r3, #0]
    a386:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    a388:	0092      	lsls	r2, r2, #2
    a38a:	58d3      	ldr	r3, [r2, r3]
    a38c:	637b      	str	r3, [r7, #52]	; 0x34

  *PtrPowerObject = pdo.GenericPDO.PowerObject;
    a38e:	2137      	movs	r1, #55	; 0x37
    a390:	187b      	adds	r3, r7, r1
    a392:	781b      	ldrb	r3, [r3, #0]
    a394:	061b      	lsls	r3, r3, #24
    a396:	0f9b      	lsrs	r3, r3, #30
    a398:	b2db      	uxtb	r3, r3
    a39a:	001a      	movs	r2, r3
    a39c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
    a39e:	601a      	str	r2, [r3, #0]

  /* Retrieve request details from SRC PDO selection */
  mv = PtrRequestPowerDetails->RequestedVoltageInmVunits;
    a3a0:	68bb      	ldr	r3, [r7, #8]
    a3a2:	681b      	ldr	r3, [r3, #0]
    a3a4:	64fb      	str	r3, [r7, #76]	; 0x4c
  ma = PtrRequestPowerDetails->OperatingCurrentInmAunits;
    a3a6:	68bb      	ldr	r3, [r7, #8]
    a3a8:	689b      	ldr	r3, [r3, #8]
    a3aa:	647b      	str	r3, [r7, #68]	; 0x44

  switch(pdo.GenericPDO.PowerObject)
    a3ac:	187b      	adds	r3, r7, r1
    a3ae:	781b      	ldrb	r3, [r3, #0]
    a3b0:	061b      	lsls	r3, r3, #24
    a3b2:	0f9b      	lsrs	r3, r3, #30
    a3b4:	b2db      	uxtb	r3, r3
    a3b6:	2b01      	cmp	r3, #1
    a3b8:	d066      	beq.n	a488 <DPM_SNK_BuildRDOfromSelectedPDO+0x290>
    a3ba:	2b02      	cmp	r3, #2
    a3bc:	d002      	beq.n	a3c4 <DPM_SNK_BuildRDOfromSelectedPDO+0x1cc>
    a3be:	2b00      	cmp	r3, #0
    a3c0:	d000      	beq.n	a3c4 <DPM_SNK_BuildRDOfromSelectedPDO+0x1cc>
      }
    }
    break;

  default:
    break;
    a3c2:	e0c6      	b.n	a552 <DPM_SNK_BuildRDOfromSelectedPDO+0x35a>
      ma = USBPD_MIN(ma, puser->DPM_SNKRequestedPower.MaxOperatingCurrentInmAunits);
    a3c4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    a3c6:	685a      	ldr	r2, [r3, #4]
    a3c8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    a3ca:	4293      	cmp	r3, r2
    a3cc:	d900      	bls.n	a3d0 <DPM_SNK_BuildRDOfromSelectedPDO+0x1d8>
    a3ce:	0013      	movs	r3, r2
    a3d0:	647b      	str	r3, [r7, #68]	; 0x44
      mw = (ma * mv)/1000; /* mW */
    a3d2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    a3d4:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
    a3d6:	435a      	muls	r2, r3
    a3d8:	23fa      	movs	r3, #250	; 0xfa
    a3da:	0099      	lsls	r1, r3, #2
    a3dc:	0010      	movs	r0, r2
    a3de:	f014 fd71 	bl	1eec4 <__udivsi3>
    a3e2:	0003      	movs	r3, r0
    a3e4:	64bb      	str	r3, [r7, #72]	; 0x48
      DPM_Ports[PortNum].DPM_RequestedCurrent           = ma;
    a3e6:	230f      	movs	r3, #15
    a3e8:	18fb      	adds	r3, r7, r3
    a3ea:	781b      	ldrb	r3, [r3, #0]
    a3ec:	4a64      	ldr	r2, [pc, #400]	; (a580 <DPM_SNK_BuildRDOfromSelectedPDO+0x388>)
    a3ee:	21b0      	movs	r1, #176	; 0xb0
    a3f0:	434b      	muls	r3, r1
    a3f2:	18d3      	adds	r3, r2, r3
    a3f4:	3348      	adds	r3, #72	; 0x48
    a3f6:	6c7a      	ldr	r2, [r7, #68]	; 0x44
    a3f8:	601a      	str	r2, [r3, #0]
      rdo.FixedVariableRDO.OperatingCurrentIn10mAunits  = ma / 10;
    a3fa:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    a3fc:	210a      	movs	r1, #10
    a3fe:	0018      	movs	r0, r3
    a400:	f014 fd60 	bl	1eec4 <__udivsi3>
    a404:	0003      	movs	r3, r0
    a406:	059b      	lsls	r3, r3, #22
    a408:	0d9b      	lsrs	r3, r3, #22
    a40a:	b29b      	uxth	r3, r3
    a40c:	059b      	lsls	r3, r3, #22
    a40e:	0d9b      	lsrs	r3, r3, #22
    a410:	029b      	lsls	r3, r3, #10
    a412:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    a414:	495d      	ldr	r1, [pc, #372]	; (a58c <DPM_SNK_BuildRDOfromSelectedPDO+0x394>)
    a416:	400a      	ands	r2, r1
    a418:	4313      	orrs	r3, r2
    a41a:	633b      	str	r3, [r7, #48]	; 0x30
      rdo.FixedVariableRDO.MaxOperatingCurrent10mAunits = ma / 10;
    a41c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    a41e:	210a      	movs	r1, #10
    a420:	0018      	movs	r0, r3
    a422:	f014 fd4f 	bl	1eec4 <__udivsi3>
    a426:	0003      	movs	r3, r0
    a428:	059b      	lsls	r3, r3, #22
    a42a:	0d9b      	lsrs	r3, r3, #22
    a42c:	b29a      	uxth	r2, r3
    a42e:	2330      	movs	r3, #48	; 0x30
    a430:	18fb      	adds	r3, r7, r3
    a432:	0592      	lsls	r2, r2, #22
    a434:	0d90      	lsrs	r0, r2, #22
    a436:	881a      	ldrh	r2, [r3, #0]
    a438:	0a92      	lsrs	r2, r2, #10
    a43a:	0292      	lsls	r2, r2, #10
    a43c:	1c11      	adds	r1, r2, #0
    a43e:	1c02      	adds	r2, r0, #0
    a440:	430a      	orrs	r2, r1
    a442:	801a      	strh	r2, [r3, #0]
      if(mw < puser->DPM_SNKRequestedPower.OperatingPowerInmWunits)
    a444:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    a446:	695b      	ldr	r3, [r3, #20]
    a448:	6cba      	ldr	r2, [r7, #72]	; 0x48
    a44a:	429a      	cmp	r2, r3
    a44c:	d300      	bcc.n	a450 <DPM_SNK_BuildRDOfromSelectedPDO+0x258>
    a44e:	e07d      	b.n	a54c <DPM_SNK_BuildRDOfromSelectedPDO+0x354>
        rdo.FixedVariableRDO.MaxOperatingCurrent10mAunits = puser->DPM_SNKRequestedPower.MaxOperatingCurrentInmAunits / 10;
    a450:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    a452:	685b      	ldr	r3, [r3, #4]
    a454:	210a      	movs	r1, #10
    a456:	0018      	movs	r0, r3
    a458:	f014 fd34 	bl	1eec4 <__udivsi3>
    a45c:	0003      	movs	r3, r0
    a45e:	059b      	lsls	r3, r3, #22
    a460:	0d9b      	lsrs	r3, r3, #22
    a462:	b29a      	uxth	r2, r3
    a464:	2330      	movs	r3, #48	; 0x30
    a466:	18fb      	adds	r3, r7, r3
    a468:	0592      	lsls	r2, r2, #22
    a46a:	0d90      	lsrs	r0, r2, #22
    a46c:	881a      	ldrh	r2, [r3, #0]
    a46e:	0a92      	lsrs	r2, r2, #10
    a470:	0292      	lsls	r2, r2, #10
    a472:	1c11      	adds	r1, r2, #0
    a474:	1c02      	adds	r2, r0, #0
    a476:	430a      	orrs	r2, r1
    a478:	801a      	strh	r2, [r3, #0]
        rdo.FixedVariableRDO.CapabilityMismatch = 1;
    a47a:	2333      	movs	r3, #51	; 0x33
    a47c:	18fb      	adds	r3, r7, r3
    a47e:	781a      	ldrb	r2, [r3, #0]
    a480:	2104      	movs	r1, #4
    a482:	430a      	orrs	r2, r1
    a484:	701a      	strb	r2, [r3, #0]
    break;
    a486:	e061      	b.n	a54c <DPM_SNK_BuildRDOfromSelectedPDO+0x354>
      mw = USBPD_MIN(PtrRequestPowerDetails->OperatingPowerInmWunits, puser->DPM_SNKRequestedPower.MaxOperatingPowerInmWunits); /* mW */
    a488:	68bb      	ldr	r3, [r7, #8]
    a48a:	6919      	ldr	r1, [r3, #16]
    a48c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    a48e:	699a      	ldr	r2, [r3, #24]
    a490:	000b      	movs	r3, r1
    a492:	4293      	cmp	r3, r2
    a494:	d900      	bls.n	a498 <DPM_SNK_BuildRDOfromSelectedPDO+0x2a0>
    a496:	0013      	movs	r3, r2
    a498:	64bb      	str	r3, [r7, #72]	; 0x48
      ma = (1000 * mw) / mv; /* mA */
    a49a:	6cba      	ldr	r2, [r7, #72]	; 0x48
    a49c:	0013      	movs	r3, r2
    a49e:	015b      	lsls	r3, r3, #5
    a4a0:	1a9b      	subs	r3, r3, r2
    a4a2:	009b      	lsls	r3, r3, #2
    a4a4:	189b      	adds	r3, r3, r2
    a4a6:	00db      	lsls	r3, r3, #3
    a4a8:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
    a4aa:	0018      	movs	r0, r3
    a4ac:	f014 fd0a 	bl	1eec4 <__udivsi3>
    a4b0:	0003      	movs	r3, r0
    a4b2:	647b      	str	r3, [r7, #68]	; 0x44
      ma = USBPD_MIN(ma, puser->DPM_SNKRequestedPower.MaxOperatingCurrentInmAunits);
    a4b4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    a4b6:	685a      	ldr	r2, [r3, #4]
    a4b8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    a4ba:	4293      	cmp	r3, r2
    a4bc:	d900      	bls.n	a4c0 <DPM_SNK_BuildRDOfromSelectedPDO+0x2c8>
    a4be:	0013      	movs	r3, r2
    a4c0:	647b      	str	r3, [r7, #68]	; 0x44
      DPM_Ports[PortNum].DPM_RequestedCurrent       = ma;
    a4c2:	230f      	movs	r3, #15
    a4c4:	18fb      	adds	r3, r7, r3
    a4c6:	781b      	ldrb	r3, [r3, #0]
    a4c8:	4a2d      	ldr	r2, [pc, #180]	; (a580 <DPM_SNK_BuildRDOfromSelectedPDO+0x388>)
    a4ca:	21b0      	movs	r1, #176	; 0xb0
    a4cc:	434b      	muls	r3, r1
    a4ce:	18d3      	adds	r3, r2, r3
    a4d0:	3348      	adds	r3, #72	; 0x48
    a4d2:	6c7a      	ldr	r2, [r7, #68]	; 0x44
    a4d4:	601a      	str	r2, [r3, #0]
      mw = (ma * mv)/1000; /* mW */
    a4d6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    a4d8:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
    a4da:	435a      	muls	r2, r3
    a4dc:	23fa      	movs	r3, #250	; 0xfa
    a4de:	0099      	lsls	r1, r3, #2
    a4e0:	0010      	movs	r0, r2
    a4e2:	f014 fcef 	bl	1eec4 <__udivsi3>
    a4e6:	0003      	movs	r3, r0
    a4e8:	64bb      	str	r3, [r7, #72]	; 0x48
      rdo.BatteryRDO.OperatingPowerIn250mWunits     = mw / 250;
    a4ea:	6cbb      	ldr	r3, [r7, #72]	; 0x48
    a4ec:	21fa      	movs	r1, #250	; 0xfa
    a4ee:	0018      	movs	r0, r3
    a4f0:	f014 fce8 	bl	1eec4 <__udivsi3>
    a4f4:	0003      	movs	r3, r0
    a4f6:	059b      	lsls	r3, r3, #22
    a4f8:	0d9b      	lsrs	r3, r3, #22
    a4fa:	b29b      	uxth	r3, r3
    a4fc:	059b      	lsls	r3, r3, #22
    a4fe:	0d9b      	lsrs	r3, r3, #22
    a500:	029b      	lsls	r3, r3, #10
    a502:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    a504:	4921      	ldr	r1, [pc, #132]	; (a58c <DPM_SNK_BuildRDOfromSelectedPDO+0x394>)
    a506:	400a      	ands	r2, r1
    a508:	4313      	orrs	r3, r2
    a50a:	633b      	str	r3, [r7, #48]	; 0x30
      rdo.BatteryRDO.MaxOperatingPowerIn250mWunits  = mw / 250;
    a50c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
    a50e:	21fa      	movs	r1, #250	; 0xfa
    a510:	0018      	movs	r0, r3
    a512:	f014 fcd7 	bl	1eec4 <__udivsi3>
    a516:	0003      	movs	r3, r0
    a518:	059b      	lsls	r3, r3, #22
    a51a:	0d9b      	lsrs	r3, r3, #22
    a51c:	b29a      	uxth	r2, r3
    a51e:	2330      	movs	r3, #48	; 0x30
    a520:	18fb      	adds	r3, r7, r3
    a522:	0592      	lsls	r2, r2, #22
    a524:	0d90      	lsrs	r0, r2, #22
    a526:	881a      	ldrh	r2, [r3, #0]
    a528:	0a92      	lsrs	r2, r2, #10
    a52a:	0292      	lsls	r2, r2, #10
    a52c:	1c11      	adds	r1, r2, #0
    a52e:	1c02      	adds	r2, r0, #0
    a530:	430a      	orrs	r2, r1
    a532:	801a      	strh	r2, [r3, #0]
      if(mw < puser->DPM_SNKRequestedPower.OperatingPowerInmWunits)
    a534:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    a536:	695b      	ldr	r3, [r3, #20]
    a538:	6cba      	ldr	r2, [r7, #72]	; 0x48
    a53a:	429a      	cmp	r2, r3
    a53c:	d208      	bcs.n	a550 <DPM_SNK_BuildRDOfromSelectedPDO+0x358>
        rdo.BatteryRDO.CapabilityMismatch = 1;
    a53e:	2333      	movs	r3, #51	; 0x33
    a540:	18fb      	adds	r3, r7, r3
    a542:	781a      	ldrb	r2, [r3, #0]
    a544:	2104      	movs	r1, #4
    a546:	430a      	orrs	r2, r1
    a548:	701a      	strb	r2, [r3, #0]
    break;
    a54a:	e001      	b.n	a550 <DPM_SNK_BuildRDOfromSelectedPDO+0x358>
    break;
    a54c:	46c0      	nop			; (mov r8, r8)
    a54e:	e000      	b.n	a552 <DPM_SNK_BuildRDOfromSelectedPDO+0x35a>
    break;
    a550:	46c0      	nop			; (mov r8, r8)
  }

  pdhandle->DPM_RequestDOMsg = rdo.d32;
    a552:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    a554:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    a556:	655a      	str	r2, [r3, #84]	; 0x54
  pdhandle->DPM_RDOPosition  = rdo.GenericRDO.ObjectPosition;
    a558:	2333      	movs	r3, #51	; 0x33
    a55a:	18fb      	adds	r3, r7, r3
    a55c:	781b      	ldrb	r3, [r3, #0]
    a55e:	065b      	lsls	r3, r3, #25
    a560:	0f5b      	lsrs	r3, r3, #29
    a562:	b2db      	uxtb	r3, r3
    a564:	001a      	movs	r2, r3
    a566:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    a568:	641a      	str	r2, [r3, #64]	; 0x40

  Rdo->d32 = pdhandle->DPM_RequestDOMsg;
    a56a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    a56c:	6d5a      	ldr	r2, [r3, #84]	; 0x54
    a56e:	687b      	ldr	r3, [r7, #4]
    a570:	601a      	str	r2, [r3, #0]
  /* Get the requested voltage */
  pdhandle->DPM_RequestedVoltage = mv;
    a572:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    a574:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
    a576:	645a      	str	r2, [r3, #68]	; 0x44
}
    a578:	46bd      	mov	sp, r7
    a57a:	b014      	add	sp, #80	; 0x50
    a57c:	bdb0      	pop	{r4, r5, r7, pc}
    a57e:	46c0      	nop			; (mov r8, r8)
    a580:	0002fffc 	.word	0x0002fffc
    a584:	0002fedc 	.word	0x0002fedc
    a588:	0001f234 	.word	0x0001f234
    a58c:	fff003ff 	.word	0xfff003ff

0000a590 <DPM_TurnOffPower>:
  * @param  PortNum The current port number
  * @param  Role    Port power role
  * @retval USBPD_OK, USBPD_ERROR
  */
static USBPD_StatusTypeDef DPM_TurnOffPower(uint8_t PortNum, USBPD_PortPowerRole_TypeDef Role)
{
    a590:	b5b0      	push	{r4, r5, r7, lr}
    a592:	b084      	sub	sp, #16
    a594:	af00      	add	r7, sp, #0
    a596:	0002      	movs	r2, r0
    a598:	6039      	str	r1, [r7, #0]
    a59a:	1dfb      	adds	r3, r7, #7
    a59c:	701a      	strb	r2, [r3, #0]
  USBPD_StatusTypeDef status = USBPD_OK;
    a59e:	250f      	movs	r5, #15
    a5a0:	197b      	adds	r3, r7, r5
    a5a2:	2200      	movs	r2, #0
    a5a4:	701a      	strb	r2, [r3, #0]

  status = USBPD_PWR_IF_VBUSDisable(PortNum);
    a5a6:	197c      	adds	r4, r7, r5
    a5a8:	1dfb      	adds	r3, r7, #7
    a5aa:	781b      	ldrb	r3, [r3, #0]
    a5ac:	0018      	movs	r0, r3
    a5ae:	f000 fa89 	bl	aac4 <USBPD_PWR_IF_VBUSDisable>
    a5b2:	0003      	movs	r3, r0
    a5b4:	7023      	strb	r3, [r4, #0]
  return status;
    a5b6:	197b      	adds	r3, r7, r5
    a5b8:	781b      	ldrb	r3, [r3, #0]
}
    a5ba:	0018      	movs	r0, r3
    a5bc:	46bd      	mov	sp, r7
    a5be:	b004      	add	sp, #16
    a5c0:	bdb0      	pop	{r4, r5, r7, pc}

0000a5c2 <DPM_TurnOnPower>:
  * @param  PortNum The current port number
  * @param  Role    Port power role
  * @retval USBPD_ACCEPT, USBPD_WAIT, USBPD_REJECT
  */
static USBPD_StatusTypeDef DPM_TurnOnPower(uint8_t PortNum, USBPD_PortPowerRole_TypeDef Role)
{
    a5c2:	b5b0      	push	{r4, r5, r7, lr}
    a5c4:	b084      	sub	sp, #16
    a5c6:	af00      	add	r7, sp, #0
    a5c8:	0002      	movs	r2, r0
    a5ca:	6039      	str	r1, [r7, #0]
    a5cc:	1dfb      	adds	r3, r7, #7
    a5ce:	701a      	strb	r2, [r3, #0]
  USBPD_StatusTypeDef status = USBPD_OK;
    a5d0:	250f      	movs	r5, #15
    a5d2:	197b      	adds	r3, r7, r5
    a5d4:	2200      	movs	r2, #0
    a5d6:	701a      	strb	r2, [r3, #0]
  /* Enable the output */
  status = USBPD_PWR_IF_VBUSEnable(PortNum);
    a5d8:	197c      	adds	r4, r7, r5
    a5da:	1dfb      	adds	r3, r7, #7
    a5dc:	781b      	ldrb	r3, [r3, #0]
    a5de:	0018      	movs	r0, r3
    a5e0:	f000 fa02 	bl	a9e8 <USBPD_PWR_IF_VBUSEnable>
    a5e4:	0003      	movs	r3, r0
    a5e6:	7023      	strb	r3, [r4, #0]

  return status;
    a5e8:	197b      	adds	r3, r7, r5
    a5ea:	781b      	ldrb	r3, [r3, #0]
}
    a5ec:	0018      	movs	r0, r3
    a5ee:	46bd      	mov	sp, r7
    a5f0:	b004      	add	sp, #16
    a5f2:	bdb0      	pop	{r4, r5, r7, pc}

0000a5f4 <DPM_AssertRp>:
  * @brief  Assert Rp resistor.
  * @param  PortNum The current port number
  * @retval None
  */
static void DPM_AssertRp(uint8_t PortNum)
{
    a5f4:	b580      	push	{r7, lr}
    a5f6:	b082      	sub	sp, #8
    a5f8:	af00      	add	r7, sp, #0
    a5fa:	0002      	movs	r2, r0
    a5fc:	1dfb      	adds	r3, r7, #7
    a5fe:	701a      	strb	r2, [r3, #0]
  USBPD_TCPM_set_cc(PortNum, TYPEC_CC_RP, USBPD_ENABLE);
    a600:	1dfb      	adds	r3, r7, #7
    a602:	781b      	ldrb	r3, [r3, #0]
    a604:	2201      	movs	r2, #1
    a606:	2101      	movs	r1, #1
    a608:	0018      	movs	r0, r3
    a60a:	f013 fc2d 	bl	1de68 <USBPD_TCPM_set_cc>

}
    a60e:	46c0      	nop			; (mov r8, r8)
    a610:	46bd      	mov	sp, r7
    a612:	b002      	add	sp, #8
    a614:	bd80      	pop	{r7, pc}

0000a616 <DPM_AssertRd>:
  * @brief  Assert Rd resistor.
  * @param  PortNum The current port number
  * @retval None
  */
static void DPM_AssertRd(uint8_t PortNum)
{
    a616:	b580      	push	{r7, lr}
    a618:	b082      	sub	sp, #8
    a61a:	af00      	add	r7, sp, #0
    a61c:	0002      	movs	r2, r0
    a61e:	1dfb      	adds	r3, r7, #7
    a620:	701a      	strb	r2, [r3, #0]
  USBPD_TCPM_set_cc(PortNum, TYPEC_CC_RD, USBPD_ENABLE);
    a622:	1dfb      	adds	r3, r7, #7
    a624:	781b      	ldrb	r3, [r3, #0]
    a626:	2201      	movs	r2, #1
    a628:	2102      	movs	r1, #2
    a62a:	0018      	movs	r0, r3
    a62c:	f013 fc1c 	bl	1de68 <USBPD_TCPM_set_cc>

}
    a630:	46c0      	nop			; (mov r8, r8)
    a632:	46bd      	mov	sp, r7
    a634:	b002      	add	sp, #8
    a636:	bd80      	pop	{r7, pc}

0000a638 <CheckDPMTimers>:
#endif /* _TRACE */
    }
  }
}
static uint32_t CheckDPMTimers(void)
{
    a638:	b580      	push	{r7, lr}
    a63a:	b084      	sub	sp, #16
    a63c:	af00      	add	r7, sp, #0
  uint32_t _timing = osWaitForever;
    a63e:	2301      	movs	r3, #1
    a640:	425b      	negs	r3, r3
    a642:	60fb      	str	r3, [r7, #12]
  uint32_t _current_timing;

  /* Calculate the minimum timers to wake-up DPM tasks */
  for(uint8_t instance = 0; instance < USBPD_PORT_COUNT; instance++)
    a644:	230b      	movs	r3, #11
    a646:	18fb      	adds	r3, r7, r3
    a648:	2200      	movs	r2, #0
    a64a:	701a      	strb	r2, [r3, #0]
    a64c:	e01c      	b.n	a688 <CheckDPMTimers+0x50>
  {
    _current_timing = DPM_Ports[instance].DPM_TimerAlert & DPM_TIMER_READ_MSK;
    a64e:	230b      	movs	r3, #11
    a650:	18fb      	adds	r3, r7, r3
    a652:	781b      	ldrb	r3, [r3, #0]
    a654:	4a11      	ldr	r2, [pc, #68]	; (a69c <CheckDPMTimers+0x64>)
    a656:	218a      	movs	r1, #138	; 0x8a
    a658:	20b0      	movs	r0, #176	; 0xb0
    a65a:	4343      	muls	r3, r0
    a65c:	18d3      	adds	r3, r2, r3
    a65e:	185b      	adds	r3, r3, r1
    a660:	881b      	ldrh	r3, [r3, #0]
    a662:	b29b      	uxth	r3, r3
    a664:	045b      	lsls	r3, r3, #17
    a666:	0c5b      	lsrs	r3, r3, #17
    a668:	607b      	str	r3, [r7, #4]
    if(_current_timing > 0)
    a66a:	687b      	ldr	r3, [r7, #4]
    a66c:	2b00      	cmp	r3, #0
    a66e:	d005      	beq.n	a67c <CheckDPMTimers+0x44>
    {
      if (_current_timing < _timing)
    a670:	687a      	ldr	r2, [r7, #4]
    a672:	68fb      	ldr	r3, [r7, #12]
    a674:	429a      	cmp	r2, r3
    a676:	d201      	bcs.n	a67c <CheckDPMTimers+0x44>
      {
        _timing = _current_timing;
    a678:	687b      	ldr	r3, [r7, #4]
    a67a:	60fb      	str	r3, [r7, #12]
  for(uint8_t instance = 0; instance < USBPD_PORT_COUNT; instance++)
    a67c:	210b      	movs	r1, #11
    a67e:	187b      	adds	r3, r7, r1
    a680:	781a      	ldrb	r2, [r3, #0]
    a682:	187b      	adds	r3, r7, r1
    a684:	3201      	adds	r2, #1
    a686:	701a      	strb	r2, [r3, #0]
    a688:	230b      	movs	r3, #11
    a68a:	18fb      	adds	r3, r7, r3
    a68c:	781b      	ldrb	r3, [r3, #0]
    a68e:	2b00      	cmp	r3, #0
    a690:	d0dd      	beq.n	a64e <CheckDPMTimers+0x16>
      }
    }
  }
  return _timing;
    a692:	68fb      	ldr	r3, [r7, #12]
}
    a694:	0018      	movs	r0, r3
    a696:	46bd      	mov	sp, r7
    a698:	b004      	add	sp, #16
    a69a:	bd80      	pop	{r7, pc}
    a69c:	0002fffc 	.word	0x0002fffc

0000a6a0 <DPM_ManageAlert>:
/**
  * @brief  Manage the ALERT.
  * @retval none
  */
void DPM_ManageAlert(void)
{
    a6a0:	b590      	push	{r4, r7, lr}
    a6a2:	b083      	sub	sp, #12
    a6a4:	af00      	add	r7, sp, #0
  for(uint8_t _instance = 0; _instance < USBPD_PORT_COUNT; _instance++)
    a6a6:	1dfb      	adds	r3, r7, #7
    a6a8:	2200      	movs	r2, #0
    a6aa:	701a      	strb	r2, [r3, #0]
    a6ac:	e09d      	b.n	a7ea <DPM_ManageAlert+0x14a>
  {
    /* check if Alert timer is expired */
    if (DPM_TIMER_ENABLE_MSK == DPM_Ports[_instance].DPM_TimerAlert)
    a6ae:	1dfb      	adds	r3, r7, #7
    a6b0:	781b      	ldrb	r3, [r3, #0]
    a6b2:	4a52      	ldr	r2, [pc, #328]	; (a7fc <DPM_ManageAlert+0x15c>)
    a6b4:	218a      	movs	r1, #138	; 0x8a
    a6b6:	20b0      	movs	r0, #176	; 0xb0
    a6b8:	4343      	muls	r3, r0
    a6ba:	18d3      	adds	r3, r2, r3
    a6bc:	185b      	adds	r3, r3, r1
    a6be:	881b      	ldrh	r3, [r3, #0]
    a6c0:	b29a      	uxth	r2, r3
    a6c2:	2380      	movs	r3, #128	; 0x80
    a6c4:	021b      	lsls	r3, r3, #8
    a6c6:	429a      	cmp	r2, r3
    a6c8:	d000      	beq.n	a6cc <DPM_ManageAlert+0x2c>
    a6ca:	e089      	b.n	a7e0 <DPM_ManageAlert+0x140>
    {
      /* Restart alert timer */
      DPM_START_TIMER(_instance, DPM_TimerAlert, DPM_TIMER_ALERT);
    a6cc:	1dfb      	adds	r3, r7, #7
    a6ce:	781b      	ldrb	r3, [r3, #0]
    a6d0:	4a4a      	ldr	r2, [pc, #296]	; (a7fc <DPM_ManageAlert+0x15c>)
    a6d2:	218a      	movs	r1, #138	; 0x8a
    a6d4:	20b0      	movs	r0, #176	; 0xb0
    a6d6:	4343      	muls	r3, r0
    a6d8:	18d3      	adds	r3, r2, r3
    a6da:	185b      	adds	r3, r3, r1
    a6dc:	4a48      	ldr	r2, [pc, #288]	; (a800 <DPM_ManageAlert+0x160>)
    a6de:	801a      	strh	r2, [r3, #0]
    a6e0:	4b48      	ldr	r3, [pc, #288]	; (a804 <DPM_ManageAlert+0x164>)
    a6e2:	681b      	ldr	r3, [r3, #0]
    a6e4:	2200      	movs	r2, #0
    a6e6:	2100      	movs	r1, #0
    a6e8:	0018      	movs	r0, r3
    a6ea:	f006 f9a5 	bl	10a38 <osMessagePut>
      DPM_Ports[_instance].DPM_MeasuredCurrent = HW_IF_PWR_GetCurrent(_instance);
    a6ee:	1dfb      	adds	r3, r7, #7
    a6f0:	781c      	ldrb	r4, [r3, #0]
    a6f2:	1dfb      	adds	r3, r7, #7
    a6f4:	781b      	ldrb	r3, [r3, #0]
    a6f6:	0018      	movs	r0, r3
    a6f8:	f003 fe0c 	bl	e314 <HW_IF_PWR_GetCurrent>
    a6fc:	0003      	movs	r3, r0
    a6fe:	0018      	movs	r0, r3
    a700:	4a3e      	ldr	r2, [pc, #248]	; (a7fc <DPM_ManageAlert+0x15c>)
    a702:	214c      	movs	r1, #76	; 0x4c
    a704:	23b0      	movs	r3, #176	; 0xb0
    a706:	4363      	muls	r3, r4
    a708:	18d3      	adds	r3, r2, r3
    a70a:	185b      	adds	r3, r3, r1
    a70c:	1c02      	adds	r2, r0, #0
    a70e:	801a      	strh	r2, [r3, #0]
      if (DPM_Ports[_instance].DPM_MeasuredCurrent > 3600)
    a710:	1dfb      	adds	r3, r7, #7
    a712:	781b      	ldrb	r3, [r3, #0]
    a714:	4a39      	ldr	r2, [pc, #228]	; (a7fc <DPM_ManageAlert+0x15c>)
    a716:	214c      	movs	r1, #76	; 0x4c
    a718:	20b0      	movs	r0, #176	; 0xb0
    a71a:	4343      	muls	r3, r0
    a71c:	18d3      	adds	r3, r2, r3
    a71e:	185b      	adds	r3, r3, r1
    a720:	2200      	movs	r2, #0
    a722:	5e9a      	ldrsh	r2, [r3, r2]
    a724:	23e1      	movs	r3, #225	; 0xe1
    a726:	011b      	lsls	r3, r3, #4
    a728:	429a      	cmp	r2, r3
    a72a:	dd05      	ble.n	a738 <DPM_ManageAlert+0x98>
      {
        USBPD_DPM_RequestHardReset(_instance);
    a72c:	1dfb      	adds	r3, r7, #7
    a72e:	781b      	ldrb	r3, [r3, #0]
    a730:	0018      	movs	r0, r3
    a732:	f7fe ff32 	bl	959a <USBPD_DPM_RequestHardReset>
    a736:	e053      	b.n	a7e0 <DPM_ManageAlert+0x140>
      }
      else
      {
        if (DPM_Ports[_instance].DPM_MeasuredCurrent > 3400)
    a738:	1dfb      	adds	r3, r7, #7
    a73a:	781b      	ldrb	r3, [r3, #0]
    a73c:	4a2f      	ldr	r2, [pc, #188]	; (a7fc <DPM_ManageAlert+0x15c>)
    a73e:	214c      	movs	r1, #76	; 0x4c
    a740:	20b0      	movs	r0, #176	; 0xb0
    a742:	4343      	muls	r3, r0
    a744:	18d3      	adds	r3, r2, r3
    a746:	185b      	adds	r3, r3, r1
    a748:	2200      	movs	r2, #0
    a74a:	5e9b      	ldrsh	r3, [r3, r2]
    a74c:	4a2e      	ldr	r2, [pc, #184]	; (a808 <DPM_ManageAlert+0x168>)
    a74e:	4293      	cmp	r3, r2
    a750:	dd30      	ble.n	a7b4 <DPM_ManageAlert+0x114>
        {
          if (0 == (DPM_Ports[_instance].DPM_SendAlert.b.TypeAlert & USBPD_ADO_TYPE_ALERT_OCP))
    a752:	1dfb      	adds	r3, r7, #7
    a754:	781b      	ldrb	r3, [r3, #0]
    a756:	4a29      	ldr	r2, [pc, #164]	; (a7fc <DPM_ManageAlert+0x15c>)
    a758:	218f      	movs	r1, #143	; 0x8f
    a75a:	20b0      	movs	r0, #176	; 0xb0
    a75c:	4343      	muls	r3, r0
    a75e:	18d3      	adds	r3, r2, r3
    a760:	185b      	adds	r3, r3, r1
    a762:	781b      	ldrb	r3, [r3, #0]
    a764:	001a      	movs	r2, r3
    a766:	2304      	movs	r3, #4
    a768:	4013      	ands	r3, r2
    a76a:	d139      	bne.n	a7e0 <DPM_ManageAlert+0x140>
          {
            USBPD_ADO_TypeDef alert = {0};
    a76c:	2300      	movs	r3, #0
    a76e:	603b      	str	r3, [r7, #0]
            alert.b.TypeAlert = USBPD_ADO_TYPE_ALERT_OCP;
    a770:	003b      	movs	r3, r7
    a772:	2204      	movs	r2, #4
    a774:	70da      	strb	r2, [r3, #3]
            USBPD_DPM_RequestAlert(_instance, alert);
    a776:	683a      	ldr	r2, [r7, #0]
    a778:	1dfb      	adds	r3, r7, #7
    a77a:	781b      	ldrb	r3, [r3, #0]
    a77c:	0011      	movs	r1, r2
    a77e:	0018      	movs	r0, r3
    a780:	f7ff f911 	bl	99a6 <USBPD_DPM_RequestAlert>
            DPM_Ports[_instance].DPM_SendAlert.b.TypeAlert |= alert.b.TypeAlert;
    a784:	1dfb      	adds	r3, r7, #7
    a786:	781b      	ldrb	r3, [r3, #0]
    a788:	4a1c      	ldr	r2, [pc, #112]	; (a7fc <DPM_ManageAlert+0x15c>)
    a78a:	218f      	movs	r1, #143	; 0x8f
    a78c:	20b0      	movs	r0, #176	; 0xb0
    a78e:	4343      	muls	r3, r0
    a790:	18d3      	adds	r3, r2, r3
    a792:	185b      	adds	r3, r3, r1
    a794:	7819      	ldrb	r1, [r3, #0]
    a796:	003b      	movs	r3, r7
    a798:	78da      	ldrb	r2, [r3, #3]
    a79a:	1dfb      	adds	r3, r7, #7
    a79c:	781b      	ldrb	r3, [r3, #0]
    a79e:	430a      	orrs	r2, r1
    a7a0:	b2d4      	uxtb	r4, r2
    a7a2:	4a16      	ldr	r2, [pc, #88]	; (a7fc <DPM_ManageAlert+0x15c>)
    a7a4:	218f      	movs	r1, #143	; 0x8f
    a7a6:	20b0      	movs	r0, #176	; 0xb0
    a7a8:	4343      	muls	r3, r0
    a7aa:	18d3      	adds	r3, r2, r3
    a7ac:	185b      	adds	r3, r3, r1
    a7ae:	1c22      	adds	r2, r4, #0
    a7b0:	701a      	strb	r2, [r3, #0]
    a7b2:	e015      	b.n	a7e0 <DPM_ManageAlert+0x140>
          }
        }
        else
        {
          /* Reset of the OCP bit */
          DPM_Ports[_instance].DPM_SendAlert.b.TypeAlert &= ~USBPD_ADO_TYPE_ALERT_OCP;
    a7b4:	1dfb      	adds	r3, r7, #7
    a7b6:	781b      	ldrb	r3, [r3, #0]
    a7b8:	4a10      	ldr	r2, [pc, #64]	; (a7fc <DPM_ManageAlert+0x15c>)
    a7ba:	218f      	movs	r1, #143	; 0x8f
    a7bc:	20b0      	movs	r0, #176	; 0xb0
    a7be:	4343      	muls	r3, r0
    a7c0:	18d3      	adds	r3, r2, r3
    a7c2:	185b      	adds	r3, r3, r1
    a7c4:	781a      	ldrb	r2, [r3, #0]
    a7c6:	1dfb      	adds	r3, r7, #7
    a7c8:	781b      	ldrb	r3, [r3, #0]
    a7ca:	2104      	movs	r1, #4
    a7cc:	438a      	bics	r2, r1
    a7ce:	b2d4      	uxtb	r4, r2
    a7d0:	4a0a      	ldr	r2, [pc, #40]	; (a7fc <DPM_ManageAlert+0x15c>)
    a7d2:	218f      	movs	r1, #143	; 0x8f
    a7d4:	20b0      	movs	r0, #176	; 0xb0
    a7d6:	4343      	muls	r3, r0
    a7d8:	18d3      	adds	r3, r2, r3
    a7da:	185b      	adds	r3, r3, r1
    a7dc:	1c22      	adds	r2, r4, #0
    a7de:	701a      	strb	r2, [r3, #0]
  for(uint8_t _instance = 0; _instance < USBPD_PORT_COUNT; _instance++)
    a7e0:	1dfb      	adds	r3, r7, #7
    a7e2:	781a      	ldrb	r2, [r3, #0]
    a7e4:	1dfb      	adds	r3, r7, #7
    a7e6:	3201      	adds	r2, #1
    a7e8:	701a      	strb	r2, [r3, #0]
    a7ea:	1dfb      	adds	r3, r7, #7
    a7ec:	781b      	ldrb	r3, [r3, #0]
    a7ee:	2b00      	cmp	r3, #0
    a7f0:	d100      	bne.n	a7f4 <DPM_ManageAlert+0x154>
    a7f2:	e75c      	b.n	a6ae <DPM_ManageAlert+0xe>
        }
      }
    }
  }
}
    a7f4:	46c0      	nop			; (mov r8, r8)
    a7f6:	46bd      	mov	sp, r7
    a7f8:	b003      	add	sp, #12
    a7fa:	bd90      	pop	{r4, r7, pc}
    a7fc:	0002fffc 	.word	0x0002fffc
    a800:	ffff8064 	.word	0xffff8064
    a804:	0003213c 	.word	0x0003213c
    a808:	00000d48 	.word	0x00000d48

0000a80c <USBPD_PWR_IF_Init>:
  * @brief  Initialize structures and variables related to power board profiles
  *         used by Sink and Source, for all available ports.
  * @retval USBPD status
*/
USBPD_StatusTypeDef USBPD_PWR_IF_Init(void)
{
    a80c:	b580      	push	{r7, lr}
    a80e:	b082      	sub	sp, #8
    a810:	af00      	add	r7, sp, #0
/* USER CODE BEGIN USBPD_PWR_IF_Init */
  USBPD_StatusTypeDef _status = USBPD_OK;
    a812:	1dfb      	adds	r3, r7, #7
    a814:	2200      	movs	r2, #0
    a816:	701a      	strb	r2, [r3, #0]

  /* Set links to PDO values and number for Port 0 (defined in PDO arrays in H file).
   */
  PWR_Port_PDO_Storage[USBPD_PORT_0].SourcePDO.ListOfPDO = (uint32_t *) PORT0_PDO_ListSRC;
    a818:	4b0f      	ldr	r3, [pc, #60]	; (a858 <USBPD_PWR_IF_Init+0x4c>)
    a81a:	4a10      	ldr	r2, [pc, #64]	; (a85c <USBPD_PWR_IF_Init+0x50>)
    a81c:	601a      	str	r2, [r3, #0]
  PWR_Port_PDO_Storage[USBPD_PORT_0].SourcePDO.NumberOfPDO = &USBPD_NbPDO[1];
    a81e:	4b0e      	ldr	r3, [pc, #56]	; (a858 <USBPD_PWR_IF_Init+0x4c>)
    a820:	4a0f      	ldr	r2, [pc, #60]	; (a860 <USBPD_PWR_IF_Init+0x54>)
    a822:	605a      	str	r2, [r3, #4]

  PWR_Port_PDO_Storage[USBPD_PORT_0].SinkPDO.ListOfPDO = (uint32_t *)PORT0_PDO_ListSNK;
    a824:	4b0c      	ldr	r3, [pc, #48]	; (a858 <USBPD_PWR_IF_Init+0x4c>)
    a826:	4a0f      	ldr	r2, [pc, #60]	; (a864 <USBPD_PWR_IF_Init+0x58>)
    a828:	609a      	str	r2, [r3, #8]
  PWR_Port_PDO_Storage[USBPD_PORT_0].SinkPDO.NumberOfPDO = &USBPD_NbPDO[0];
    a82a:	4b0b      	ldr	r3, [pc, #44]	; (a858 <USBPD_PWR_IF_Init+0x4c>)
    a82c:	4a0e      	ldr	r2, [pc, #56]	; (a868 <USBPD_PWR_IF_Init+0x5c>)
    a82e:	60da      	str	r2, [r3, #12]
  _status |= USBPD_PWR_IF_CheckUpdateSNKPower(USBPD_PORT_0);
    a830:	2000      	movs	r0, #0
    a832:	f000 fae5 	bl	ae00 <USBPD_PWR_IF_CheckUpdateSNKPower>
    a836:	0003      	movs	r3, r0
    a838:	0019      	movs	r1, r3
    a83a:	1dfb      	adds	r3, r7, #7
    a83c:	1dfa      	adds	r2, r7, #7
    a83e:	7812      	ldrb	r2, [r2, #0]
    a840:	430a      	orrs	r2, r1
    a842:	701a      	strb	r2, [r3, #0]


  /* Add consistency check on PDO definition 
     Could help to detect unexpected flash settings content */
  _PWR_CheckPDOContent(USBPD_PORT_0);
    a844:	2000      	movs	r0, #0
    a846:	f000 fc45 	bl	b0d4 <_PWR_CheckPDOContent>
#if USBPD_PORT_COUNT == 2
  _PWR_CheckPDOContent(USBPD_PORT_1);
#endif /* USBPD_PORT_COUNT == 2 */

  return _status;
    a84a:	1dfb      	adds	r3, r7, #7
    a84c:	781b      	ldrb	r3, [r3, #0]
/* USER CODE END USBPD_PWR_IF_Init */
}
    a84e:	0018      	movs	r0, r3
    a850:	46bd      	mov	sp, r7
    a852:	b002      	add	sp, #8
    a854:	bd80      	pop	{r7, pc}
    a856:	46c0      	nop			; (mov r8, r8)
    a858:	00032140 	.word	0x00032140
    a85c:	0002fe24 	.word	0x0002fe24
    a860:	0002fe21 	.word	0x0002fe21
    a864:	0002fe40 	.word	0x0002fe40
    a868:	0002fe20 	.word	0x0002fe20

0000a86c <USBPD_PWR_IF_SetProfile>:
  * @param  Profile          Number of the required Power Data Objects
  * @param  PreviousPowerProfile  Number of the previous required Power Data Objects
  * @retval USBPD status
  */
USBPD_StatusTypeDef USBPD_PWR_IF_SetProfile(uint8_t PortNum, uint8_t Profile, uint8_t PreviousPowerProfile)
{
    a86c:	b590      	push	{r4, r7, lr}
    a86e:	b087      	sub	sp, #28
    a870:	af00      	add	r7, sp, #0
    a872:	0004      	movs	r4, r0
    a874:	0008      	movs	r0, r1
    a876:	0011      	movs	r1, r2
    a878:	1dfb      	adds	r3, r7, #7
    a87a:	1c22      	adds	r2, r4, #0
    a87c:	701a      	strb	r2, [r3, #0]
    a87e:	1dbb      	adds	r3, r7, #6
    a880:	1c02      	adds	r2, r0, #0
    a882:	701a      	strb	r2, [r3, #0]
    a884:	1d7b      	adds	r3, r7, #5
    a886:	1c0a      	adds	r2, r1, #0
    a888:	701a      	strb	r2, [r3, #0]
/* USER CODE BEGIN USBPD_PWR_IF_SetProfile */
  uint32_t vbusTargetInmv;
  USBPD_PDO_TypeDef pdo;
  uint32_t origine;
  USBPD_StatusTypeDef      ret = USBPD_OK;
    a88a:	2317      	movs	r3, #23
    a88c:	18fb      	adds	r3, r7, r3
    a88e:	2200      	movs	r2, #0
    a890:	701a      	strb	r2, [r3, #0]

  /* Check if valid port */
  if ( !USBPD_PORT_IsValid(PortNum) )
    a892:	1dfb      	adds	r3, r7, #7
    a894:	781b      	ldrb	r3, [r3, #0]
    a896:	2b00      	cmp	r3, #0
    a898:	d001      	beq.n	a89e <USBPD_PWR_IF_SetProfile+0x32>
  {
    return USBPD_ERROR;
    a89a:	2302      	movs	r3, #2
    a89c:	e067      	b.n	a96e <USBPD_PWR_IF_SetProfile+0x102>
  }

  /* Check if profile nb is valid for this port */
  /* SRC Mode */
  if (USBPD_PORTPOWERROLE_SRC == DPM_Params[PortNum].PE_PowerRole)
    a89e:	1dfb      	adds	r3, r7, #7
    a8a0:	781a      	ldrb	r2, [r3, #0]
    a8a2:	4b35      	ldr	r3, [pc, #212]	; (a978 <USBPD_PWR_IF_SetProfile+0x10c>)
    a8a4:	0092      	lsls	r2, r2, #2
    a8a6:	5cd3      	ldrb	r3, [r2, r3]
    a8a8:	075b      	lsls	r3, r3, #29
    a8aa:	0fdb      	lsrs	r3, r3, #31
    a8ac:	b2db      	uxtb	r3, r3
    a8ae:	2b01      	cmp	r3, #1
    a8b0:	d15a      	bne.n	a968 <USBPD_PWR_IF_SetProfile+0xfc>
  {
    if (Profile >= *PWR_Port_PDO_Storage[PortNum].SourcePDO.NumberOfPDO)
    a8b2:	1dfb      	adds	r3, r7, #7
    a8b4:	781b      	ldrb	r3, [r3, #0]
    a8b6:	4a31      	ldr	r2, [pc, #196]	; (a97c <USBPD_PWR_IF_SetProfile+0x110>)
    a8b8:	011b      	lsls	r3, r3, #4
    a8ba:	18d3      	adds	r3, r2, r3
    a8bc:	3304      	adds	r3, #4
    a8be:	681b      	ldr	r3, [r3, #0]
    a8c0:	781b      	ldrb	r3, [r3, #0]
    a8c2:	1dba      	adds	r2, r7, #6
    a8c4:	7812      	ldrb	r2, [r2, #0]
    a8c6:	429a      	cmp	r2, r3
    a8c8:	d301      	bcc.n	a8ce <USBPD_PWR_IF_SetProfile+0x62>
    {
      return USBPD_ERROR;
    a8ca:	2302      	movs	r3, #2
    a8cc:	e04f      	b.n	a96e <USBPD_PWR_IF_SetProfile+0x102>
    }
    if (0 == *PWR_Port_PDO_Storage[PortNum].SourcePDO.NumberOfPDO)
    a8ce:	1dfb      	adds	r3, r7, #7
    a8d0:	781b      	ldrb	r3, [r3, #0]
    a8d2:	4a2a      	ldr	r2, [pc, #168]	; (a97c <USBPD_PWR_IF_SetProfile+0x110>)
    a8d4:	011b      	lsls	r3, r3, #4
    a8d6:	18d3      	adds	r3, r2, r3
    a8d8:	3304      	adds	r3, #4
    a8da:	681b      	ldr	r3, [r3, #0]
    a8dc:	781b      	ldrb	r3, [r3, #0]
    a8de:	2b00      	cmp	r3, #0
    a8e0:	d101      	bne.n	a8e6 <USBPD_PWR_IF_SetProfile+0x7a>
    {
      return USBPD_ERROR;
    a8e2:	2302      	movs	r3, #2
    a8e4:	e043      	b.n	a96e <USBPD_PWR_IF_SetProfile+0x102>
    }
    pdo.d32 = PWR_Port_PDO_Storage[PortNum].SourcePDO.ListOfPDO[Profile];
    a8e6:	1dfb      	adds	r3, r7, #7
    a8e8:	781a      	ldrb	r2, [r3, #0]
    a8ea:	4b24      	ldr	r3, [pc, #144]	; (a97c <USBPD_PWR_IF_SetProfile+0x110>)
    a8ec:	0112      	lsls	r2, r2, #4
    a8ee:	58d2      	ldr	r2, [r2, r3]
    a8f0:	1dbb      	adds	r3, r7, #6
    a8f2:	781b      	ldrb	r3, [r3, #0]
    a8f4:	009b      	lsls	r3, r3, #2
    a8f6:	18d3      	adds	r3, r2, r3
    a8f8:	681b      	ldr	r3, [r3, #0]
    a8fa:	60bb      	str	r3, [r7, #8]

    {
      /* Case PDO is a fixed type */
      if (pdo.GenericPDO.PowerObject == USBPD_PDO_TYPE_FIXED)
    a8fc:	230b      	movs	r3, #11
    a8fe:	18fb      	adds	r3, r7, r3
    a900:	781b      	ldrb	r3, [r3, #0]
    a902:	223f      	movs	r2, #63	; 0x3f
    a904:	4393      	bics	r3, r2
    a906:	b2db      	uxtb	r3, r3
    a908:	2b00      	cmp	r3, #0
    a90a:	d110      	bne.n	a92e <USBPD_PWR_IF_SetProfile+0xc2>
      {
        vbusTargetInmv = (pdo.SRCFixedPDO.VoltageIn50mVunits * 50);
    a90c:	68bb      	ldr	r3, [r7, #8]
    a90e:	031b      	lsls	r3, r3, #12
    a910:	0d9b      	lsrs	r3, r3, #22
    a912:	b29b      	uxth	r3, r3
    a914:	001a      	movs	r2, r3
    a916:	2332      	movs	r3, #50	; 0x32
    a918:	4353      	muls	r3, r2
    a91a:	613b      	str	r3, [r7, #16]
      else
      {
        return USBPD_ERROR;
      }
    }
    if (USBPD_ENABLE == USBPD_PWR_IF_VBUSIsEnabled(PortNum))
    a91c:	1dfb      	adds	r3, r7, #7
    a91e:	781b      	ldrb	r3, [r3, #0]
    a920:	0018      	movs	r0, r3
    a922:	f000 f91d 	bl	ab60 <USBPD_PWR_IF_VBUSIsEnabled>
    a926:	0003      	movs	r3, r0
    a928:	2b01      	cmp	r3, #1
    a92a:	d116      	bne.n	a95a <USBPD_PWR_IF_SetProfile+0xee>
    a92c:	e001      	b.n	a932 <USBPD_PWR_IF_SetProfile+0xc6>
        return USBPD_ERROR;
    a92e:	2302      	movs	r3, #2
    a930:	e01d      	b.n	a96e <USBPD_PWR_IF_SetProfile+0x102>
    {
      /* We ask for 100mV precision */
      origine = HW_IF_PWR_GetVoltage(PortNum);
    a932:	1dfb      	adds	r3, r7, #7
    a934:	781b      	ldrb	r3, [r3, #0]
    a936:	0018      	movs	r0, r3
    a938:	f003 fcdc 	bl	e2f4 <HW_IF_PWR_GetVoltage>
    a93c:	0003      	movs	r3, r0
    a93e:	60fb      	str	r3, [r7, #12]
      if (origine != vbusTargetInmv)
    a940:	68fa      	ldr	r2, [r7, #12]
    a942:	693b      	ldr	r3, [r7, #16]
    a944:	429a      	cmp	r2, r3
    a946:	d00f      	beq.n	a968 <USBPD_PWR_IF_SetProfile+0xfc>
      {
          HW_IF_PWR_SetVoltage(PortNum, vbusTargetInmv);
    a948:	693b      	ldr	r3, [r7, #16]
    a94a:	b29a      	uxth	r2, r3
    a94c:	1dfb      	adds	r3, r7, #7
    a94e:	781b      	ldrb	r3, [r3, #0]
    a950:	0011      	movs	r1, r2
    a952:	0018      	movs	r0, r3
    a954:	f003 fcc0 	bl	e2d8 <HW_IF_PWR_SetVoltage>
    a958:	e006      	b.n	a968 <USBPD_PWR_IF_SetProfile+0xfc>
      }
    }
    else  /* USBPD_DISABLE */
    {
      HW_IF_PWR_SetVoltage(PortNum, 5000);
    a95a:	4a09      	ldr	r2, [pc, #36]	; (a980 <USBPD_PWR_IF_SetProfile+0x114>)
    a95c:	1dfb      	adds	r3, r7, #7
    a95e:	781b      	ldrb	r3, [r3, #0]
    a960:	0011      	movs	r1, r2
    a962:	0018      	movs	r0, r3
    a964:	f003 fcb8 	bl	e2d8 <HW_IF_PWR_SetVoltage>
    }
  }
  return ret;
    a968:	2317      	movs	r3, #23
    a96a:	18fb      	adds	r3, r7, r3
    a96c:	781b      	ldrb	r3, [r3, #0]
/* USER CODE END USBPD_PWR_IF_SetProfile */
}
    a96e:	0018      	movs	r0, r3
    a970:	46bd      	mov	sp, r7
    a972:	b007      	add	sp, #28
    a974:	bd90      	pop	{r4, r7, pc}
    a976:	46c0      	nop			; (mov r8, r8)
    a978:	000321d4 	.word	0x000321d4
    a97c:	00032140 	.word	0x00032140
    a980:	00001388 	.word	0x00001388

0000a984 <USBPD_PWR_IF_SupplyReady>:
  * @param  PortNum Port number
  * @param  Vsafe   Vsafe status based on @ref USBPD_VSAFE_StatusTypeDef
  * @retval USBPD status
  */
USBPD_StatusTypeDef USBPD_PWR_IF_SupplyReady(uint8_t PortNum, USBPD_VSAFE_StatusTypeDef Vsafe)
{
    a984:	b590      	push	{r4, r7, lr}
    a986:	b085      	sub	sp, #20
    a988:	af00      	add	r7, sp, #0
    a98a:	0002      	movs	r2, r0
    a98c:	1dfb      	adds	r3, r7, #7
    a98e:	701a      	strb	r2, [r3, #0]
    a990:	1dbb      	adds	r3, r7, #6
    a992:	1c0a      	adds	r2, r1, #0
    a994:	701a      	strb	r2, [r3, #0]
/* USER CODE BEGIN USBPD_PWR_IF_SupplyReady */
  USBPD_StatusTypeDef status = USBPD_ERROR;
    a996:	230f      	movs	r3, #15
    a998:	18fb      	adds	r3, r7, r3
    a99a:	2202      	movs	r2, #2
    a99c:	701a      	strb	r2, [r3, #0]

  /* check for valid port */
  if (!USBPD_PORT_IsValid(PortNum))
    a99e:	1dfb      	adds	r3, r7, #7
    a9a0:	781b      	ldrb	r3, [r3, #0]
    a9a2:	2b00      	cmp	r3, #0
    a9a4:	d001      	beq.n	a9aa <USBPD_PWR_IF_SupplyReady+0x26>
  {
    return USBPD_ERROR;
    a9a6:	2302      	movs	r3, #2
    a9a8:	e019      	b.n	a9de <USBPD_PWR_IF_SupplyReady+0x5a>
  }

  if (USBPD_VSAFE_0V == Vsafe)
    a9aa:	1dbb      	adds	r3, r7, #6
    a9ac:	781b      	ldrb	r3, [r3, #0]
    a9ae:	2b00      	cmp	r3, #0
    a9b0:	d109      	bne.n	a9c6 <USBPD_PWR_IF_SupplyReady+0x42>
  {
    /* Vsafe0V */
    status = USBPD_TCPM_VBUS_IsVsafe0V(PortNum);
    a9b2:	1dfb      	adds	r3, r7, #7
    a9b4:	781b      	ldrb	r3, [r3, #0]
    a9b6:	220f      	movs	r2, #15
    a9b8:	18bc      	adds	r4, r7, r2
    a9ba:	0018      	movs	r0, r3
    a9bc:	f013 fa74 	bl	1dea8 <USBPD_TCPM_VBUS_IsVsafe0V>
    a9c0:	0003      	movs	r3, r0
    a9c2:	7023      	strb	r3, [r4, #0]
    a9c4:	e008      	b.n	a9d8 <USBPD_PWR_IF_SupplyReady+0x54>
  }
  else
  {
    /* Vsafe5V */
    status = USBPD_TCPM_VBUS_IsVsafe5V(PortNum);
    a9c6:	1dfb      	adds	r3, r7, #7
    a9c8:	781b      	ldrb	r3, [r3, #0]
    a9ca:	220f      	movs	r2, #15
    a9cc:	18bc      	adds	r4, r7, r2
    a9ce:	0018      	movs	r0, r3
    a9d0:	f013 fa82 	bl	1ded8 <USBPD_TCPM_VBUS_IsVsafe5V>
    a9d4:	0003      	movs	r3, r0
    a9d6:	7023      	strb	r3, [r4, #0]
  }
  return status;
    a9d8:	230f      	movs	r3, #15
    a9da:	18fb      	adds	r3, r7, r3
    a9dc:	781b      	ldrb	r3, [r3, #0]
/* USER CODE END USBPD_PWR_IF_SupplyReady */
}
    a9de:	0018      	movs	r0, r3
    a9e0:	46bd      	mov	sp, r7
    a9e2:	b005      	add	sp, #20
    a9e4:	bd90      	pop	{r4, r7, pc}
	...

0000a9e8 <USBPD_PWR_IF_VBUSEnable>:
  * @brief  Enables VBUS power on a specified port
  * @param  PortNum Port number
  * @retval USBPD status
  */
USBPD_StatusTypeDef USBPD_PWR_IF_VBUSEnable(uint8_t PortNum)
{
    a9e8:	b5b0      	push	{r4, r5, r7, lr}
    a9ea:	b08a      	sub	sp, #40	; 0x28
    a9ec:	af02      	add	r7, sp, #8
    a9ee:	0002      	movs	r2, r0
    a9f0:	1dfb      	adds	r3, r7, #7
    a9f2:	701a      	strb	r2, [r3, #0]
/* USER CODE BEGIN USBPD_PWR_IF_VBUSEnable */
  USBPD_StatusTypeDef _status = USBPD_ERROR;
    a9f4:	231f      	movs	r3, #31
    a9f6:	18fb      	adds	r3, r7, r3
    a9f8:	2202      	movs	r2, #2
    a9fa:	701a      	strb	r2, [r3, #0]
  
  /* check for valid port */
  if (USBPD_PORT_IsValid(PortNum))
    a9fc:	1dfb      	adds	r3, r7, #7
    a9fe:	781b      	ldrb	r3, [r3, #0]
    aa00:	2b00      	cmp	r3, #0
    aa02:	d151      	bne.n	aaa8 <USBPD_PWR_IF_VBUSEnable+0xc0>
  {
    POWER_IF_TRACE(PortNum, "EN_VBUS", 7);
    aa04:	4a2c      	ldr	r2, [pc, #176]	; (aab8 <USBPD_PWR_IF_VBUSEnable+0xd0>)
    aa06:	1dfb      	adds	r3, r7, #7
    aa08:	7819      	ldrb	r1, [r3, #0]
    aa0a:	2307      	movs	r3, #7
    aa0c:	9300      	str	r3, [sp, #0]
    aa0e:	0013      	movs	r3, r2
    aa10:	2200      	movs	r2, #0
    aa12:	2006      	movs	r0, #6
    aa14:	f005 fda6 	bl	10564 <USBPD_TRACE_Add>
    /* Set the new state */
#if defined(_TRACE)
    char str[20];
    sprintf(str, "CC:%d VCONN:%d", DPM_Params[PortNum].VconnCCIs, DPM_Params[PortNum].VconnStatus);
    aa18:	1dfb      	adds	r3, r7, #7
    aa1a:	781b      	ldrb	r3, [r3, #0]
    aa1c:	4a27      	ldr	r2, [pc, #156]	; (aabc <USBPD_PWR_IF_VBUSEnable+0xd4>)
    aa1e:	009b      	lsls	r3, r3, #2
    aa20:	18d3      	adds	r3, r2, r3
    aa22:	785b      	ldrb	r3, [r3, #1]
    aa24:	065b      	lsls	r3, r3, #25
    aa26:	0f9b      	lsrs	r3, r3, #30
    aa28:	b2db      	uxtb	r3, r3
    aa2a:	001c      	movs	r4, r3
    aa2c:	1dfb      	adds	r3, r7, #7
    aa2e:	781b      	ldrb	r3, [r3, #0]
    aa30:	4a22      	ldr	r2, [pc, #136]	; (aabc <USBPD_PWR_IF_VBUSEnable+0xd4>)
    aa32:	009b      	lsls	r3, r3, #2
    aa34:	18d3      	adds	r3, r2, r3
    aa36:	785b      	ldrb	r3, [r3, #1]
    aa38:	061b      	lsls	r3, r3, #24
    aa3a:	0fdb      	lsrs	r3, r3, #31
    aa3c:	b2db      	uxtb	r3, r3
    aa3e:	4920      	ldr	r1, [pc, #128]	; (aac0 <USBPD_PWR_IF_VBUSEnable+0xd8>)
    aa40:	2508      	movs	r5, #8
    aa42:	1978      	adds	r0, r7, r5
    aa44:	0022      	movs	r2, r4
    aa46:	f013 fef1 	bl	1e82c <siprintf>
    POWER_IF_TRACE(PortNum, (uint8_t*)str, strlen(str));
    aa4a:	002c      	movs	r4, r5
    aa4c:	193b      	adds	r3, r7, r4
    aa4e:	0018      	movs	r0, r3
    aa50:	f013 ff0c 	bl	1e86c <strlen>
    aa54:	193a      	adds	r2, r7, r4
    aa56:	1dfb      	adds	r3, r7, #7
    aa58:	7819      	ldrb	r1, [r3, #0]
    aa5a:	9000      	str	r0, [sp, #0]
    aa5c:	0013      	movs	r3, r2
    aa5e:	2200      	movs	r2, #0
    aa60:	2006      	movs	r0, #6
    aa62:	f005 fd7f 	bl	10564 <USBPD_TRACE_Add>
#endif /* _TRACE */
    _status = (USBPD_StatusTypeDef)HW_IF_PWR_Enable(PortNum, USBPD_ENABLE, DPM_Params[PortNum].VconnCCIs, DPM_Params[PortNum].VconnStatus, USBPD_PORTPOWERROLE_SRC);
    aa66:	1dfb      	adds	r3, r7, #7
    aa68:	781b      	ldrb	r3, [r3, #0]
    aa6a:	4a14      	ldr	r2, [pc, #80]	; (aabc <USBPD_PWR_IF_VBUSEnable+0xd4>)
    aa6c:	009b      	lsls	r3, r3, #2
    aa6e:	18d3      	adds	r3, r2, r3
    aa70:	785b      	ldrb	r3, [r3, #1]
    aa72:	065b      	lsls	r3, r3, #25
    aa74:	0f9b      	lsrs	r3, r3, #30
    aa76:	b2db      	uxtb	r3, r3
    aa78:	0019      	movs	r1, r3
    aa7a:	1dfb      	adds	r3, r7, #7
    aa7c:	781b      	ldrb	r3, [r3, #0]
    aa7e:	4a0f      	ldr	r2, [pc, #60]	; (aabc <USBPD_PWR_IF_VBUSEnable+0xd4>)
    aa80:	009b      	lsls	r3, r3, #2
    aa82:	18d3      	adds	r3, r2, r3
    aa84:	785b      	ldrb	r3, [r3, #1]
    aa86:	061b      	lsls	r3, r3, #24
    aa88:	0fdb      	lsrs	r3, r3, #31
    aa8a:	b2db      	uxtb	r3, r3
    aa8c:	001a      	movs	r2, r3
    aa8e:	231f      	movs	r3, #31
    aa90:	18fc      	adds	r4, r7, r3
    aa92:	1dfb      	adds	r3, r7, #7
    aa94:	7818      	ldrb	r0, [r3, #0]
    aa96:	2301      	movs	r3, #1
    aa98:	9300      	str	r3, [sp, #0]
    aa9a:	0013      	movs	r3, r2
    aa9c:	000a      	movs	r2, r1
    aa9e:	2101      	movs	r1, #1
    aaa0:	f003 fc44 	bl	e32c <HW_IF_PWR_Enable>
    aaa4:	0003      	movs	r3, r0
    aaa6:	7023      	strb	r3, [r4, #0]
  }
  return _status;
    aaa8:	231f      	movs	r3, #31
    aaaa:	18fb      	adds	r3, r7, r3
    aaac:	781b      	ldrb	r3, [r3, #0]
/* USER CODE END USBPD_PWR_IF_VBUSEnable */
}
    aaae:	0018      	movs	r0, r3
    aab0:	46bd      	mov	sp, r7
    aab2:	b008      	add	sp, #32
    aab4:	bdb0      	pop	{r4, r5, r7, pc}
    aab6:	46c0      	nop			; (mov r8, r8)
    aab8:	0001f334 	.word	0x0001f334
    aabc:	000321d4 	.word	0x000321d4
    aac0:	0001f33c 	.word	0x0001f33c

0000aac4 <USBPD_PWR_IF_VBUSDisable>:
  * @brief  Disbale VBUS/VCONN the power on a specified port
  * @param  PortNum Port number
  * @retval USBPD status
  */
USBPD_StatusTypeDef USBPD_PWR_IF_VBUSDisable(uint8_t PortNum)
{
    aac4:	b590      	push	{r4, r7, lr}
    aac6:	b087      	sub	sp, #28
    aac8:	af02      	add	r7, sp, #8
    aaca:	0002      	movs	r2, r0
    aacc:	1dfb      	adds	r3, r7, #7
    aace:	701a      	strb	r2, [r3, #0]
/* USER CODE BEGIN USBPD_PWR_IF_VBUSDisable */
  USBPD_StatusTypeDef _status = USBPD_ERROR;
    aad0:	230f      	movs	r3, #15
    aad2:	18fb      	adds	r3, r7, r3
    aad4:	2202      	movs	r2, #2
    aad6:	701a      	strb	r2, [r3, #0]
  
  /* check for valid port */
  if (USBPD_PORT_IsValid(PortNum))
    aad8:	1dfb      	adds	r3, r7, #7
    aada:	781b      	ldrb	r3, [r3, #0]
    aadc:	2b00      	cmp	r3, #0
    aade:	d133      	bne.n	ab48 <USBPD_PWR_IF_VBUSDisable+0x84>
  {
    POWER_IF_TRACE(PortNum, "DIS VBUS", 8);
    aae0:	4a1d      	ldr	r2, [pc, #116]	; (ab58 <USBPD_PWR_IF_VBUSDisable+0x94>)
    aae2:	1dfb      	adds	r3, r7, #7
    aae4:	7819      	ldrb	r1, [r3, #0]
    aae6:	2308      	movs	r3, #8
    aae8:	9300      	str	r3, [sp, #0]
    aaea:	0013      	movs	r3, r2
    aaec:	2200      	movs	r2, #0
    aaee:	2006      	movs	r0, #6
    aaf0:	f005 fd38 	bl	10564 <USBPD_TRACE_Add>
    /* Set the new state */
    _status = (USBPD_StatusTypeDef)HW_IF_PWR_Enable(PortNum, USBPD_DISABLE, DPM_Params[PortNum].VconnCCIs, DPM_Params[PortNum].VconnStatus, USBPD_PORTPOWERROLE_SRC);
    aaf4:	1dfb      	adds	r3, r7, #7
    aaf6:	781b      	ldrb	r3, [r3, #0]
    aaf8:	4a18      	ldr	r2, [pc, #96]	; (ab5c <USBPD_PWR_IF_VBUSDisable+0x98>)
    aafa:	009b      	lsls	r3, r3, #2
    aafc:	18d3      	adds	r3, r2, r3
    aafe:	785b      	ldrb	r3, [r3, #1]
    ab00:	065b      	lsls	r3, r3, #25
    ab02:	0f9b      	lsrs	r3, r3, #30
    ab04:	b2db      	uxtb	r3, r3
    ab06:	0019      	movs	r1, r3
    ab08:	1dfb      	adds	r3, r7, #7
    ab0a:	781b      	ldrb	r3, [r3, #0]
    ab0c:	4a13      	ldr	r2, [pc, #76]	; (ab5c <USBPD_PWR_IF_VBUSDisable+0x98>)
    ab0e:	009b      	lsls	r3, r3, #2
    ab10:	18d3      	adds	r3, r2, r3
    ab12:	785b      	ldrb	r3, [r3, #1]
    ab14:	061b      	lsls	r3, r3, #24
    ab16:	0fdb      	lsrs	r3, r3, #31
    ab18:	b2db      	uxtb	r3, r3
    ab1a:	001a      	movs	r2, r3
    ab1c:	230f      	movs	r3, #15
    ab1e:	18fc      	adds	r4, r7, r3
    ab20:	1dfb      	adds	r3, r7, #7
    ab22:	7818      	ldrb	r0, [r3, #0]
    ab24:	2301      	movs	r3, #1
    ab26:	9300      	str	r3, [sp, #0]
    ab28:	0013      	movs	r3, r2
    ab2a:	000a      	movs	r2, r1
    ab2c:	2100      	movs	r1, #0
    ab2e:	f003 fbfd 	bl	e32c <HW_IF_PWR_Enable>
    ab32:	0003      	movs	r3, r0
    ab34:	7023      	strb	r3, [r4, #0]
    DPM_Params[PortNum].VconnStatus = USBPD_FALSE;
    ab36:	1dfb      	adds	r3, r7, #7
    ab38:	781b      	ldrb	r3, [r3, #0]
    ab3a:	4a08      	ldr	r2, [pc, #32]	; (ab5c <USBPD_PWR_IF_VBUSDisable+0x98>)
    ab3c:	009b      	lsls	r3, r3, #2
    ab3e:	18d3      	adds	r3, r2, r3
    ab40:	785a      	ldrb	r2, [r3, #1]
    ab42:	217f      	movs	r1, #127	; 0x7f
    ab44:	400a      	ands	r2, r1
    ab46:	705a      	strb	r2, [r3, #1]
  }
  return _status;
    ab48:	230f      	movs	r3, #15
    ab4a:	18fb      	adds	r3, r7, r3
    ab4c:	781b      	ldrb	r3, [r3, #0]
/* USER CODE END USBPD_PWR_IF_VBUSDisable */
}
    ab4e:	0018      	movs	r0, r3
    ab50:	46bd      	mov	sp, r7
    ab52:	b005      	add	sp, #20
    ab54:	bd90      	pop	{r4, r7, pc}
    ab56:	46c0      	nop			; (mov r8, r8)
    ab58:	0001f34c 	.word	0x0001f34c
    ab5c:	000321d4 	.word	0x000321d4

0000ab60 <USBPD_PWR_IF_VBUSIsEnabled>:
  * @brief  Checks if the power on a specified port is enabled
  * @param  PortNum Port number
  * @retval USBPD_ENABLE or USBPD_DISABLE
  */
USBPD_FunctionalState USBPD_PWR_IF_VBUSIsEnabled(uint8_t PortNum)
{
    ab60:	b580      	push	{r7, lr}
    ab62:	b082      	sub	sp, #8
    ab64:	af00      	add	r7, sp, #0
    ab66:	0002      	movs	r2, r0
    ab68:	1dfb      	adds	r3, r7, #7
    ab6a:	701a      	strb	r2, [r3, #0]
  /* Get the Status of the port */
  return USBPD_PORT_IsValid(PortNum) ? (USBPD_FunctionalState)HW_IF_PWR_VBUSIsEnabled(PortNum) : USBPD_DISABLE;
    ab6c:	1dfb      	adds	r3, r7, #7
    ab6e:	781b      	ldrb	r3, [r3, #0]
    ab70:	2b00      	cmp	r3, #0
    ab72:	d106      	bne.n	ab82 <USBPD_PWR_IF_VBUSIsEnabled+0x22>
    ab74:	1dfb      	adds	r3, r7, #7
    ab76:	781b      	ldrb	r3, [r3, #0]
    ab78:	0018      	movs	r0, r3
    ab7a:	f003 fc4b 	bl	e414 <HW_IF_PWR_VBUSIsEnabled>
    ab7e:	0003      	movs	r3, r0
    ab80:	e000      	b.n	ab84 <USBPD_PWR_IF_VBUSIsEnabled+0x24>
    ab82:	2300      	movs	r3, #0
}
    ab84:	0018      	movs	r0, r3
    ab86:	46bd      	mov	sp, r7
    ab88:	b002      	add	sp, #8
    ab8a:	bd80      	pop	{r7, pc}

0000ab8c <USBPD_PWR_IF_Enable_VConn>:
  * @param  PortNum Port number
  * @param  CC      Specifies the CCx to be selected based on @ref CCxPin_TypeDef structure
  * @retval USBPD status
  */
USBPD_StatusTypeDef USBPD_PWR_IF_Enable_VConn(uint8_t PortNum, CCxPin_TypeDef CC)
{
    ab8c:	b590      	push	{r4, r7, lr}
    ab8e:	b087      	sub	sp, #28
    ab90:	af02      	add	r7, sp, #8
    ab92:	0002      	movs	r2, r0
    ab94:	6039      	str	r1, [r7, #0]
    ab96:	1dfb      	adds	r3, r7, #7
    ab98:	701a      	strb	r2, [r3, #0]
/* USER CODE BEGIN USBPD_PWR_IF_Enable_VConn */
  USBPD_StatusTypeDef _status = USBPD_OK;
    ab9a:	240f      	movs	r4, #15
    ab9c:	193b      	adds	r3, r7, r4
    ab9e:	2200      	movs	r2, #0
    aba0:	701a      	strb	r2, [r3, #0]
  POWER_IF_TRACE(PortNum, "VCONN ON", 8);
    aba2:	4a12      	ldr	r2, [pc, #72]	; (abec <USBPD_PWR_IF_Enable_VConn+0x60>)
    aba4:	1dfb      	adds	r3, r7, #7
    aba6:	7819      	ldrb	r1, [r3, #0]
    aba8:	2308      	movs	r3, #8
    abaa:	9300      	str	r3, [sp, #0]
    abac:	0013      	movs	r3, r2
    abae:	2200      	movs	r2, #0
    abb0:	2006      	movs	r0, #6
    abb2:	f005 fcd7 	bl	10564 <USBPD_TRACE_Add>
  USBPD_TCPM_set_vconn(PortNum, USBPD_ENABLE);
    abb6:	1dfb      	adds	r3, r7, #7
    abb8:	781b      	ldrb	r3, [r3, #0]
    abba:	2101      	movs	r1, #1
    abbc:	0018      	movs	r0, r3
    abbe:	f013 fb61 	bl	1e284 <USBPD_TCPM_set_vconn>
  if(USBPD_OK == _status)
    abc2:	193b      	adds	r3, r7, r4
    abc4:	781b      	ldrb	r3, [r3, #0]
    abc6:	2b00      	cmp	r3, #0
    abc8:	d109      	bne.n	abde <USBPD_PWR_IF_Enable_VConn+0x52>
  {
    DPM_Params[PortNum].VconnStatus = USBPD_TRUE;
    abca:	1dfb      	adds	r3, r7, #7
    abcc:	781b      	ldrb	r3, [r3, #0]
    abce:	4a08      	ldr	r2, [pc, #32]	; (abf0 <USBPD_PWR_IF_Enable_VConn+0x64>)
    abd0:	009b      	lsls	r3, r3, #2
    abd2:	18d3      	adds	r3, r2, r3
    abd4:	785a      	ldrb	r2, [r3, #1]
    abd6:	2180      	movs	r1, #128	; 0x80
    abd8:	4249      	negs	r1, r1
    abda:	430a      	orrs	r2, r1
    abdc:	705a      	strb	r2, [r3, #1]
  }
  return _status;
    abde:	230f      	movs	r3, #15
    abe0:	18fb      	adds	r3, r7, r3
    abe2:	781b      	ldrb	r3, [r3, #0]
/* USER CODE END USBPD_PWR_IF_Enable_VConn */
}
    abe4:	0018      	movs	r0, r3
    abe6:	46bd      	mov	sp, r7
    abe8:	b005      	add	sp, #20
    abea:	bd90      	pop	{r4, r7, pc}
    abec:	0001f358 	.word	0x0001f358
    abf0:	000321d4 	.word	0x000321d4

0000abf4 <USBPD_PWR_IF_Disable_VConn>:
  * @param  PortNum Port number
  * @param  CC      Specifies the CCx to be selected based on @ref CCxPin_TypeDef structure
  * @retval USBPD status
  */
USBPD_StatusTypeDef USBPD_PWR_IF_Disable_VConn(uint8_t PortNum, CCxPin_TypeDef CC)
{
    abf4:	b590      	push	{r4, r7, lr}
    abf6:	b087      	sub	sp, #28
    abf8:	af02      	add	r7, sp, #8
    abfa:	0002      	movs	r2, r0
    abfc:	6039      	str	r1, [r7, #0]
    abfe:	1dfb      	adds	r3, r7, #7
    ac00:	701a      	strb	r2, [r3, #0]
/* USER CODE BEGIN USBPD_PWR_IF_Disable_VConn */
  USBPD_StatusTypeDef _status = USBPD_OK;
    ac02:	240f      	movs	r4, #15
    ac04:	193b      	adds	r3, r7, r4
    ac06:	2200      	movs	r2, #0
    ac08:	701a      	strb	r2, [r3, #0]
  POWER_IF_TRACE(PortNum, "VCONN OFF", 9);
    ac0a:	4a12      	ldr	r2, [pc, #72]	; (ac54 <USBPD_PWR_IF_Disable_VConn+0x60>)
    ac0c:	1dfb      	adds	r3, r7, #7
    ac0e:	7819      	ldrb	r1, [r3, #0]
    ac10:	2309      	movs	r3, #9
    ac12:	9300      	str	r3, [sp, #0]
    ac14:	0013      	movs	r3, r2
    ac16:	2200      	movs	r2, #0
    ac18:	2006      	movs	r0, #6
    ac1a:	f005 fca3 	bl	10564 <USBPD_TRACE_Add>
  USBPD_TCPM_set_vconn(PortNum, USBPD_DISABLE);
    ac1e:	1dfb      	adds	r3, r7, #7
    ac20:	781b      	ldrb	r3, [r3, #0]
    ac22:	2100      	movs	r1, #0
    ac24:	0018      	movs	r0, r3
    ac26:	f013 fb2d 	bl	1e284 <USBPD_TCPM_set_vconn>
  if(USBPD_OK == _status)
    ac2a:	193b      	adds	r3, r7, r4
    ac2c:	781b      	ldrb	r3, [r3, #0]
    ac2e:	2b00      	cmp	r3, #0
    ac30:	d108      	bne.n	ac44 <USBPD_PWR_IF_Disable_VConn+0x50>
  {
    DPM_Params[PortNum].VconnStatus = USBPD_FALSE;
    ac32:	1dfb      	adds	r3, r7, #7
    ac34:	781b      	ldrb	r3, [r3, #0]
    ac36:	4a08      	ldr	r2, [pc, #32]	; (ac58 <USBPD_PWR_IF_Disable_VConn+0x64>)
    ac38:	009b      	lsls	r3, r3, #2
    ac3a:	18d3      	adds	r3, r2, r3
    ac3c:	785a      	ldrb	r2, [r3, #1]
    ac3e:	217f      	movs	r1, #127	; 0x7f
    ac40:	400a      	ands	r2, r1
    ac42:	705a      	strb	r2, [r3, #1]
  }
  return _status;
    ac44:	230f      	movs	r3, #15
    ac46:	18fb      	adds	r3, r7, r3
    ac48:	781b      	ldrb	r3, [r3, #0]
/* USER CODE END USBPD_PWR_IF_Disable_VConn */
}
    ac4a:	0018      	movs	r0, r3
    ac4c:	46bd      	mov	sp, r7
    ac4e:	b005      	add	sp, #20
    ac50:	bd90      	pop	{r4, r7, pc}
    ac52:	46c0      	nop			; (mov r8, r8)
    ac54:	0001f364 	.word	0x0001f364
    ac58:	000321d4 	.word	0x000321d4

0000ac5c <USBPD_PWR_IF_GetPortPDOs>:
  * @param  Ptr Pointer on address where PDO values should be written (u8 pointer)
  * @param  Size Pointer on nb of u32 written by PWR_IF (nb of PDOs)
  * @retval None
  */
void USBPD_PWR_IF_GetPortPDOs(uint8_t PortNum, USBPD_CORE_DataInfoType_TypeDef DataId, uint8_t *Ptr, uint32_t *Size)
{
    ac5c:	b590      	push	{r4, r7, lr}
    ac5e:	b08b      	sub	sp, #44	; 0x2c
    ac60:	af00      	add	r7, sp, #0
    ac62:	60ba      	str	r2, [r7, #8]
    ac64:	607b      	str	r3, [r7, #4]
    ac66:	240f      	movs	r4, #15
    ac68:	193b      	adds	r3, r7, r4
    ac6a:	1c02      	adds	r2, r0, #0
    ac6c:	701a      	strb	r2, [r3, #0]
    ac6e:	230e      	movs	r3, #14
    ac70:	18fb      	adds	r3, r7, r3
    ac72:	1c0a      	adds	r2, r1, #0
    ac74:	701a      	strb	r2, [r3, #0]
/* USER CODE BEGIN USBPD_PWR_IF_GetPortPDOs */
  uint32_t   nbpdo, index, nb_valid_pdo = 0;
    ac76:	2300      	movs	r3, #0
    ac78:	61fb      	str	r3, [r7, #28]
  uint32_t   *ptpdoarray = NULL;
    ac7a:	2300      	movs	r3, #0
    ac7c:	61bb      	str	r3, [r7, #24]
    USBPD_PDO_TypeDef pdo_first;

  /* Check if valid port */
  if (USBPD_PORT_IsValid(PortNum))
    ac7e:	193b      	adds	r3, r7, r4
    ac80:	781b      	ldrb	r3, [r3, #0]
    ac82:	2b00      	cmp	r3, #0
    ac84:	d000      	beq.n	ac88 <USBPD_PWR_IF_GetPortPDOs+0x2c>
    ac86:	e07e      	b.n	ad86 <USBPD_PWR_IF_GetPortPDOs+0x12a>
  {
    /* According to type of PDO to be read, set pointer on values and nb of elements */
    switch (DataId)
    ac88:	230e      	movs	r3, #14
    ac8a:	18fb      	adds	r3, r7, r3
    ac8c:	781b      	ldrb	r3, [r3, #0]
    ac8e:	2b00      	cmp	r3, #0
    ac90:	d002      	beq.n	ac98 <USBPD_PWR_IF_GetPortPDOs+0x3c>
    ac92:	2b01      	cmp	r3, #1
    ac94:	d024      	beq.n	ace0 <USBPD_PWR_IF_GetPortPDOs+0x84>
    ac96:	e049      	b.n	ad2c <USBPD_PWR_IF_GetPortPDOs+0xd0>
    {
    case USBPD_CORE_DATATYPE_SRC_PDO:
      nbpdo       = *PWR_Port_PDO_Storage[PortNum].SourcePDO.NumberOfPDO;
    ac98:	210f      	movs	r1, #15
    ac9a:	187b      	adds	r3, r7, r1
    ac9c:	781b      	ldrb	r3, [r3, #0]
    ac9e:	4a3c      	ldr	r2, [pc, #240]	; (ad90 <USBPD_PWR_IF_GetPortPDOs+0x134>)
    aca0:	011b      	lsls	r3, r3, #4
    aca2:	18d3      	adds	r3, r2, r3
    aca4:	3304      	adds	r3, #4
    aca6:	681b      	ldr	r3, [r3, #0]
    aca8:	781b      	ldrb	r3, [r3, #0]
    acaa:	627b      	str	r3, [r7, #36]	; 0x24
      ptpdoarray  = PWR_Port_PDO_Storage[PortNum].SourcePDO.ListOfPDO;
    acac:	187b      	adds	r3, r7, r1
    acae:	781a      	ldrb	r2, [r3, #0]
    acb0:	4b37      	ldr	r3, [pc, #220]	; (ad90 <USBPD_PWR_IF_GetPortPDOs+0x134>)
    acb2:	0112      	lsls	r2, r2, #4
    acb4:	58d3      	ldr	r3, [r2, r3]
    acb6:	61bb      	str	r3, [r7, #24]
      /* Save the 1st PDO */
      pdo_first.d32 = *ptpdoarray;
    acb8:	69bb      	ldr	r3, [r7, #24]
    acba:	681b      	ldr	r3, [r3, #0]
    acbc:	617b      	str	r3, [r7, #20]
      /* Reset unchunked bit if current revision is PD2.0*/
      if (USBPD_SPECIFICATION_REV2 == DPM_Params[PortNum].PE_SpecRevision)
    acbe:	187b      	adds	r3, r7, r1
    acc0:	781a      	ldrb	r2, [r3, #0]
    acc2:	4b34      	ldr	r3, [pc, #208]	; (ad94 <USBPD_PWR_IF_GetPortPDOs+0x138>)
    acc4:	0092      	lsls	r2, r2, #2
    acc6:	5cd3      	ldrb	r3, [r2, r3]
    acc8:	079b      	lsls	r3, r3, #30
    acca:	0f9b      	lsrs	r3, r3, #30
    accc:	b2db      	uxtb	r3, r3
    acce:	2b01      	cmp	r3, #1
    acd0:	d12f      	bne.n	ad32 <USBPD_PWR_IF_GetPortPDOs+0xd6>
      {
        pdo_first.SRCFixedPDO.UnchunkedExtendedMessage  = USBPD_PDO_SRC_FIXED_UNCHUNK_NOT_SUPPORTED;
    acd2:	2317      	movs	r3, #23
    acd4:	18fb      	adds	r3, r7, r3
    acd6:	781a      	ldrb	r2, [r3, #0]
    acd8:	2101      	movs	r1, #1
    acda:	438a      	bics	r2, r1
    acdc:	701a      	strb	r2, [r3, #0]
      }
      break;
    acde:	e028      	b.n	ad32 <USBPD_PWR_IF_GetPortPDOs+0xd6>
    case USBPD_CORE_DATATYPE_SNK_PDO:
      nbpdo       = *PWR_Port_PDO_Storage[PortNum].SinkPDO.NumberOfPDO;
    ace0:	210f      	movs	r1, #15
    ace2:	187b      	adds	r3, r7, r1
    ace4:	781b      	ldrb	r3, [r3, #0]
    ace6:	4a2a      	ldr	r2, [pc, #168]	; (ad90 <USBPD_PWR_IF_GetPortPDOs+0x134>)
    ace8:	011b      	lsls	r3, r3, #4
    acea:	18d3      	adds	r3, r2, r3
    acec:	330c      	adds	r3, #12
    acee:	681b      	ldr	r3, [r3, #0]
    acf0:	781b      	ldrb	r3, [r3, #0]
    acf2:	627b      	str	r3, [r7, #36]	; 0x24
      ptpdoarray  = PWR_Port_PDO_Storage[PortNum].SinkPDO.ListOfPDO;
    acf4:	187b      	adds	r3, r7, r1
    acf6:	781b      	ldrb	r3, [r3, #0]
    acf8:	4a25      	ldr	r2, [pc, #148]	; (ad90 <USBPD_PWR_IF_GetPortPDOs+0x134>)
    acfa:	011b      	lsls	r3, r3, #4
    acfc:	18d3      	adds	r3, r2, r3
    acfe:	3308      	adds	r3, #8
    ad00:	681b      	ldr	r3, [r3, #0]
    ad02:	61bb      	str	r3, [r7, #24]
      /* Save the 1st PDO */
      pdo_first.d32 = *ptpdoarray;
    ad04:	69bb      	ldr	r3, [r7, #24]
    ad06:	681b      	ldr	r3, [r3, #0]
    ad08:	617b      	str	r3, [r7, #20]
      /* Reset FRS bit if current revision is PD2.0*/
      if (USBPD_SPECIFICATION_REV2 == DPM_Params[PortNum].PE_SpecRevision)
    ad0a:	187b      	adds	r3, r7, r1
    ad0c:	781a      	ldrb	r2, [r3, #0]
    ad0e:	4b21      	ldr	r3, [pc, #132]	; (ad94 <USBPD_PWR_IF_GetPortPDOs+0x138>)
    ad10:	0092      	lsls	r2, r2, #2
    ad12:	5cd3      	ldrb	r3, [r2, r3]
    ad14:	079b      	lsls	r3, r3, #30
    ad16:	0f9b      	lsrs	r3, r3, #30
    ad18:	b2db      	uxtb	r3, r3
    ad1a:	2b01      	cmp	r3, #1
    ad1c:	d10b      	bne.n	ad36 <USBPD_PWR_IF_GetPortPDOs+0xda>
      {
        pdo_first.SNKFixedPDO.FastRoleSwapRequiredCurrent = USBPD_PDO_SNK_FIXED_FRS_NOT_SUPPORTED;
    ad1e:	2316      	movs	r3, #22
    ad20:	18fb      	adds	r3, r7, r3
    ad22:	781a      	ldrb	r2, [r3, #0]
    ad24:	2130      	movs	r1, #48	; 0x30
    ad26:	438a      	bics	r2, r1
    ad28:	701a      	strb	r2, [r3, #0]
      }
      break;
    ad2a:	e004      	b.n	ad36 <USBPD_PWR_IF_GetPortPDOs+0xda>
    default:
      nbpdo = 0;
    ad2c:	2300      	movs	r3, #0
    ad2e:	627b      	str	r3, [r7, #36]	; 0x24
      break;
    ad30:	e002      	b.n	ad38 <USBPD_PWR_IF_GetPortPDOs+0xdc>
      break;
    ad32:	46c0      	nop			; (mov r8, r8)
    ad34:	e000      	b.n	ad38 <USBPD_PWR_IF_GetPortPDOs+0xdc>
      break;
    ad36:	46c0      	nop			; (mov r8, r8)
    }

    /* Copy PDO data in output buffer */
    for (index = 0; index < nbpdo; index++)
    ad38:	2300      	movs	r3, #0
    ad3a:	623b      	str	r3, [r7, #32]
    ad3c:	e01c      	b.n	ad78 <USBPD_PWR_IF_GetPortPDOs+0x11c>
    {
      {
        /* Copy 1st PDO as potentially FRS or UNCHUNKED bits have been reset */
        if (0 == index)
    ad3e:	6a3b      	ldr	r3, [r7, #32]
    ad40:	2b00      	cmp	r3, #0
    ad42:	d107      	bne.n	ad54 <USBPD_PWR_IF_GetPortPDOs+0xf8>
        {
          (void)memcpy(Ptr, (uint8_t*)&pdo_first.d32, 4u);
    ad44:	2314      	movs	r3, #20
    ad46:	18f9      	adds	r1, r7, r3
    ad48:	68bb      	ldr	r3, [r7, #8]
    ad4a:	2204      	movs	r2, #4
    ad4c:	0018      	movs	r0, r3
    ad4e:	f013 fca1 	bl	1e694 <memcpy>
    ad52:	e008      	b.n	ad66 <USBPD_PWR_IF_GetPortPDOs+0x10a>
        }
        else
        {
          (void)memcpy((Ptr + (nb_valid_pdo * 4u)), (uint8_t*)ptpdoarray, 4u);
    ad54:	69fb      	ldr	r3, [r7, #28]
    ad56:	009b      	lsls	r3, r3, #2
    ad58:	68ba      	ldr	r2, [r7, #8]
    ad5a:	18d3      	adds	r3, r2, r3
    ad5c:	69b9      	ldr	r1, [r7, #24]
    ad5e:	2204      	movs	r2, #4
    ad60:	0018      	movs	r0, r3
    ad62:	f013 fc97 	bl	1e694 <memcpy>
        }
        nb_valid_pdo++;
    ad66:	69fb      	ldr	r3, [r7, #28]
    ad68:	3301      	adds	r3, #1
    ad6a:	61fb      	str	r3, [r7, #28]
      }
      ptpdoarray++;
    ad6c:	69bb      	ldr	r3, [r7, #24]
    ad6e:	3304      	adds	r3, #4
    ad70:	61bb      	str	r3, [r7, #24]
    for (index = 0; index < nbpdo; index++)
    ad72:	6a3b      	ldr	r3, [r7, #32]
    ad74:	3301      	adds	r3, #1
    ad76:	623b      	str	r3, [r7, #32]
    ad78:	6a3a      	ldr	r2, [r7, #32]
    ad7a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    ad7c:	429a      	cmp	r2, r3
    ad7e:	d3de      	bcc.n	ad3e <USBPD_PWR_IF_GetPortPDOs+0xe2>
    }
    /* Set nb of read PDO (nb of u32 elements); */
    *Size = nb_valid_pdo;
    ad80:	687b      	ldr	r3, [r7, #4]
    ad82:	69fa      	ldr	r2, [r7, #28]
    ad84:	601a      	str	r2, [r3, #0]
  }
/* USER CODE END USBPD_PWR_IF_GetPortPDOs */
}
    ad86:	46c0      	nop			; (mov r8, r8)
    ad88:	46bd      	mov	sp, r7
    ad8a:	b00b      	add	sp, #44	; 0x2c
    ad8c:	bd90      	pop	{r4, r7, pc}
    ad8e:	46c0      	nop			; (mov r8, r8)
    ad90:	00032140 	.word	0x00032140
    ad94:	000321d4 	.word	0x000321d4

0000ad98 <USBPD_PWR_IF_SearchRequestedPDO>:
  * @retval Status of search
  *         USBPD_OK : Src PDO found for requested DO position (output Pdo parameter is set)
  *         USBPD_FAIL : Position is not compliant with current Src PDO for this port (no corresponding PDO value)
  */
USBPD_StatusTypeDef USBPD_PWR_IF_SearchRequestedPDO(uint8_t PortNum, uint32_t RdoPosition, uint32_t *Pdo)
{
    ad98:	b580      	push	{r7, lr}
    ad9a:	b084      	sub	sp, #16
    ad9c:	af00      	add	r7, sp, #0
    ad9e:	60b9      	str	r1, [r7, #8]
    ada0:	607a      	str	r2, [r7, #4]
    ada2:	230f      	movs	r3, #15
    ada4:	18fb      	adds	r3, r7, r3
    ada6:	1c02      	adds	r2, r0, #0
    ada8:	701a      	strb	r2, [r3, #0]
/* USER CODE BEGIN USBPD_PWR_IF_SearchRequestedPDO */
  if((RdoPosition == 0) || (RdoPosition > *PWR_Port_PDO_Storage[PortNum].SourcePDO.NumberOfPDO))
    adaa:	68bb      	ldr	r3, [r7, #8]
    adac:	2b00      	cmp	r3, #0
    adae:	d00c      	beq.n	adca <USBPD_PWR_IF_SearchRequestedPDO+0x32>
    adb0:	230f      	movs	r3, #15
    adb2:	18fb      	adds	r3, r7, r3
    adb4:	781b      	ldrb	r3, [r3, #0]
    adb6:	4a10      	ldr	r2, [pc, #64]	; (adf8 <USBPD_PWR_IF_SearchRequestedPDO+0x60>)
    adb8:	011b      	lsls	r3, r3, #4
    adba:	18d3      	adds	r3, r2, r3
    adbc:	3304      	adds	r3, #4
    adbe:	681b      	ldr	r3, [r3, #0]
    adc0:	781b      	ldrb	r3, [r3, #0]
    adc2:	001a      	movs	r2, r3
    adc4:	68bb      	ldr	r3, [r7, #8]
    adc6:	4293      	cmp	r3, r2
    adc8:	d901      	bls.n	adce <USBPD_PWR_IF_SearchRequestedPDO+0x36>
  {
    /* Invalid PDO index */
    return USBPD_FAIL;
    adca:	2310      	movs	r3, #16
    adcc:	e00f      	b.n	adee <USBPD_PWR_IF_SearchRequestedPDO+0x56>
  }

  *Pdo = PWR_Port_PDO_Storage[PortNum].SourcePDO.ListOfPDO[RdoPosition - 1];
    adce:	230f      	movs	r3, #15
    add0:	18fb      	adds	r3, r7, r3
    add2:	781a      	ldrb	r2, [r3, #0]
    add4:	4b08      	ldr	r3, [pc, #32]	; (adf8 <USBPD_PWR_IF_SearchRequestedPDO+0x60>)
    add6:	0112      	lsls	r2, r2, #4
    add8:	58d2      	ldr	r2, [r2, r3]
    adda:	68bb      	ldr	r3, [r7, #8]
    addc:	4907      	ldr	r1, [pc, #28]	; (adfc <USBPD_PWR_IF_SearchRequestedPDO+0x64>)
    adde:	468c      	mov	ip, r1
    ade0:	4463      	add	r3, ip
    ade2:	009b      	lsls	r3, r3, #2
    ade4:	18d3      	adds	r3, r2, r3
    ade6:	681a      	ldr	r2, [r3, #0]
    ade8:	687b      	ldr	r3, [r7, #4]
    adea:	601a      	str	r2, [r3, #0]
  return USBPD_OK;
    adec:	2300      	movs	r3, #0
/* USER CODE END USBPD_PWR_IF_SearchRequestedPDO */
}
    adee:	0018      	movs	r0, r3
    adf0:	46bd      	mov	sp, r7
    adf2:	b004      	add	sp, #16
    adf4:	bd80      	pop	{r7, pc}
    adf6:	46c0      	nop			; (mov r8, r8)
    adf8:	00032140 	.word	0x00032140
    adfc:	3fffffff 	.word	0x3fffffff

0000ae00 <USBPD_PWR_IF_CheckUpdateSNKPower>:
  * @brief  Function to check validity between SNK PDO and power user settings
  * @param  PortNum Port number
  * @retval USBPD Status
  */
USBPD_StatusTypeDef USBPD_PWR_IF_CheckUpdateSNKPower(uint8_t PortNum)
{
    ae00:	b5b0      	push	{r4, r5, r7, lr}
    ae02:	b08a      	sub	sp, #40	; 0x28
    ae04:	af00      	add	r7, sp, #0
    ae06:	0002      	movs	r2, r0
    ae08:	1dfb      	adds	r3, r7, #7
    ae0a:	701a      	strb	r2, [r3, #0]
  USBPD_StatusTypeDef _status = USBPD_OK;
    ae0c:	2317      	movs	r3, #23
    ae0e:	18fb      	adds	r3, r7, r3
    ae10:	2200      	movs	r2, #0
    ae12:	701a      	strb	r2, [r3, #0]
  USBPD_PDO_TypeDef pdo;
  uint32_t _max_power = 0;
    ae14:	2300      	movs	r3, #0
    ae16:	627b      	str	r3, [r7, #36]	; 0x24
  uint16_t _voltage = 0, _current = 0, _power = 0;
    ae18:	2314      	movs	r3, #20
    ae1a:	18fb      	adds	r3, r7, r3
    ae1c:	2200      	movs	r2, #0
    ae1e:	801a      	strh	r2, [r3, #0]
    ae20:	2312      	movs	r3, #18
    ae22:	18fb      	adds	r3, r7, r3
    ae24:	2200      	movs	r2, #0
    ae26:	801a      	strh	r2, [r3, #0]
    ae28:	2310      	movs	r3, #16
    ae2a:	18fb      	adds	r3, r7, r3
    ae2c:	2200      	movs	r2, #0
    ae2e:	801a      	strh	r2, [r3, #0]
  uint16_t _min_voltage = 0xFFFF, _max_voltage = 0, _max_current = 0;
    ae30:	2322      	movs	r3, #34	; 0x22
    ae32:	18fb      	adds	r3, r7, r3
    ae34:	2201      	movs	r2, #1
    ae36:	4252      	negs	r2, r2
    ae38:	801a      	strh	r2, [r3, #0]
    ae3a:	2320      	movs	r3, #32
    ae3c:	18fb      	adds	r3, r7, r3
    ae3e:	2200      	movs	r2, #0
    ae40:	801a      	strh	r2, [r3, #0]
    ae42:	231e      	movs	r3, #30
    ae44:	18fb      	adds	r3, r7, r3
    ae46:	2200      	movs	r2, #0
    ae48:	801a      	strh	r2, [r3, #0]

  for (uint32_t _index = 0; _index < *PWR_Port_PDO_Storage[PortNum].SinkPDO.NumberOfPDO; _index++)
    ae4a:	2300      	movs	r3, #0
    ae4c:	61bb      	str	r3, [r7, #24]
    ae4e:	e0f3      	b.n	b038 <USBPD_PWR_IF_CheckUpdateSNKPower+0x238>
  {
    pdo.d32 = PWR_Port_PDO_Storage[PortNum].SinkPDO.ListOfPDO[_index];
    ae50:	1dfb      	adds	r3, r7, #7
    ae52:	781b      	ldrb	r3, [r3, #0]
    ae54:	4a9d      	ldr	r2, [pc, #628]	; (b0cc <USBPD_PWR_IF_CheckUpdateSNKPower+0x2cc>)
    ae56:	011b      	lsls	r3, r3, #4
    ae58:	18d3      	adds	r3, r2, r3
    ae5a:	3308      	adds	r3, #8
    ae5c:	681a      	ldr	r2, [r3, #0]
    ae5e:	69bb      	ldr	r3, [r7, #24]
    ae60:	009b      	lsls	r3, r3, #2
    ae62:	18d3      	adds	r3, r2, r3
    ae64:	681b      	ldr	r3, [r3, #0]
    ae66:	60fb      	str	r3, [r7, #12]
    switch (pdo.GenericPDO.PowerObject)
    ae68:	230f      	movs	r3, #15
    ae6a:	18fb      	adds	r3, r7, r3
    ae6c:	781b      	ldrb	r3, [r3, #0]
    ae6e:	061b      	lsls	r3, r3, #24
    ae70:	0f9b      	lsrs	r3, r3, #30
    ae72:	b2db      	uxtb	r3, r3
    ae74:	2b01      	cmp	r3, #1
    ae76:	d046      	beq.n	af06 <USBPD_PWR_IF_CheckUpdateSNKPower+0x106>
    ae78:	2b02      	cmp	r3, #2
    ae7a:	d100      	bne.n	ae7e <USBPD_PWR_IF_CheckUpdateSNKPower+0x7e>
    ae7c:	e089      	b.n	af92 <USBPD_PWR_IF_CheckUpdateSNKPower+0x192>
    ae7e:	2b00      	cmp	r3, #0
    ae80:	d000      	beq.n	ae84 <USBPD_PWR_IF_CheckUpdateSNKPower+0x84>
        _PWR_UPDATE_VOLTAGE_MAX(_voltage, _max_voltage);
        _current = PWR_DECODE_10MA(pdo.SNKVariablePDO.OperationalCurrentIn10mAunits);
        _PWR_UPDATE_CURRENT_MAX(_current, _max_current);
        break;
      default:
        break;
    ae82:	e0d6      	b.n	b032 <USBPD_PWR_IF_CheckUpdateSNKPower+0x232>
        _voltage = PWR_DECODE_50MV(pdo.SNKFixedPDO.VoltageIn50mVunits);
    ae84:	68fb      	ldr	r3, [r7, #12]
    ae86:	031b      	lsls	r3, r3, #12
    ae88:	0d9b      	lsrs	r3, r3, #22
    ae8a:	b29b      	uxth	r3, r3
    ae8c:	0019      	movs	r1, r3
    ae8e:	2014      	movs	r0, #20
    ae90:	183b      	adds	r3, r7, r0
    ae92:	2232      	movs	r2, #50	; 0x32
    ae94:	434a      	muls	r2, r1
    ae96:	801a      	strh	r2, [r3, #0]
        _PWR_UPDATE_VOLTAGE_MIN(_voltage, _min_voltage);
    ae98:	183a      	adds	r2, r7, r0
    ae9a:	2322      	movs	r3, #34	; 0x22
    ae9c:	18fb      	adds	r3, r7, r3
    ae9e:	8812      	ldrh	r2, [r2, #0]
    aea0:	881b      	ldrh	r3, [r3, #0]
    aea2:	429a      	cmp	r2, r3
    aea4:	d205      	bcs.n	aeb2 <USBPD_PWR_IF_CheckUpdateSNKPower+0xb2>
    aea6:	2322      	movs	r3, #34	; 0x22
    aea8:	18fb      	adds	r3, r7, r3
    aeaa:	2214      	movs	r2, #20
    aeac:	18ba      	adds	r2, r7, r2
    aeae:	8812      	ldrh	r2, [r2, #0]
    aeb0:	801a      	strh	r2, [r3, #0]
        _PWR_UPDATE_VOLTAGE_MAX(_voltage, _max_voltage);
    aeb2:	2314      	movs	r3, #20
    aeb4:	18fa      	adds	r2, r7, r3
    aeb6:	2320      	movs	r3, #32
    aeb8:	18fb      	adds	r3, r7, r3
    aeba:	8812      	ldrh	r2, [r2, #0]
    aebc:	881b      	ldrh	r3, [r3, #0]
    aebe:	429a      	cmp	r2, r3
    aec0:	d905      	bls.n	aece <USBPD_PWR_IF_CheckUpdateSNKPower+0xce>
    aec2:	2320      	movs	r3, #32
    aec4:	18fb      	adds	r3, r7, r3
    aec6:	2214      	movs	r2, #20
    aec8:	18ba      	adds	r2, r7, r2
    aeca:	8812      	ldrh	r2, [r2, #0]
    aecc:	801a      	strh	r2, [r3, #0]
        _current = PWR_DECODE_10MA(pdo.SNKFixedPDO.OperationalCurrentIn10mAunits);
    aece:	230c      	movs	r3, #12
    aed0:	18fb      	adds	r3, r7, r3
    aed2:	881b      	ldrh	r3, [r3, #0]
    aed4:	059b      	lsls	r3, r3, #22
    aed6:	0d9b      	lsrs	r3, r3, #22
    aed8:	b29b      	uxth	r3, r3
    aeda:	2012      	movs	r0, #18
    aedc:	183a      	adds	r2, r7, r0
    aede:	1c19      	adds	r1, r3, #0
    aee0:	0089      	lsls	r1, r1, #2
    aee2:	18cb      	adds	r3, r1, r3
    aee4:	18db      	adds	r3, r3, r3
    aee6:	8013      	strh	r3, [r2, #0]
        _PWR_UPDATE_CURRENT_MAX(_current, _max_current);
    aee8:	183a      	adds	r2, r7, r0
    aeea:	231e      	movs	r3, #30
    aeec:	18fb      	adds	r3, r7, r3
    aeee:	8812      	ldrh	r2, [r2, #0]
    aef0:	881b      	ldrh	r3, [r3, #0]
    aef2:	429a      	cmp	r2, r3
    aef4:	d800      	bhi.n	aef8 <USBPD_PWR_IF_CheckUpdateSNKPower+0xf8>
    aef6:	e097      	b.n	b028 <USBPD_PWR_IF_CheckUpdateSNKPower+0x228>
    aef8:	231e      	movs	r3, #30
    aefa:	18fb      	adds	r3, r7, r3
    aefc:	2212      	movs	r2, #18
    aefe:	18ba      	adds	r2, r7, r2
    af00:	8812      	ldrh	r2, [r2, #0]
    af02:	801a      	strh	r2, [r3, #0]
        break;
    af04:	e090      	b.n	b028 <USBPD_PWR_IF_CheckUpdateSNKPower+0x228>
        _voltage = PWR_DECODE_50MV(pdo.SNKBatteryPDO.MinVoltageIn50mVunits);
    af06:	68fb      	ldr	r3, [r7, #12]
    af08:	031b      	lsls	r3, r3, #12
    af0a:	0d9b      	lsrs	r3, r3, #22
    af0c:	b29b      	uxth	r3, r3
    af0e:	0019      	movs	r1, r3
    af10:	2014      	movs	r0, #20
    af12:	183b      	adds	r3, r7, r0
    af14:	2232      	movs	r2, #50	; 0x32
    af16:	434a      	muls	r2, r1
    af18:	801a      	strh	r2, [r3, #0]
        _PWR_UPDATE_VOLTAGE_MIN(_voltage, _min_voltage);
    af1a:	183a      	adds	r2, r7, r0
    af1c:	2322      	movs	r3, #34	; 0x22
    af1e:	18fb      	adds	r3, r7, r3
    af20:	8812      	ldrh	r2, [r2, #0]
    af22:	881b      	ldrh	r3, [r3, #0]
    af24:	429a      	cmp	r2, r3
    af26:	d205      	bcs.n	af34 <USBPD_PWR_IF_CheckUpdateSNKPower+0x134>
    af28:	2322      	movs	r3, #34	; 0x22
    af2a:	18fb      	adds	r3, r7, r3
    af2c:	2214      	movs	r2, #20
    af2e:	18ba      	adds	r2, r7, r2
    af30:	8812      	ldrh	r2, [r2, #0]
    af32:	801a      	strh	r2, [r3, #0]
        _voltage = PWR_DECODE_50MV(pdo.SNKBatteryPDO.MaxVoltageIn50mVunits);
    af34:	230e      	movs	r3, #14
    af36:	18fb      	adds	r3, r7, r3
    af38:	881b      	ldrh	r3, [r3, #0]
    af3a:	049b      	lsls	r3, r3, #18
    af3c:	0d9b      	lsrs	r3, r3, #22
    af3e:	b29b      	uxth	r3, r3
    af40:	0019      	movs	r1, r3
    af42:	2014      	movs	r0, #20
    af44:	183b      	adds	r3, r7, r0
    af46:	2232      	movs	r2, #50	; 0x32
    af48:	434a      	muls	r2, r1
    af4a:	801a      	strh	r2, [r3, #0]
        _PWR_UPDATE_VOLTAGE_MAX(_voltage, _max_voltage);
    af4c:	183a      	adds	r2, r7, r0
    af4e:	2320      	movs	r3, #32
    af50:	18fb      	adds	r3, r7, r3
    af52:	8812      	ldrh	r2, [r2, #0]
    af54:	881b      	ldrh	r3, [r3, #0]
    af56:	429a      	cmp	r2, r3
    af58:	d905      	bls.n	af66 <USBPD_PWR_IF_CheckUpdateSNKPower+0x166>
    af5a:	2320      	movs	r3, #32
    af5c:	18fb      	adds	r3, r7, r3
    af5e:	2214      	movs	r2, #20
    af60:	18ba      	adds	r2, r7, r2
    af62:	8812      	ldrh	r2, [r2, #0]
    af64:	801a      	strh	r2, [r3, #0]
        _power = PWR_DECODE_MW(pdo.SNKBatteryPDO.OperationalPowerIn250mWunits);
    af66:	230c      	movs	r3, #12
    af68:	18fb      	adds	r3, r7, r3
    af6a:	881b      	ldrh	r3, [r3, #0]
    af6c:	059b      	lsls	r3, r3, #22
    af6e:	0d9b      	lsrs	r3, r3, #22
    af70:	b29b      	uxth	r3, r3
    af72:	0019      	movs	r1, r3
    af74:	2010      	movs	r0, #16
    af76:	183b      	adds	r3, r7, r0
    af78:	22fa      	movs	r2, #250	; 0xfa
    af7a:	434a      	muls	r2, r1
    af7c:	801a      	strh	r2, [r3, #0]
        _PWR_UPDATE_POWER_MAX(_power, _max_power);
    af7e:	183b      	adds	r3, r7, r0
    af80:	881b      	ldrh	r3, [r3, #0]
    af82:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    af84:	429a      	cmp	r2, r3
    af86:	d251      	bcs.n	b02c <USBPD_PWR_IF_CheckUpdateSNKPower+0x22c>
    af88:	2310      	movs	r3, #16
    af8a:	18fb      	adds	r3, r7, r3
    af8c:	881b      	ldrh	r3, [r3, #0]
    af8e:	627b      	str	r3, [r7, #36]	; 0x24
        break;
    af90:	e04c      	b.n	b02c <USBPD_PWR_IF_CheckUpdateSNKPower+0x22c>
        _voltage = PWR_DECODE_50MV(pdo.SNKVariablePDO.MinVoltageIn50mVunits);
    af92:	68fb      	ldr	r3, [r7, #12]
    af94:	031b      	lsls	r3, r3, #12
    af96:	0d9b      	lsrs	r3, r3, #22
    af98:	b29b      	uxth	r3, r3
    af9a:	0019      	movs	r1, r3
    af9c:	2014      	movs	r0, #20
    af9e:	183b      	adds	r3, r7, r0
    afa0:	2232      	movs	r2, #50	; 0x32
    afa2:	434a      	muls	r2, r1
    afa4:	801a      	strh	r2, [r3, #0]
        _PWR_UPDATE_VOLTAGE_MIN(_voltage, _min_voltage);
    afa6:	183a      	adds	r2, r7, r0
    afa8:	2322      	movs	r3, #34	; 0x22
    afaa:	18fb      	adds	r3, r7, r3
    afac:	8812      	ldrh	r2, [r2, #0]
    afae:	881b      	ldrh	r3, [r3, #0]
    afb0:	429a      	cmp	r2, r3
    afb2:	d205      	bcs.n	afc0 <USBPD_PWR_IF_CheckUpdateSNKPower+0x1c0>
    afb4:	2322      	movs	r3, #34	; 0x22
    afb6:	18fb      	adds	r3, r7, r3
    afb8:	2214      	movs	r2, #20
    afba:	18ba      	adds	r2, r7, r2
    afbc:	8812      	ldrh	r2, [r2, #0]
    afbe:	801a      	strh	r2, [r3, #0]
        _voltage = PWR_DECODE_50MV(pdo.SNKVariablePDO.MaxVoltageIn50mVunits);
    afc0:	230e      	movs	r3, #14
    afc2:	18fb      	adds	r3, r7, r3
    afc4:	881b      	ldrh	r3, [r3, #0]
    afc6:	049b      	lsls	r3, r3, #18
    afc8:	0d9b      	lsrs	r3, r3, #22
    afca:	b29b      	uxth	r3, r3
    afcc:	0019      	movs	r1, r3
    afce:	2014      	movs	r0, #20
    afd0:	183b      	adds	r3, r7, r0
    afd2:	2232      	movs	r2, #50	; 0x32
    afd4:	434a      	muls	r2, r1
    afd6:	801a      	strh	r2, [r3, #0]
        _PWR_UPDATE_VOLTAGE_MAX(_voltage, _max_voltage);
    afd8:	183a      	adds	r2, r7, r0
    afda:	2320      	movs	r3, #32
    afdc:	18fb      	adds	r3, r7, r3
    afde:	8812      	ldrh	r2, [r2, #0]
    afe0:	881b      	ldrh	r3, [r3, #0]
    afe2:	429a      	cmp	r2, r3
    afe4:	d905      	bls.n	aff2 <USBPD_PWR_IF_CheckUpdateSNKPower+0x1f2>
    afe6:	2320      	movs	r3, #32
    afe8:	18fb      	adds	r3, r7, r3
    afea:	2214      	movs	r2, #20
    afec:	18ba      	adds	r2, r7, r2
    afee:	8812      	ldrh	r2, [r2, #0]
    aff0:	801a      	strh	r2, [r3, #0]
        _current = PWR_DECODE_10MA(pdo.SNKVariablePDO.OperationalCurrentIn10mAunits);
    aff2:	230c      	movs	r3, #12
    aff4:	18fb      	adds	r3, r7, r3
    aff6:	881b      	ldrh	r3, [r3, #0]
    aff8:	059b      	lsls	r3, r3, #22
    affa:	0d9b      	lsrs	r3, r3, #22
    affc:	b29b      	uxth	r3, r3
    affe:	2012      	movs	r0, #18
    b000:	183a      	adds	r2, r7, r0
    b002:	1c19      	adds	r1, r3, #0
    b004:	0089      	lsls	r1, r1, #2
    b006:	18cb      	adds	r3, r1, r3
    b008:	18db      	adds	r3, r3, r3
    b00a:	8013      	strh	r3, [r2, #0]
        _PWR_UPDATE_CURRENT_MAX(_current, _max_current);
    b00c:	183a      	adds	r2, r7, r0
    b00e:	231e      	movs	r3, #30
    b010:	18fb      	adds	r3, r7, r3
    b012:	8812      	ldrh	r2, [r2, #0]
    b014:	881b      	ldrh	r3, [r3, #0]
    b016:	429a      	cmp	r2, r3
    b018:	d90a      	bls.n	b030 <USBPD_PWR_IF_CheckUpdateSNKPower+0x230>
    b01a:	231e      	movs	r3, #30
    b01c:	18fb      	adds	r3, r7, r3
    b01e:	2212      	movs	r2, #18
    b020:	18ba      	adds	r2, r7, r2
    b022:	8812      	ldrh	r2, [r2, #0]
    b024:	801a      	strh	r2, [r3, #0]
        break;
    b026:	e003      	b.n	b030 <USBPD_PWR_IF_CheckUpdateSNKPower+0x230>
        break;
    b028:	46c0      	nop			; (mov r8, r8)
    b02a:	e002      	b.n	b032 <USBPD_PWR_IF_CheckUpdateSNKPower+0x232>
        break;
    b02c:	46c0      	nop			; (mov r8, r8)
    b02e:	e000      	b.n	b032 <USBPD_PWR_IF_CheckUpdateSNKPower+0x232>
        break;
    b030:	46c0      	nop			; (mov r8, r8)
  for (uint32_t _index = 0; _index < *PWR_Port_PDO_Storage[PortNum].SinkPDO.NumberOfPDO; _index++)
    b032:	69bb      	ldr	r3, [r7, #24]
    b034:	3301      	adds	r3, #1
    b036:	61bb      	str	r3, [r7, #24]
    b038:	1dfb      	adds	r3, r7, #7
    b03a:	781b      	ldrb	r3, [r3, #0]
    b03c:	4a23      	ldr	r2, [pc, #140]	; (b0cc <USBPD_PWR_IF_CheckUpdateSNKPower+0x2cc>)
    b03e:	011b      	lsls	r3, r3, #4
    b040:	18d3      	adds	r3, r2, r3
    b042:	330c      	adds	r3, #12
    b044:	681b      	ldr	r3, [r3, #0]
    b046:	781b      	ldrb	r3, [r3, #0]
    b048:	001a      	movs	r2, r3
    b04a:	69bb      	ldr	r3, [r7, #24]
    b04c:	4293      	cmp	r3, r2
    b04e:	d200      	bcs.n	b052 <USBPD_PWR_IF_CheckUpdateSNKPower+0x252>
    b050:	e6fe      	b.n	ae50 <USBPD_PWR_IF_CheckUpdateSNKPower+0x50>
    }
  }

  _PWR_CHECK_VOLTAGE_MIN(_min_voltage, DPM_USER_Settings[PortNum].DPM_SNKRequestedPower.MinOperatingVoltageInmVunits);
    b052:	1dfb      	adds	r3, r7, #7
    b054:	781b      	ldrb	r3, [r3, #0]
    b056:	2222      	movs	r2, #34	; 0x22
    b058:	18ba      	adds	r2, r7, r2
    b05a:	8812      	ldrh	r2, [r2, #0]
    b05c:	491c      	ldr	r1, [pc, #112]	; (b0d0 <USBPD_PWR_IF_CheckUpdateSNKPower+0x2d0>)
    b05e:	2074      	movs	r0, #116	; 0x74
    b060:	4343      	muls	r3, r0
    b062:	18cb      	adds	r3, r1, r3
    b064:	3310      	adds	r3, #16
    b066:	601a      	str	r2, [r3, #0]
  _PWR_CHECK_VOLTAGE_MAX(_max_voltage, DPM_USER_Settings[PortNum].DPM_SNKRequestedPower.MaxOperatingVoltageInmVunits);
    b068:	1dfb      	adds	r3, r7, #7
    b06a:	781b      	ldrb	r3, [r3, #0]
    b06c:	2420      	movs	r4, #32
    b06e:	193a      	adds	r2, r7, r4
    b070:	8812      	ldrh	r2, [r2, #0]
    b072:	4917      	ldr	r1, [pc, #92]	; (b0d0 <USBPD_PWR_IF_CheckUpdateSNKPower+0x2d0>)
    b074:	2074      	movs	r0, #116	; 0x74
    b076:	4343      	muls	r3, r0
    b078:	18cb      	adds	r3, r1, r3
    b07a:	330c      	adds	r3, #12
    b07c:	601a      	str	r2, [r3, #0]
  _PWR_CHECK_CURRENT_MAX(_max_current, DPM_USER_Settings[PortNum].DPM_SNKRequestedPower.MaxOperatingCurrentInmAunits);
    b07e:	1dfb      	adds	r3, r7, #7
    b080:	781b      	ldrb	r3, [r3, #0]
    b082:	251e      	movs	r5, #30
    b084:	197a      	adds	r2, r7, r5
    b086:	8812      	ldrh	r2, [r2, #0]
    b088:	4911      	ldr	r1, [pc, #68]	; (b0d0 <USBPD_PWR_IF_CheckUpdateSNKPower+0x2d0>)
    b08a:	2074      	movs	r0, #116	; 0x74
    b08c:	4343      	muls	r3, r0
    b08e:	18cb      	adds	r3, r1, r3
    b090:	3304      	adds	r3, #4
    b092:	601a      	str	r2, [r3, #0]
  _max_power = (_max_voltage * _max_current) / 1000;
    b094:	193b      	adds	r3, r7, r4
    b096:	881b      	ldrh	r3, [r3, #0]
    b098:	197a      	adds	r2, r7, r5
    b09a:	8812      	ldrh	r2, [r2, #0]
    b09c:	435a      	muls	r2, r3
    b09e:	23fa      	movs	r3, #250	; 0xfa
    b0a0:	0099      	lsls	r1, r3, #2
    b0a2:	0010      	movs	r0, r2
    b0a4:	f013 ff98 	bl	1efd8 <__divsi3>
    b0a8:	0003      	movs	r3, r0
    b0aa:	627b      	str	r3, [r7, #36]	; 0x24
  _PWR_CHECK_POWER_MAX(_max_power, DPM_USER_Settings[PortNum].DPM_SNKRequestedPower.MaxOperatingPowerInmWunits);
    b0ac:	1dfb      	adds	r3, r7, #7
    b0ae:	781b      	ldrb	r3, [r3, #0]
    b0b0:	4a07      	ldr	r2, [pc, #28]	; (b0d0 <USBPD_PWR_IF_CheckUpdateSNKPower+0x2d0>)
    b0b2:	2174      	movs	r1, #116	; 0x74
    b0b4:	434b      	muls	r3, r1
    b0b6:	18d3      	adds	r3, r2, r3
    b0b8:	3318      	adds	r3, #24
    b0ba:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    b0bc:	601a      	str	r2, [r3, #0]

  return _status;
    b0be:	2317      	movs	r3, #23
    b0c0:	18fb      	adds	r3, r7, r3
    b0c2:	781b      	ldrb	r3, [r3, #0]
}
    b0c4:	0018      	movs	r0, r3
    b0c6:	46bd      	mov	sp, r7
    b0c8:	b00a      	add	sp, #40	; 0x28
    b0ca:	bdb0      	pop	{r4, r5, r7, pc}
    b0cc:	00032140 	.word	0x00032140
    b0d0:	0002fedc 	.word	0x0002fedc

0000b0d4 <_PWR_CheckPDOContent>:
  * @brief  Add consistency check on PDO definition (Could help to detect unexpected flash settings content)
  * @param  PortNum Port number
  * @retval None
  */
void _PWR_CheckPDOContent(uint8_t PortNum)
{
    b0d4:	b580      	push	{r7, lr}
    b0d6:	b084      	sub	sp, #16
    b0d8:	af00      	add	r7, sp, #0
    b0da:	0002      	movs	r2, r0
    b0dc:	1dfb      	adds	r3, r7, #7
    b0de:	701a      	strb	r2, [r3, #0]
  uint32_t firstpdo;
  uint8_t error_in_content = 0U;
    b0e0:	230f      	movs	r3, #15
    b0e2:	18fb      	adds	r3, r7, r3
    b0e4:	2200      	movs	r2, #0
    b0e6:	701a      	strb	r2, [r3, #0]
     - if SRC PDO are defined, 1st SRC PDO should at least have following characteristics :
         Type Fixed (bits 31-30)
         bits 23-22 shall be reserved
         Voltage in 50mv units = 5V (bits19-10 should be equal to 100)
  */
  if (*PWR_Port_PDO_Storage[PortNum].SourcePDO.NumberOfPDO > USBPD_MAX_NB_PDO)
    b0e8:	1dfb      	adds	r3, r7, #7
    b0ea:	781b      	ldrb	r3, [r3, #0]
    b0ec:	4a31      	ldr	r2, [pc, #196]	; (b1b4 <_PWR_CheckPDOContent+0xe0>)
    b0ee:	011b      	lsls	r3, r3, #4
    b0f0:	18d3      	adds	r3, r2, r3
    b0f2:	3304      	adds	r3, #4
    b0f4:	681b      	ldr	r3, [r3, #0]
    b0f6:	781b      	ldrb	r3, [r3, #0]
    b0f8:	2b07      	cmp	r3, #7
    b0fa:	d904      	bls.n	b106 <_PWR_CheckPDOContent+0x32>
  {
    error_in_content = 1U;
    b0fc:	230f      	movs	r3, #15
    b0fe:	18fb      	adds	r3, r7, r3
    b100:	2201      	movs	r2, #1
    b102:	701a      	strb	r2, [r3, #0]
    b104:	e01b      	b.n	b13e <_PWR_CheckPDOContent+0x6a>
  }
  else
  {
    if (*PWR_Port_PDO_Storage[PortNum].SourcePDO.NumberOfPDO >= 1U)
    b106:	1dfb      	adds	r3, r7, #7
    b108:	781b      	ldrb	r3, [r3, #0]
    b10a:	4a2a      	ldr	r2, [pc, #168]	; (b1b4 <_PWR_CheckPDOContent+0xe0>)
    b10c:	011b      	lsls	r3, r3, #4
    b10e:	18d3      	adds	r3, r2, r3
    b110:	3304      	adds	r3, #4
    b112:	681b      	ldr	r3, [r3, #0]
    b114:	781b      	ldrb	r3, [r3, #0]
    b116:	2b00      	cmp	r3, #0
    b118:	d011      	beq.n	b13e <_PWR_CheckPDOContent+0x6a>
    {
      firstpdo = (PWR_Port_PDO_Storage[PortNum].SourcePDO.ListOfPDO[0U])
    b11a:	1dfb      	adds	r3, r7, #7
    b11c:	781a      	ldrb	r2, [r3, #0]
    b11e:	4b25      	ldr	r3, [pc, #148]	; (b1b4 <_PWR_CheckPDOContent+0xe0>)
    b120:	0112      	lsls	r2, r2, #4
    b122:	58d3      	ldr	r3, [r2, r3]
    b124:	681b      	ldr	r3, [r3, #0]
    b126:	4a24      	ldr	r2, [pc, #144]	; (b1b8 <_PWR_CheckPDOContent+0xe4>)
    b128:	4013      	ands	r3, r2
    b12a:	60bb      	str	r3, [r7, #8]
                 & (USBPD_PDO_TYPE_Msk | USBPD_PDO_SRC_FIXED_VOLTAGE_Msk | (0x3U << 22U));
      if (firstpdo != (USBPD_PDO_TYPE_FIXED | (100U << USBPD_PDO_SRC_FIXED_VOLTAGE_Pos)))
    b12c:	68ba      	ldr	r2, [r7, #8]
    b12e:	23c8      	movs	r3, #200	; 0xc8
    b130:	025b      	lsls	r3, r3, #9
    b132:	429a      	cmp	r2, r3
    b134:	d003      	beq.n	b13e <_PWR_CheckPDOContent+0x6a>
      {
        error_in_content = 1U;
    b136:	230f      	movs	r3, #15
    b138:	18fb      	adds	r3, r7, r3
    b13a:	2201      	movs	r2, #1
    b13c:	701a      	strb	r2, [r3, #0]
     - if SNK PDO are defined, 1st SNK PDO should at least have following characteristics :
         Type Fixed (bits 31-30)
         bits 22-20 shall be reserved
         Voltage in 50mv units = 5V (bits19-10 should be equal to 100)
  */
  if (*PWR_Port_PDO_Storage[PortNum].SinkPDO.NumberOfPDO > USBPD_MAX_NB_PDO)
    b13e:	1dfb      	adds	r3, r7, #7
    b140:	781b      	ldrb	r3, [r3, #0]
    b142:	4a1c      	ldr	r2, [pc, #112]	; (b1b4 <_PWR_CheckPDOContent+0xe0>)
    b144:	011b      	lsls	r3, r3, #4
    b146:	18d3      	adds	r3, r2, r3
    b148:	330c      	adds	r3, #12
    b14a:	681b      	ldr	r3, [r3, #0]
    b14c:	781b      	ldrb	r3, [r3, #0]
    b14e:	2b07      	cmp	r3, #7
    b150:	d904      	bls.n	b15c <_PWR_CheckPDOContent+0x88>
  {
    error_in_content = 1U;
    b152:	230f      	movs	r3, #15
    b154:	18fb      	adds	r3, r7, r3
    b156:	2201      	movs	r2, #1
    b158:	701a      	strb	r2, [r3, #0]
    b15a:	e01d      	b.n	b198 <_PWR_CheckPDOContent+0xc4>
  }
  else
  {
    if (*PWR_Port_PDO_Storage[PortNum].SinkPDO.NumberOfPDO >= 1U)
    b15c:	1dfb      	adds	r3, r7, #7
    b15e:	781b      	ldrb	r3, [r3, #0]
    b160:	4a14      	ldr	r2, [pc, #80]	; (b1b4 <_PWR_CheckPDOContent+0xe0>)
    b162:	011b      	lsls	r3, r3, #4
    b164:	18d3      	adds	r3, r2, r3
    b166:	330c      	adds	r3, #12
    b168:	681b      	ldr	r3, [r3, #0]
    b16a:	781b      	ldrb	r3, [r3, #0]
    b16c:	2b00      	cmp	r3, #0
    b16e:	d013      	beq.n	b198 <_PWR_CheckPDOContent+0xc4>
    {
      firstpdo = (PWR_Port_PDO_Storage[PortNum].SinkPDO.ListOfPDO[0U])
    b170:	1dfb      	adds	r3, r7, #7
    b172:	781b      	ldrb	r3, [r3, #0]
    b174:	4a0f      	ldr	r2, [pc, #60]	; (b1b4 <_PWR_CheckPDOContent+0xe0>)
    b176:	011b      	lsls	r3, r3, #4
    b178:	18d3      	adds	r3, r2, r3
    b17a:	3308      	adds	r3, #8
    b17c:	681b      	ldr	r3, [r3, #0]
    b17e:	681b      	ldr	r3, [r3, #0]
    b180:	4a0e      	ldr	r2, [pc, #56]	; (b1bc <_PWR_CheckPDOContent+0xe8>)
    b182:	4013      	ands	r3, r2
    b184:	60bb      	str	r3, [r7, #8]
                 & (USBPD_PDO_TYPE_Msk | USBPD_PDO_SNK_FIXED_VOLTAGE_Msk | (0x3U << 20U));
      if (firstpdo != (USBPD_PDO_TYPE_FIXED | (100U << USBPD_PDO_SNK_FIXED_VOLTAGE_Pos)))
    b186:	68ba      	ldr	r2, [r7, #8]
    b188:	23c8      	movs	r3, #200	; 0xc8
    b18a:	025b      	lsls	r3, r3, #9
    b18c:	429a      	cmp	r2, r3
    b18e:	d003      	beq.n	b198 <_PWR_CheckPDOContent+0xc4>
      {
        error_in_content = 1U;
    b190:	230f      	movs	r3, #15
    b192:	18fb      	adds	r3, r7, r3
    b194:	2201      	movs	r2, #1
    b196:	701a      	strb	r2, [r3, #0]
      }
    }
  }
#endif /* _SNK || _DRP */

  if (error_in_content == 1U)
    b198:	230f      	movs	r3, #15
    b19a:	18fb      	adds	r3, r7, r3
    b19c:	781b      	ldrb	r3, [r3, #0]
    b19e:	2b01      	cmp	r3, #1
    b1a0:	d103      	bne.n	b1aa <_PWR_CheckPDOContent+0xd6>
  {
    /* Stop RTOS scheduling */
    vTaskSuspendAll();
    b1a2:	f006 fc67 	bl	11a74 <vTaskSuspendAll>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
    b1a6:	b672      	cpsid	i


    /* disable all interrupt to lock the system */
    __disable_irq();
    while(1);
    b1a8:	e7fe      	b.n	b1a8 <_PWR_CheckPDOContent+0xd4>
  }
}
    b1aa:	46c0      	nop			; (mov r8, r8)
    b1ac:	46bd      	mov	sp, r7
    b1ae:	b004      	add	sp, #16
    b1b0:	bd80      	pop	{r7, pc}
    b1b2:	46c0      	nop			; (mov r8, r8)
    b1b4:	00032140 	.word	0x00032140
    b1b8:	c0cffc00 	.word	0xc0cffc00
    b1bc:	c03ffc00 	.word	0xc03ffc00

0000b1c0 <USBPD_VDM_InformIdentity>:
  * @param  CommandStatus Command status based on @ref USBPD_VDM_CommandType_Typedef
  * @param  pIdentity     Pointer on the discovery identity information based on @ref USBPD_DiscoveryIdentity_TypeDef
  * @retval None
*/
static void USBPD_VDM_InformIdentity(uint8_t PortNum, USBPD_SOPType_TypeDef SOPType, USBPD_VDM_CommandType_Typedef CommandStatus, USBPD_DiscoveryIdentity_TypeDef *pIdentity)
{
    b1c0:	b590      	push	{r4, r7, lr}
    b1c2:	b087      	sub	sp, #28
    b1c4:	af00      	add	r7, sp, #0
    b1c6:	60ba      	str	r2, [r7, #8]
    b1c8:	607b      	str	r3, [r7, #4]
    b1ca:	230f      	movs	r3, #15
    b1cc:	18fb      	adds	r3, r7, r3
    b1ce:	1c02      	adds	r2, r0, #0
    b1d0:	701a      	strb	r2, [r3, #0]
    b1d2:	230e      	movs	r3, #14
    b1d4:	18fb      	adds	r3, r7, r3
    b1d6:	1c0a      	adds	r2, r1, #0
    b1d8:	701a      	strb	r2, [r3, #0]
/* USER CODE BEGIN USBPD_VDM_InformIdentity */
  switch(CommandStatus)
    b1da:	68bb      	ldr	r3, [r7, #8]
    b1dc:	2b05      	cmp	r3, #5
    b1de:	d841      	bhi.n	b264 <USBPD_VDM_InformIdentity+0xa4>
    b1e0:	68bb      	ldr	r3, [r7, #8]
    b1e2:	009a      	lsls	r2, r3, #2
    b1e4:	4b25      	ldr	r3, [pc, #148]	; (b27c <USBPD_VDM_InformIdentity+0xbc>)
    b1e6:	18d3      	adds	r3, r2, r3
    b1e8:	681b      	ldr	r3, [r3, #0]
    b1ea:	469f      	mov	pc, r3
  {
  case SVDM_RESPONDER_ACK :
    if (USBPD_SOPTYPE_SOP1 == SOPType)
    b1ec:	230e      	movs	r3, #14
    b1ee:	18fb      	adds	r3, r7, r3
    b1f0:	781b      	ldrb	r3, [r3, #0]
    b1f2:	2b01      	cmp	r3, #1
    b1f4:	d138      	bne.n	b268 <USBPD_VDM_InformIdentity+0xa8>
    {
      uint8_t*  disco_ident;
      disco_ident = (uint8_t*)&DPM_Ports[PortNum].VDM_DiscoCableIdentify;
    b1f6:	230f      	movs	r3, #15
    b1f8:	18fb      	adds	r3, r7, r3
    b1fa:	781b      	ldrb	r3, [r3, #0]
    b1fc:	22b0      	movs	r2, #176	; 0xb0
    b1fe:	4353      	muls	r3, r2
    b200:	3398      	adds	r3, #152	; 0x98
    b202:	001a      	movs	r2, r3
    b204:	4b1e      	ldr	r3, [pc, #120]	; (b280 <USBPD_VDM_InformIdentity+0xc0>)
    b206:	18d3      	adds	r3, r2, r3
    b208:	617b      	str	r3, [r7, #20]
      memcpy(disco_ident, (uint8_t*)pIdentity, sizeof(USBPD_DiscoveryIdentity_TypeDef));
    b20a:	6879      	ldr	r1, [r7, #4]
    b20c:	697b      	ldr	r3, [r7, #20]
    b20e:	2218      	movs	r2, #24
    b210:	0018      	movs	r0, r3
    b212:	f013 fa3f 	bl	1e694 <memcpy>
      if (NULL != DPM_GUI_SaveInfo)
    b216:	4b1b      	ldr	r3, [pc, #108]	; (b284 <USBPD_VDM_InformIdentity+0xc4>)
    b218:	681b      	ldr	r3, [r3, #0]
    b21a:	2b00      	cmp	r3, #0
    b21c:	d026      	beq.n	b26c <USBPD_VDM_InformIdentity+0xac>
      {
        DPM_GUI_SaveInfo(PortNum, VDM_CABLE_INFO, (uint8_t*)pIdentity, sizeof(USBPD_DiscoveryIdentity_TypeDef));
    b21e:	4b19      	ldr	r3, [pc, #100]	; (b284 <USBPD_VDM_InformIdentity+0xc4>)
    b220:	681c      	ldr	r4, [r3, #0]
    b222:	687a      	ldr	r2, [r7, #4]
    b224:	230f      	movs	r3, #15
    b226:	18fb      	adds	r3, r7, r3
    b228:	7818      	ldrb	r0, [r3, #0]
    b22a:	2318      	movs	r3, #24
    b22c:	2114      	movs	r1, #20
    b22e:	47a0      	blx	r4
    }
    else
    break;
  case SVDM_RESPONDER_NAK :
    /* Nothing to do */
    break;
    b230:	e01c      	b.n	b26c <USBPD_VDM_InformIdentity+0xac>
  case SVDM_RESPONDER_BUSY :
    /* retry in 50ms */
    break;
  case SVDM_CABLE_NO_PD_CAPABLE :
    if (USBPD_SOPTYPE_SOP1 == SOPType)
    b232:	230e      	movs	r3, #14
    b234:	18fb      	adds	r3, r7, r3
    b236:	781b      	ldrb	r3, [r3, #0]
    b238:	2b01      	cmp	r3, #1
    b23a:	d119      	bne.n	b270 <USBPD_VDM_InformIdentity+0xb0>
    {
      USBPD_DPM_PE_VconnPwr(PortNum, USBPD_DISABLE);
    b23c:	240f      	movs	r4, #15
    b23e:	193b      	adds	r3, r7, r4
    b240:	781b      	ldrb	r3, [r3, #0]
    b242:	2100      	movs	r1, #0
    b244:	0018      	movs	r0, r3
    b246:	f7fe f8bd 	bl	93c4 <USBPD_DPM_PE_VconnPwr>
      /* No more need to request VCONN ON as CABLE is not PD capable. */
      DPM_Ports[PortNum].DPM_CablePDCapable = USBPD_FALSE;
    b24a:	193b      	adds	r3, r7, r4
    b24c:	781b      	ldrb	r3, [r3, #0]
    b24e:	4a0c      	ldr	r2, [pc, #48]	; (b280 <USBPD_VDM_InformIdentity+0xc0>)
    b250:	2160      	movs	r1, #96	; 0x60
    b252:	20b0      	movs	r0, #176	; 0xb0
    b254:	4343      	muls	r3, r0
    b256:	18d3      	adds	r3, r2, r3
    b258:	185b      	adds	r3, r3, r1
    b25a:	795a      	ldrb	r2, [r3, #5]
    b25c:	2101      	movs	r1, #1
    b25e:	438a      	bics	r2, r1
    b260:	715a      	strb	r2, [r3, #5]
    }
    break;
    b262:	e005      	b.n	b270 <USBPD_VDM_InformIdentity+0xb0>
    if (USBPD_SOPTYPE_SOP1 == SOPType)
    {
    }
    break;
  default :
    break;
    b264:	46c0      	nop			; (mov r8, r8)
    b266:	e004      	b.n	b272 <USBPD_VDM_InformIdentity+0xb2>
    break;
    b268:	46c0      	nop			; (mov r8, r8)
    b26a:	e002      	b.n	b272 <USBPD_VDM_InformIdentity+0xb2>
    break;
    b26c:	46c0      	nop			; (mov r8, r8)
    b26e:	e000      	b.n	b272 <USBPD_VDM_InformIdentity+0xb2>
    break;
    b270:	46c0      	nop			; (mov r8, r8)
  }
/* USER CODE END USBPD_VDM_InformIdentity */
}
    b272:	46c0      	nop			; (mov r8, r8)
    b274:	46bd      	mov	sp, r7
    b276:	b007      	add	sp, #28
    b278:	bd90      	pop	{r4, r7, pc}
    b27a:	46c0      	nop			; (mov r8, r8)
    b27c:	0001f3b4 	.word	0x0001f3b4
    b280:	0002fffc 	.word	0x0002fffc
    b284:	000300b4 	.word	0x000300b4

0000b288 <USBPD_VDM_InformSVID>:
  * @param  CommandStatus Command status based on @ref USBPD_VDM_CommandType_Typedef
  * @param  pListSVID     Pointer of list of SVID based on @ref USBPD_SVIDInfo_TypeDef
  * @retval None
  */
static void USBPD_VDM_InformSVID(uint8_t PortNum, USBPD_SOPType_TypeDef SOPType, USBPD_VDM_CommandType_Typedef CommandStatus, USBPD_SVIDInfo_TypeDef *pListSVID)
{
    b288:	b580      	push	{r7, lr}
    b28a:	b084      	sub	sp, #16
    b28c:	af00      	add	r7, sp, #0
    b28e:	60ba      	str	r2, [r7, #8]
    b290:	607b      	str	r3, [r7, #4]
    b292:	230f      	movs	r3, #15
    b294:	18fb      	adds	r3, r7, r3
    b296:	1c02      	adds	r2, r0, #0
    b298:	701a      	strb	r2, [r3, #0]
    b29a:	230e      	movs	r3, #14
    b29c:	18fb      	adds	r3, r7, r3
    b29e:	1c0a      	adds	r2, r1, #0
    b2a0:	701a      	strb	r2, [r3, #0]
/* USER CODE BEGIN USBPD_VDM_InformSVID */
/* USER CODE END USBPD_VDM_InformSVID */
}
    b2a2:	46c0      	nop			; (mov r8, r8)
    b2a4:	46bd      	mov	sp, r7
    b2a6:	b004      	add	sp, #16
    b2a8:	bd80      	pop	{r7, pc}

0000b2aa <USBPD_VDM_InformMode>:
  * @param  CommandStatus   Command status based on @ref USBPD_VDM_CommandType_Typedef
  * @param  pModesInfo      Pointer of Modes info based on @ref USBPD_ModeInfo_TypeDef
  * @retval None
  */
static void USBPD_VDM_InformMode(uint8_t PortNum, USBPD_SOPType_TypeDef SOPType, USBPD_VDM_CommandType_Typedef CommandStatus, USBPD_ModeInfo_TypeDef *pModesInfo)
{
    b2aa:	b580      	push	{r7, lr}
    b2ac:	b084      	sub	sp, #16
    b2ae:	af00      	add	r7, sp, #0
    b2b0:	60ba      	str	r2, [r7, #8]
    b2b2:	607b      	str	r3, [r7, #4]
    b2b4:	230f      	movs	r3, #15
    b2b6:	18fb      	adds	r3, r7, r3
    b2b8:	1c02      	adds	r2, r0, #0
    b2ba:	701a      	strb	r2, [r3, #0]
    b2bc:	230e      	movs	r3, #14
    b2be:	18fb      	adds	r3, r7, r3
    b2c0:	1c0a      	adds	r2, r1, #0
    b2c2:	701a      	strb	r2, [r3, #0]
/* USER CODE BEGIN USBPD_VDM_InformMode */
/* USER CODE END USBPD_VDM_InformMode */
}
    b2c4:	46c0      	nop			; (mov r8, r8)
    b2c6:	46bd      	mov	sp, r7
    b2c8:	b004      	add	sp, #16
    b2ca:	bd80      	pop	{r7, pc}

0000b2cc <USBPD_VDM_InformModeEnter>:
  * @param  SVID      SVID ID
  * @param  ModeIndex Index of the mode to be entered
  * @retval None
  */
static void USBPD_VDM_InformModeEnter(uint8_t PortNum, USBPD_SOPType_TypeDef SOPType, USBPD_VDM_CommandType_Typedef CommandStatus, uint16_t SVID, uint32_t ModeIndex)
{
    b2cc:	b590      	push	{r4, r7, lr}
    b2ce:	b083      	sub	sp, #12
    b2d0:	af00      	add	r7, sp, #0
    b2d2:	0004      	movs	r4, r0
    b2d4:	0008      	movs	r0, r1
    b2d6:	603a      	str	r2, [r7, #0]
    b2d8:	0019      	movs	r1, r3
    b2da:	1dfb      	adds	r3, r7, #7
    b2dc:	1c22      	adds	r2, r4, #0
    b2de:	701a      	strb	r2, [r3, #0]
    b2e0:	1dbb      	adds	r3, r7, #6
    b2e2:	1c02      	adds	r2, r0, #0
    b2e4:	701a      	strb	r2, [r3, #0]
    b2e6:	1d3b      	adds	r3, r7, #4
    b2e8:	1c0a      	adds	r2, r1, #0
    b2ea:	801a      	strh	r2, [r3, #0]
/* USER CODE BEGIN USBPD_VDM_InformModeEnter */
/* USER CODE END USBPD_VDM_InformModeEnter */
}
    b2ec:	46c0      	nop			; (mov r8, r8)
    b2ee:	46bd      	mov	sp, r7
    b2f0:	b003      	add	sp, #12
    b2f2:	bd90      	pop	{r4, r7, pc}

0000b2f4 <USBPD_VDM_InformModeExit>:
  * @param  SVID      SVID ID
  * @param  ModeIndex Index of the mode to be entered
  * @retval None
  */
static void USBPD_VDM_InformModeExit(uint8_t PortNum, USBPD_SOPType_TypeDef SOPType, USBPD_VDM_CommandType_Typedef CommandStatus, uint16_t SVID, uint32_t ModeIndex)
{
    b2f4:	b590      	push	{r4, r7, lr}
    b2f6:	b083      	sub	sp, #12
    b2f8:	af00      	add	r7, sp, #0
    b2fa:	0004      	movs	r4, r0
    b2fc:	0008      	movs	r0, r1
    b2fe:	603a      	str	r2, [r7, #0]
    b300:	0019      	movs	r1, r3
    b302:	1dfb      	adds	r3, r7, #7
    b304:	1c22      	adds	r2, r4, #0
    b306:	701a      	strb	r2, [r3, #0]
    b308:	1dbb      	adds	r3, r7, #6
    b30a:	1c02      	adds	r2, r0, #0
    b30c:	701a      	strb	r2, [r3, #0]
    b30e:	1d3b      	adds	r3, r7, #4
    b310:	1c0a      	adds	r2, r1, #0
    b312:	801a      	strh	r2, [r3, #0]
/* USER CODE BEGIN USBPD_VDM_InformModeExit */
/* USER CODE END USBPD_VDM_InformModeExit */
}
    b314:	46c0      	nop			; (mov r8, r8)
    b316:	46bd      	mov	sp, r7
    b318:	b003      	add	sp, #12
    b31a:	bd90      	pop	{r4, r7, pc}

0000b31c <USBPD_VDM_SendSpecific>:
  * @param  pNbData    Pointer of number of VDO to send
  * @param  pVDO       Pointer of VDO to send
  * @retval None
  */
static void USBPD_VDM_SendSpecific(uint8_t PortNum, USBPD_SOPType_TypeDef SOPType, USBPD_VDM_Command_Typedef VDMCommand, uint8_t *pNbData, uint32_t *pVDO)
{
    b31c:	b580      	push	{r7, lr}
    b31e:	b084      	sub	sp, #16
    b320:	af00      	add	r7, sp, #0
    b322:	60ba      	str	r2, [r7, #8]
    b324:	607b      	str	r3, [r7, #4]
    b326:	230f      	movs	r3, #15
    b328:	18fb      	adds	r3, r7, r3
    b32a:	1c02      	adds	r2, r0, #0
    b32c:	701a      	strb	r2, [r3, #0]
    b32e:	230e      	movs	r3, #14
    b330:	18fb      	adds	r3, r7, r3
    b332:	1c0a      	adds	r2, r1, #0
    b334:	701a      	strb	r2, [r3, #0]
  }
  else
{
  }
/* USER CODE END USBPD_VDM_SendSpecific */
}
    b336:	46c0      	nop			; (mov r8, r8)
    b338:	46bd      	mov	sp, r7
    b33a:	b004      	add	sp, #16
    b33c:	bd80      	pop	{r7, pc}

0000b33e <USBPD_VDM_InformSpecific>:
  * @param  pNbData    Pointer of number of received VDO
  * @param  pVDO       Pointer of received VDO
  * @retval None
  */
static void USBPD_VDM_InformSpecific(uint8_t PortNum, USBPD_SOPType_TypeDef SOPType, USBPD_VDM_Command_Typedef VDMCommand, uint8_t *pNbData, uint32_t *pVDO)
{
    b33e:	b580      	push	{r7, lr}
    b340:	b084      	sub	sp, #16
    b342:	af00      	add	r7, sp, #0
    b344:	60ba      	str	r2, [r7, #8]
    b346:	607b      	str	r3, [r7, #4]
    b348:	230f      	movs	r3, #15
    b34a:	18fb      	adds	r3, r7, r3
    b34c:	1c02      	adds	r2, r0, #0
    b34e:	701a      	strb	r2, [r3, #0]
    b350:	230e      	movs	r3, #14
    b352:	18fb      	adds	r3, r7, r3
    b354:	1c0a      	adds	r2, r1, #0
    b356:	701a      	strb	r2, [r3, #0]
  }
  else
  {
  }
/* USER CODE END USBPD_VDM_InformSpecific */
}
    b358:	46c0      	nop			; (mov r8, r8)
    b35a:	46bd      	mov	sp, r7
    b35c:	b004      	add	sp, #16
    b35e:	bd80      	pop	{r7, pc}

0000b360 <USBPD_VDM_UserInit>:
  * @brief  VDM Initialization function
  * @param  PortNum     Index of current used port
  * @retval status
  */
USBPD_StatusTypeDef USBPD_VDM_UserInit(uint8_t PortNum)
{
    b360:	b580      	push	{r7, lr}
    b362:	b082      	sub	sp, #8
    b364:	af00      	add	r7, sp, #0
    b366:	0002      	movs	r2, r0
    b368:	1dfb      	adds	r3, r7, #7
    b36a:	701a      	strb	r2, [r3, #0]
/* USER CODE BEGIN USBPD_VDM_UserInit */
  USBPD_PE_InitVDM_Callback(PortNum, (USBPD_VDM_Callbacks *)&vdmCallbacks);
    b36c:	4a05      	ldr	r2, [pc, #20]	; (b384 <USBPD_VDM_UserInit+0x24>)
    b36e:	1dfb      	adds	r3, r7, #7
    b370:	781b      	ldrb	r3, [r3, #0]
    b372:	0011      	movs	r1, r2
    b374:	0018      	movs	r0, r3
    b376:	f00e ff01 	bl	1a17c <USBPD_PE_InitVDM_Callback>
  return USBPD_OK;
    b37a:	2300      	movs	r3, #0
/* USER CODE END USBPD_VDM_UserInit */
}
    b37c:	0018      	movs	r0, r3
    b37e:	46bd      	mov	sp, r7
    b380:	b002      	add	sp, #8
    b382:	bd80      	pop	{r7, pc}
    b384:	0001f370 	.word	0x0001f370

0000b388 <fusb305_tcpc_init>:
  *         @arg @ref USBPD_PORTPOWERROLE_DRP_SRC
  *         @arg @ref USBPD_PORTPOWERROLE_DRP_SNK
  * @retval USBPD status
  */
USBPD_StatusTypeDef fusb305_tcpc_init(uint32_t Port, USBPD_PortPowerRole_TypeDef Role, uint8_t ToggleRole, uint8_t (*IsSwapOngoing)(uint8_t))
{
    b388:	b5f0      	push	{r4, r5, r6, r7, lr}
    b38a:	b087      	sub	sp, #28
    b38c:	af00      	add	r7, sp, #0
    b38e:	60f8      	str	r0, [r7, #12]
    b390:	60b9      	str	r1, [r7, #8]
    b392:	603b      	str	r3, [r7, #0]
    b394:	1dfb      	adds	r3, r7, #7
    b396:	701a      	strb	r2, [r3, #0]
  USBPD_StatusTypeDef usbpd_status = USBPD_FAIL;
    b398:	2117      	movs	r1, #23
    b39a:	187b      	adds	r3, r7, r1
    b39c:	2210      	movs	r2, #16
    b39e:	701a      	strb	r2, [r3, #0]
  uint8_t power_status = 1;
    b3a0:	2615      	movs	r6, #21
    b3a2:	19bb      	adds	r3, r7, r6
    b3a4:	2201      	movs	r2, #1
    b3a6:	701a      	strb	r2, [r3, #0]

  /* Reset FUSB305 */
  usbpd_status = USBPD_TCPCI_WriteRegister(Port, 0xA2, (uint8_t*)&power_status, 2);
    b3a8:	68fb      	ldr	r3, [r7, #12]
    b3aa:	b2d8      	uxtb	r0, r3
    b3ac:	000d      	movs	r5, r1
    b3ae:	187c      	adds	r4, r7, r1
    b3b0:	19ba      	adds	r2, r7, r6
    b3b2:	2302      	movs	r3, #2
    b3b4:	21a2      	movs	r1, #162	; 0xa2
    b3b6:	f002 fdf7 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
    b3ba:	0003      	movs	r3, r0
    b3bc:	7023      	strb	r3, [r4, #0]
  __ASM volatile ("cpsie i" : : : "memory");
    b3be:	b662      	cpsie	i
  /* Enable IRQ which has been disabled by FreeRTOS services */
  __enable_irq();

  /* all other variables assumed to default to 0 */
  usbpd_status = InitializeRegisters(Port);
    b3c0:	197c      	adds	r4, r7, r5
    b3c2:	68fb      	ldr	r3, [r7, #12]
    b3c4:	0018      	movs	r0, r3
    b3c6:	f002 fa23 	bl	d810 <InitializeRegisters>
    b3ca:	0003      	movs	r3, r0
    b3cc:	7023      	strb	r3, [r4, #0]
  if (USBPD_OK != usbpd_status)
    b3ce:	197b      	adds	r3, r7, r5
    b3d0:	781b      	ldrb	r3, [r3, #0]
    b3d2:	2b00      	cmp	r3, #0
    b3d4:	d000      	beq.n	b3d8 <fusb305_tcpc_init+0x50>
    b3d6:	e1ef      	b.n	b7b8 <fusb305_tcpc_init+0x430>
  {
    goto exit;
  }

  /* Save the CAD callback to check if PR swap is ongoing */
  state[Port].IsSwapOngoing        = IsSwapOngoing;
    b3d8:	49d6      	ldr	r1, [pc, #856]	; (b734 <fusb305_tcpc_init+0x3ac>)
    b3da:	68fa      	ldr	r2, [r7, #12]
    b3dc:	0013      	movs	r3, r2
    b3de:	015b      	lsls	r3, r3, #5
    b3e0:	189b      	adds	r3, r3, r2
    b3e2:	009b      	lsls	r3, r3, #2
    b3e4:	18cb      	adds	r3, r1, r3
    b3e6:	3378      	adds	r3, #120	; 0x78
    b3e8:	683a      	ldr	r2, [r7, #0]
    b3ea:	601a      	str	r2, [r3, #0]
   * TCPM shall check the state of the TCPC Initialization Status bit when it starts or resets. 
   * TCPM shall not start normal operation until the TCPC Initialization Status bit is cleared.
   */
  while (1) 
  {
    usbpd_status = fusb305_tcpc_get_power_status(Port, &power_status);
    b3ec:	2517      	movs	r5, #23
    b3ee:	197c      	adds	r4, r7, r5
    b3f0:	2315      	movs	r3, #21
    b3f2:	18fa      	adds	r2, r7, r3
    b3f4:	68fb      	ldr	r3, [r7, #12]
    b3f6:	0011      	movs	r1, r2
    b3f8:	0018      	movs	r0, r3
    b3fa:	f001 f93f 	bl	c67c <fusb305_tcpc_get_power_status>
    b3fe:	0003      	movs	r3, r0
    b400:	7023      	strb	r3, [r4, #0]
    /*
     * If read succeeds and the uninitialized bit is clear, then
     * initalization is complete, clear all alert bits and write
     * the initial alert mask.
     */
    if ((usbpd_status == USBPD_OK) && !(power_status & TCPC_REG_POWER_STATUS_MASK_TCPC_INIT)) 
    b402:	197b      	adds	r3, r7, r5
    b404:	781b      	ldrb	r3, [r3, #0]
    b406:	2b00      	cmp	r3, #0
    b408:	d1f0      	bne.n	b3ec <fusb305_tcpc_init+0x64>
    b40a:	2315      	movs	r3, #21
    b40c:	18fb      	adds	r3, r7, r3
    b40e:	781b      	ldrb	r3, [r3, #0]
    b410:	001a      	movs	r2, r3
    b412:	2340      	movs	r3, #64	; 0x40
    b414:	4013      	ands	r3, r2
    b416:	d1e9      	bne.n	b3ec <fusb305_tcpc_init+0x64>
    {
      /* Initialize power role */
      state[Port].PowerRole     = USBPD_PORTPOWERROLE_SNK;
    b418:	49c6      	ldr	r1, [pc, #792]	; (b734 <fusb305_tcpc_init+0x3ac>)
    b41a:	68fa      	ldr	r2, [r7, #12]
    b41c:	0013      	movs	r3, r2
    b41e:	015b      	lsls	r3, r3, #5
    b420:	189b      	adds	r3, r3, r2
    b422:	009b      	lsls	r3, r3, #2
    b424:	18cb      	adds	r3, r1, r3
    b426:	3368      	adds	r3, #104	; 0x68
    b428:	2200      	movs	r2, #0
    b42a:	601a      	str	r2, [r3, #0]
      state[Port].DataRole      = USBPD_PORTDATAROLE_UFP;
    b42c:	49c1      	ldr	r1, [pc, #772]	; (b734 <fusb305_tcpc_init+0x3ac>)
    b42e:	68fa      	ldr	r2, [r7, #12]
    b430:	0013      	movs	r3, r2
    b432:	015b      	lsls	r3, r3, #5
    b434:	189b      	adds	r3, r3, r2
    b436:	009b      	lsls	r3, r3, #2
    b438:	18cb      	adds	r3, r1, r3
    b43a:	336c      	adds	r3, #108	; 0x6c
    b43c:	2200      	movs	r2, #0
    b43e:	601a      	str	r2, [r3, #0]
      state[Port].CC_Pull       = TYPEC_CC_OPEN;
    b440:	49bc      	ldr	r1, [pc, #752]	; (b734 <fusb305_tcpc_init+0x3ac>)
    b442:	68fa      	ldr	r2, [r7, #12]
    b444:	2070      	movs	r0, #112	; 0x70
    b446:	0013      	movs	r3, r2
    b448:	015b      	lsls	r3, r3, #5
    b44a:	189b      	adds	r3, r3, r2
    b44c:	009b      	lsls	r3, r3, #2
    b44e:	18cb      	adds	r3, r1, r3
    b450:	181b      	adds	r3, r3, r0
    b452:	2203      	movs	r2, #3
    b454:	701a      	strb	r2, [r3, #0]
      state[Port].VConnPresence = TYPEC_CC_OPEN;
    b456:	49b7      	ldr	r1, [pc, #732]	; (b734 <fusb305_tcpc_init+0x3ac>)
    b458:	68fa      	ldr	r2, [r7, #12]
    b45a:	2073      	movs	r0, #115	; 0x73
    b45c:	0013      	movs	r3, r2
    b45e:	015b      	lsls	r3, r3, #5
    b460:	189b      	adds	r3, r3, r2
    b462:	009b      	lsls	r3, r3, #2
    b464:	18cb      	adds	r3, r1, r3
    b466:	181b      	adds	r3, r3, r0
    b468:	2203      	movs	r2, #3
    b46a:	701a      	strb	r2, [r3, #0]
      
      if (usbpd_status == USBPD_OK)
    b46c:	2317      	movs	r3, #23
    b46e:	18fb      	adds	r3, r7, r3
    b470:	781b      	ldrb	r3, [r3, #0]
    b472:	2b00      	cmp	r3, #0
    b474:	d1ba      	bne.n	b3ec <fusb305_tcpc_init+0x64>
      {
        TCPC_CC_Pull_TypeDef cc_value  = TYPEC_CC_OPEN;
    b476:	2316      	movs	r3, #22
    b478:	18fb      	adds	r3, r7, r3
    b47a:	2203      	movs	r2, #3
    b47c:	701a      	strb	r2, [r3, #0]
        /* Initialize power_status_mask */
        if (tcpc_init_power_status_mask(Port) != USBPD_OK)
    b47e:	68fb      	ldr	r3, [r7, #12]
    b480:	0018      	movs	r0, r3
    b482:	f002 fad3 	bl	da2c <tcpc_init_power_status_mask>
    b486:	1e03      	subs	r3, r0, #0
    b488:	d004      	beq.n	b494 <fusb305_tcpc_init+0x10c>
        {
          usbpd_status = USBPD_ERROR;
    b48a:	2317      	movs	r3, #23
    b48c:	18fb      	adds	r3, r7, r3
    b48e:	2202      	movs	r2, #2
    b490:	701a      	strb	r2, [r3, #0]
          goto exit;
    b492:	e192      	b.n	b7ba <fusb305_tcpc_init+0x432>
        }
        
        /* Initialize alert mask*/
        if (tcpc_set_alert_mask(Port, TYPEC_CC_OPEN, USBPD_DISABLE) != USBPD_OK)
    b494:	68fb      	ldr	r3, [r7, #12]
    b496:	2200      	movs	r2, #0
    b498:	2103      	movs	r1, #3
    b49a:	0018      	movs	r0, r3
    b49c:	f002 f9fa 	bl	d894 <tcpc_set_alert_mask>
    b4a0:	1e03      	subs	r3, r0, #0
    b4a2:	d004      	beq.n	b4ae <fusb305_tcpc_init+0x126>
        {
          usbpd_status = USBPD_ERROR;
    b4a4:	2317      	movs	r3, #23
    b4a6:	18fb      	adds	r3, r7, r3
    b4a8:	2202      	movs	r2, #2
    b4aa:	701a      	strb	r2, [r3, #0]
          goto exit;
    b4ac:	e185      	b.n	b7ba <fusb305_tcpc_init+0x432>
        }

        /* Disable all the VD interrupt */
        state[Port].Vendor.ALERT_VD_MASK = 0;
    b4ae:	49a1      	ldr	r1, [pc, #644]	; (b734 <fusb305_tcpc_init+0x3ac>)
    b4b0:	68fa      	ldr	r2, [r7, #12]
    b4b2:	2066      	movs	r0, #102	; 0x66
    b4b4:	0013      	movs	r3, r2
    b4b6:	015b      	lsls	r3, r3, #5
    b4b8:	189b      	adds	r3, r3, r2
    b4ba:	009b      	lsls	r3, r3, #2
    b4bc:	18cb      	adds	r3, r1, r3
    b4be:	181b      	adds	r3, r3, r0
    b4c0:	2200      	movs	r2, #0
    b4c2:	701a      	strb	r2, [r3, #0]
        USBPD_TCPCI_WriteRegister(Port, TCPC_REG_ALERT_VD_MASK, (uint8_t*)&state[Port].Vendor.ALERT_VD_MASK, 1);
    b4c4:	68fb      	ldr	r3, [r7, #12]
    b4c6:	b2d8      	uxtb	r0, r3
    b4c8:	68fa      	ldr	r2, [r7, #12]
    b4ca:	0013      	movs	r3, r2
    b4cc:	015b      	lsls	r3, r3, #5
    b4ce:	189b      	adds	r3, r3, r2
    b4d0:	009b      	lsls	r3, r3, #2
    b4d2:	3360      	adds	r3, #96	; 0x60
    b4d4:	001a      	movs	r2, r3
    b4d6:	4b97      	ldr	r3, [pc, #604]	; (b734 <fusb305_tcpc_init+0x3ac>)
    b4d8:	18d3      	adds	r3, r2, r3
    b4da:	1d9a      	adds	r2, r3, #6
    b4dc:	2301      	movs	r3, #1
    b4de:	21b4      	movs	r1, #180	; 0xb4
    b4e0:	f002 fd62 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
        /*  
            GPIO1 can be used to prevent the FPF3695 from closing the sink path automatically when in dead battery condition.
            It allows you to disable the entire FPF3695, regardless of attach state.
            Most systems are ok with closing the path on attach, so GPIO1 should be driven low (enabled).
        */
        state[Port].Vendor.GPO1_EN = 1;
    b4e4:	4993      	ldr	r1, [pc, #588]	; (b734 <fusb305_tcpc_init+0x3ac>)
    b4e6:	68fa      	ldr	r2, [r7, #12]
    b4e8:	2050      	movs	r0, #80	; 0x50
    b4ea:	0013      	movs	r3, r2
    b4ec:	015b      	lsls	r3, r3, #5
    b4ee:	189b      	adds	r3, r3, r2
    b4f0:	009b      	lsls	r3, r3, #2
    b4f2:	18cb      	adds	r3, r1, r3
    b4f4:	181b      	adds	r3, r3, r0
    b4f6:	799a      	ldrb	r2, [r3, #6]
    b4f8:	2101      	movs	r1, #1
    b4fa:	430a      	orrs	r2, r1
    b4fc:	719a      	strb	r2, [r3, #6]
        USBPD_TCPCI_WriteRegister(Port, TCPC_REG_GPIO1_CFG, (uint8_t*)&state[Port].Vendor.GPIO1_CFG, 1);
    b4fe:	68fb      	ldr	r3, [r7, #12]
    b500:	b2d8      	uxtb	r0, r3
    b502:	68fa      	ldr	r2, [r7, #12]
    b504:	0013      	movs	r3, r2
    b506:	015b      	lsls	r3, r3, #5
    b508:	189b      	adds	r3, r3, r2
    b50a:	009b      	lsls	r3, r3, #2
    b50c:	3350      	adds	r3, #80	; 0x50
    b50e:	001a      	movs	r2, r3
    b510:	4b88      	ldr	r3, [pc, #544]	; (b734 <fusb305_tcpc_init+0x3ac>)
    b512:	18d3      	adds	r3, r2, r3
    b514:	1d9a      	adds	r2, r3, #6
    b516:	2301      	movs	r3, #1
    b518:	21a4      	movs	r1, #164	; 0xa4
    b51a:	f002 fd45 	bl	dfa8 <USBPD_TCPCI_WriteRegister>

        /* Disable RX_DETECT in waiting for connection */
        state[Port].Registers.FrameInfo.u2.RECEIVE_DETECT = 0;
    b51e:	4985      	ldr	r1, [pc, #532]	; (b734 <fusb305_tcpc_init+0x3ac>)
    b520:	68fa      	ldr	r2, [r7, #12]
    b522:	2023      	movs	r0, #35	; 0x23
    b524:	0013      	movs	r3, r2
    b526:	015b      	lsls	r3, r3, #5
    b528:	189b      	adds	r3, r3, r2
    b52a:	009b      	lsls	r3, r3, #2
    b52c:	18cb      	adds	r3, r1, r3
    b52e:	181b      	adds	r3, r3, r0
    b530:	2200      	movs	r2, #0
    b532:	701a      	strb	r2, [r3, #0]
        USBPD_TCPCI_WriteRegister(Port, TCPC_REG_RX_DETECT, (uint8_t*)&state[Port].Registers.FrameInfo.u2.RECEIVE_DETECT, 1);
    b534:	68fb      	ldr	r3, [r7, #12]
    b536:	b2d8      	uxtb	r0, r3
    b538:	68fa      	ldr	r2, [r7, #12]
    b53a:	0013      	movs	r3, r2
    b53c:	015b      	lsls	r3, r3, #5
    b53e:	189b      	adds	r3, r3, r2
    b540:	009b      	lsls	r3, r3, #2
    b542:	3320      	adds	r3, #32
    b544:	001a      	movs	r2, r3
    b546:	4b7b      	ldr	r3, [pc, #492]	; (b734 <fusb305_tcpc_init+0x3ac>)
    b548:	18d3      	adds	r3, r2, r3
    b54a:	1cda      	adds	r2, r3, #3
    b54c:	2301      	movs	r3, #1
    b54e:	212f      	movs	r1, #47	; 0x2f
    b550:	f002 fd2a 	bl	dfa8 <USBPD_TCPCI_WriteRegister>

        /* Disable SOURCE VBUS */
        state[Port].Registers.Command.u.COMMAND = TCPC_REG_COMMAND_DISABLE_SRC_VBUS;
    b554:	4977      	ldr	r1, [pc, #476]	; (b734 <fusb305_tcpc_init+0x3ac>)
    b556:	68fa      	ldr	r2, [r7, #12]
    b558:	0013      	movs	r3, r2
    b55a:	015b      	lsls	r3, r3, #5
    b55c:	189b      	adds	r3, r3, r2
    b55e:	009b      	lsls	r3, r3, #2
    b560:	18cb      	adds	r3, r1, r3
    b562:	331a      	adds	r3, #26
    b564:	2266      	movs	r2, #102	; 0x66
    b566:	701a      	strb	r2, [r3, #0]
        if (USBPD_TCPCI_WriteRegister(Port, TCPC_REG_COMMAND, &state[Port].Registers.Command.u.COMMAND, 1) != USBPD_OK)
    b568:	68fb      	ldr	r3, [r7, #12]
    b56a:	b2d8      	uxtb	r0, r3
    b56c:	68fa      	ldr	r2, [r7, #12]
    b56e:	0013      	movs	r3, r2
    b570:	015b      	lsls	r3, r3, #5
    b572:	189b      	adds	r3, r3, r2
    b574:	009b      	lsls	r3, r3, #2
    b576:	3318      	adds	r3, #24
    b578:	001a      	movs	r2, r3
    b57a:	4b6e      	ldr	r3, [pc, #440]	; (b734 <fusb305_tcpc_init+0x3ac>)
    b57c:	18d3      	adds	r3, r2, r3
    b57e:	1c9a      	adds	r2, r3, #2
    b580:	2301      	movs	r3, #1
    b582:	2123      	movs	r1, #35	; 0x23
    b584:	f002 fd10 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
    b588:	1e03      	subs	r3, r0, #0
    b58a:	d004      	beq.n	b596 <fusb305_tcpc_init+0x20e>
        {
          usbpd_status = USBPD_ERROR;
    b58c:	2317      	movs	r3, #23
    b58e:	18fb      	adds	r3, r7, r3
    b590:	2202      	movs	r2, #2
    b592:	701a      	strb	r2, [r3, #0]
          goto exit;
    b594:	e111      	b.n	b7ba <fusb305_tcpc_init+0x432>
        }

        /* Disable SOURCE VBUS */
        state[Port].Registers.Command.u.COMMAND = TCPC_REG_COMMAND_DISABLE_VBUS_DETECT;
    b596:	4967      	ldr	r1, [pc, #412]	; (b734 <fusb305_tcpc_init+0x3ac>)
    b598:	68fa      	ldr	r2, [r7, #12]
    b59a:	0013      	movs	r3, r2
    b59c:	015b      	lsls	r3, r3, #5
    b59e:	189b      	adds	r3, r3, r2
    b5a0:	009b      	lsls	r3, r3, #2
    b5a2:	18cb      	adds	r3, r1, r3
    b5a4:	331a      	adds	r3, #26
    b5a6:	2222      	movs	r2, #34	; 0x22
    b5a8:	701a      	strb	r2, [r3, #0]
        if (USBPD_TCPCI_WriteRegister(Port, TCPC_REG_COMMAND, &state[Port].Registers.Command.u.COMMAND, 1) != USBPD_OK)
    b5aa:	68fb      	ldr	r3, [r7, #12]
    b5ac:	b2d8      	uxtb	r0, r3
    b5ae:	68fa      	ldr	r2, [r7, #12]
    b5b0:	0013      	movs	r3, r2
    b5b2:	015b      	lsls	r3, r3, #5
    b5b4:	189b      	adds	r3, r3, r2
    b5b6:	009b      	lsls	r3, r3, #2
    b5b8:	3318      	adds	r3, #24
    b5ba:	001a      	movs	r2, r3
    b5bc:	4b5d      	ldr	r3, [pc, #372]	; (b734 <fusb305_tcpc_init+0x3ac>)
    b5be:	18d3      	adds	r3, r2, r3
    b5c0:	1c9a      	adds	r2, r3, #2
    b5c2:	2301      	movs	r3, #1
    b5c4:	2123      	movs	r1, #35	; 0x23
    b5c6:	f002 fcef 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
    b5ca:	1e03      	subs	r3, r0, #0
    b5cc:	d004      	beq.n	b5d8 <fusb305_tcpc_init+0x250>
        {
          usbpd_status = USBPD_ERROR;
    b5ce:	2317      	movs	r3, #23
    b5d0:	18fb      	adds	r3, r7, r3
    b5d2:	2202      	movs	r2, #2
    b5d4:	701a      	strb	r2, [r3, #0]
          goto exit;
    b5d6:	e0f0      	b.n	b7ba <fusb305_tcpc_init+0x432>
        }

        /* Reset Power control register */
        state[Port].Registers.Control.s.u5.POWER_CONTROL = 0;
    b5d8:	4956      	ldr	r1, [pc, #344]	; (b734 <fusb305_tcpc_init+0x3ac>)
    b5da:	68fa      	ldr	r2, [r7, #12]
    b5dc:	0013      	movs	r3, r2
    b5de:	015b      	lsls	r3, r3, #5
    b5e0:	189b      	adds	r3, r3, r2
    b5e2:	009b      	lsls	r3, r3, #2
    b5e4:	18cb      	adds	r3, r1, r3
    b5e6:	3316      	adds	r3, #22
    b5e8:	2200      	movs	r2, #0
    b5ea:	701a      	strb	r2, [r3, #0]
        state[Port].Registers.Control.s.u5.b5.DIS_VALRM   = 1;
    b5ec:	4951      	ldr	r1, [pc, #324]	; (b734 <fusb305_tcpc_init+0x3ac>)
    b5ee:	68fa      	ldr	r2, [r7, #12]
    b5f0:	2010      	movs	r0, #16
    b5f2:	0013      	movs	r3, r2
    b5f4:	015b      	lsls	r3, r3, #5
    b5f6:	189b      	adds	r3, r3, r2
    b5f8:	009b      	lsls	r3, r3, #2
    b5fa:	18cb      	adds	r3, r1, r3
    b5fc:	181b      	adds	r3, r3, r0
    b5fe:	799a      	ldrb	r2, [r3, #6]
    b600:	2120      	movs	r1, #32
    b602:	430a      	orrs	r2, r1
    b604:	719a      	strb	r2, [r3, #6]
        if (USBPD_TCPCI_WriteRegister(Port, TCPC_REG_POWER_CONTROL, &state[Port].Registers.Control.s.u5.POWER_CONTROL, 1) != USBPD_OK)
    b606:	68fb      	ldr	r3, [r7, #12]
    b608:	b2d8      	uxtb	r0, r3
    b60a:	68fa      	ldr	r2, [r7, #12]
    b60c:	0013      	movs	r3, r2
    b60e:	015b      	lsls	r3, r3, #5
    b610:	189b      	adds	r3, r3, r2
    b612:	009b      	lsls	r3, r3, #2
    b614:	3310      	adds	r3, #16
    b616:	001a      	movs	r2, r3
    b618:	4b46      	ldr	r3, [pc, #280]	; (b734 <fusb305_tcpc_init+0x3ac>)
    b61a:	18d3      	adds	r3, r2, r3
    b61c:	1d9a      	adds	r2, r3, #6
    b61e:	2301      	movs	r3, #1
    b620:	211c      	movs	r1, #28
    b622:	f002 fcc1 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
    b626:	1e03      	subs	r3, r0, #0
    b628:	d004      	beq.n	b634 <fusb305_tcpc_init+0x2ac>
        {
          usbpd_status = USBPD_ERROR;
    b62a:	2317      	movs	r3, #23
    b62c:	18fb      	adds	r3, r7, r3
    b62e:	2202      	movs	r2, #2
    b630:	701a      	strb	r2, [r3, #0]
          goto exit;
    b632:	e0c2      	b.n	b7ba <fusb305_tcpc_init+0x432>
        }
          /* Initialize VBUS Threshold */
        state[Port].Registers.VBUS.s.VBUS_VOLTAGE_ALARM_HI_CFG   = 840;
    b634:	493f      	ldr	r1, [pc, #252]	; (b734 <fusb305_tcpc_init+0x3ac>)
    b636:	68fa      	ldr	r2, [r7, #12]
    b638:	204e      	movs	r0, #78	; 0x4e
    b63a:	0013      	movs	r3, r2
    b63c:	015b      	lsls	r3, r3, #5
    b63e:	189b      	adds	r3, r3, r2
    b640:	009b      	lsls	r3, r3, #2
    b642:	18cb      	adds	r3, r1, r3
    b644:	181b      	adds	r3, r3, r0
    b646:	22d2      	movs	r2, #210	; 0xd2
    b648:	0092      	lsls	r2, r2, #2
    b64a:	801a      	strh	r2, [r3, #0]
        if (USBPD_TCPCI_WriteRegister(Port, TCPC_REG_VBUS_VOLTAGE_ALARM_HI_CFG, (uint8_t*)&state[Port].Registers.VBUS.s.VBUS_VOLTAGE_ALARM_HI_CFG, 2) != USBPD_OK)
    b64c:	68fb      	ldr	r3, [r7, #12]
    b64e:	b2d8      	uxtb	r0, r3
    b650:	68fa      	ldr	r2, [r7, #12]
    b652:	0013      	movs	r3, r2
    b654:	015b      	lsls	r3, r3, #5
    b656:	189b      	adds	r3, r3, r2
    b658:	009b      	lsls	r3, r3, #2
    b65a:	3348      	adds	r3, #72	; 0x48
    b65c:	001a      	movs	r2, r3
    b65e:	4b35      	ldr	r3, [pc, #212]	; (b734 <fusb305_tcpc_init+0x3ac>)
    b660:	18d3      	adds	r3, r2, r3
    b662:	1d9a      	adds	r2, r3, #6
    b664:	2302      	movs	r3, #2
    b666:	2176      	movs	r1, #118	; 0x76
    b668:	f002 fc9e 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
    b66c:	1e03      	subs	r3, r0, #0
    b66e:	d004      	beq.n	b67a <fusb305_tcpc_init+0x2f2>
        {
          usbpd_status = USBPD_ERROR;
    b670:	2317      	movs	r3, #23
    b672:	18fb      	adds	r3, r7, r3
    b674:	2202      	movs	r2, #2
    b676:	701a      	strb	r2, [r3, #0]
          goto exit;
    b678:	e09f      	b.n	b7ba <fusb305_tcpc_init+0x432>
        }
        
        state[Port].Registers.VBUS.s.VBUS_VOLTAGE_ALARM_LO_CFG   = 32;
    b67a:	492e      	ldr	r1, [pc, #184]	; (b734 <fusb305_tcpc_init+0x3ac>)
    b67c:	68fa      	ldr	r2, [r7, #12]
    b67e:	2050      	movs	r0, #80	; 0x50
    b680:	0013      	movs	r3, r2
    b682:	015b      	lsls	r3, r3, #5
    b684:	189b      	adds	r3, r3, r2
    b686:	009b      	lsls	r3, r3, #2
    b688:	18cb      	adds	r3, r1, r3
    b68a:	181b      	adds	r3, r3, r0
    b68c:	2220      	movs	r2, #32
    b68e:	801a      	strh	r2, [r3, #0]
        if (USBPD_TCPCI_WriteRegister(Port, TCPC_REG_VBUS_VOLTAGE_ALARM_LO_CFG, (uint8_t*)&state[Port].Registers.VBUS.s.VBUS_VOLTAGE_ALARM_LO_CFG, 2) != USBPD_OK)
    b690:	68fb      	ldr	r3, [r7, #12]
    b692:	b2d8      	uxtb	r0, r3
    b694:	68fa      	ldr	r2, [r7, #12]
    b696:	0013      	movs	r3, r2
    b698:	015b      	lsls	r3, r3, #5
    b69a:	189b      	adds	r3, r3, r2
    b69c:	009b      	lsls	r3, r3, #2
    b69e:	3350      	adds	r3, #80	; 0x50
    b6a0:	001a      	movs	r2, r3
    b6a2:	4b24      	ldr	r3, [pc, #144]	; (b734 <fusb305_tcpc_init+0x3ac>)
    b6a4:	18d2      	adds	r2, r2, r3
    b6a6:	2302      	movs	r3, #2
    b6a8:	2178      	movs	r1, #120	; 0x78
    b6aa:	f002 fc7d 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
    b6ae:	1e03      	subs	r3, r0, #0
    b6b0:	d004      	beq.n	b6bc <fusb305_tcpc_init+0x334>
        {
          usbpd_status = USBPD_ERROR;
    b6b2:	2317      	movs	r3, #23
    b6b4:	18fb      	adds	r3, r7, r3
    b6b6:	2202      	movs	r2, #2
    b6b8:	701a      	strb	r2, [r3, #0]
          goto exit;
    b6ba:	e07e      	b.n	b7ba <fusb305_tcpc_init+0x432>
        }

        /* Set ROLE_CONTROL for TCPC */
        state[Port].TogglingEnable       = ToggleRole;
    b6bc:	491d      	ldr	r1, [pc, #116]	; (b734 <fusb305_tcpc_init+0x3ac>)
    b6be:	68fa      	ldr	r2, [r7, #12]
    b6c0:	2074      	movs	r0, #116	; 0x74
    b6c2:	0013      	movs	r3, r2
    b6c4:	015b      	lsls	r3, r3, #5
    b6c6:	189b      	adds	r3, r3, r2
    b6c8:	009b      	lsls	r3, r3, #2
    b6ca:	18cb      	adds	r3, r1, r3
    b6cc:	181b      	adds	r3, r3, r0
    b6ce:	1dfa      	adds	r2, r7, #7
    b6d0:	7812      	ldrb	r2, [r2, #0]
    b6d2:	701a      	strb	r2, [r3, #0]
        switch(Role)
    b6d4:	68bb      	ldr	r3, [r7, #8]
    b6d6:	2b00      	cmp	r3, #0
    b6d8:	d002      	beq.n	b6e0 <fusb305_tcpc_init+0x358>
    b6da:	2b01      	cmp	r3, #1
    b6dc:	d005      	beq.n	b6ea <fusb305_tcpc_init+0x362>
    b6de:	e009      	b.n	b6f4 <fusb305_tcpc_init+0x36c>
        {
          case USBPD_PORTPOWERROLE_SNK:         /*!< Sink                         */
            cc_value = TYPEC_CC_RD;
    b6e0:	2316      	movs	r3, #22
    b6e2:	18fb      	adds	r3, r7, r3
    b6e4:	2202      	movs	r2, #2
    b6e6:	701a      	strb	r2, [r3, #0]
            break;
    b6e8:	e009      	b.n	b6fe <fusb305_tcpc_init+0x376>
          case USBPD_PORTPOWERROLE_SRC:         /*!< Source                       */
            cc_value = TYPEC_CC_RP;
    b6ea:	2316      	movs	r3, #22
    b6ec:	18fb      	adds	r3, r7, r3
    b6ee:	2201      	movs	r2, #1
    b6f0:	701a      	strb	r2, [r3, #0]
            break;
    b6f2:	e004      	b.n	b6fe <fusb305_tcpc_init+0x376>
        default:
            usbpd_status = USBPD_ERROR;
    b6f4:	2317      	movs	r3, #23
    b6f6:	18fb      	adds	r3, r7, r3
    b6f8:	2202      	movs	r2, #2
    b6fa:	701a      	strb	r2, [r3, #0]
            goto exit;
    b6fc:	e05d      	b.n	b7ba <fusb305_tcpc_init+0x432>
        }

        state[Port].TypeC_State       = Disabled;
    b6fe:	490d      	ldr	r1, [pc, #52]	; (b734 <fusb305_tcpc_init+0x3ac>)
    b700:	68fa      	ldr	r2, [r7, #12]
    b702:	2072      	movs	r0, #114	; 0x72
    b704:	0013      	movs	r3, r2
    b706:	015b      	lsls	r3, r3, #5
    b708:	189b      	adds	r3, r3, r2
    b70a:	009b      	lsls	r3, r3, #2
    b70c:	18cb      	adds	r3, r1, r3
    b70e:	181b      	adds	r3, r3, r0
    b710:	2200      	movs	r2, #0
    b712:	701a      	strb	r2, [r3, #0]
        if (fusb305_tcpc_set_cc(Port, cc_value, USBPD_DISABLE) != USBPD_OK)
    b714:	2316      	movs	r3, #22
    b716:	18fb      	adds	r3, r7, r3
    b718:	7819      	ldrb	r1, [r3, #0]
    b71a:	68fb      	ldr	r3, [r7, #12]
    b71c:	2200      	movs	r2, #0
    b71e:	0018      	movs	r0, r3
    b720:	f000 fa78 	bl	bc14 <fusb305_tcpc_set_cc>
    b724:	1e03      	subs	r3, r0, #0
    b726:	d007      	beq.n	b738 <fusb305_tcpc_init+0x3b0>
        {
          usbpd_status = USBPD_ERROR;
    b728:	2317      	movs	r3, #23
    b72a:	18fb      	adds	r3, r7, r3
    b72c:	2202      	movs	r2, #2
    b72e:	701a      	strb	r2, [r3, #0]
          goto exit;
    b730:	e043      	b.n	b7ba <fusb305_tcpc_init+0x432>
    b732:	46c0      	nop			; (mov r8, r8)
    b734:	000300b8 	.word	0x000300b8
        }
        
        /* Start DRP toggling */
        state[Port].Registers.Command.u.COMMAND = TCPC_REG_COMMAND_LOOK4CONNECTION;
    b738:	4923      	ldr	r1, [pc, #140]	; (b7c8 <fusb305_tcpc_init+0x440>)
    b73a:	68fa      	ldr	r2, [r7, #12]
    b73c:	0013      	movs	r3, r2
    b73e:	015b      	lsls	r3, r3, #5
    b740:	189b      	adds	r3, r3, r2
    b742:	009b      	lsls	r3, r3, #2
    b744:	18cb      	adds	r3, r1, r3
    b746:	331a      	adds	r3, #26
    b748:	2299      	movs	r2, #153	; 0x99
    b74a:	701a      	strb	r2, [r3, #0]
        if (USBPD_TCPCI_WriteRegister(Port, TCPC_REG_COMMAND, &state[Port].Registers.Command.u.COMMAND, 1) != USBPD_OK)
    b74c:	68fb      	ldr	r3, [r7, #12]
    b74e:	b2d8      	uxtb	r0, r3
    b750:	68fa      	ldr	r2, [r7, #12]
    b752:	0013      	movs	r3, r2
    b754:	015b      	lsls	r3, r3, #5
    b756:	189b      	adds	r3, r3, r2
    b758:	009b      	lsls	r3, r3, #2
    b75a:	3318      	adds	r3, #24
    b75c:	001a      	movs	r2, r3
    b75e:	4b1a      	ldr	r3, [pc, #104]	; (b7c8 <fusb305_tcpc_init+0x440>)
    b760:	18d3      	adds	r3, r2, r3
    b762:	1c9a      	adds	r2, r3, #2
    b764:	2301      	movs	r3, #1
    b766:	2123      	movs	r1, #35	; 0x23
    b768:	f002 fc1e 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
    b76c:	1e03      	subs	r3, r0, #0
    b76e:	d004      	beq.n	b77a <fusb305_tcpc_init+0x3f2>
        {
          usbpd_status = USBPD_ERROR;
    b770:	2317      	movs	r3, #23
    b772:	18fb      	adds	r3, r7, r3
    b774:	2202      	movs	r2, #2
    b776:	701a      	strb	r2, [r3, #0]
          goto exit;
    b778:	e01f      	b.n	b7ba <fusb305_tcpc_init+0x432>
        }
        state[Port].Registers.Alerts.word[0] = TCPC_REG_ALERT_CLEAR_ALL;
    b77a:	4913      	ldr	r1, [pc, #76]	; (b7c8 <fusb305_tcpc_init+0x440>)
    b77c:	68fa      	ldr	r2, [r7, #12]
    b77e:	0013      	movs	r3, r2
    b780:	015b      	lsls	r3, r3, #5
    b782:	189b      	adds	r3, r3, r2
    b784:	009b      	lsls	r3, r3, #2
    b786:	18cb      	adds	r3, r1, r3
    b788:	330c      	adds	r3, #12
    b78a:	4a10      	ldr	r2, [pc, #64]	; (b7cc <fusb305_tcpc_init+0x444>)
    b78c:	801a      	strh	r2, [r3, #0]
        usbpd_status = USBPD_TCPCI_WriteRegister(Port, TCPC_REG_ALERT, (uint8_t*)&state[Port].Registers.Alerts.word[0], 2);
    b78e:	68fb      	ldr	r3, [r7, #12]
    b790:	b2d8      	uxtb	r0, r3
    b792:	68fa      	ldr	r2, [r7, #12]
    b794:	0013      	movs	r3, r2
    b796:	015b      	lsls	r3, r3, #5
    b798:	189b      	adds	r3, r3, r2
    b79a:	009b      	lsls	r3, r3, #2
    b79c:	3308      	adds	r3, #8
    b79e:	001a      	movs	r2, r3
    b7a0:	4b09      	ldr	r3, [pc, #36]	; (b7c8 <fusb305_tcpc_init+0x440>)
    b7a2:	18d3      	adds	r3, r2, r3
    b7a4:	1d1a      	adds	r2, r3, #4
    b7a6:	2317      	movs	r3, #23
    b7a8:	18fc      	adds	r4, r7, r3
    b7aa:	2302      	movs	r3, #2
    b7ac:	2110      	movs	r1, #16
    b7ae:	f002 fbfb 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
    b7b2:	0003      	movs	r3, r0
    b7b4:	7023      	strb	r3, [r4, #0]
        
        break;
    b7b6:	e000      	b.n	b7ba <fusb305_tcpc_init+0x432>
    goto exit;
    b7b8:	46c0      	nop			; (mov r8, r8)
    }
  }

exit:

  return usbpd_status;
    b7ba:	2317      	movs	r3, #23
    b7bc:	18fb      	adds	r3, r7, r3
    b7be:	781b      	ldrb	r3, [r3, #0]
}
    b7c0:	0018      	movs	r0, r3
    b7c2:	46bd      	mov	sp, r7
    b7c4:	b007      	add	sp, #28
    b7c6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    b7c8:	000300b8 	.word	0x000300b8
    b7cc:	ffff8fff 	.word	0xffff8fff

0000b7d0 <fusb305_tcpc_get_cc>:
  * @param  CC1_Level Pointer of status of the CC1 line
  * @param  CC2_Level Pointer of status of the CC2 line
  * @retval USBPD status
  */
USBPD_StatusTypeDef fusb305_tcpc_get_cc(uint32_t Port, uint32_t *CC1_Level, uint32_t *CC2_Level)
{
    b7d0:	b590      	push	{r4, r7, lr}
    b7d2:	b08b      	sub	sp, #44	; 0x2c
    b7d4:	af02      	add	r7, sp, #8
    b7d6:	60f8      	str	r0, [r7, #12]
    b7d8:	60b9      	str	r1, [r7, #8]
    b7da:	607a      	str	r2, [r7, #4]
  USBPD_StatusTypeDef status = USBPD_BUSY;
    b7dc:	231f      	movs	r3, #31
    b7de:	18fb      	adds	r3, r7, r3
    b7e0:	2203      	movs	r2, #3
    b7e2:	701a      	strb	r2, [r3, #0]

  /* Start a delay for CC debounce */
  USBPD_TCPCI_Delay(CC_DEBOUNCE_TIMER);
    b7e4:	2004      	movs	r0, #4
    b7e6:	f002 fd6b 	bl	e2c0 <USBPD_TCPCI_Delay>
  
  /* If TCPC read fails, return error */
  USBPD_TCPCI_ReadRegister(Port, TCPC_REG_CC_STATUS, (uint8_t*)&state[Port].Registers.Status.u1.CC_STATUS, 1);
    b7ea:	68fb      	ldr	r3, [r7, #12]
    b7ec:	b2d8      	uxtb	r0, r3
    b7ee:	68fa      	ldr	r2, [r7, #12]
    b7f0:	0013      	movs	r3, r2
    b7f2:	015b      	lsls	r3, r3, #5
    b7f4:	189b      	adds	r3, r3, r2
    b7f6:	009b      	lsls	r3, r3, #2
    b7f8:	3310      	adds	r3, #16
    b7fa:	001a      	movs	r2, r3
    b7fc:	4bdf      	ldr	r3, [pc, #892]	; (bb7c <fusb305_tcpc_get_cc+0x3ac>)
    b7fe:	18d3      	adds	r3, r2, r3
    b800:	1dda      	adds	r2, r3, #7
    b802:	2301      	movs	r3, #1
    b804:	211d      	movs	r1, #29
    b806:	f002 fd11 	bl	e22c <USBPD_TCPCI_ReadRegister>
  
#if defined(_TRACE)
  if (*CC1_Level != 0xFF)
    b80a:	68bb      	ldr	r3, [r7, #8]
    b80c:	681b      	ldr	r3, [r3, #0]
    b80e:	2bff      	cmp	r3, #255	; 0xff
    b810:	d027      	beq.n	b862 <fusb305_tcpc_get_cc+0x92>
  {
    uint8_t tab[10] = {0};
    b812:	2414      	movs	r4, #20
    b814:	193b      	adds	r3, r7, r4
    b816:	0018      	movs	r0, r3
    b818:	230a      	movs	r3, #10
    b81a:	001a      	movs	r2, r3
    b81c:	2100      	movs	r1, #0
    b81e:	f012 ff42 	bl	1e6a6 <memset>
    sprintf((char*)tab,"CC_S2=%2X", *&state[Port].Registers.Status.u1.CC_STATUS);
    b822:	49d6      	ldr	r1, [pc, #856]	; (bb7c <fusb305_tcpc_get_cc+0x3ac>)
    b824:	68fa      	ldr	r2, [r7, #12]
    b826:	0013      	movs	r3, r2
    b828:	015b      	lsls	r3, r3, #5
    b82a:	189b      	adds	r3, r3, r2
    b82c:	009b      	lsls	r3, r3, #2
    b82e:	18cb      	adds	r3, r1, r3
    b830:	3317      	adds	r3, #23
    b832:	781b      	ldrb	r3, [r3, #0]
    b834:	001a      	movs	r2, r3
    b836:	49d2      	ldr	r1, [pc, #840]	; (bb80 <fusb305_tcpc_get_cc+0x3b0>)
    b838:	193b      	adds	r3, r7, r4
    b83a:	0018      	movs	r0, r3
    b83c:	f012 fff6 	bl	1e82c <siprintf>
    FUSB307_DEBUG_TRACE(Port, FUSB307_DEBUG_LEVEL_0, tab);
    b840:	4bd0      	ldr	r3, [pc, #832]	; (bb84 <fusb305_tcpc_get_cc+0x3b4>)
    b842:	781b      	ldrb	r3, [r3, #0]
    b844:	001a      	movs	r2, r3
    b846:	2301      	movs	r3, #1
    b848:	4013      	ands	r3, r2
    b84a:	d00a      	beq.n	b862 <fusb305_tcpc_get_cc+0x92>
    b84c:	68fb      	ldr	r3, [r7, #12]
    b84e:	b2d9      	uxtb	r1, r3
    b850:	2314      	movs	r3, #20
    b852:	18fa      	adds	r2, r7, r3
    b854:	2309      	movs	r3, #9
    b856:	9300      	str	r3, [sp, #0]
    b858:	0013      	movs	r3, r2
    b85a:	2200      	movs	r2, #0
    b85c:	2006      	movs	r0, #6
    b85e:	f004 fe81 	bl	10564 <USBPD_TRACE_Add>
  }
#endif /* _TRACE */
  
  /* Check for CC connection only if TCPC found a connection */
  if (state[Port].Registers.Status.u1.b1.LOOK4CON != 1)
    b862:	49c6      	ldr	r1, [pc, #792]	; (bb7c <fusb305_tcpc_get_cc+0x3ac>)
    b864:	68fa      	ldr	r2, [r7, #12]
    b866:	2010      	movs	r0, #16
    b868:	0013      	movs	r3, r2
    b86a:	015b      	lsls	r3, r3, #5
    b86c:	189b      	adds	r3, r3, r2
    b86e:	009b      	lsls	r3, r3, #2
    b870:	18cb      	adds	r3, r1, r3
    b872:	181b      	adds	r3, r3, r0
    b874:	79db      	ldrb	r3, [r3, #7]
    b876:	069b      	lsls	r3, r3, #26
    b878:	0fdb      	lsrs	r3, r3, #31
    b87a:	b2db      	uxtb	r3, r3
    b87c:	2b01      	cmp	r3, #1
    b87e:	d100      	bne.n	b882 <fusb305_tcpc_get_cc+0xb2>
    b880:	e1bf      	b.n	bc02 <fusb305_tcpc_get_cc+0x432>
  {
    *CC1_Level = state[Port].Registers.Status.u1.b1.CC1_STAT;
    b882:	49be      	ldr	r1, [pc, #760]	; (bb7c <fusb305_tcpc_get_cc+0x3ac>)
    b884:	68fa      	ldr	r2, [r7, #12]
    b886:	2010      	movs	r0, #16
    b888:	0013      	movs	r3, r2
    b88a:	015b      	lsls	r3, r3, #5
    b88c:	189b      	adds	r3, r3, r2
    b88e:	009b      	lsls	r3, r3, #2
    b890:	18cb      	adds	r3, r1, r3
    b892:	181b      	adds	r3, r3, r0
    b894:	79db      	ldrb	r3, [r3, #7]
    b896:	079b      	lsls	r3, r3, #30
    b898:	0f9b      	lsrs	r3, r3, #30
    b89a:	b2db      	uxtb	r3, r3
    b89c:	001a      	movs	r2, r3
    b89e:	68bb      	ldr	r3, [r7, #8]
    b8a0:	601a      	str	r2, [r3, #0]
    *CC2_Level = state[Port].Registers.Status.u1.b1.CC2_STAT;
    b8a2:	49b6      	ldr	r1, [pc, #728]	; (bb7c <fusb305_tcpc_get_cc+0x3ac>)
    b8a4:	68fa      	ldr	r2, [r7, #12]
    b8a6:	2010      	movs	r0, #16
    b8a8:	0013      	movs	r3, r2
    b8aa:	015b      	lsls	r3, r3, #5
    b8ac:	189b      	adds	r3, r3, r2
    b8ae:	009b      	lsls	r3, r3, #2
    b8b0:	18cb      	adds	r3, r1, r3
    b8b2:	181b      	adds	r3, r3, r0
    b8b4:	79db      	ldrb	r3, [r3, #7]
    b8b6:	071b      	lsls	r3, r3, #28
    b8b8:	0f9b      	lsrs	r3, r3, #30
    b8ba:	b2db      	uxtb	r3, r3
    b8bc:	001a      	movs	r2, r3
    b8be:	687b      	ldr	r3, [r7, #4]
    b8c0:	601a      	str	r2, [r3, #0]

    /*
     * If status is not open, then OR in termination to convert to
     * enum @ref TCPC_CC_Volt_Status_TypeDef.
     */
    status = USBPD_OK;
    b8c2:	231f      	movs	r3, #31
    b8c4:	18fb      	adds	r3, r7, r3
    b8c6:	2200      	movs	r2, #0
    b8c8:	701a      	strb	r2, [r3, #0]
    if ((state[Port].IsSwapOngoing(Port) == 0) && (state[Port].HardReset == 0U))
    b8ca:	49ac      	ldr	r1, [pc, #688]	; (bb7c <fusb305_tcpc_get_cc+0x3ac>)
    b8cc:	68fa      	ldr	r2, [r7, #12]
    b8ce:	0013      	movs	r3, r2
    b8d0:	015b      	lsls	r3, r3, #5
    b8d2:	189b      	adds	r3, r3, r2
    b8d4:	009b      	lsls	r3, r3, #2
    b8d6:	18cb      	adds	r3, r1, r3
    b8d8:	3378      	adds	r3, #120	; 0x78
    b8da:	681b      	ldr	r3, [r3, #0]
    b8dc:	68fa      	ldr	r2, [r7, #12]
    b8de:	b2d2      	uxtb	r2, r2
    b8e0:	0010      	movs	r0, r2
    b8e2:	4798      	blx	r3
    b8e4:	1e03      	subs	r3, r0, #0
    b8e6:	d000      	beq.n	b8ea <fusb305_tcpc_get_cc+0x11a>
    b8e8:	e18b      	b.n	bc02 <fusb305_tcpc_get_cc+0x432>
    b8ea:	49a4      	ldr	r1, [pc, #656]	; (bb7c <fusb305_tcpc_get_cc+0x3ac>)
    b8ec:	68fa      	ldr	r2, [r7, #12]
    b8ee:	2080      	movs	r0, #128	; 0x80
    b8f0:	0013      	movs	r3, r2
    b8f2:	015b      	lsls	r3, r3, #5
    b8f4:	189b      	adds	r3, r3, r2
    b8f6:	009b      	lsls	r3, r3, #2
    b8f8:	18cb      	adds	r3, r1, r3
    b8fa:	181b      	adds	r3, r3, r0
    b8fc:	781b      	ldrb	r3, [r3, #0]
    b8fe:	2b00      	cmp	r3, #0
    b900:	d000      	beq.n	b904 <fusb305_tcpc_get_cc+0x134>
    b902:	e17e      	b.n	bc02 <fusb305_tcpc_get_cc+0x432>
    {
      state[Port].CC_Pin = CCNONE;
    b904:	499d      	ldr	r1, [pc, #628]	; (bb7c <fusb305_tcpc_get_cc+0x3ac>)
    b906:	68fa      	ldr	r2, [r7, #12]
    b908:	0013      	movs	r3, r2
    b90a:	015b      	lsls	r3, r3, #5
    b90c:	189b      	adds	r3, r3, r2
    b90e:	009b      	lsls	r3, r3, #2
    b910:	18cb      	adds	r3, r1, r3
    b912:	337c      	adds	r3, #124	; 0x7c
    b914:	2200      	movs	r2, #0
    b916:	601a      	str	r2, [r3, #0]
      /* Check CC1 pin */
      if (*CC1_Level != TYPEC_CC_VOLT_OPEN)
    b918:	68bb      	ldr	r3, [r7, #8]
    b91a:	681b      	ldr	r3, [r3, #0]
    b91c:	2b00      	cmp	r3, #0
    b91e:	d100      	bne.n	b922 <fusb305_tcpc_get_cc+0x152>
    b920:	e0b1      	b.n	ba86 <fusb305_tcpc_get_cc+0x2b6>
      {
        state[Port].CC_Pin = CC1;
    b922:	4996      	ldr	r1, [pc, #600]	; (bb7c <fusb305_tcpc_get_cc+0x3ac>)
    b924:	68fa      	ldr	r2, [r7, #12]
    b926:	0013      	movs	r3, r2
    b928:	015b      	lsls	r3, r3, #5
    b92a:	189b      	adds	r3, r3, r2
    b92c:	009b      	lsls	r3, r3, #2
    b92e:	18cb      	adds	r3, r1, r3
    b930:	337c      	adds	r3, #124	; 0x7c
    b932:	2201      	movs	r2, #1
    b934:	601a      	str	r2, [r3, #0]
        if (((state[Port].TogglingEnable == 0) &&
    b936:	4991      	ldr	r1, [pc, #580]	; (bb7c <fusb305_tcpc_get_cc+0x3ac>)
    b938:	68fa      	ldr	r2, [r7, #12]
    b93a:	2074      	movs	r0, #116	; 0x74
    b93c:	0013      	movs	r3, r2
    b93e:	015b      	lsls	r3, r3, #5
    b940:	189b      	adds	r3, r3, r2
    b942:	009b      	lsls	r3, r3, #2
    b944:	18cb      	adds	r3, r1, r3
    b946:	181b      	adds	r3, r3, r0
    b948:	781b      	ldrb	r3, [r3, #0]
    b94a:	2b00      	cmp	r3, #0
    b94c:	d11d      	bne.n	b98a <fusb305_tcpc_get_cc+0x1ba>
                ((TYPEC_CC_RD == state[Port].Registers.Control.s.u3.b3.CC1_TERM)||(state[Port].Registers.Status.u1.b1.CON_RES == 1)))
    b94e:	498b      	ldr	r1, [pc, #556]	; (bb7c <fusb305_tcpc_get_cc+0x3ac>)
    b950:	68fa      	ldr	r2, [r7, #12]
    b952:	2010      	movs	r0, #16
    b954:	0013      	movs	r3, r2
    b956:	015b      	lsls	r3, r3, #5
    b958:	189b      	adds	r3, r3, r2
    b95a:	009b      	lsls	r3, r3, #2
    b95c:	18cb      	adds	r3, r1, r3
    b95e:	181b      	adds	r3, r3, r0
    b960:	791b      	ldrb	r3, [r3, #4]
    b962:	079b      	lsls	r3, r3, #30
    b964:	0f9b      	lsrs	r3, r3, #30
    b966:	b2db      	uxtb	r3, r3
        if (((state[Port].TogglingEnable == 0) &&
    b968:	2b02      	cmp	r3, #2
    b96a:	d029      	beq.n	b9c0 <fusb305_tcpc_get_cc+0x1f0>
                ((TYPEC_CC_RD == state[Port].Registers.Control.s.u3.b3.CC1_TERM)||(state[Port].Registers.Status.u1.b1.CON_RES == 1)))
    b96c:	4983      	ldr	r1, [pc, #524]	; (bb7c <fusb305_tcpc_get_cc+0x3ac>)
    b96e:	68fa      	ldr	r2, [r7, #12]
    b970:	2010      	movs	r0, #16
    b972:	0013      	movs	r3, r2
    b974:	015b      	lsls	r3, r3, #5
    b976:	189b      	adds	r3, r3, r2
    b978:	009b      	lsls	r3, r3, #2
    b97a:	18cb      	adds	r3, r1, r3
    b97c:	181b      	adds	r3, r3, r0
    b97e:	79db      	ldrb	r3, [r3, #7]
    b980:	06db      	lsls	r3, r3, #27
    b982:	0fdb      	lsrs	r3, r3, #31
    b984:	b2db      	uxtb	r3, r3
    b986:	2b01      	cmp	r3, #1
    b988:	d01a      	beq.n	b9c0 <fusb305_tcpc_get_cc+0x1f0>
            ||((state[Port].TogglingEnable == 1) &&
    b98a:	497c      	ldr	r1, [pc, #496]	; (bb7c <fusb305_tcpc_get_cc+0x3ac>)
    b98c:	68fa      	ldr	r2, [r7, #12]
    b98e:	2074      	movs	r0, #116	; 0x74
    b990:	0013      	movs	r3, r2
    b992:	015b      	lsls	r3, r3, #5
    b994:	189b      	adds	r3, r3, r2
    b996:	009b      	lsls	r3, r3, #2
    b998:	18cb      	adds	r3, r1, r3
    b99a:	181b      	adds	r3, r3, r0
    b99c:	781b      	ldrb	r3, [r3, #0]
    b99e:	2b01      	cmp	r3, #1
    b9a0:	d134      	bne.n	ba0c <fusb305_tcpc_get_cc+0x23c>
                (state[Port].Registers.Status.u1.b1.CON_RES == 1)))
    b9a2:	4976      	ldr	r1, [pc, #472]	; (bb7c <fusb305_tcpc_get_cc+0x3ac>)
    b9a4:	68fa      	ldr	r2, [r7, #12]
    b9a6:	2010      	movs	r0, #16
    b9a8:	0013      	movs	r3, r2
    b9aa:	015b      	lsls	r3, r3, #5
    b9ac:	189b      	adds	r3, r3, r2
    b9ae:	009b      	lsls	r3, r3, #2
    b9b0:	18cb      	adds	r3, r1, r3
    b9b2:	181b      	adds	r3, r3, r0
    b9b4:	79db      	ldrb	r3, [r3, #7]
    b9b6:	06db      	lsls	r3, r3, #27
    b9b8:	0fdb      	lsrs	r3, r3, #31
    b9ba:	b2db      	uxtb	r3, r3
            ||((state[Port].TogglingEnable == 1) &&
    b9bc:	2b01      	cmp	r3, #1
    b9be:	d125      	bne.n	ba0c <fusb305_tcpc_get_cc+0x23c>
        {
          *CC1_Level |= (1 << 2);
    b9c0:	68bb      	ldr	r3, [r7, #8]
    b9c2:	681b      	ldr	r3, [r3, #0]
    b9c4:	2204      	movs	r2, #4
    b9c6:	431a      	orrs	r2, r3
    b9c8:	68bb      	ldr	r3, [r7, #8]
    b9ca:	601a      	str	r2, [r3, #0]
          /* Save current power role */
          state[Port].PowerRole = USBPD_PORTPOWERROLE_SNK;
    b9cc:	496b      	ldr	r1, [pc, #428]	; (bb7c <fusb305_tcpc_get_cc+0x3ac>)
    b9ce:	68fa      	ldr	r2, [r7, #12]
    b9d0:	0013      	movs	r3, r2
    b9d2:	015b      	lsls	r3, r3, #5
    b9d4:	189b      	adds	r3, r3, r2
    b9d6:	009b      	lsls	r3, r3, #2
    b9d8:	18cb      	adds	r3, r1, r3
    b9da:	3368      	adds	r3, #104	; 0x68
    b9dc:	2200      	movs	r2, #0
    b9de:	601a      	str	r2, [r3, #0]
          state[Port].DataRole  = USBPD_PORTDATAROLE_UFP;
    b9e0:	4966      	ldr	r1, [pc, #408]	; (bb7c <fusb305_tcpc_get_cc+0x3ac>)
    b9e2:	68fa      	ldr	r2, [r7, #12]
    b9e4:	0013      	movs	r3, r2
    b9e6:	015b      	lsls	r3, r3, #5
    b9e8:	189b      	adds	r3, r3, r2
    b9ea:	009b      	lsls	r3, r3, #2
    b9ec:	18cb      	adds	r3, r1, r3
    b9ee:	336c      	adds	r3, #108	; 0x6c
    b9f0:	2200      	movs	r2, #0
    b9f2:	601a      	str	r2, [r3, #0]
          state[Port].CC_Pull   = TYPEC_CC_RD;
    b9f4:	4961      	ldr	r1, [pc, #388]	; (bb7c <fusb305_tcpc_get_cc+0x3ac>)
    b9f6:	68fa      	ldr	r2, [r7, #12]
    b9f8:	2070      	movs	r0, #112	; 0x70
    b9fa:	0013      	movs	r3, r2
    b9fc:	015b      	lsls	r3, r3, #5
    b9fe:	189b      	adds	r3, r3, r2
    ba00:	009b      	lsls	r3, r3, #2
    ba02:	18cb      	adds	r3, r1, r3
    ba04:	181b      	adds	r3, r3, r0
    ba06:	2202      	movs	r2, #2
    ba08:	701a      	strb	r2, [r3, #0]
    ba0a:	e03c      	b.n	ba86 <fusb305_tcpc_get_cc+0x2b6>
        }
        else
        {
          /* Check that on another pin than a RA is present */
          if ((TYPEC_CC_OPEN != state[Port].Registers.Control.s.u3.b3.CC2_TERM)
    ba0c:	495b      	ldr	r1, [pc, #364]	; (bb7c <fusb305_tcpc_get_cc+0x3ac>)
    ba0e:	68fa      	ldr	r2, [r7, #12]
    ba10:	2010      	movs	r0, #16
    ba12:	0013      	movs	r3, r2
    ba14:	015b      	lsls	r3, r3, #5
    ba16:	189b      	adds	r3, r3, r2
    ba18:	009b      	lsls	r3, r3, #2
    ba1a:	18cb      	adds	r3, r1, r3
    ba1c:	181b      	adds	r3, r3, r0
    ba1e:	791b      	ldrb	r3, [r3, #4]
    ba20:	071b      	lsls	r3, r3, #28
    ba22:	0f9b      	lsrs	r3, r3, #30
    ba24:	b2db      	uxtb	r3, r3
    ba26:	2b03      	cmp	r3, #3
    ba28:	d00e      	beq.n	ba48 <fusb305_tcpc_get_cc+0x278>
           && (TYPEC_CC_VOLT_RA == *CC2_Level))
    ba2a:	687b      	ldr	r3, [r7, #4]
    ba2c:	681b      	ldr	r3, [r3, #0]
    ba2e:	2b01      	cmp	r3, #1
    ba30:	d10a      	bne.n	ba48 <fusb305_tcpc_get_cc+0x278>
          {
            /* RA detected on pin CC2 */
            state[Port].VConnPresence = TYPEC_CC_RA;
    ba32:	4952      	ldr	r1, [pc, #328]	; (bb7c <fusb305_tcpc_get_cc+0x3ac>)
    ba34:	68fa      	ldr	r2, [r7, #12]
    ba36:	2073      	movs	r0, #115	; 0x73
    ba38:	0013      	movs	r3, r2
    ba3a:	015b      	lsls	r3, r3, #5
    ba3c:	189b      	adds	r3, r3, r2
    ba3e:	009b      	lsls	r3, r3, #2
    ba40:	18cb      	adds	r3, r1, r3
    ba42:	181b      	adds	r3, r3, r0
    ba44:	2200      	movs	r2, #0
    ba46:	701a      	strb	r2, [r3, #0]
          }
          /* Save current power role */
          state[Port].PowerRole = USBPD_PORTPOWERROLE_SRC;
    ba48:	494c      	ldr	r1, [pc, #304]	; (bb7c <fusb305_tcpc_get_cc+0x3ac>)
    ba4a:	68fa      	ldr	r2, [r7, #12]
    ba4c:	0013      	movs	r3, r2
    ba4e:	015b      	lsls	r3, r3, #5
    ba50:	189b      	adds	r3, r3, r2
    ba52:	009b      	lsls	r3, r3, #2
    ba54:	18cb      	adds	r3, r1, r3
    ba56:	3368      	adds	r3, #104	; 0x68
    ba58:	2201      	movs	r2, #1
    ba5a:	601a      	str	r2, [r3, #0]
          state[Port].DataRole  = USBPD_PORTDATAROLE_DFP;
    ba5c:	4947      	ldr	r1, [pc, #284]	; (bb7c <fusb305_tcpc_get_cc+0x3ac>)
    ba5e:	68fa      	ldr	r2, [r7, #12]
    ba60:	0013      	movs	r3, r2
    ba62:	015b      	lsls	r3, r3, #5
    ba64:	189b      	adds	r3, r3, r2
    ba66:	009b      	lsls	r3, r3, #2
    ba68:	18cb      	adds	r3, r1, r3
    ba6a:	336c      	adds	r3, #108	; 0x6c
    ba6c:	2201      	movs	r2, #1
    ba6e:	601a      	str	r2, [r3, #0]
          state[Port].CC_Pull   = TYPEC_CC_RP;
    ba70:	4942      	ldr	r1, [pc, #264]	; (bb7c <fusb305_tcpc_get_cc+0x3ac>)
    ba72:	68fa      	ldr	r2, [r7, #12]
    ba74:	2070      	movs	r0, #112	; 0x70
    ba76:	0013      	movs	r3, r2
    ba78:	015b      	lsls	r3, r3, #5
    ba7a:	189b      	adds	r3, r3, r2
    ba7c:	009b      	lsls	r3, r3, #2
    ba7e:	18cb      	adds	r3, r1, r3
    ba80:	181b      	adds	r3, r3, r0
    ba82:	2201      	movs	r2, #1
    ba84:	701a      	strb	r2, [r3, #0]
        }
      }
      
      /* Check CC2 pin */
      if (*CC2_Level != TYPEC_CC_VOLT_OPEN)
    ba86:	687b      	ldr	r3, [r7, #4]
    ba88:	681b      	ldr	r3, [r3, #0]
    ba8a:	2b00      	cmp	r3, #0
    ba8c:	d100      	bne.n	ba90 <fusb305_tcpc_get_cc+0x2c0>
    ba8e:	e0b8      	b.n	bc02 <fusb305_tcpc_get_cc+0x432>
      {
        state[Port].CC_Pin = CC2;
    ba90:	493a      	ldr	r1, [pc, #232]	; (bb7c <fusb305_tcpc_get_cc+0x3ac>)
    ba92:	68fa      	ldr	r2, [r7, #12]
    ba94:	0013      	movs	r3, r2
    ba96:	015b      	lsls	r3, r3, #5
    ba98:	189b      	adds	r3, r3, r2
    ba9a:	009b      	lsls	r3, r3, #2
    ba9c:	18cb      	adds	r3, r1, r3
    ba9e:	337c      	adds	r3, #124	; 0x7c
    baa0:	2202      	movs	r2, #2
    baa2:	601a      	str	r2, [r3, #0]
        if (((state[Port].TogglingEnable == 0) &&
    baa4:	4935      	ldr	r1, [pc, #212]	; (bb7c <fusb305_tcpc_get_cc+0x3ac>)
    baa6:	68fa      	ldr	r2, [r7, #12]
    baa8:	2074      	movs	r0, #116	; 0x74
    baaa:	0013      	movs	r3, r2
    baac:	015b      	lsls	r3, r3, #5
    baae:	189b      	adds	r3, r3, r2
    bab0:	009b      	lsls	r3, r3, #2
    bab2:	18cb      	adds	r3, r1, r3
    bab4:	181b      	adds	r3, r3, r0
    bab6:	781b      	ldrb	r3, [r3, #0]
    bab8:	2b00      	cmp	r3, #0
    baba:	d11d      	bne.n	baf8 <fusb305_tcpc_get_cc+0x328>
                ((TYPEC_CC_RD == state[Port].Registers.Control.s.u3.b3.CC2_TERM)||(state[Port].Registers.Status.u1.b1.CON_RES == 1)))
    babc:	492f      	ldr	r1, [pc, #188]	; (bb7c <fusb305_tcpc_get_cc+0x3ac>)
    babe:	68fa      	ldr	r2, [r7, #12]
    bac0:	2010      	movs	r0, #16
    bac2:	0013      	movs	r3, r2
    bac4:	015b      	lsls	r3, r3, #5
    bac6:	189b      	adds	r3, r3, r2
    bac8:	009b      	lsls	r3, r3, #2
    baca:	18cb      	adds	r3, r1, r3
    bacc:	181b      	adds	r3, r3, r0
    bace:	791b      	ldrb	r3, [r3, #4]
    bad0:	071b      	lsls	r3, r3, #28
    bad2:	0f9b      	lsrs	r3, r3, #30
    bad4:	b2db      	uxtb	r3, r3
        if (((state[Port].TogglingEnable == 0) &&
    bad6:	2b02      	cmp	r3, #2
    bad8:	d029      	beq.n	bb2e <fusb305_tcpc_get_cc+0x35e>
                ((TYPEC_CC_RD == state[Port].Registers.Control.s.u3.b3.CC2_TERM)||(state[Port].Registers.Status.u1.b1.CON_RES == 1)))
    bada:	4928      	ldr	r1, [pc, #160]	; (bb7c <fusb305_tcpc_get_cc+0x3ac>)
    badc:	68fa      	ldr	r2, [r7, #12]
    bade:	2010      	movs	r0, #16
    bae0:	0013      	movs	r3, r2
    bae2:	015b      	lsls	r3, r3, #5
    bae4:	189b      	adds	r3, r3, r2
    bae6:	009b      	lsls	r3, r3, #2
    bae8:	18cb      	adds	r3, r1, r3
    baea:	181b      	adds	r3, r3, r0
    baec:	79db      	ldrb	r3, [r3, #7]
    baee:	06db      	lsls	r3, r3, #27
    baf0:	0fdb      	lsrs	r3, r3, #31
    baf2:	b2db      	uxtb	r3, r3
    baf4:	2b01      	cmp	r3, #1
    baf6:	d01a      	beq.n	bb2e <fusb305_tcpc_get_cc+0x35e>
            ||((state[Port].TogglingEnable == 1) &&
    baf8:	4920      	ldr	r1, [pc, #128]	; (bb7c <fusb305_tcpc_get_cc+0x3ac>)
    bafa:	68fa      	ldr	r2, [r7, #12]
    bafc:	2074      	movs	r0, #116	; 0x74
    bafe:	0013      	movs	r3, r2
    bb00:	015b      	lsls	r3, r3, #5
    bb02:	189b      	adds	r3, r3, r2
    bb04:	009b      	lsls	r3, r3, #2
    bb06:	18cb      	adds	r3, r1, r3
    bb08:	181b      	adds	r3, r3, r0
    bb0a:	781b      	ldrb	r3, [r3, #0]
    bb0c:	2b01      	cmp	r3, #1
    bb0e:	d13b      	bne.n	bb88 <fusb305_tcpc_get_cc+0x3b8>
                (state[Port].Registers.Status.u1.b1.CON_RES == 1)))
    bb10:	491a      	ldr	r1, [pc, #104]	; (bb7c <fusb305_tcpc_get_cc+0x3ac>)
    bb12:	68fa      	ldr	r2, [r7, #12]
    bb14:	2010      	movs	r0, #16
    bb16:	0013      	movs	r3, r2
    bb18:	015b      	lsls	r3, r3, #5
    bb1a:	189b      	adds	r3, r3, r2
    bb1c:	009b      	lsls	r3, r3, #2
    bb1e:	18cb      	adds	r3, r1, r3
    bb20:	181b      	adds	r3, r3, r0
    bb22:	79db      	ldrb	r3, [r3, #7]
    bb24:	06db      	lsls	r3, r3, #27
    bb26:	0fdb      	lsrs	r3, r3, #31
    bb28:	b2db      	uxtb	r3, r3
            ||((state[Port].TogglingEnable == 1) &&
    bb2a:	2b01      	cmp	r3, #1
    bb2c:	d12c      	bne.n	bb88 <fusb305_tcpc_get_cc+0x3b8>
        {
          *CC2_Level |= (1 << 2);
    bb2e:	687b      	ldr	r3, [r7, #4]
    bb30:	681b      	ldr	r3, [r3, #0]
    bb32:	2204      	movs	r2, #4
    bb34:	431a      	orrs	r2, r3
    bb36:	687b      	ldr	r3, [r7, #4]
    bb38:	601a      	str	r2, [r3, #0]
          /* Save current power role */
          state[Port].PowerRole = USBPD_PORTPOWERROLE_SNK;
    bb3a:	4910      	ldr	r1, [pc, #64]	; (bb7c <fusb305_tcpc_get_cc+0x3ac>)
    bb3c:	68fa      	ldr	r2, [r7, #12]
    bb3e:	0013      	movs	r3, r2
    bb40:	015b      	lsls	r3, r3, #5
    bb42:	189b      	adds	r3, r3, r2
    bb44:	009b      	lsls	r3, r3, #2
    bb46:	18cb      	adds	r3, r1, r3
    bb48:	3368      	adds	r3, #104	; 0x68
    bb4a:	2200      	movs	r2, #0
    bb4c:	601a      	str	r2, [r3, #0]
          state[Port].DataRole  = USBPD_PORTDATAROLE_UFP;
    bb4e:	490b      	ldr	r1, [pc, #44]	; (bb7c <fusb305_tcpc_get_cc+0x3ac>)
    bb50:	68fa      	ldr	r2, [r7, #12]
    bb52:	0013      	movs	r3, r2
    bb54:	015b      	lsls	r3, r3, #5
    bb56:	189b      	adds	r3, r3, r2
    bb58:	009b      	lsls	r3, r3, #2
    bb5a:	18cb      	adds	r3, r1, r3
    bb5c:	336c      	adds	r3, #108	; 0x6c
    bb5e:	2200      	movs	r2, #0
    bb60:	601a      	str	r2, [r3, #0]
          state[Port].CC_Pull   = TYPEC_CC_RD;
    bb62:	4906      	ldr	r1, [pc, #24]	; (bb7c <fusb305_tcpc_get_cc+0x3ac>)
    bb64:	68fa      	ldr	r2, [r7, #12]
    bb66:	2070      	movs	r0, #112	; 0x70
    bb68:	0013      	movs	r3, r2
    bb6a:	015b      	lsls	r3, r3, #5
    bb6c:	189b      	adds	r3, r3, r2
    bb6e:	009b      	lsls	r3, r3, #2
    bb70:	18cb      	adds	r3, r1, r3
    bb72:	181b      	adds	r3, r3, r0
    bb74:	2202      	movs	r2, #2
    bb76:	701a      	strb	r2, [r3, #0]
    bb78:	e043      	b.n	bc02 <fusb305_tcpc_get_cc+0x432>
    bb7a:	46c0      	nop			; (mov r8, r8)
    bb7c:	000300b8 	.word	0x000300b8
    bb80:	0001f3cc 	.word	0x0001f3cc
    bb84:	0002febc 	.word	0x0002febc
        }
        else
        {
          /* Check that on another pin than a RA is present */
          if ((TYPEC_CC_OPEN != state[Port].Registers.Control.s.u3.b3.CC1_TERM)
    bb88:	4921      	ldr	r1, [pc, #132]	; (bc10 <fusb305_tcpc_get_cc+0x440>)
    bb8a:	68fa      	ldr	r2, [r7, #12]
    bb8c:	2010      	movs	r0, #16
    bb8e:	0013      	movs	r3, r2
    bb90:	015b      	lsls	r3, r3, #5
    bb92:	189b      	adds	r3, r3, r2
    bb94:	009b      	lsls	r3, r3, #2
    bb96:	18cb      	adds	r3, r1, r3
    bb98:	181b      	adds	r3, r3, r0
    bb9a:	791b      	ldrb	r3, [r3, #4]
    bb9c:	079b      	lsls	r3, r3, #30
    bb9e:	0f9b      	lsrs	r3, r3, #30
    bba0:	b2db      	uxtb	r3, r3
    bba2:	2b03      	cmp	r3, #3
    bba4:	d00e      	beq.n	bbc4 <fusb305_tcpc_get_cc+0x3f4>
            && (TYPEC_CC_VOLT_RA == *CC1_Level))
    bba6:	68bb      	ldr	r3, [r7, #8]
    bba8:	681b      	ldr	r3, [r3, #0]
    bbaa:	2b01      	cmp	r3, #1
    bbac:	d10a      	bne.n	bbc4 <fusb305_tcpc_get_cc+0x3f4>
          {
            /* RA detected on pin CC1 */
            state[Port].VConnPresence = TYPEC_CC_RA;
    bbae:	4918      	ldr	r1, [pc, #96]	; (bc10 <fusb305_tcpc_get_cc+0x440>)
    bbb0:	68fa      	ldr	r2, [r7, #12]
    bbb2:	2073      	movs	r0, #115	; 0x73
    bbb4:	0013      	movs	r3, r2
    bbb6:	015b      	lsls	r3, r3, #5
    bbb8:	189b      	adds	r3, r3, r2
    bbba:	009b      	lsls	r3, r3, #2
    bbbc:	18cb      	adds	r3, r1, r3
    bbbe:	181b      	adds	r3, r3, r0
    bbc0:	2200      	movs	r2, #0
    bbc2:	701a      	strb	r2, [r3, #0]
          }
          /* Save current power role */
          state[Port].PowerRole = USBPD_PORTPOWERROLE_SRC;
    bbc4:	4912      	ldr	r1, [pc, #72]	; (bc10 <fusb305_tcpc_get_cc+0x440>)
    bbc6:	68fa      	ldr	r2, [r7, #12]
    bbc8:	0013      	movs	r3, r2
    bbca:	015b      	lsls	r3, r3, #5
    bbcc:	189b      	adds	r3, r3, r2
    bbce:	009b      	lsls	r3, r3, #2
    bbd0:	18cb      	adds	r3, r1, r3
    bbd2:	3368      	adds	r3, #104	; 0x68
    bbd4:	2201      	movs	r2, #1
    bbd6:	601a      	str	r2, [r3, #0]
          state[Port].DataRole  = USBPD_PORTDATAROLE_DFP;
    bbd8:	490d      	ldr	r1, [pc, #52]	; (bc10 <fusb305_tcpc_get_cc+0x440>)
    bbda:	68fa      	ldr	r2, [r7, #12]
    bbdc:	0013      	movs	r3, r2
    bbde:	015b      	lsls	r3, r3, #5
    bbe0:	189b      	adds	r3, r3, r2
    bbe2:	009b      	lsls	r3, r3, #2
    bbe4:	18cb      	adds	r3, r1, r3
    bbe6:	336c      	adds	r3, #108	; 0x6c
    bbe8:	2201      	movs	r2, #1
    bbea:	601a      	str	r2, [r3, #0]
          state[Port].CC_Pull   = TYPEC_CC_RP;
    bbec:	4908      	ldr	r1, [pc, #32]	; (bc10 <fusb305_tcpc_get_cc+0x440>)
    bbee:	68fa      	ldr	r2, [r7, #12]
    bbf0:	2070      	movs	r0, #112	; 0x70
    bbf2:	0013      	movs	r3, r2
    bbf4:	015b      	lsls	r3, r3, #5
    bbf6:	189b      	adds	r3, r3, r2
    bbf8:	009b      	lsls	r3, r3, #2
    bbfa:	18cb      	adds	r3, r1, r3
    bbfc:	181b      	adds	r3, r3, r0
    bbfe:	2201      	movs	r2, #1
    bc00:	701a      	strb	r2, [r3, #0]
        }
      }
    }
  }

  return status;
    bc02:	231f      	movs	r3, #31
    bc04:	18fb      	adds	r3, r7, r3
    bc06:	781b      	ldrb	r3, [r3, #0]
}
    bc08:	0018      	movs	r0, r3
    bc0a:	46bd      	mov	sp, r7
    bc0c:	b009      	add	sp, #36	; 0x24
    bc0e:	bd90      	pop	{r4, r7, pc}
    bc10:	000300b8 	.word	0x000300b8

0000bc14 <fusb305_tcpc_set_cc>:
  *         @arg @ref TYPEC_CC_OPEN
  * @param  State  State of the connection
  * @retval USBPD status
  */
USBPD_StatusTypeDef fusb305_tcpc_set_cc(uint32_t Port, TCPC_CC_Pull_TypeDef Pull, USBPD_FunctionalState State)
{
    bc14:	b5b0      	push	{r4, r5, r7, lr}
    bc16:	b082      	sub	sp, #8
    bc18:	af00      	add	r7, sp, #0
    bc1a:	6078      	str	r0, [r7, #4]
    bc1c:	0008      	movs	r0, r1
    bc1e:	0011      	movs	r1, r2
    bc20:	1cfb      	adds	r3, r7, #3
    bc22:	1c02      	adds	r2, r0, #0
    bc24:	701a      	strb	r2, [r3, #0]
    bc26:	1cbb      	adds	r3, r7, #2
    bc28:	1c0a      	adds	r2, r1, #0
    bc2a:	701a      	strb	r2, [r3, #0]
  /* Save current power role */
  if (TYPEC_CC_RP == Pull)
    bc2c:	1cfb      	adds	r3, r7, #3
    bc2e:	781b      	ldrb	r3, [r3, #0]
    bc30:	2b01      	cmp	r3, #1
    bc32:	d114      	bne.n	bc5e <fusb305_tcpc_set_cc+0x4a>
  {
    state[Port].PowerRole = USBPD_PORTPOWERROLE_SRC;
    bc34:	4940      	ldr	r1, [pc, #256]	; (bd38 <fusb305_tcpc_set_cc+0x124>)
    bc36:	687a      	ldr	r2, [r7, #4]
    bc38:	0013      	movs	r3, r2
    bc3a:	015b      	lsls	r3, r3, #5
    bc3c:	189b      	adds	r3, r3, r2
    bc3e:	009b      	lsls	r3, r3, #2
    bc40:	18cb      	adds	r3, r1, r3
    bc42:	3368      	adds	r3, #104	; 0x68
    bc44:	2201      	movs	r2, #1
    bc46:	601a      	str	r2, [r3, #0]
    state[Port].DataRole  = USBPD_PORTDATAROLE_DFP;
    bc48:	493b      	ldr	r1, [pc, #236]	; (bd38 <fusb305_tcpc_set_cc+0x124>)
    bc4a:	687a      	ldr	r2, [r7, #4]
    bc4c:	0013      	movs	r3, r2
    bc4e:	015b      	lsls	r3, r3, #5
    bc50:	189b      	adds	r3, r3, r2
    bc52:	009b      	lsls	r3, r3, #2
    bc54:	18cb      	adds	r3, r1, r3
    bc56:	336c      	adds	r3, #108	; 0x6c
    bc58:	2201      	movs	r2, #1
    bc5a:	601a      	str	r2, [r3, #0]
    bc5c:	e013      	b.n	bc86 <fusb305_tcpc_set_cc+0x72>
  }
  else
  {
    state[Port].PowerRole = USBPD_PORTPOWERROLE_SNK;
    bc5e:	4936      	ldr	r1, [pc, #216]	; (bd38 <fusb305_tcpc_set_cc+0x124>)
    bc60:	687a      	ldr	r2, [r7, #4]
    bc62:	0013      	movs	r3, r2
    bc64:	015b      	lsls	r3, r3, #5
    bc66:	189b      	adds	r3, r3, r2
    bc68:	009b      	lsls	r3, r3, #2
    bc6a:	18cb      	adds	r3, r1, r3
    bc6c:	3368      	adds	r3, #104	; 0x68
    bc6e:	2200      	movs	r2, #0
    bc70:	601a      	str	r2, [r3, #0]
    state[Port].DataRole  = USBPD_PORTDATAROLE_UFP;
    bc72:	4931      	ldr	r1, [pc, #196]	; (bd38 <fusb305_tcpc_set_cc+0x124>)
    bc74:	687a      	ldr	r2, [r7, #4]
    bc76:	0013      	movs	r3, r2
    bc78:	015b      	lsls	r3, r3, #5
    bc7a:	189b      	adds	r3, r3, r2
    bc7c:	009b      	lsls	r3, r3, #2
    bc7e:	18cb      	adds	r3, r1, r3
    bc80:	336c      	adds	r3, #108	; 0x6c
    bc82:	2200      	movs	r2, #0
    bc84:	601a      	str	r2, [r3, #0]
  }
  state[Port].CC_Pull = Pull;
    bc86:	492c      	ldr	r1, [pc, #176]	; (bd38 <fusb305_tcpc_set_cc+0x124>)
    bc88:	687a      	ldr	r2, [r7, #4]
    bc8a:	2070      	movs	r0, #112	; 0x70
    bc8c:	0013      	movs	r3, r2
    bc8e:	015b      	lsls	r3, r3, #5
    bc90:	189b      	adds	r3, r3, r2
    bc92:	009b      	lsls	r3, r3, #2
    bc94:	18cb      	adds	r3, r1, r3
    bc96:	181b      	adds	r3, r3, r0
    bc98:	1cfa      	adds	r2, r7, #3
    bc9a:	7812      	ldrb	r2, [r2, #0]
    bc9c:	701a      	strb	r2, [r3, #0]

  /* Set the role of each CC pin */
  tcpc_set_pin_role(Port, Pull, State);
    bc9e:	1cbb      	adds	r3, r7, #2
    bca0:	781a      	ldrb	r2, [r3, #0]
    bca2:	1cfb      	adds	r3, r7, #3
    bca4:	7819      	ldrb	r1, [r3, #0]
    bca6:	687b      	ldr	r3, [r7, #4]
    bca8:	0018      	movs	r0, r3
    bcaa:	f001 ff05 	bl	dab8 <tcpc_set_pin_role>

  /* Check if PD communication is enabled */
  if (state[Port].Registers.FrameInfo.u2.RECEIVE_DETECT != 0)
    bcae:	4922      	ldr	r1, [pc, #136]	; (bd38 <fusb305_tcpc_set_cc+0x124>)
    bcb0:	687a      	ldr	r2, [r7, #4]
    bcb2:	2023      	movs	r0, #35	; 0x23
    bcb4:	0013      	movs	r3, r2
    bcb6:	015b      	lsls	r3, r3, #5
    bcb8:	189b      	adds	r3, r3, r2
    bcba:	009b      	lsls	r3, r3, #2
    bcbc:	18cb      	adds	r3, r1, r3
    bcbe:	181b      	adds	r3, r3, r0
    bcc0:	781b      	ldrb	r3, [r3, #0]
    bcc2:	2b00      	cmp	r3, #0
    bcc4:	d00e      	beq.n	bce4 <fusb305_tcpc_set_cc+0xd0>
  {
    /* Udpate ALERT mask */
    tcpc_set_alert_mask(Port, state[Port].PowerRole, USBPD_ENABLE);
    bcc6:	491c      	ldr	r1, [pc, #112]	; (bd38 <fusb305_tcpc_set_cc+0x124>)
    bcc8:	687a      	ldr	r2, [r7, #4]
    bcca:	0013      	movs	r3, r2
    bccc:	015b      	lsls	r3, r3, #5
    bcce:	189b      	adds	r3, r3, r2
    bcd0:	009b      	lsls	r3, r3, #2
    bcd2:	18cb      	adds	r3, r1, r3
    bcd4:	3368      	adds	r3, #104	; 0x68
    bcd6:	681b      	ldr	r3, [r3, #0]
    bcd8:	b2d9      	uxtb	r1, r3
    bcda:	687b      	ldr	r3, [r7, #4]
    bcdc:	2201      	movs	r2, #1
    bcde:	0018      	movs	r0, r3
    bce0:	f001 fdd8 	bl	d894 <tcpc_set_alert_mask>
  }

  /* Update role in TCPC PD header */
  fusb305_tcpc_set_msg_header(Port, state[Port].PowerRole, state[Port].DataRole, state[Port].Registers.FrameInfo.u1.b1.USB_PD_REV);
    bce4:	4914      	ldr	r1, [pc, #80]	; (bd38 <fusb305_tcpc_set_cc+0x124>)
    bce6:	687a      	ldr	r2, [r7, #4]
    bce8:	0013      	movs	r3, r2
    bcea:	015b      	lsls	r3, r3, #5
    bcec:	189b      	adds	r3, r3, r2
    bcee:	009b      	lsls	r3, r3, #2
    bcf0:	18cb      	adds	r3, r1, r3
    bcf2:	3368      	adds	r3, #104	; 0x68
    bcf4:	681c      	ldr	r4, [r3, #0]
    bcf6:	4910      	ldr	r1, [pc, #64]	; (bd38 <fusb305_tcpc_set_cc+0x124>)
    bcf8:	687a      	ldr	r2, [r7, #4]
    bcfa:	0013      	movs	r3, r2
    bcfc:	015b      	lsls	r3, r3, #5
    bcfe:	189b      	adds	r3, r3, r2
    bd00:	009b      	lsls	r3, r3, #2
    bd02:	18cb      	adds	r3, r1, r3
    bd04:	336c      	adds	r3, #108	; 0x6c
    bd06:	681d      	ldr	r5, [r3, #0]
    bd08:	490b      	ldr	r1, [pc, #44]	; (bd38 <fusb305_tcpc_set_cc+0x124>)
    bd0a:	687a      	ldr	r2, [r7, #4]
    bd0c:	2020      	movs	r0, #32
    bd0e:	0013      	movs	r3, r2
    bd10:	015b      	lsls	r3, r3, #5
    bd12:	189b      	adds	r3, r3, r2
    bd14:	009b      	lsls	r3, r3, #2
    bd16:	18cb      	adds	r3, r1, r3
    bd18:	181b      	adds	r3, r3, r0
    bd1a:	789b      	ldrb	r3, [r3, #2]
    bd1c:	075b      	lsls	r3, r3, #29
    bd1e:	0f9b      	lsrs	r3, r3, #30
    bd20:	b2db      	uxtb	r3, r3
    bd22:	6878      	ldr	r0, [r7, #4]
    bd24:	002a      	movs	r2, r5
    bd26:	0021      	movs	r1, r4
    bd28:	f000 f8da 	bl	bee0 <fusb305_tcpc_set_msg_header>
  
  return USBPD_OK;
    bd2c:	2300      	movs	r3, #0
}
    bd2e:	0018      	movs	r0, r3
    bd30:	46bd      	mov	sp, r7
    bd32:	b002      	add	sp, #8
    bd34:	bdb0      	pop	{r4, r5, r7, pc}
    bd36:	46c0      	nop			; (mov r8, r8)
    bd38:	000300b8 	.word	0x000300b8

0000bd3c <fusb305_tcpc_set_polarity>:
  * @param  Port port number value
  * @param  Polarity Polarity
  * @retval USBPD status
  */
USBPD_StatusTypeDef fusb305_tcpc_set_polarity(uint32_t Port, uint8_t Polarity)
{
    bd3c:	b5b0      	push	{r4, r5, r7, lr}
    bd3e:	b084      	sub	sp, #16
    bd40:	af00      	add	r7, sp, #0
    bd42:	6078      	str	r0, [r7, #4]
    bd44:	000a      	movs	r2, r1
    bd46:	1cfb      	adds	r3, r7, #3
    bd48:	701a      	strb	r2, [r3, #0]
  USBPD_StatusTypeDef status = USBPD_FAIL;
    bd4a:	250f      	movs	r5, #15
    bd4c:	197b      	adds	r3, r7, r5
    bd4e:	2210      	movs	r2, #16
    bd50:	701a      	strb	r2, [r3, #0]
  state[Port].Registers.Control.s.u2.b2.PLUG_ORIENT = Polarity;
    bd52:	1cfb      	adds	r3, r7, #3
    bd54:	781b      	ldrb	r3, [r3, #0]
    bd56:	2201      	movs	r2, #1
    bd58:	4013      	ands	r3, r2
    bd5a:	b2d9      	uxtb	r1, r3
    bd5c:	4815      	ldr	r0, [pc, #84]	; (bdb4 <fusb305_tcpc_set_polarity+0x78>)
    bd5e:	687a      	ldr	r2, [r7, #4]
    bd60:	2410      	movs	r4, #16
    bd62:	0013      	movs	r3, r2
    bd64:	015b      	lsls	r3, r3, #5
    bd66:	189b      	adds	r3, r3, r2
    bd68:	009b      	lsls	r3, r3, #2
    bd6a:	18c3      	adds	r3, r0, r3
    bd6c:	191b      	adds	r3, r3, r4
    bd6e:	2201      	movs	r2, #1
    bd70:	4011      	ands	r1, r2
    bd72:	0008      	movs	r0, r1
    bd74:	78da      	ldrb	r2, [r3, #3]
    bd76:	2101      	movs	r1, #1
    bd78:	438a      	bics	r2, r1
    bd7a:	1c11      	adds	r1, r2, #0
    bd7c:	1c02      	adds	r2, r0, #0
    bd7e:	430a      	orrs	r2, r1
    bd80:	70da      	strb	r2, [r3, #3]

  status = USBPD_TCPCI_WriteRegister(Port, TCPC_REG_TCPC_CONTROL, &state[Port].Registers.Control.s.u2.TCPC_CONTROL, 1);
    bd82:	687b      	ldr	r3, [r7, #4]
    bd84:	b2d8      	uxtb	r0, r3
    bd86:	687a      	ldr	r2, [r7, #4]
    bd88:	0013      	movs	r3, r2
    bd8a:	015b      	lsls	r3, r3, #5
    bd8c:	189b      	adds	r3, r3, r2
    bd8e:	009b      	lsls	r3, r3, #2
    bd90:	3310      	adds	r3, #16
    bd92:	001a      	movs	r2, r3
    bd94:	4b07      	ldr	r3, [pc, #28]	; (bdb4 <fusb305_tcpc_set_polarity+0x78>)
    bd96:	18d3      	adds	r3, r2, r3
    bd98:	1cda      	adds	r2, r3, #3
    bd9a:	197c      	adds	r4, r7, r5
    bd9c:	2301      	movs	r3, #1
    bd9e:	2119      	movs	r1, #25
    bda0:	f002 f902 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
    bda4:	0003      	movs	r3, r0
    bda6:	7023      	strb	r3, [r4, #0]
    state[Port].Registers.StatusMask.s.u1.POWER_STATUS_MASK = TCPC_REG_POWER_STATUS_MASK_VBUS_PRES;
    status |= USBPD_TCPCI_WriteRegister(Port, TCPC_REG_POWER_STATUS_MASK , &state[Port].Registers.StatusMask.s.u1.POWER_STATUS_MASK, 1);
  }
#endif

  return status;
    bda8:	197b      	adds	r3, r7, r5
    bdaa:	781b      	ldrb	r3, [r3, #0]
}
    bdac:	0018      	movs	r0, r3
    bdae:	46bd      	mov	sp, r7
    bdb0:	b004      	add	sp, #16
    bdb2:	bdb0      	pop	{r4, r5, r7, pc}
    bdb4:	000300b8 	.word	0x000300b8

0000bdb8 <fusb305_tcpc_set_vconn>:
  * @param  Port port number value
  * @param  State Activation or deactivation of VCONN
  * @retval USBPD status
  */
USBPD_StatusTypeDef fusb305_tcpc_set_vconn(uint32_t Port, USBPD_FunctionalState State)
{
    bdb8:	b580      	push	{r7, lr}
    bdba:	b082      	sub	sp, #8
    bdbc:	af00      	add	r7, sp, #0
    bdbe:	6078      	str	r0, [r7, #4]
    bdc0:	000a      	movs	r2, r1
    bdc2:	1cfb      	adds	r3, r7, #3
    bdc4:	701a      	strb	r2, [r3, #0]
  state[Port].Registers.Control.s.u5.b5.EN_VCONN = 0;
    bdc6:	4945      	ldr	r1, [pc, #276]	; (bedc <fusb305_tcpc_set_vconn+0x124>)
    bdc8:	687a      	ldr	r2, [r7, #4]
    bdca:	2010      	movs	r0, #16
    bdcc:	0013      	movs	r3, r2
    bdce:	015b      	lsls	r3, r3, #5
    bdd0:	189b      	adds	r3, r3, r2
    bdd2:	009b      	lsls	r3, r3, #2
    bdd4:	18cb      	adds	r3, r1, r3
    bdd6:	181b      	adds	r3, r3, r0
    bdd8:	799a      	ldrb	r2, [r3, #6]
    bdda:	2101      	movs	r1, #1
    bddc:	438a      	bics	r2, r1
    bdde:	719a      	strb	r2, [r3, #6]
  if (State)
    bde0:	1cfb      	adds	r3, r7, #3
    bde2:	781b      	ldrb	r3, [r3, #0]
    bde4:	2b00      	cmp	r3, #0
    bde6:	d00c      	beq.n	be02 <fusb305_tcpc_set_vconn+0x4a>
  {
    state[Port].Registers.Control.s.u5.b5.EN_VCONN = 1;
    bde8:	493c      	ldr	r1, [pc, #240]	; (bedc <fusb305_tcpc_set_vconn+0x124>)
    bdea:	687a      	ldr	r2, [r7, #4]
    bdec:	2010      	movs	r0, #16
    bdee:	0013      	movs	r3, r2
    bdf0:	015b      	lsls	r3, r3, #5
    bdf2:	189b      	adds	r3, r3, r2
    bdf4:	009b      	lsls	r3, r3, #2
    bdf6:	18cb      	adds	r3, r1, r3
    bdf8:	181b      	adds	r3, r3, r0
    bdfa:	799a      	ldrb	r2, [r3, #6]
    bdfc:	2101      	movs	r1, #1
    bdfe:	430a      	orrs	r2, r1
    be00:	719a      	strb	r2, [r3, #6]
  }
  USBPD_TCPCI_WriteRegister(Port, TCPC_REG_POWER_CONTROL, &state[Port].Registers.Control.s.u5.POWER_CONTROL, 1);
    be02:	687b      	ldr	r3, [r7, #4]
    be04:	b2d8      	uxtb	r0, r3
    be06:	687a      	ldr	r2, [r7, #4]
    be08:	0013      	movs	r3, r2
    be0a:	015b      	lsls	r3, r3, #5
    be0c:	189b      	adds	r3, r3, r2
    be0e:	009b      	lsls	r3, r3, #2
    be10:	3310      	adds	r3, #16
    be12:	001a      	movs	r2, r3
    be14:	4b31      	ldr	r3, [pc, #196]	; (bedc <fusb305_tcpc_set_vconn+0x124>)
    be16:	18d3      	adds	r3, r2, r3
    be18:	1d9a      	adds	r2, r3, #6
    be1a:	2301      	movs	r3, #1
    be1c:	211c      	movs	r1, #28
    be1e:	f002 f8c3 	bl	dfa8 <USBPD_TCPCI_WriteRegister>

  USBPD_TCPCI_ReadRegister(Port, TCPC_REG_POWER_STATUS, &state[Port].Registers.Status.u2.POWER_STATUS, 1);
    be22:	687b      	ldr	r3, [r7, #4]
    be24:	b2d8      	uxtb	r0, r3
    be26:	687a      	ldr	r2, [r7, #4]
    be28:	0013      	movs	r3, r2
    be2a:	015b      	lsls	r3, r3, #5
    be2c:	189b      	adds	r3, r3, r2
    be2e:	009b      	lsls	r3, r3, #2
    be30:	3310      	adds	r3, #16
    be32:	001a      	movs	r2, r3
    be34:	4b29      	ldr	r3, [pc, #164]	; (bedc <fusb305_tcpc_set_vconn+0x124>)
    be36:	18d3      	adds	r3, r2, r3
    be38:	3308      	adds	r3, #8
    be3a:	001a      	movs	r2, r3
    be3c:	2301      	movs	r3, #1
    be3e:	211e      	movs	r1, #30
    be40:	f002 f9f4 	bl	e22c <USBPD_TCPCI_ReadRegister>
  
  if (State)
    be44:	1cfb      	adds	r3, r7, #3
    be46:	781b      	ldrb	r3, [r3, #0]
    be48:	2b00      	cmp	r3, #0
    be4a:	d032      	beq.n	beb2 <fusb305_tcpc_set_vconn+0xfa>
  {
    while (state[Port].Registers.Status.u2.b2.VCONN_VAL == 0)
    be4c:	e010      	b.n	be70 <fusb305_tcpc_set_vconn+0xb8>
      USBPD_TCPCI_ReadRegister(Port, TCPC_REG_POWER_STATUS, &state[Port].Registers.Status.u2.POWER_STATUS, 1);
    be4e:	687b      	ldr	r3, [r7, #4]
    be50:	b2d8      	uxtb	r0, r3
    be52:	687a      	ldr	r2, [r7, #4]
    be54:	0013      	movs	r3, r2
    be56:	015b      	lsls	r3, r3, #5
    be58:	189b      	adds	r3, r3, r2
    be5a:	009b      	lsls	r3, r3, #2
    be5c:	3310      	adds	r3, #16
    be5e:	001a      	movs	r2, r3
    be60:	4b1e      	ldr	r3, [pc, #120]	; (bedc <fusb305_tcpc_set_vconn+0x124>)
    be62:	18d3      	adds	r3, r2, r3
    be64:	3308      	adds	r3, #8
    be66:	001a      	movs	r2, r3
    be68:	2301      	movs	r3, #1
    be6a:	211e      	movs	r1, #30
    be6c:	f002 f9de 	bl	e22c <USBPD_TCPCI_ReadRegister>
    while (state[Port].Registers.Status.u2.b2.VCONN_VAL == 0)
    be70:	491a      	ldr	r1, [pc, #104]	; (bedc <fusb305_tcpc_set_vconn+0x124>)
    be72:	687a      	ldr	r2, [r7, #4]
    be74:	2010      	movs	r0, #16
    be76:	0013      	movs	r3, r2
    be78:	015b      	lsls	r3, r3, #5
    be7a:	189b      	adds	r3, r3, r2
    be7c:	009b      	lsls	r3, r3, #2
    be7e:	18cb      	adds	r3, r1, r3
    be80:	181b      	adds	r3, r3, r0
    be82:	7a1b      	ldrb	r3, [r3, #8]
    be84:	079b      	lsls	r3, r3, #30
    be86:	0fdb      	lsrs	r3, r3, #31
    be88:	b2db      	uxtb	r3, r3
    be8a:	2b00      	cmp	r3, #0
    be8c:	d0df      	beq.n	be4e <fusb305_tcpc_set_vconn+0x96>
    be8e:	e01f      	b.n	bed0 <fusb305_tcpc_set_vconn+0x118>
  }
  else
  {
    while (state[Port].Registers.Status.u2.b2.VCONN_VAL == 1)
      USBPD_TCPCI_ReadRegister(Port, TCPC_REG_POWER_STATUS, &state[Port].Registers.Status.u2.POWER_STATUS, 1);
    be90:	687b      	ldr	r3, [r7, #4]
    be92:	b2d8      	uxtb	r0, r3
    be94:	687a      	ldr	r2, [r7, #4]
    be96:	0013      	movs	r3, r2
    be98:	015b      	lsls	r3, r3, #5
    be9a:	189b      	adds	r3, r3, r2
    be9c:	009b      	lsls	r3, r3, #2
    be9e:	3310      	adds	r3, #16
    bea0:	001a      	movs	r2, r3
    bea2:	4b0e      	ldr	r3, [pc, #56]	; (bedc <fusb305_tcpc_set_vconn+0x124>)
    bea4:	18d3      	adds	r3, r2, r3
    bea6:	3308      	adds	r3, #8
    bea8:	001a      	movs	r2, r3
    beaa:	2301      	movs	r3, #1
    beac:	211e      	movs	r1, #30
    beae:	f002 f9bd 	bl	e22c <USBPD_TCPCI_ReadRegister>
    while (state[Port].Registers.Status.u2.b2.VCONN_VAL == 1)
    beb2:	490a      	ldr	r1, [pc, #40]	; (bedc <fusb305_tcpc_set_vconn+0x124>)
    beb4:	687a      	ldr	r2, [r7, #4]
    beb6:	2010      	movs	r0, #16
    beb8:	0013      	movs	r3, r2
    beba:	015b      	lsls	r3, r3, #5
    bebc:	189b      	adds	r3, r3, r2
    bebe:	009b      	lsls	r3, r3, #2
    bec0:	18cb      	adds	r3, r1, r3
    bec2:	181b      	adds	r3, r3, r0
    bec4:	7a1b      	ldrb	r3, [r3, #8]
    bec6:	079b      	lsls	r3, r3, #30
    bec8:	0fdb      	lsrs	r3, r3, #31
    beca:	b2db      	uxtb	r3, r3
    becc:	2b01      	cmp	r3, #1
    bece:	d0df      	beq.n	be90 <fusb305_tcpc_set_vconn+0xd8>
  }
 
  return USBPD_OK;
    bed0:	2300      	movs	r3, #0
}
    bed2:	0018      	movs	r0, r3
    bed4:	46bd      	mov	sp, r7
    bed6:	b002      	add	sp, #8
    bed8:	bd80      	pop	{r7, pc}
    beda:	46c0      	nop			; (mov r8, r8)
    bedc:	000300b8 	.word	0x000300b8

0000bee0 <fusb305_tcpc_set_msg_header>:
  * @param  DataRole  Data role
  * @param  Specification   PD Specification version
  * @retval USBPD status
  */
USBPD_StatusTypeDef fusb305_tcpc_set_msg_header(uint32_t PortNum, USBPD_PortPowerRole_TypeDef PowerRole, USBPD_PortDataRole_TypeDef DataRole, USBPD_SpecRev_TypeDef Specification)
{
    bee0:	b590      	push	{r4, r7, lr}
    bee2:	b085      	sub	sp, #20
    bee4:	af00      	add	r7, sp, #0
    bee6:	60f8      	str	r0, [r7, #12]
    bee8:	60b9      	str	r1, [r7, #8]
    beea:	607a      	str	r2, [r7, #4]
    beec:	603b      	str	r3, [r7, #0]
  state[PortNum].Registers.FrameInfo.u1.MESSAGE_HEADER_INFO = TCPC_REG_MSG_HEADER_INFO_SET(DataRole, PowerRole, USBPD_SPECIFICATION_REV2);
    beee:	687b      	ldr	r3, [r7, #4]
    bef0:	b2db      	uxtb	r3, r3
    bef2:	00db      	lsls	r3, r3, #3
    bef4:	b2da      	uxtb	r2, r3
    bef6:	68bb      	ldr	r3, [r7, #8]
    bef8:	b2db      	uxtb	r3, r3
    befa:	4313      	orrs	r3, r2
    befc:	b2db      	uxtb	r3, r3
    befe:	2202      	movs	r2, #2
    bf00:	4313      	orrs	r3, r2
    bf02:	b2dc      	uxtb	r4, r3
    bf04:	490f      	ldr	r1, [pc, #60]	; (bf44 <fusb305_tcpc_set_msg_header+0x64>)
    bf06:	68fa      	ldr	r2, [r7, #12]
    bf08:	2022      	movs	r0, #34	; 0x22
    bf0a:	0013      	movs	r3, r2
    bf0c:	015b      	lsls	r3, r3, #5
    bf0e:	189b      	adds	r3, r3, r2
    bf10:	009b      	lsls	r3, r3, #2
    bf12:	18cb      	adds	r3, r1, r3
    bf14:	181b      	adds	r3, r3, r0
    bf16:	1c22      	adds	r2, r4, #0
    bf18:	701a      	strb	r2, [r3, #0]

  return USBPD_TCPCI_WriteRegister(PortNum, TCPC_REG_MSG_HEADER_INFO, &state[PortNum].Registers.FrameInfo.u1.MESSAGE_HEADER_INFO, 1);
    bf1a:	68fb      	ldr	r3, [r7, #12]
    bf1c:	b2d8      	uxtb	r0, r3
    bf1e:	68fa      	ldr	r2, [r7, #12]
    bf20:	0013      	movs	r3, r2
    bf22:	015b      	lsls	r3, r3, #5
    bf24:	189b      	adds	r3, r3, r2
    bf26:	009b      	lsls	r3, r3, #2
    bf28:	3320      	adds	r3, #32
    bf2a:	001a      	movs	r2, r3
    bf2c:	4b05      	ldr	r3, [pc, #20]	; (bf44 <fusb305_tcpc_set_msg_header+0x64>)
    bf2e:	18d3      	adds	r3, r2, r3
    bf30:	1c9a      	adds	r2, r3, #2
    bf32:	2301      	movs	r3, #1
    bf34:	212e      	movs	r1, #46	; 0x2e
    bf36:	f002 f837 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
    bf3a:	0003      	movs	r3, r0
}
    bf3c:	0018      	movs	r0, r3
    bf3e:	46bd      	mov	sp, r7
    bf40:	b005      	add	sp, #20
    bf42:	bd90      	pop	{r4, r7, pc}
    bf44:	000300b8 	.word	0x000300b8

0000bf48 <fusb305_tcpc_set_rx_state>:
  * @param  SupportedSOP  Supported SOP by PRL
  * @param  HardReset     Hard reset status based on @ref TCPC_hard_reset
  * @retval USBPD status
  */
USBPD_StatusTypeDef fusb305_tcpc_set_rx_state(uint32_t Port, TCPC_CC_Pull_TypeDef Pull, USBPD_FunctionalState State, uint32_t SupportedSOP, TCPC_hard_reset HardReset)
{
    bf48:	b5b0      	push	{r4, r5, r7, lr}
    bf4a:	b08c      	sub	sp, #48	; 0x30
    bf4c:	af02      	add	r7, sp, #8
    bf4e:	60f8      	str	r0, [r7, #12]
    bf50:	0008      	movs	r0, r1
    bf52:	0011      	movs	r1, r2
    bf54:	607b      	str	r3, [r7, #4]
    bf56:	230b      	movs	r3, #11
    bf58:	18fb      	adds	r3, r7, r3
    bf5a:	1c02      	adds	r2, r0, #0
    bf5c:	701a      	strb	r2, [r3, #0]
    bf5e:	240a      	movs	r4, #10
    bf60:	193b      	adds	r3, r7, r4
    bf62:	1c0a      	adds	r2, r1, #0
    bf64:	701a      	strb	r2, [r3, #0]
  USBPD_StatusTypeDef status = USBPD_OK;
    bf66:	2327      	movs	r3, #39	; 0x27
    bf68:	18fb      	adds	r3, r7, r3
    bf6a:	2200      	movs	r2, #0
    bf6c:	701a      	strb	r2, [r3, #0]
#if defined(_TRACE)
  {
    uint8_t tracedata[18] = {0};
    bf6e:	2514      	movs	r5, #20
    bf70:	197b      	adds	r3, r7, r5
    bf72:	0018      	movs	r0, r3
    bf74:	2312      	movs	r3, #18
    bf76:	001a      	movs	r2, r3
    bf78:	2100      	movs	r1, #0
    bf7a:	f012 fb94 	bl	1e6a6 <memset>
    sprintf((char*)tracedata,"state=%d", State);
    bf7e:	193b      	adds	r3, r7, r4
    bf80:	781a      	ldrb	r2, [r3, #0]
    bf82:	49a2      	ldr	r1, [pc, #648]	; (c20c <fusb305_tcpc_set_rx_state+0x2c4>)
    bf84:	197b      	adds	r3, r7, r5
    bf86:	0018      	movs	r0, r3
    bf88:	f012 fc50 	bl	1e82c <siprintf>
    FUSB307_DEBUG_TRACE(Port, FUSB307_DEBUG_LEVEL_0, tracedata);
    bf8c:	4ba0      	ldr	r3, [pc, #640]	; (c210 <fusb305_tcpc_set_rx_state+0x2c8>)
    bf8e:	781b      	ldrb	r3, [r3, #0]
    bf90:	001a      	movs	r2, r3
    bf92:	2301      	movs	r3, #1
    bf94:	4013      	ands	r3, r2
    bf96:	d00a      	beq.n	bfae <fusb305_tcpc_set_rx_state+0x66>
    bf98:	68fb      	ldr	r3, [r7, #12]
    bf9a:	b2d9      	uxtb	r1, r3
    bf9c:	2314      	movs	r3, #20
    bf9e:	18fa      	adds	r2, r7, r3
    bfa0:	2311      	movs	r3, #17
    bfa2:	9300      	str	r3, [sp, #0]
    bfa4:	0013      	movs	r3, r2
    bfa6:	2200      	movs	r2, #0
    bfa8:	2006      	movs	r0, #6
    bfaa:	f004 fadb 	bl	10564 <USBPD_TRACE_Add>
  }
#endif

  /* Just enable RX after receiving a hard reset */
  if ((TCPC_HARD_RESET_RECEIVED == HardReset) || (TCPC_HARD_RESET_SENT == HardReset))
    bfae:	2338      	movs	r3, #56	; 0x38
    bfb0:	18fb      	adds	r3, r7, r3
    bfb2:	781b      	ldrb	r3, [r3, #0]
    bfb4:	2b02      	cmp	r3, #2
    bfb6:	d004      	beq.n	bfc2 <fusb305_tcpc_set_rx_state+0x7a>
    bfb8:	2338      	movs	r3, #56	; 0x38
    bfba:	18fb      	adds	r3, r7, r3
    bfbc:	781b      	ldrb	r3, [r3, #0]
    bfbe:	2b01      	cmp	r3, #1
    bfc0:	d138      	bne.n	c034 <fusb305_tcpc_set_rx_state+0xec>
  {
    /* Enable RX */
    state[Port].Registers.FrameInfo.u2.RECEIVE_DETECT = SupportedSOP;
    bfc2:	687b      	ldr	r3, [r7, #4]
    bfc4:	b2dc      	uxtb	r4, r3
    bfc6:	4993      	ldr	r1, [pc, #588]	; (c214 <fusb305_tcpc_set_rx_state+0x2cc>)
    bfc8:	68fa      	ldr	r2, [r7, #12]
    bfca:	2023      	movs	r0, #35	; 0x23
    bfcc:	0013      	movs	r3, r2
    bfce:	015b      	lsls	r3, r3, #5
    bfd0:	189b      	adds	r3, r3, r2
    bfd2:	009b      	lsls	r3, r3, #2
    bfd4:	18cb      	adds	r3, r1, r3
    bfd6:	181b      	adds	r3, r3, r0
    bfd8:	1c22      	adds	r2, r4, #0
    bfda:	701a      	strb	r2, [r3, #0]
    state[Port].Registers.FrameInfo.u2.b2.EN_HRD_RST  = 1;
    bfdc:	498d      	ldr	r1, [pc, #564]	; (c214 <fusb305_tcpc_set_rx_state+0x2cc>)
    bfde:	68fa      	ldr	r2, [r7, #12]
    bfe0:	2020      	movs	r0, #32
    bfe2:	0013      	movs	r3, r2
    bfe4:	015b      	lsls	r3, r3, #5
    bfe6:	189b      	adds	r3, r3, r2
    bfe8:	009b      	lsls	r3, r3, #2
    bfea:	18cb      	adds	r3, r1, r3
    bfec:	181b      	adds	r3, r3, r0
    bfee:	78da      	ldrb	r2, [r3, #3]
    bff0:	2120      	movs	r1, #32
    bff2:	430a      	orrs	r2, r1
    bff4:	70da      	strb	r2, [r3, #3]
    USBPD_TCPCI_WriteRegister(Port, TCPC_REG_RX_DETECT, (uint8_t*)&state[Port].Registers.FrameInfo.u2.RECEIVE_DETECT, 1);
    bff6:	68fb      	ldr	r3, [r7, #12]
    bff8:	b2d8      	uxtb	r0, r3
    bffa:	68fa      	ldr	r2, [r7, #12]
    bffc:	0013      	movs	r3, r2
    bffe:	015b      	lsls	r3, r3, #5
    c000:	189b      	adds	r3, r3, r2
    c002:	009b      	lsls	r3, r3, #2
    c004:	3320      	adds	r3, #32
    c006:	001a      	movs	r2, r3
    c008:	4b82      	ldr	r3, [pc, #520]	; (c214 <fusb305_tcpc_set_rx_state+0x2cc>)
    c00a:	18d3      	adds	r3, r2, r3
    c00c:	1cda      	adds	r2, r3, #3
    c00e:	2301      	movs	r3, #1
    c010:	212f      	movs	r1, #47	; 0x2f
    c012:	f001 ffc9 	bl	dfa8 <USBPD_TCPCI_WriteRegister>

    /* Disable CC interuptions */
    state[Port].HardReset = 1;
    c016:	497f      	ldr	r1, [pc, #508]	; (c214 <fusb305_tcpc_set_rx_state+0x2cc>)
    c018:	68fa      	ldr	r2, [r7, #12]
    c01a:	2080      	movs	r0, #128	; 0x80
    c01c:	0013      	movs	r3, r2
    c01e:	015b      	lsls	r3, r3, #5
    c020:	189b      	adds	r3, r3, r2
    c022:	009b      	lsls	r3, r3, #2
    c024:	18cb      	adds	r3, r1, r3
    c026:	181b      	adds	r3, r3, r0
    c028:	2201      	movs	r2, #1
    c02a:	701a      	strb	r2, [r3, #0]

    return status;
    c02c:	2327      	movs	r3, #39	; 0x27
    c02e:	18fb      	adds	r3, r7, r3
    c030:	781b      	ldrb	r3, [r3, #0]
    c032:	e17f      	b.n	c334 <fusb305_tcpc_set_rx_state+0x3ec>
  }

  /* Check if TCPC role is set to source */
  if (TYPEC_CC_RP == Pull)
    c034:	230b      	movs	r3, #11
    c036:	18fb      	adds	r3, r7, r3
    c038:	781b      	ldrb	r3, [r3, #0]
    c03a:	2b01      	cmp	r3, #1
    c03c:	d121      	bne.n	c082 <fusb305_tcpc_set_rx_state+0x13a>
  {
    state[Port].Registers.StatusMask.s.u1.POWER_STATUS_MASK = 0xFF;
    c03e:	4975      	ldr	r1, [pc, #468]	; (c214 <fusb305_tcpc_set_rx_state+0x2cc>)
    c040:	68fa      	ldr	r2, [r7, #12]
    c042:	0013      	movs	r3, r2
    c044:	015b      	lsls	r3, r3, #5
    c046:	189b      	adds	r3, r3, r2
    c048:	009b      	lsls	r3, r3, #2
    c04a:	18cb      	adds	r3, r1, r3
    c04c:	3310      	adds	r3, #16
    c04e:	22ff      	movs	r2, #255	; 0xff
    c050:	701a      	strb	r2, [r3, #0]
    status |= USBPD_TCPCI_WriteRegister(Port, TCPC_REG_POWER_STATUS_MASK , &state[Port].Registers.StatusMask.s.u1.POWER_STATUS_MASK, 1);
    c052:	68fb      	ldr	r3, [r7, #12]
    c054:	b2d8      	uxtb	r0, r3
    c056:	68fa      	ldr	r2, [r7, #12]
    c058:	0013      	movs	r3, r2
    c05a:	015b      	lsls	r3, r3, #5
    c05c:	189b      	adds	r3, r3, r2
    c05e:	009b      	lsls	r3, r3, #2
    c060:	3310      	adds	r3, #16
    c062:	001a      	movs	r2, r3
    c064:	4b6b      	ldr	r3, [pc, #428]	; (c214 <fusb305_tcpc_set_rx_state+0x2cc>)
    c066:	18d2      	adds	r2, r2, r3
    c068:	2301      	movs	r3, #1
    c06a:	2114      	movs	r1, #20
    c06c:	f001 ff9c 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
    c070:	0003      	movs	r3, r0
    c072:	0019      	movs	r1, r3
    c074:	2227      	movs	r2, #39	; 0x27
    c076:	18bb      	adds	r3, r7, r2
    c078:	18ba      	adds	r2, r7, r2
    c07a:	7812      	ldrb	r2, [r2, #0]
    c07c:	430a      	orrs	r2, r1
    c07e:	701a      	strb	r2, [r3, #0]
    c080:	e020      	b.n	c0c4 <fusb305_tcpc_set_rx_state+0x17c>
  }
  else
  {
    state[Port].Registers.StatusMask.s.u1.POWER_STATUS_MASK = TCPC_REG_POWER_STATUS_MASK_VBUS_PRES;
    c082:	4964      	ldr	r1, [pc, #400]	; (c214 <fusb305_tcpc_set_rx_state+0x2cc>)
    c084:	68fa      	ldr	r2, [r7, #12]
    c086:	0013      	movs	r3, r2
    c088:	015b      	lsls	r3, r3, #5
    c08a:	189b      	adds	r3, r3, r2
    c08c:	009b      	lsls	r3, r3, #2
    c08e:	18cb      	adds	r3, r1, r3
    c090:	3310      	adds	r3, #16
    c092:	2204      	movs	r2, #4
    c094:	701a      	strb	r2, [r3, #0]
    status |= USBPD_TCPCI_WriteRegister(Port, TCPC_REG_POWER_STATUS_MASK , &state[Port].Registers.StatusMask.s.u1.POWER_STATUS_MASK, 1);
    c096:	68fb      	ldr	r3, [r7, #12]
    c098:	b2d8      	uxtb	r0, r3
    c09a:	68fa      	ldr	r2, [r7, #12]
    c09c:	0013      	movs	r3, r2
    c09e:	015b      	lsls	r3, r3, #5
    c0a0:	189b      	adds	r3, r3, r2
    c0a2:	009b      	lsls	r3, r3, #2
    c0a4:	3310      	adds	r3, #16
    c0a6:	001a      	movs	r2, r3
    c0a8:	4b5a      	ldr	r3, [pc, #360]	; (c214 <fusb305_tcpc_set_rx_state+0x2cc>)
    c0aa:	18d2      	adds	r2, r2, r3
    c0ac:	2301      	movs	r3, #1
    c0ae:	2114      	movs	r1, #20
    c0b0:	f001 ff7a 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
    c0b4:	0003      	movs	r3, r0
    c0b6:	0019      	movs	r1, r3
    c0b8:	2227      	movs	r2, #39	; 0x27
    c0ba:	18bb      	adds	r3, r7, r2
    c0bc:	18ba      	adds	r2, r7, r2
    c0be:	7812      	ldrb	r2, [r2, #0]
    c0c0:	430a      	orrs	r2, r1
    c0c2:	701a      	strb	r2, [r3, #0]
  }

  /* If enable, then set RX detect for SOP */
  if (State)
    c0c4:	230a      	movs	r3, #10
    c0c6:	18fb      	adds	r3, r7, r3
    c0c8:	781b      	ldrb	r3, [r3, #0]
    c0ca:	2b00      	cmp	r3, #0
    c0cc:	d100      	bne.n	c0d0 <fusb305_tcpc_set_rx_state+0x188>
    c0ce:	e0a3      	b.n	c218 <fusb305_tcpc_set_rx_state+0x2d0>
  {
    /* Set role of CC pins */
    fusb305_tcpc_set_cc(Port, Pull, State);
    c0d0:	230a      	movs	r3, #10
    c0d2:	18fb      	adds	r3, r7, r3
    c0d4:	781a      	ldrb	r2, [r3, #0]
    c0d6:	240b      	movs	r4, #11
    c0d8:	193b      	adds	r3, r7, r4
    c0da:	7819      	ldrb	r1, [r3, #0]
    c0dc:	68fb      	ldr	r3, [r7, #12]
    c0de:	0018      	movs	r0, r3
    c0e0:	f7ff fd98 	bl	bc14 <fusb305_tcpc_set_cc>

    if (TYPEC_CC_RD == Pull)
    c0e4:	193b      	adds	r3, r7, r4
    c0e6:	781b      	ldrb	r3, [r3, #0]
    c0e8:	2b02      	cmp	r3, #2
    c0ea:	d10a      	bne.n	c102 <fusb305_tcpc_set_rx_state+0x1ba>
    {
      state[Port].TypeC_State = AttachWaitSink;
    c0ec:	4949      	ldr	r1, [pc, #292]	; (c214 <fusb305_tcpc_set_rx_state+0x2cc>)
    c0ee:	68fa      	ldr	r2, [r7, #12]
    c0f0:	2072      	movs	r0, #114	; 0x72
    c0f2:	0013      	movs	r3, r2
    c0f4:	015b      	lsls	r3, r3, #5
    c0f6:	189b      	adds	r3, r3, r2
    c0f8:	009b      	lsls	r3, r3, #2
    c0fa:	18cb      	adds	r3, r1, r3
    c0fc:	181b      	adds	r3, r3, r0
    c0fe:	2203      	movs	r2, #3
    c100:	701a      	strb	r2, [r3, #0]
    }

    if (USBPD_OK == tcpc_set_power(Port, State, HardReset))
    c102:	2338      	movs	r3, #56	; 0x38
    c104:	18fb      	adds	r3, r7, r3
    c106:	781a      	ldrb	r2, [r3, #0]
    c108:	230a      	movs	r3, #10
    c10a:	18fb      	adds	r3, r7, r3
    c10c:	7819      	ldrb	r1, [r3, #0]
    c10e:	68fb      	ldr	r3, [r7, #12]
    c110:	0018      	movs	r0, r3
    c112:	f000 fead 	bl	ce70 <tcpc_set_power>
    c116:	1e03      	subs	r3, r0, #0
    c118:	d144      	bne.n	c1a4 <fusb305_tcpc_set_rx_state+0x25c>
    {
      /* Update ALERT mask */
      tcpc_set_alert_mask(Port, state[Port].PowerRole, USBPD_ENABLE);
    c11a:	493e      	ldr	r1, [pc, #248]	; (c214 <fusb305_tcpc_set_rx_state+0x2cc>)
    c11c:	68fa      	ldr	r2, [r7, #12]
    c11e:	0013      	movs	r3, r2
    c120:	015b      	lsls	r3, r3, #5
    c122:	189b      	adds	r3, r3, r2
    c124:	009b      	lsls	r3, r3, #2
    c126:	18cb      	adds	r3, r1, r3
    c128:	3368      	adds	r3, #104	; 0x68
    c12a:	681b      	ldr	r3, [r3, #0]
    c12c:	b2d9      	uxtb	r1, r3
    c12e:	68fb      	ldr	r3, [r7, #12]
    c130:	2201      	movs	r2, #1
    c132:	0018      	movs	r0, r3
    c134:	f001 fbae 	bl	d894 <tcpc_set_alert_mask>

      /* Enable RX */
      state[Port].Registers.FrameInfo.u2.RECEIVE_DETECT = SupportedSOP;
    c138:	687b      	ldr	r3, [r7, #4]
    c13a:	b2dc      	uxtb	r4, r3
    c13c:	4935      	ldr	r1, [pc, #212]	; (c214 <fusb305_tcpc_set_rx_state+0x2cc>)
    c13e:	68fa      	ldr	r2, [r7, #12]
    c140:	2023      	movs	r0, #35	; 0x23
    c142:	0013      	movs	r3, r2
    c144:	015b      	lsls	r3, r3, #5
    c146:	189b      	adds	r3, r3, r2
    c148:	009b      	lsls	r3, r3, #2
    c14a:	18cb      	adds	r3, r1, r3
    c14c:	181b      	adds	r3, r3, r0
    c14e:	1c22      	adds	r2, r4, #0
    c150:	701a      	strb	r2, [r3, #0]
      state[Port].Registers.FrameInfo.u2.b2.EN_HRD_RST  = 1;
    c152:	4930      	ldr	r1, [pc, #192]	; (c214 <fusb305_tcpc_set_rx_state+0x2cc>)
    c154:	68fa      	ldr	r2, [r7, #12]
    c156:	2020      	movs	r0, #32
    c158:	0013      	movs	r3, r2
    c15a:	015b      	lsls	r3, r3, #5
    c15c:	189b      	adds	r3, r3, r2
    c15e:	009b      	lsls	r3, r3, #2
    c160:	18cb      	adds	r3, r1, r3
    c162:	181b      	adds	r3, r3, r0
    c164:	78da      	ldrb	r2, [r3, #3]
    c166:	2120      	movs	r1, #32
    c168:	430a      	orrs	r2, r1
    c16a:	70da      	strb	r2, [r3, #3]
      USBPD_TCPCI_WriteRegister(Port, TCPC_REG_RX_DETECT, (uint8_t*)&state[Port].Registers.FrameInfo.u2.RECEIVE_DETECT, 1);
    c16c:	68fb      	ldr	r3, [r7, #12]
    c16e:	b2d8      	uxtb	r0, r3
    c170:	68fa      	ldr	r2, [r7, #12]
    c172:	0013      	movs	r3, r2
    c174:	015b      	lsls	r3, r3, #5
    c176:	189b      	adds	r3, r3, r2
    c178:	009b      	lsls	r3, r3, #2
    c17a:	3320      	adds	r3, #32
    c17c:	001a      	movs	r2, r3
    c17e:	4b25      	ldr	r3, [pc, #148]	; (c214 <fusb305_tcpc_set_rx_state+0x2cc>)
    c180:	18d3      	adds	r3, r2, r3
    c182:	1cda      	adds	r2, r3, #3
    c184:	2301      	movs	r3, #1
    c186:	212f      	movs	r1, #47	; 0x2f
    c188:	f001 ff0e 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
      state[Port].TypeC_State = Disabled;
    c18c:	4921      	ldr	r1, [pc, #132]	; (c214 <fusb305_tcpc_set_rx_state+0x2cc>)
    c18e:	68fa      	ldr	r2, [r7, #12]
    c190:	2072      	movs	r0, #114	; 0x72
    c192:	0013      	movs	r3, r2
    c194:	015b      	lsls	r3, r3, #5
    c196:	189b      	adds	r3, r3, r2
    c198:	009b      	lsls	r3, r3, #2
    c19a:	18cb      	adds	r3, r1, r3
    c19c:	181b      	adds	r3, r3, r0
    c19e:	2200      	movs	r2, #0
    c1a0:	701a      	strb	r2, [r3, #0]
    c1a2:	e0c4      	b.n	c32e <fusb305_tcpc_set_rx_state+0x3e6>
    }
    else
    {
      /* Set role of CC pins */
      fusb305_tcpc_set_cc(Port, state[Port].CC_Pull, USBPD_DISABLE);
    c1a4:	491b      	ldr	r1, [pc, #108]	; (c214 <fusb305_tcpc_set_rx_state+0x2cc>)
    c1a6:	68fa      	ldr	r2, [r7, #12]
    c1a8:	2070      	movs	r0, #112	; 0x70
    c1aa:	0013      	movs	r3, r2
    c1ac:	015b      	lsls	r3, r3, #5
    c1ae:	189b      	adds	r3, r3, r2
    c1b0:	009b      	lsls	r3, r3, #2
    c1b2:	18cb      	adds	r3, r1, r3
    c1b4:	181b      	adds	r3, r3, r0
    c1b6:	7819      	ldrb	r1, [r3, #0]
    c1b8:	68fb      	ldr	r3, [r7, #12]
    c1ba:	2200      	movs	r2, #0
    c1bc:	0018      	movs	r0, r3
    c1be:	f7ff fd29 	bl	bc14 <fusb305_tcpc_set_cc>

      /* Reset ALERT MASK */
      tcpc_set_alert_mask(Port,  TYPEC_CC_OPEN, USBPD_DISABLE);
    c1c2:	68fb      	ldr	r3, [r7, #12]
    c1c4:	2200      	movs	r2, #0
    c1c6:	2103      	movs	r1, #3
    c1c8:	0018      	movs	r0, r3
    c1ca:	f001 fb63 	bl	d894 <tcpc_set_alert_mask>
      
      state[Port].Registers.Command.u.COMMAND = TCPC_REG_COMMAND_LOOK4CONNECTION;
    c1ce:	4911      	ldr	r1, [pc, #68]	; (c214 <fusb305_tcpc_set_rx_state+0x2cc>)
    c1d0:	68fa      	ldr	r2, [r7, #12]
    c1d2:	0013      	movs	r3, r2
    c1d4:	015b      	lsls	r3, r3, #5
    c1d6:	189b      	adds	r3, r3, r2
    c1d8:	009b      	lsls	r3, r3, #2
    c1da:	18cb      	adds	r3, r1, r3
    c1dc:	331a      	adds	r3, #26
    c1de:	2299      	movs	r2, #153	; 0x99
    c1e0:	701a      	strb	r2, [r3, #0]
      USBPD_TCPCI_WriteRegister(Port, TCPC_REG_COMMAND, &state[Port].Registers.Command.u.COMMAND, 1);
    c1e2:	68fb      	ldr	r3, [r7, #12]
    c1e4:	b2d8      	uxtb	r0, r3
    c1e6:	68fa      	ldr	r2, [r7, #12]
    c1e8:	0013      	movs	r3, r2
    c1ea:	015b      	lsls	r3, r3, #5
    c1ec:	189b      	adds	r3, r3, r2
    c1ee:	009b      	lsls	r3, r3, #2
    c1f0:	3318      	adds	r3, #24
    c1f2:	001a      	movs	r2, r3
    c1f4:	4b07      	ldr	r3, [pc, #28]	; (c214 <fusb305_tcpc_set_rx_state+0x2cc>)
    c1f6:	18d3      	adds	r3, r2, r3
    c1f8:	1c9a      	adds	r2, r3, #2
    c1fa:	2301      	movs	r3, #1
    c1fc:	2123      	movs	r1, #35	; 0x23
    c1fe:	f001 fed3 	bl	dfa8 <USBPD_TCPCI_WriteRegister>

      status =  USBPD_FAIL;
    c202:	2327      	movs	r3, #39	; 0x27
    c204:	18fb      	adds	r3, r7, r3
    c206:	2210      	movs	r2, #16
    c208:	701a      	strb	r2, [r3, #0]
    c20a:	e090      	b.n	c32e <fusb305_tcpc_set_rx_state+0x3e6>
    c20c:	0001f3d8 	.word	0x0001f3d8
    c210:	0002febc 	.word	0x0002febc
    c214:	000300b8 	.word	0x000300b8
    }
  }
  else
  {
    /* Detach has been detected, reset BIST data is case of activation */
    state[Port].Registers.Control.s.u2.b2.BIST_TMODE = 0;
    c218:	4948      	ldr	r1, [pc, #288]	; (c33c <fusb305_tcpc_set_rx_state+0x3f4>)
    c21a:	68fa      	ldr	r2, [r7, #12]
    c21c:	2010      	movs	r0, #16
    c21e:	0013      	movs	r3, r2
    c220:	015b      	lsls	r3, r3, #5
    c222:	189b      	adds	r3, r3, r2
    c224:	009b      	lsls	r3, r3, #2
    c226:	18cb      	adds	r3, r1, r3
    c228:	181b      	adds	r3, r3, r0
    c22a:	78da      	ldrb	r2, [r3, #3]
    c22c:	2102      	movs	r1, #2
    c22e:	438a      	bics	r2, r1
    c230:	70da      	strb	r2, [r3, #3]
    USBPD_TCPCI_WriteRegister(Port, TCPC_REG_TCPC_CONTROL, &state[Port].Registers.Control.s.u2.TCPC_CONTROL, 1);
    c232:	68fb      	ldr	r3, [r7, #12]
    c234:	b2d8      	uxtb	r0, r3
    c236:	68fa      	ldr	r2, [r7, #12]
    c238:	0013      	movs	r3, r2
    c23a:	015b      	lsls	r3, r3, #5
    c23c:	189b      	adds	r3, r3, r2
    c23e:	009b      	lsls	r3, r3, #2
    c240:	3310      	adds	r3, #16
    c242:	001a      	movs	r2, r3
    c244:	4b3d      	ldr	r3, [pc, #244]	; (c33c <fusb305_tcpc_set_rx_state+0x3f4>)
    c246:	18d3      	adds	r3, r2, r3
    c248:	1cda      	adds	r2, r3, #3
    c24a:	2301      	movs	r3, #1
    c24c:	2119      	movs	r1, #25
    c24e:	f001 feab 	bl	dfa8 <USBPD_TCPCI_WriteRegister>

    /* Disable VBUS */
    status = tcpc_set_power(Port, USBPD_DISABLE, TCPC_HARD_RESET_NONE);
    c252:	2327      	movs	r3, #39	; 0x27
    c254:	18fc      	adds	r4, r7, r3
    c256:	68fb      	ldr	r3, [r7, #12]
    c258:	2200      	movs	r2, #0
    c25a:	2100      	movs	r1, #0
    c25c:	0018      	movs	r0, r3
    c25e:	f000 fe07 	bl	ce70 <tcpc_set_power>
    c262:	0003      	movs	r3, r0
    c264:	7023      	strb	r3, [r4, #0]

    /* Reset ALERT MASK */
    tcpc_set_alert_mask(Port,  TYPEC_CC_OPEN, USBPD_DISABLE);
    c266:	68fb      	ldr	r3, [r7, #12]
    c268:	2200      	movs	r2, #0
    c26a:	2103      	movs	r1, #3
    c26c:	0018      	movs	r0, r3
    c26e:	f001 fb11 	bl	d894 <tcpc_set_alert_mask>

    /* Disable RX */
    state[Port].Registers.FrameInfo.u2.RECEIVE_DETECT = 0;
    c272:	4932      	ldr	r1, [pc, #200]	; (c33c <fusb305_tcpc_set_rx_state+0x3f4>)
    c274:	68fa      	ldr	r2, [r7, #12]
    c276:	2023      	movs	r0, #35	; 0x23
    c278:	0013      	movs	r3, r2
    c27a:	015b      	lsls	r3, r3, #5
    c27c:	189b      	adds	r3, r3, r2
    c27e:	009b      	lsls	r3, r3, #2
    c280:	18cb      	adds	r3, r1, r3
    c282:	181b      	adds	r3, r3, r0
    c284:	2200      	movs	r2, #0
    c286:	701a      	strb	r2, [r3, #0]
    USBPD_TCPCI_WriteRegister(Port, TCPC_REG_RX_DETECT, (uint8_t*)&state[Port].Registers.FrameInfo.u2.RECEIVE_DETECT, 1);
    c288:	68fb      	ldr	r3, [r7, #12]
    c28a:	b2d8      	uxtb	r0, r3
    c28c:	68fa      	ldr	r2, [r7, #12]
    c28e:	0013      	movs	r3, r2
    c290:	015b      	lsls	r3, r3, #5
    c292:	189b      	adds	r3, r3, r2
    c294:	009b      	lsls	r3, r3, #2
    c296:	3320      	adds	r3, #32
    c298:	001a      	movs	r2, r3
    c29a:	4b28      	ldr	r3, [pc, #160]	; (c33c <fusb305_tcpc_set_rx_state+0x3f4>)
    c29c:	18d3      	adds	r3, r2, r3
    c29e:	1cda      	adds	r2, r3, #3
    c2a0:	2301      	movs	r3, #1
    c2a2:	212f      	movs	r1, #47	; 0x2f
    c2a4:	f001 fe80 	bl	dfa8 <USBPD_TCPCI_WriteRegister>

    /* Disable VBUS detect */
    state[Port].Registers.Command.u.COMMAND = TCPC_REG_COMMAND_DISABLE_VBUS_DETECT;
    c2a8:	4924      	ldr	r1, [pc, #144]	; (c33c <fusb305_tcpc_set_rx_state+0x3f4>)
    c2aa:	68fa      	ldr	r2, [r7, #12]
    c2ac:	0013      	movs	r3, r2
    c2ae:	015b      	lsls	r3, r3, #5
    c2b0:	189b      	adds	r3, r3, r2
    c2b2:	009b      	lsls	r3, r3, #2
    c2b4:	18cb      	adds	r3, r1, r3
    c2b6:	331a      	adds	r3, #26
    c2b8:	2222      	movs	r2, #34	; 0x22
    c2ba:	701a      	strb	r2, [r3, #0]
    USBPD_TCPCI_WriteRegister(Port, TCPC_REG_COMMAND, &state[Port].Registers.Command.u.COMMAND, 1);
    c2bc:	68fb      	ldr	r3, [r7, #12]
    c2be:	b2d8      	uxtb	r0, r3
    c2c0:	68fa      	ldr	r2, [r7, #12]
    c2c2:	0013      	movs	r3, r2
    c2c4:	015b      	lsls	r3, r3, #5
    c2c6:	189b      	adds	r3, r3, r2
    c2c8:	009b      	lsls	r3, r3, #2
    c2ca:	3318      	adds	r3, #24
    c2cc:	001a      	movs	r2, r3
    c2ce:	4b1b      	ldr	r3, [pc, #108]	; (c33c <fusb305_tcpc_set_rx_state+0x3f4>)
    c2d0:	18d3      	adds	r3, r2, r3
    c2d2:	1c9a      	adds	r2, r3, #2
    c2d4:	2301      	movs	r3, #1
    c2d6:	2123      	movs	r1, #35	; 0x23
    c2d8:	f001 fe66 	bl	dfa8 <USBPD_TCPCI_WriteRegister>

    /* Set CC functionality */
    fusb305_tcpc_set_cc(Port, state[Port].CC_Pull, USBPD_DISABLE);
    c2dc:	4917      	ldr	r1, [pc, #92]	; (c33c <fusb305_tcpc_set_rx_state+0x3f4>)
    c2de:	68fa      	ldr	r2, [r7, #12]
    c2e0:	2070      	movs	r0, #112	; 0x70
    c2e2:	0013      	movs	r3, r2
    c2e4:	015b      	lsls	r3, r3, #5
    c2e6:	189b      	adds	r3, r3, r2
    c2e8:	009b      	lsls	r3, r3, #2
    c2ea:	18cb      	adds	r3, r1, r3
    c2ec:	181b      	adds	r3, r3, r0
    c2ee:	7819      	ldrb	r1, [r3, #0]
    c2f0:	68fb      	ldr	r3, [r7, #12]
    c2f2:	2200      	movs	r2, #0
    c2f4:	0018      	movs	r0, r3
    c2f6:	f7ff fc8d 	bl	bc14 <fusb305_tcpc_set_cc>

    state[Port].Registers.Command.u.COMMAND = TCPC_REG_COMMAND_LOOK4CONNECTION;
    c2fa:	4910      	ldr	r1, [pc, #64]	; (c33c <fusb305_tcpc_set_rx_state+0x3f4>)
    c2fc:	68fa      	ldr	r2, [r7, #12]
    c2fe:	0013      	movs	r3, r2
    c300:	015b      	lsls	r3, r3, #5
    c302:	189b      	adds	r3, r3, r2
    c304:	009b      	lsls	r3, r3, #2
    c306:	18cb      	adds	r3, r1, r3
    c308:	331a      	adds	r3, #26
    c30a:	2299      	movs	r2, #153	; 0x99
    c30c:	701a      	strb	r2, [r3, #0]
    USBPD_TCPCI_WriteRegister(Port, TCPC_REG_COMMAND, &state[Port].Registers.Command.u.COMMAND, 1);
    c30e:	68fb      	ldr	r3, [r7, #12]
    c310:	b2d8      	uxtb	r0, r3
    c312:	68fa      	ldr	r2, [r7, #12]
    c314:	0013      	movs	r3, r2
    c316:	015b      	lsls	r3, r3, #5
    c318:	189b      	adds	r3, r3, r2
    c31a:	009b      	lsls	r3, r3, #2
    c31c:	3318      	adds	r3, #24
    c31e:	001a      	movs	r2, r3
    c320:	4b06      	ldr	r3, [pc, #24]	; (c33c <fusb305_tcpc_set_rx_state+0x3f4>)
    c322:	18d3      	adds	r3, r2, r3
    c324:	1c9a      	adds	r2, r3, #2
    c326:	2301      	movs	r3, #1
    c328:	2123      	movs	r1, #35	; 0x23
    c32a:	f001 fe3d 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
  }

  return status;
    c32e:	2327      	movs	r3, #39	; 0x27
    c330:	18fb      	adds	r3, r7, r3
    c332:	781b      	ldrb	r3, [r3, #0]
}
    c334:	0018      	movs	r0, r3
    c336:	46bd      	mov	sp, r7
    c338:	b00a      	add	sp, #40	; 0x28
    c33a:	bdb0      	pop	{r4, r5, r7, pc}
    c33c:	000300b8 	.word	0x000300b8

0000c340 <fusb305_tcpc_EnableRx>:
  * @brief  Enable RX
  * @param  PortNum    Number of the port.
  * @retval None
  */
USBPD_StatusTypeDef fusb305_tcpc_EnableRx(uint32_t Port)
{
    c340:	b590      	push	{r4, r7, lr}
    c342:	b085      	sub	sp, #20
    c344:	af00      	add	r7, sp, #0
    c346:	6078      	str	r0, [r7, #4]
  USBPD_StatusTypeDef status = USBPD_OK;
    c348:	240f      	movs	r4, #15
    c34a:	193b      	adds	r3, r7, r4
    c34c:	2200      	movs	r2, #0
    c34e:	701a      	strb	r2, [r3, #0]
  /* Enable RX */
  USBPD_TCPCI_WriteRegister(Port, TCPC_REG_RX_DETECT, (uint8_t*)&state[Port].Registers.FrameInfo.u2.RECEIVE_DETECT, 1);
    c350:	687b      	ldr	r3, [r7, #4]
    c352:	b2d8      	uxtb	r0, r3
    c354:	687a      	ldr	r2, [r7, #4]
    c356:	0013      	movs	r3, r2
    c358:	015b      	lsls	r3, r3, #5
    c35a:	189b      	adds	r3, r3, r2
    c35c:	009b      	lsls	r3, r3, #2
    c35e:	3320      	adds	r3, #32
    c360:	001a      	movs	r2, r3
    c362:	4b0c      	ldr	r3, [pc, #48]	; (c394 <fusb305_tcpc_EnableRx+0x54>)
    c364:	18d3      	adds	r3, r2, r3
    c366:	1cda      	adds	r2, r3, #3
    c368:	2301      	movs	r3, #1
    c36a:	212f      	movs	r1, #47	; 0x2f
    c36c:	f001 fe1c 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
  state[Port].HardReset = 0U;
    c370:	4908      	ldr	r1, [pc, #32]	; (c394 <fusb305_tcpc_EnableRx+0x54>)
    c372:	687a      	ldr	r2, [r7, #4]
    c374:	2080      	movs	r0, #128	; 0x80
    c376:	0013      	movs	r3, r2
    c378:	015b      	lsls	r3, r3, #5
    c37a:	189b      	adds	r3, r3, r2
    c37c:	009b      	lsls	r3, r3, #2
    c37e:	18cb      	adds	r3, r1, r3
    c380:	181b      	adds	r3, r3, r0
    c382:	2200      	movs	r2, #0
    c384:	701a      	strb	r2, [r3, #0]
  return status;
    c386:	193b      	adds	r3, r7, r4
    c388:	781b      	ldrb	r3, [r3, #0]
}
    c38a:	0018      	movs	r0, r3
    c38c:	46bd      	mov	sp, r7
    c38e:	b005      	add	sp, #20
    c390:	bd90      	pop	{r4, r7, pc}
    c392:	46c0      	nop			; (mov r8, r8)
    c394:	000300b8 	.word	0x000300b8

0000c398 <fusb305_tcpc_DisableRx>:
  * @brief  Disable RX
  * @param  PortNum    Number of the port.
  * @retval None
  */
USBPD_StatusTypeDef fusb305_tcpc_DisableRx(uint32_t Port)
{
    c398:	b580      	push	{r7, lr}
    c39a:	b086      	sub	sp, #24
    c39c:	af02      	add	r7, sp, #8
    c39e:	6078      	str	r0, [r7, #4]
  USBPD_StatusTypeDef status = USBPD_OK;
    c3a0:	230f      	movs	r3, #15
    c3a2:	18fb      	adds	r3, r7, r3
    c3a4:	2200      	movs	r2, #0
    c3a6:	701a      	strb	r2, [r3, #0]
  /* Disable RX for SOP* */
  if (0U == state[Port].HardReset)
    c3a8:	4916      	ldr	r1, [pc, #88]	; (c404 <fusb305_tcpc_DisableRx+0x6c>)
    c3aa:	687a      	ldr	r2, [r7, #4]
    c3ac:	2080      	movs	r0, #128	; 0x80
    c3ae:	0013      	movs	r3, r2
    c3b0:	015b      	lsls	r3, r3, #5
    c3b2:	189b      	adds	r3, r3, r2
    c3b4:	009b      	lsls	r3, r3, #2
    c3b6:	18cb      	adds	r3, r1, r3
    c3b8:	181b      	adds	r3, r3, r0
    c3ba:	781b      	ldrb	r3, [r3, #0]
    c3bc:	2b00      	cmp	r3, #0
    c3be:	d11a      	bne.n	c3f6 <fusb305_tcpc_DisableRx+0x5e>
  {
    uint8_t disable = 0;
    c3c0:	210e      	movs	r1, #14
    c3c2:	187b      	adds	r3, r7, r1
    c3c4:	2200      	movs	r2, #0
    c3c6:	701a      	strb	r2, [r3, #0]
    USBPD_TCPCI_WriteRegister(Port, TCPC_REG_RX_DETECT, (uint8_t*)&disable, 1);
    c3c8:	687b      	ldr	r3, [r7, #4]
    c3ca:	b2d8      	uxtb	r0, r3
    c3cc:	187a      	adds	r2, r7, r1
    c3ce:	2301      	movs	r3, #1
    c3d0:	212f      	movs	r1, #47	; 0x2f
    c3d2:	f001 fde9 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
    FUSB307_DEBUG_TRACE(Port, FUSB307_DEBUG_LEVEL_0, "DisableRx");
    c3d6:	4b0c      	ldr	r3, [pc, #48]	; (c408 <fusb305_tcpc_DisableRx+0x70>)
    c3d8:	781b      	ldrb	r3, [r3, #0]
    c3da:	001a      	movs	r2, r3
    c3dc:	2301      	movs	r3, #1
    c3de:	4013      	ands	r3, r2
    c3e0:	d009      	beq.n	c3f6 <fusb305_tcpc_DisableRx+0x5e>
    c3e2:	687b      	ldr	r3, [r7, #4]
    c3e4:	b2d9      	uxtb	r1, r3
    c3e6:	4a09      	ldr	r2, [pc, #36]	; (c40c <fusb305_tcpc_DisableRx+0x74>)
    c3e8:	2309      	movs	r3, #9
    c3ea:	9300      	str	r3, [sp, #0]
    c3ec:	0013      	movs	r3, r2
    c3ee:	2200      	movs	r2, #0
    c3f0:	2006      	movs	r0, #6
    c3f2:	f004 f8b7 	bl	10564 <USBPD_TRACE_Add>
  }  
  return status;
    c3f6:	230f      	movs	r3, #15
    c3f8:	18fb      	adds	r3, r7, r3
    c3fa:	781b      	ldrb	r3, [r3, #0]
}
    c3fc:	0018      	movs	r0, r3
    c3fe:	46bd      	mov	sp, r7
    c400:	b004      	add	sp, #16
    c402:	bd80      	pop	{r7, pc}
    c404:	000300b8 	.word	0x000300b8
    c408:	0002febc 	.word	0x0002febc
    c40c:	0001f3e4 	.word	0x0001f3e4

0000c410 <fusb305_tcpc_set_sop_supported>:
  * @param  PortNum       PortNum number value
  * @param  SupportedSOP  Supported SOP by PRL
  * @retval USBPD status
  */
USBPD_StatusTypeDef fusb305_tcpc_set_sop_supported(uint32_t Port, uint32_t SupportedSOP)
{
    c410:	b5b0      	push	{r4, r5, r7, lr}
    c412:	b084      	sub	sp, #16
    c414:	af00      	add	r7, sp, #0
    c416:	6078      	str	r0, [r7, #4]
    c418:	6039      	str	r1, [r7, #0]
  USBPD_StatusTypeDef status = USBPD_OK;
    c41a:	250f      	movs	r5, #15
    c41c:	197b      	adds	r3, r7, r5
    c41e:	2200      	movs	r2, #0
    c420:	701a      	strb	r2, [r3, #0]

  /* Enable RX */
  state[Port].Registers.FrameInfo.u2.RECEIVE_DETECT = SupportedSOP;
    c422:	683b      	ldr	r3, [r7, #0]
    c424:	b2dc      	uxtb	r4, r3
    c426:	4917      	ldr	r1, [pc, #92]	; (c484 <fusb305_tcpc_set_sop_supported+0x74>)
    c428:	687a      	ldr	r2, [r7, #4]
    c42a:	2023      	movs	r0, #35	; 0x23
    c42c:	0013      	movs	r3, r2
    c42e:	015b      	lsls	r3, r3, #5
    c430:	189b      	adds	r3, r3, r2
    c432:	009b      	lsls	r3, r3, #2
    c434:	18cb      	adds	r3, r1, r3
    c436:	181b      	adds	r3, r3, r0
    c438:	1c22      	adds	r2, r4, #0
    c43a:	701a      	strb	r2, [r3, #0]
  state[Port].Registers.FrameInfo.u2.b2.EN_HRD_RST  = 1;
    c43c:	4911      	ldr	r1, [pc, #68]	; (c484 <fusb305_tcpc_set_sop_supported+0x74>)
    c43e:	687a      	ldr	r2, [r7, #4]
    c440:	2020      	movs	r0, #32
    c442:	0013      	movs	r3, r2
    c444:	015b      	lsls	r3, r3, #5
    c446:	189b      	adds	r3, r3, r2
    c448:	009b      	lsls	r3, r3, #2
    c44a:	18cb      	adds	r3, r1, r3
    c44c:	181b      	adds	r3, r3, r0
    c44e:	78da      	ldrb	r2, [r3, #3]
    c450:	2120      	movs	r1, #32
    c452:	430a      	orrs	r2, r1
    c454:	70da      	strb	r2, [r3, #3]
  USBPD_TCPCI_WriteRegister(Port, TCPC_REG_RX_DETECT, (uint8_t*)&state[Port].Registers.FrameInfo.u2.RECEIVE_DETECT, 1);
    c456:	687b      	ldr	r3, [r7, #4]
    c458:	b2d8      	uxtb	r0, r3
    c45a:	687a      	ldr	r2, [r7, #4]
    c45c:	0013      	movs	r3, r2
    c45e:	015b      	lsls	r3, r3, #5
    c460:	189b      	adds	r3, r3, r2
    c462:	009b      	lsls	r3, r3, #2
    c464:	3320      	adds	r3, #32
    c466:	001a      	movs	r2, r3
    c468:	4b06      	ldr	r3, [pc, #24]	; (c484 <fusb305_tcpc_set_sop_supported+0x74>)
    c46a:	18d3      	adds	r3, r2, r3
    c46c:	1cda      	adds	r2, r3, #3
    c46e:	2301      	movs	r3, #1
    c470:	212f      	movs	r1, #47	; 0x2f
    c472:	f001 fd99 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
  return status;
    c476:	197b      	adds	r3, r7, r5
    c478:	781b      	ldrb	r3, [r3, #0]
}
    c47a:	0018      	movs	r0, r3
    c47c:	46bd      	mov	sp, r7
    c47e:	b004      	add	sp, #16
    c480:	bdb0      	pop	{r4, r5, r7, pc}
    c482:	46c0      	nop			; (mov r8, r8)
    c484:	000300b8 	.word	0x000300b8

0000c488 <fusb305_tcpc_get_message>:
  * @param  Payload Pointer on the payload
  * @param  Type Pointer on the message type
  * @retval USBPD status
  */
USBPD_StatusTypeDef fusb305_tcpc_get_message(uint32_t Port, uint8_t *Payload, uint8_t *Type)
{
    c488:	b580      	push	{r7, lr}
    c48a:	b084      	sub	sp, #16
    c48c:	af00      	add	r7, sp, #0
    c48e:	60f8      	str	r0, [r7, #12]
    c490:	60b9      	str	r1, [r7, #8]
    c492:	607a      	str	r2, [r7, #4]
  return USBPD_TCPCI_ReceiveBuffer(Port, TCPC_REG_RX_BYTE_COUNT, (uint8_t *)Payload, Type);
    c494:	687b      	ldr	r3, [r7, #4]
    c496:	68ba      	ldr	r2, [r7, #8]
    c498:	68f8      	ldr	r0, [r7, #12]
    c49a:	2130      	movs	r1, #48	; 0x30
    c49c:	f001 fe4a 	bl	e134 <USBPD_TCPCI_ReceiveBuffer>
    c4a0:	0003      	movs	r3, r0
}
    c4a2:	0018      	movs	r0, r3
    c4a4:	46bd      	mov	sp, r7
    c4a6:	b004      	add	sp, #16
    c4a8:	bd80      	pop	{r7, pc}
	...

0000c4ac <fusb305_tcpc_transmit>:
  * @param  pData Pointer on the data message
  * @param  RetryNumber Number of retry
  * @retval USBPD status
  */
USBPD_StatusTypeDef fusb305_tcpc_transmit(uint32_t Port, USBPD_SOPType_TypeDef Type, uint16_t Header, const uint8_t *pData, uint32_t RetryNumber)
{
    c4ac:	b5b0      	push	{r4, r5, r7, lr}
    c4ae:	b088      	sub	sp, #32
    c4b0:	af02      	add	r7, sp, #8
    c4b2:	60f8      	str	r0, [r7, #12]
    c4b4:	0008      	movs	r0, r1
    c4b6:	0011      	movs	r1, r2
    c4b8:	607b      	str	r3, [r7, #4]
    c4ba:	240b      	movs	r4, #11
    c4bc:	193b      	adds	r3, r7, r4
    c4be:	1c02      	adds	r2, r0, #0
    c4c0:	701a      	strb	r2, [r3, #0]
    c4c2:	2308      	movs	r3, #8
    c4c4:	18fb      	adds	r3, r7, r3
    c4c6:	1c0a      	adds	r2, r1, #0
    c4c8:	801a      	strh	r2, [r3, #0]
  USBPD_StatusTypeDef status = USBPD_ERROR;
    c4ca:	2317      	movs	r3, #23
    c4cc:	18fb      	adds	r3, r7, r3
    c4ce:	2202      	movs	r2, #2
    c4d0:	701a      	strb	r2, [r3, #0]
  if ((USBPD_SOPTYPE_HARD_RESET != Type) && (USBPD_SOPTYPE_BIST_MODE_2 != Type) && (USBPD_SOPTYPE_CABLE_RESET != Type))
    c4d2:	193b      	adds	r3, r7, r4
    c4d4:	781b      	ldrb	r3, [r3, #0]
    c4d6:	2b05      	cmp	r3, #5
    c4d8:	d068      	beq.n	c5ac <fusb305_tcpc_transmit+0x100>
    c4da:	230b      	movs	r3, #11
    c4dc:	18fb      	adds	r3, r7, r3
    c4de:	781b      	ldrb	r3, [r3, #0]
    c4e0:	2b07      	cmp	r3, #7
    c4e2:	d063      	beq.n	c5ac <fusb305_tcpc_transmit+0x100>
    c4e4:	230b      	movs	r3, #11
    c4e6:	18fb      	adds	r3, r7, r3
    c4e8:	781b      	ldrb	r3, [r3, #0]
    c4ea:	2b06      	cmp	r3, #6
    c4ec:	d05e      	beq.n	c5ac <fusb305_tcpc_transmit+0x100>
  {
    uint32_t count = 4 * PD_HEADER_COUNT(Header);
    c4ee:	2308      	movs	r3, #8
    c4f0:	18fb      	adds	r3, r7, r3
    c4f2:	881b      	ldrh	r3, [r3, #0]
    c4f4:	0b1b      	lsrs	r3, r3, #12
    c4f6:	b29b      	uxth	r3, r3
    c4f8:	001a      	movs	r2, r3
    c4fa:	2307      	movs	r3, #7
    c4fc:	4013      	ands	r3, r2
    c4fe:	009b      	lsls	r3, r3, #2
    c500:	613b      	str	r3, [r7, #16]

    if (count > USBPD_TCPM_MAX_RX_BUFFER_SIZE)
    c502:	693b      	ldr	r3, [r7, #16]
    c504:	2b1e      	cmp	r3, #30
    c506:	d903      	bls.n	c510 <fusb305_tcpc_transmit+0x64>
    {
      return status;
    c508:	2317      	movs	r3, #23
    c50a:	18fb      	adds	r3, r7, r3
    c50c:	781b      	ldrb	r3, [r3, #0]
    c50e:	e0af      	b.n	c670 <fusb305_tcpc_transmit+0x1c4>
    * - TCPC_REG_TX_BYTE_COUNT register address
    * - Transmit Byte Count
    * - Transmit Header
    * - Data
    */
    state[Port].Registers.TXFrame.u.TRANSMIT_BYTE_COUNT = (count + 2);
    c510:	693b      	ldr	r3, [r7, #16]
    c512:	b2db      	uxtb	r3, r3
    c514:	3302      	adds	r3, #2
    c516:	b2dc      	uxtb	r4, r3
    c518:	4957      	ldr	r1, [pc, #348]	; (c678 <fusb305_tcpc_transmit+0x1cc>)
    c51a:	68fa      	ldr	r2, [r7, #12]
    c51c:	2029      	movs	r0, #41	; 0x29
    c51e:	0013      	movs	r3, r2
    c520:	015b      	lsls	r3, r3, #5
    c522:	189b      	adds	r3, r3, r2
    c524:	009b      	lsls	r3, r3, #2
    c526:	18cb      	adds	r3, r1, r3
    c528:	181b      	adds	r3, r3, r0
    c52a:	1c22      	adds	r2, r4, #0
    c52c:	701a      	strb	r2, [r3, #0]
    status = USBPD_TCPCI_SendTransmitBuffer(Port, TCPC_REG_TX_BYTE_COUNT, (count + 2), Header, (uint8_t *)pData);
    c52e:	693b      	ldr	r3, [r7, #16]
    c530:	b2db      	uxtb	r3, r3
    c532:	3302      	adds	r3, #2
    c534:	b2da      	uxtb	r2, r3
    c536:	2517      	movs	r5, #23
    c538:	197c      	adds	r4, r7, r5
    c53a:	2308      	movs	r3, #8
    c53c:	18fb      	adds	r3, r7, r3
    c53e:	8819      	ldrh	r1, [r3, #0]
    c540:	68f8      	ldr	r0, [r7, #12]
    c542:	687b      	ldr	r3, [r7, #4]
    c544:	9300      	str	r3, [sp, #0]
    c546:	000b      	movs	r3, r1
    c548:	2151      	movs	r1, #81	; 0x51
    c54a:	f001 fd77 	bl	e03c <USBPD_TCPCI_SendTransmitBuffer>
    c54e:	0003      	movs	r3, r0
    c550:	7023      	strb	r3, [r4, #0]
    
    if (status == USBPD_OK)
    c552:	197b      	adds	r3, r7, r5
    c554:	781b      	ldrb	r3, [r3, #0]
    c556:	2b00      	cmp	r3, #0
    c558:	d000      	beq.n	c55c <fusb305_tcpc_transmit+0xb0>
    c55a:	e085      	b.n	c668 <fusb305_tcpc_transmit+0x1bc>
    {
      state[Port].Registers.TXFrame.u.TRANSMIT = TCPC_REG_TRANSMIT_SET(Type, RetryNumber);
    c55c:	6abb      	ldr	r3, [r7, #40]	; 0x28
    c55e:	b2db      	uxtb	r3, r3
    c560:	011b      	lsls	r3, r3, #4
    c562:	b2da      	uxtb	r2, r3
    c564:	230b      	movs	r3, #11
    c566:	18fb      	adds	r3, r7, r3
    c568:	781b      	ldrb	r3, [r3, #0]
    c56a:	4313      	orrs	r3, r2
    c56c:	b2dc      	uxtb	r4, r3
    c56e:	4942      	ldr	r1, [pc, #264]	; (c678 <fusb305_tcpc_transmit+0x1cc>)
    c570:	68fa      	ldr	r2, [r7, #12]
    c572:	2028      	movs	r0, #40	; 0x28
    c574:	0013      	movs	r3, r2
    c576:	015b      	lsls	r3, r3, #5
    c578:	189b      	adds	r3, r3, r2
    c57a:	009b      	lsls	r3, r3, #2
    c57c:	18cb      	adds	r3, r1, r3
    c57e:	181b      	adds	r3, r3, r0
    c580:	1c22      	adds	r2, r4, #0
    c582:	701a      	strb	r2, [r3, #0]
      status = USBPD_TCPCI_WriteRegister(Port, TCPC_REG_TRANSMIT, &state[Port].Registers.TXFrame.u.TRANSMIT, 1);
    c584:	68fb      	ldr	r3, [r7, #12]
    c586:	b2d8      	uxtb	r0, r3
    c588:	68fa      	ldr	r2, [r7, #12]
    c58a:	0013      	movs	r3, r2
    c58c:	015b      	lsls	r3, r3, #5
    c58e:	189b      	adds	r3, r3, r2
    c590:	009b      	lsls	r3, r3, #2
    c592:	3328      	adds	r3, #40	; 0x28
    c594:	001a      	movs	r2, r3
    c596:	4b38      	ldr	r3, [pc, #224]	; (c678 <fusb305_tcpc_transmit+0x1cc>)
    c598:	18d2      	adds	r2, r2, r3
    c59a:	2317      	movs	r3, #23
    c59c:	18fc      	adds	r4, r7, r3
    c59e:	2301      	movs	r3, #1
    c5a0:	2150      	movs	r1, #80	; 0x50
    c5a2:	f001 fd01 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
    c5a6:	0003      	movs	r3, r0
    c5a8:	7023      	strb	r3, [r4, #0]
  {
    c5aa:	e05d      	b.n	c668 <fusb305_tcpc_transmit+0x1bc>
    }
  }
  else
  {
    USBPD_TCPCI_WriteRegister(Port, TCPC_REG_RX_DETECT, (uint8_t*)&state[Port].Registers.FrameInfo.u2.RECEIVE_DETECT, 1);
    c5ac:	68fb      	ldr	r3, [r7, #12]
    c5ae:	b2d8      	uxtb	r0, r3
    c5b0:	68fa      	ldr	r2, [r7, #12]
    c5b2:	0013      	movs	r3, r2
    c5b4:	015b      	lsls	r3, r3, #5
    c5b6:	189b      	adds	r3, r3, r2
    c5b8:	009b      	lsls	r3, r3, #2
    c5ba:	3320      	adds	r3, #32
    c5bc:	001a      	movs	r2, r3
    c5be:	4b2e      	ldr	r3, [pc, #184]	; (c678 <fusb305_tcpc_transmit+0x1cc>)
    c5c0:	18d3      	adds	r3, r2, r3
    c5c2:	1cda      	adds	r2, r3, #3
    c5c4:	2301      	movs	r3, #1
    c5c6:	212f      	movs	r1, #47	; 0x2f
    c5c8:	f001 fcee 	bl	dfa8 <USBPD_TCPCI_WriteRegister>

    /* Send Hard Reset, Cable Reset, or BIST Carrier Mode 2 signaling */
    state[Port].Registers.TXFrame.u.TRANSMIT_BYTE_COUNT = 0;
    c5cc:	492a      	ldr	r1, [pc, #168]	; (c678 <fusb305_tcpc_transmit+0x1cc>)
    c5ce:	68fa      	ldr	r2, [r7, #12]
    c5d0:	2029      	movs	r0, #41	; 0x29
    c5d2:	0013      	movs	r3, r2
    c5d4:	015b      	lsls	r3, r3, #5
    c5d6:	189b      	adds	r3, r3, r2
    c5d8:	009b      	lsls	r3, r3, #2
    c5da:	18cb      	adds	r3, r1, r3
    c5dc:	181b      	adds	r3, r3, r0
    c5de:	2200      	movs	r2, #0
    c5e0:	701a      	strb	r2, [r3, #0]
    status = USBPD_TCPCI_WriteRegister(Port, TCPC_REG_TX_BYTE_COUNT, &state[Port].Registers.TXFrame.u.TRANSMIT_BYTE_COUNT, 1);
    c5e2:	68fb      	ldr	r3, [r7, #12]
    c5e4:	b2d8      	uxtb	r0, r3
    c5e6:	68fa      	ldr	r2, [r7, #12]
    c5e8:	0013      	movs	r3, r2
    c5ea:	015b      	lsls	r3, r3, #5
    c5ec:	189b      	adds	r3, r3, r2
    c5ee:	009b      	lsls	r3, r3, #2
    c5f0:	3328      	adds	r3, #40	; 0x28
    c5f2:	001a      	movs	r2, r3
    c5f4:	4b20      	ldr	r3, [pc, #128]	; (c678 <fusb305_tcpc_transmit+0x1cc>)
    c5f6:	18d3      	adds	r3, r2, r3
    c5f8:	1c5a      	adds	r2, r3, #1
    c5fa:	2517      	movs	r5, #23
    c5fc:	197c      	adds	r4, r7, r5
    c5fe:	2301      	movs	r3, #1
    c600:	2151      	movs	r1, #81	; 0x51
    c602:	f001 fcd1 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
    c606:	0003      	movs	r3, r0
    c608:	7023      	strb	r3, [r4, #0]
    state[Port].Registers.TXFrame.u.TRANSMIT = TCPC_REG_TRANSMIT_SET(Type, 0);
    c60a:	491b      	ldr	r1, [pc, #108]	; (c678 <fusb305_tcpc_transmit+0x1cc>)
    c60c:	68fa      	ldr	r2, [r7, #12]
    c60e:	2028      	movs	r0, #40	; 0x28
    c610:	0013      	movs	r3, r2
    c612:	015b      	lsls	r3, r3, #5
    c614:	189b      	adds	r3, r3, r2
    c616:	009b      	lsls	r3, r3, #2
    c618:	18cb      	adds	r3, r1, r3
    c61a:	181b      	adds	r3, r3, r0
    c61c:	220b      	movs	r2, #11
    c61e:	18ba      	adds	r2, r7, r2
    c620:	7812      	ldrb	r2, [r2, #0]
    c622:	701a      	strb	r2, [r3, #0]
    status |= USBPD_TCPCI_WriteRegister(Port, TCPC_REG_TRANSMIT, &state[Port].Registers.TXFrame.u.TRANSMIT, 1);
    c624:	68fb      	ldr	r3, [r7, #12]
    c626:	b2d8      	uxtb	r0, r3
    c628:	68fa      	ldr	r2, [r7, #12]
    c62a:	0013      	movs	r3, r2
    c62c:	015b      	lsls	r3, r3, #5
    c62e:	189b      	adds	r3, r3, r2
    c630:	009b      	lsls	r3, r3, #2
    c632:	3328      	adds	r3, #40	; 0x28
    c634:	001a      	movs	r2, r3
    c636:	4b10      	ldr	r3, [pc, #64]	; (c678 <fusb305_tcpc_transmit+0x1cc>)
    c638:	18d2      	adds	r2, r2, r3
    c63a:	2301      	movs	r3, #1
    c63c:	2150      	movs	r1, #80	; 0x50
    c63e:	f001 fcb3 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
    c642:	0003      	movs	r3, r0
    c644:	0019      	movs	r1, r3
    c646:	197b      	adds	r3, r7, r5
    c648:	197a      	adds	r2, r7, r5
    c64a:	7812      	ldrb	r2, [r2, #0]
    c64c:	430a      	orrs	r2, r1
    c64e:	701a      	strb	r2, [r3, #0]
    state[Port].HardReset = 1;
    c650:	4909      	ldr	r1, [pc, #36]	; (c678 <fusb305_tcpc_transmit+0x1cc>)
    c652:	68fa      	ldr	r2, [r7, #12]
    c654:	2080      	movs	r0, #128	; 0x80
    c656:	0013      	movs	r3, r2
    c658:	015b      	lsls	r3, r3, #5
    c65a:	189b      	adds	r3, r3, r2
    c65c:	009b      	lsls	r3, r3, #2
    c65e:	18cb      	adds	r3, r1, r3
    c660:	181b      	adds	r3, r3, r0
    c662:	2201      	movs	r2, #1
    c664:	701a      	strb	r2, [r3, #0]
    c666:	e000      	b.n	c66a <fusb305_tcpc_transmit+0x1be>
  {
    c668:	46c0      	nop			; (mov r8, r8)
  }

  return status;
    c66a:	2317      	movs	r3, #23
    c66c:	18fb      	adds	r3, r7, r3
    c66e:	781b      	ldrb	r3, [r3, #0]
}
    c670:	0018      	movs	r0, r3
    c672:	46bd      	mov	sp, r7
    c674:	b006      	add	sp, #24
    c676:	bdb0      	pop	{r4, r5, r7, pc}
    c678:	000300b8 	.word	0x000300b8

0000c67c <fusb305_tcpc_get_power_status>:
  * @param  Port port number value
  * @param  PowerStatus Pointer on Power status
  * @retval USBPD status
  */
USBPD_StatusTypeDef fusb305_tcpc_get_power_status(uint32_t Port, uint8_t *PowerStatus)
{
    c67c:	b590      	push	{r4, r7, lr}
    c67e:	b089      	sub	sp, #36	; 0x24
    c680:	af02      	add	r7, sp, #8
    c682:	6078      	str	r0, [r7, #4]
    c684:	6039      	str	r1, [r7, #0]
  USBPD_StatusTypeDef usbpd_status = USBPD_OK;
    c686:	2117      	movs	r1, #23
    c688:	187b      	adds	r3, r7, r1
    c68a:	2200      	movs	r2, #0
    c68c:	701a      	strb	r2, [r3, #0]

  usbpd_status = USBPD_TCPCI_ReadRegister(Port, TCPC_REG_POWER_STATUS, &state[Port].Registers.Status.u2.POWER_STATUS, 1);
    c68e:	687b      	ldr	r3, [r7, #4]
    c690:	b2d8      	uxtb	r0, r3
    c692:	687a      	ldr	r2, [r7, #4]
    c694:	0013      	movs	r3, r2
    c696:	015b      	lsls	r3, r3, #5
    c698:	189b      	adds	r3, r3, r2
    c69a:	009b      	lsls	r3, r3, #2
    c69c:	3310      	adds	r3, #16
    c69e:	001a      	movs	r2, r3
    c6a0:	4b1e      	ldr	r3, [pc, #120]	; (c71c <fusb305_tcpc_get_power_status+0xa0>)
    c6a2:	18d3      	adds	r3, r2, r3
    c6a4:	3308      	adds	r3, #8
    c6a6:	001a      	movs	r2, r3
    c6a8:	187c      	adds	r4, r7, r1
    c6aa:	2301      	movs	r3, #1
    c6ac:	211e      	movs	r1, #30
    c6ae:	f001 fdbd 	bl	e22c <USBPD_TCPCI_ReadRegister>
    c6b2:	0003      	movs	r3, r0
    c6b4:	7023      	strb	r3, [r4, #0]
  *PowerStatus = state[Port].Registers.Status.u2.POWER_STATUS;
    c6b6:	4919      	ldr	r1, [pc, #100]	; (c71c <fusb305_tcpc_get_power_status+0xa0>)
    c6b8:	687a      	ldr	r2, [r7, #4]
    c6ba:	0013      	movs	r3, r2
    c6bc:	015b      	lsls	r3, r3, #5
    c6be:	189b      	adds	r3, r3, r2
    c6c0:	009b      	lsls	r3, r3, #2
    c6c2:	18cb      	adds	r3, r1, r3
    c6c4:	3318      	adds	r3, #24
    c6c6:	781a      	ldrb	r2, [r3, #0]
    c6c8:	683b      	ldr	r3, [r7, #0]
    c6ca:	701a      	strb	r2, [r3, #0]

#if defined(_TRACE)
  uint8_t tab[10] = {0};
    c6cc:	240c      	movs	r4, #12
    c6ce:	193b      	adds	r3, r7, r4
    c6d0:	0018      	movs	r0, r3
    c6d2:	230a      	movs	r3, #10
    c6d4:	001a      	movs	r2, r3
    c6d6:	2100      	movs	r1, #0
    c6d8:	f011 ffe5 	bl	1e6a6 <memset>
  sprintf((char*)tab,"power=%2x", *PowerStatus);
    c6dc:	683b      	ldr	r3, [r7, #0]
    c6de:	781b      	ldrb	r3, [r3, #0]
    c6e0:	001a      	movs	r2, r3
    c6e2:	490f      	ldr	r1, [pc, #60]	; (c720 <fusb305_tcpc_get_power_status+0xa4>)
    c6e4:	193b      	adds	r3, r7, r4
    c6e6:	0018      	movs	r0, r3
    c6e8:	f012 f8a0 	bl	1e82c <siprintf>
  FUSB307_DEBUG_TRACE(Port, FUSB307_DEBUG_LEVEL_0, tab);
    c6ec:	4b0d      	ldr	r3, [pc, #52]	; (c724 <fusb305_tcpc_get_power_status+0xa8>)
    c6ee:	781b      	ldrb	r3, [r3, #0]
    c6f0:	001a      	movs	r2, r3
    c6f2:	2301      	movs	r3, #1
    c6f4:	4013      	ands	r3, r2
    c6f6:	d00a      	beq.n	c70e <fusb305_tcpc_get_power_status+0x92>
    c6f8:	687b      	ldr	r3, [r7, #4]
    c6fa:	b2d9      	uxtb	r1, r3
    c6fc:	230c      	movs	r3, #12
    c6fe:	18fa      	adds	r2, r7, r3
    c700:	2309      	movs	r3, #9
    c702:	9300      	str	r3, [sp, #0]
    c704:	0013      	movs	r3, r2
    c706:	2200      	movs	r2, #0
    c708:	2006      	movs	r0, #6
    c70a:	f003 ff2b 	bl	10564 <USBPD_TRACE_Add>
#endif /* _TRACE */

  return usbpd_status;
    c70e:	2317      	movs	r3, #23
    c710:	18fb      	adds	r3, r7, r3
    c712:	781b      	ldrb	r3, [r3, #0]
}
    c714:	0018      	movs	r0, r3
    c716:	46bd      	mov	sp, r7
    c718:	b007      	add	sp, #28
    c71a:	bd90      	pop	{r4, r7, pc}
    c71c:	000300b8 	.word	0x000300b8
    c720:	0001f3f0 	.word	0x0001f3f0
    c724:	0002febc 	.word	0x0002febc

0000c728 <fusb305_tcpc_get_fault_status>:
  * @param  Port port number value
  * @param  FaultStatus Pointer on Fault status
  * @retval USBPD status
  */
USBPD_StatusTypeDef fusb305_tcpc_get_fault_status(uint32_t Port, uint8_t *FaultStatus)
{
    c728:	b5b0      	push	{r4, r5, r7, lr}
    c72a:	b084      	sub	sp, #16
    c72c:	af00      	add	r7, sp, #0
    c72e:	6078      	str	r0, [r7, #4]
    c730:	6039      	str	r1, [r7, #0]
  USBPD_StatusTypeDef usbpd_status = USBPD_OK;
    c732:	210f      	movs	r1, #15
    c734:	187b      	adds	r3, r7, r1
    c736:	2200      	movs	r2, #0
    c738:	701a      	strb	r2, [r3, #0]

  usbpd_status = USBPD_TCPCI_ReadRegister(Port, TCPC_REG_FAULT_STATUS, &state[Port].Registers.Status.u3.FAULT_STATUS, 1);
    c73a:	687b      	ldr	r3, [r7, #4]
    c73c:	b2d8      	uxtb	r0, r3
    c73e:	687a      	ldr	r2, [r7, #4]
    c740:	0013      	movs	r3, r2
    c742:	015b      	lsls	r3, r3, #5
    c744:	189b      	adds	r3, r3, r2
    c746:	009b      	lsls	r3, r3, #2
    c748:	3310      	adds	r3, #16
    c74a:	001a      	movs	r2, r3
    c74c:	4b0e      	ldr	r3, [pc, #56]	; (c788 <fusb305_tcpc_get_fault_status+0x60>)
    c74e:	18d3      	adds	r3, r2, r3
    c750:	3309      	adds	r3, #9
    c752:	001a      	movs	r2, r3
    c754:	000d      	movs	r5, r1
    c756:	187c      	adds	r4, r7, r1
    c758:	2301      	movs	r3, #1
    c75a:	211f      	movs	r1, #31
    c75c:	f001 fd66 	bl	e22c <USBPD_TCPCI_ReadRegister>
    c760:	0003      	movs	r3, r0
    c762:	7023      	strb	r3, [r4, #0]
  *FaultStatus = state[Port].Registers.Status.u3.FAULT_STATUS;
    c764:	4908      	ldr	r1, [pc, #32]	; (c788 <fusb305_tcpc_get_fault_status+0x60>)
    c766:	687a      	ldr	r2, [r7, #4]
    c768:	0013      	movs	r3, r2
    c76a:	015b      	lsls	r3, r3, #5
    c76c:	189b      	adds	r3, r3, r2
    c76e:	009b      	lsls	r3, r3, #2
    c770:	18cb      	adds	r3, r1, r3
    c772:	3319      	adds	r3, #25
    c774:	781a      	ldrb	r2, [r3, #0]
    c776:	683b      	ldr	r3, [r7, #0]
    c778:	701a      	strb	r2, [r3, #0]

  return usbpd_status;
    c77a:	0029      	movs	r1, r5
    c77c:	187b      	adds	r3, r7, r1
    c77e:	781b      	ldrb	r3, [r3, #0]
}
    c780:	0018      	movs	r0, r3
    c782:	46bd      	mov	sp, r7
    c784:	b004      	add	sp, #16
    c786:	bdb0      	pop	{r4, r5, r7, pc}
    c788:	000300b8 	.word	0x000300b8

0000c78c <fusb305_tcpc_set_fault_status>:
  * @param  Port        port number value
  * @param  FaultStatus Fault status
  * @retval USBPD status
  */
USBPD_StatusTypeDef fusb305_tcpc_set_fault_status(uint32_t Port, uint8_t FaultStatus)
{
    c78c:	b5b0      	push	{r4, r5, r7, lr}
    c78e:	b084      	sub	sp, #16
    c790:	af00      	add	r7, sp, #0
    c792:	6078      	str	r0, [r7, #4]
    c794:	000a      	movs	r2, r1
    c796:	1cfb      	adds	r3, r7, #3
    c798:	701a      	strb	r2, [r3, #0]
  USBPD_StatusTypeDef usbpd_status = USBPD_OK;
    c79a:	240f      	movs	r4, #15
    c79c:	193b      	adds	r3, r7, r4
    c79e:	2200      	movs	r2, #0
    c7a0:	701a      	strb	r2, [r3, #0]

  state[Port].Registers.Status.u3.FAULT_STATUS = FaultStatus;
    c7a2:	1cfb      	adds	r3, r7, #3
    c7a4:	7818      	ldrb	r0, [r3, #0]
    c7a6:	490e      	ldr	r1, [pc, #56]	; (c7e0 <fusb305_tcpc_set_fault_status+0x54>)
    c7a8:	687a      	ldr	r2, [r7, #4]
    c7aa:	0013      	movs	r3, r2
    c7ac:	015b      	lsls	r3, r3, #5
    c7ae:	189b      	adds	r3, r3, r2
    c7b0:	009b      	lsls	r3, r3, #2
    c7b2:	18cb      	adds	r3, r1, r3
    c7b4:	3319      	adds	r3, #25
    c7b6:	1c02      	adds	r2, r0, #0
    c7b8:	701a      	strb	r2, [r3, #0]
  usbpd_status = USBPD_TCPCI_WriteRegister(Port, TCPC_REG_FAULT_STATUS, &FaultStatus, 1);
    c7ba:	687b      	ldr	r3, [r7, #4]
    c7bc:	b2d8      	uxtb	r0, r3
    c7be:	0025      	movs	r5, r4
    c7c0:	193c      	adds	r4, r7, r4
    c7c2:	1cfa      	adds	r2, r7, #3
    c7c4:	2301      	movs	r3, #1
    c7c6:	211f      	movs	r1, #31
    c7c8:	f001 fbee 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
    c7cc:	0003      	movs	r3, r0
    c7ce:	7023      	strb	r3, [r4, #0]

  return usbpd_status;
    c7d0:	002c      	movs	r4, r5
    c7d2:	193b      	adds	r3, r7, r4
    c7d4:	781b      	ldrb	r3, [r3, #0]
}
    c7d6:	0018      	movs	r0, r3
    c7d8:	46bd      	mov	sp, r7
    c7da:	b004      	add	sp, #16
    c7dc:	bdb0      	pop	{r4, r5, r7, pc}
    c7de:	46c0      	nop			; (mov r8, r8)
    c7e0:	000300b8 	.word	0x000300b8

0000c7e4 <fusb305_tcpc_get_vbus_level>:
  * @param  VBUSLevel   Pointer on VBUS level
  * @param  VBUSVoltage Pointer on VBUS Voltage (in mV)
  * @retval USBPD status
  */
USBPD_StatusTypeDef fusb305_tcpc_get_vbus_level(uint32_t Port, uint8_t *VBUSLevel, uint16_t *VBUSVoltage)
{
    c7e4:	b580      	push	{r7, lr}
    c7e6:	b08a      	sub	sp, #40	; 0x28
    c7e8:	af02      	add	r7, sp, #8
    c7ea:	60f8      	str	r0, [r7, #12]
    c7ec:	60b9      	str	r1, [r7, #8]
    c7ee:	607a      	str	r2, [r7, #4]
  USBPD_TCPCI_ReadRegister(Port, TCPC_REG_POWER_STATUS, &state[Port].Registers.Status.u2.POWER_STATUS, 1);
    c7f0:	68fb      	ldr	r3, [r7, #12]
    c7f2:	b2d8      	uxtb	r0, r3
    c7f4:	68fa      	ldr	r2, [r7, #12]
    c7f6:	0013      	movs	r3, r2
    c7f8:	015b      	lsls	r3, r3, #5
    c7fa:	189b      	adds	r3, r3, r2
    c7fc:	009b      	lsls	r3, r3, #2
    c7fe:	3310      	adds	r3, #16
    c800:	001a      	movs	r2, r3
    c802:	4b4a      	ldr	r3, [pc, #296]	; (c92c <fusb305_tcpc_get_vbus_level+0x148>)
    c804:	18d3      	adds	r3, r2, r3
    c806:	3308      	adds	r3, #8
    c808:	001a      	movs	r2, r3
    c80a:	2301      	movs	r3, #1
    c80c:	211e      	movs	r1, #30
    c80e:	f001 fd0d 	bl	e22c <USBPD_TCPCI_ReadRegister>
  *VBUSLevel = state[Port].Registers.Status.u2.b2.VBUS_VAL;
    c812:	4946      	ldr	r1, [pc, #280]	; (c92c <fusb305_tcpc_get_vbus_level+0x148>)
    c814:	68fa      	ldr	r2, [r7, #12]
    c816:	2010      	movs	r0, #16
    c818:	0013      	movs	r3, r2
    c81a:	015b      	lsls	r3, r3, #5
    c81c:	189b      	adds	r3, r3, r2
    c81e:	009b      	lsls	r3, r3, #2
    c820:	18cb      	adds	r3, r1, r3
    c822:	181b      	adds	r3, r3, r0
    c824:	7a1b      	ldrb	r3, [r3, #8]
    c826:	075b      	lsls	r3, r3, #29
    c828:	0fdb      	lsrs	r3, r3, #31
    c82a:	b2db      	uxtb	r3, r3
    c82c:	001a      	movs	r2, r3
    c82e:	68bb      	ldr	r3, [r7, #8]
    c830:	701a      	strb	r2, [r3, #0]

  /* Get VBUS measurement */
  USBPD_TCPCI_ReadRegister(Port, TCPC_REG_VBUS_VOLTAGE, (uint8_t*)&state[Port].Registers.VBUS.s.u.VBUS_VOLTAGE, 2);
    c832:	68fb      	ldr	r3, [r7, #12]
    c834:	b2d8      	uxtb	r0, r3
    c836:	68fa      	ldr	r2, [r7, #12]
    c838:	0013      	movs	r3, r2
    c83a:	015b      	lsls	r3, r3, #5
    c83c:	189b      	adds	r3, r3, r2
    c83e:	009b      	lsls	r3, r3, #2
    c840:	3348      	adds	r3, #72	; 0x48
    c842:	001a      	movs	r2, r3
    c844:	4b39      	ldr	r3, [pc, #228]	; (c92c <fusb305_tcpc_get_vbus_level+0x148>)
    c846:	18d2      	adds	r2, r2, r3
    c848:	2302      	movs	r3, #2
    c84a:	2170      	movs	r1, #112	; 0x70
    c84c:	f001 fcee 	bl	e22c <USBPD_TCPCI_ReadRegister>
  *VBUSVoltage = state[Port].Registers.VBUS.s.u.VBUS_VOLTAGE * 25;
    c850:	4936      	ldr	r1, [pc, #216]	; (c92c <fusb305_tcpc_get_vbus_level+0x148>)
    c852:	68fa      	ldr	r2, [r7, #12]
    c854:	2048      	movs	r0, #72	; 0x48
    c856:	0013      	movs	r3, r2
    c858:	015b      	lsls	r3, r3, #5
    c85a:	189b      	adds	r3, r3, r2
    c85c:	009b      	lsls	r3, r3, #2
    c85e:	18cb      	adds	r3, r1, r3
    c860:	181b      	adds	r3, r3, r0
    c862:	881b      	ldrh	r3, [r3, #0]
    c864:	1c1a      	adds	r2, r3, #0
    c866:	0092      	lsls	r2, r2, #2
    c868:	18d3      	adds	r3, r2, r3
    c86a:	1c1a      	adds	r2, r3, #0
    c86c:	0091      	lsls	r1, r2, #2
    c86e:	1c1a      	adds	r2, r3, #0
    c870:	1c0b      	adds	r3, r1, #0
    c872:	18d3      	adds	r3, r2, r3
    c874:	b29a      	uxth	r2, r3
    c876:	687b      	ldr	r3, [r7, #4]
    c878:	801a      	strh	r2, [r3, #0]

#if defined(_TRACE)
  static volatile uint8_t previous_vbus = 0;
  static volatile uint16_t previous_vbus_voltage = 0;
  uint8_t tab[15] = {0};
    c87a:	2310      	movs	r3, #16
    c87c:	18fb      	adds	r3, r7, r3
    c87e:	0018      	movs	r0, r3
    c880:	230f      	movs	r3, #15
    c882:	001a      	movs	r2, r3
    c884:	2100      	movs	r1, #0
    c886:	f011 ff0e 	bl	1e6a6 <memset>

  if (previous_vbus != *VBUSLevel)
    c88a:	68bb      	ldr	r3, [r7, #8]
    c88c:	781a      	ldrb	r2, [r3, #0]
    c88e:	4b28      	ldr	r3, [pc, #160]	; (c930 <fusb305_tcpc_get_vbus_level+0x14c>)
    c890:	781b      	ldrb	r3, [r3, #0]
    c892:	b2db      	uxtb	r3, r3
    c894:	429a      	cmp	r2, r3
    c896:	d01e      	beq.n	c8d6 <fusb305_tcpc_get_vbus_level+0xf2>
  {
    previous_vbus = *VBUSLevel;
    c898:	68bb      	ldr	r3, [r7, #8]
    c89a:	781a      	ldrb	r2, [r3, #0]
    c89c:	4b24      	ldr	r3, [pc, #144]	; (c930 <fusb305_tcpc_get_vbus_level+0x14c>)
    c89e:	701a      	strb	r2, [r3, #0]
    sprintf((char*)tab,"Vbus=%2x", previous_vbus);
    c8a0:	4b23      	ldr	r3, [pc, #140]	; (c930 <fusb305_tcpc_get_vbus_level+0x14c>)
    c8a2:	781b      	ldrb	r3, [r3, #0]
    c8a4:	b2db      	uxtb	r3, r3
    c8a6:	001a      	movs	r2, r3
    c8a8:	4922      	ldr	r1, [pc, #136]	; (c934 <fusb305_tcpc_get_vbus_level+0x150>)
    c8aa:	2310      	movs	r3, #16
    c8ac:	18fb      	adds	r3, r7, r3
    c8ae:	0018      	movs	r0, r3
    c8b0:	f011 ffbc 	bl	1e82c <siprintf>
    FUSB307_DEBUG_TRACE(Port, FUSB307_DEBUG_LEVEL_1, tab);
    c8b4:	4b20      	ldr	r3, [pc, #128]	; (c938 <fusb305_tcpc_get_vbus_level+0x154>)
    c8b6:	781b      	ldrb	r3, [r3, #0]
    c8b8:	001a      	movs	r2, r3
    c8ba:	2302      	movs	r3, #2
    c8bc:	4013      	ands	r3, r2
    c8be:	d00a      	beq.n	c8d6 <fusb305_tcpc_get_vbus_level+0xf2>
    c8c0:	68fb      	ldr	r3, [r7, #12]
    c8c2:	b2d9      	uxtb	r1, r3
    c8c4:	2310      	movs	r3, #16
    c8c6:	18fa      	adds	r2, r7, r3
    c8c8:	230e      	movs	r3, #14
    c8ca:	9300      	str	r3, [sp, #0]
    c8cc:	0013      	movs	r3, r2
    c8ce:	2200      	movs	r2, #0
    c8d0:	2006      	movs	r0, #6
    c8d2:	f003 fe47 	bl	10564 <USBPD_TRACE_Add>
  }

  if (previous_vbus_voltage != *VBUSVoltage)
    c8d6:	687b      	ldr	r3, [r7, #4]
    c8d8:	881a      	ldrh	r2, [r3, #0]
    c8da:	4b18      	ldr	r3, [pc, #96]	; (c93c <fusb305_tcpc_get_vbus_level+0x158>)
    c8dc:	881b      	ldrh	r3, [r3, #0]
    c8de:	b29b      	uxth	r3, r3
    c8e0:	429a      	cmp	r2, r3
    c8e2:	d01e      	beq.n	c922 <fusb305_tcpc_get_vbus_level+0x13e>
  {
    previous_vbus_voltage = *VBUSVoltage;
    c8e4:	687b      	ldr	r3, [r7, #4]
    c8e6:	881a      	ldrh	r2, [r3, #0]
    c8e8:	4b14      	ldr	r3, [pc, #80]	; (c93c <fusb305_tcpc_get_vbus_level+0x158>)
    c8ea:	801a      	strh	r2, [r3, #0]
    sprintf((char*)tab,"VbusVolt=%d", previous_vbus_voltage);
    c8ec:	4b13      	ldr	r3, [pc, #76]	; (c93c <fusb305_tcpc_get_vbus_level+0x158>)
    c8ee:	881b      	ldrh	r3, [r3, #0]
    c8f0:	b29b      	uxth	r3, r3
    c8f2:	001a      	movs	r2, r3
    c8f4:	4912      	ldr	r1, [pc, #72]	; (c940 <fusb305_tcpc_get_vbus_level+0x15c>)
    c8f6:	2310      	movs	r3, #16
    c8f8:	18fb      	adds	r3, r7, r3
    c8fa:	0018      	movs	r0, r3
    c8fc:	f011 ff96 	bl	1e82c <siprintf>
    FUSB307_DEBUG_TRACE(Port, FUSB307_DEBUG_LEVEL_1, tab);
    c900:	4b0d      	ldr	r3, [pc, #52]	; (c938 <fusb305_tcpc_get_vbus_level+0x154>)
    c902:	781b      	ldrb	r3, [r3, #0]
    c904:	001a      	movs	r2, r3
    c906:	2302      	movs	r3, #2
    c908:	4013      	ands	r3, r2
    c90a:	d00a      	beq.n	c922 <fusb305_tcpc_get_vbus_level+0x13e>
    c90c:	68fb      	ldr	r3, [r7, #12]
    c90e:	b2d9      	uxtb	r1, r3
    c910:	2310      	movs	r3, #16
    c912:	18fa      	adds	r2, r7, r3
    c914:	230e      	movs	r3, #14
    c916:	9300      	str	r3, [sp, #0]
    c918:	0013      	movs	r3, r2
    c91a:	2200      	movs	r2, #0
    c91c:	2006      	movs	r0, #6
    c91e:	f003 fe21 	bl	10564 <USBPD_TRACE_Add>
  }
#endif /* _TRACE */

  return USBPD_OK;
    c922:	2300      	movs	r3, #0
}
    c924:	0018      	movs	r0, r3
    c926:	46bd      	mov	sp, r7
    c928:	b008      	add	sp, #32
    c92a:	bd80      	pop	{r7, pc}
    c92c:	000300b8 	.word	0x000300b8
    c930:	0003013c 	.word	0x0003013c
    c934:	0001f3fc 	.word	0x0001f3fc
    c938:	0002febc 	.word	0x0002febc
    c93c:	0003013e 	.word	0x0003013e
    c940:	0001f408 	.word	0x0001f408

0000c944 <fusb305_tcpc_set_vbus_level>:
  * @param  Port port number value
  * @param  Enable Enable or disable VBUS level
  * @retval USBPD status
  */
USBPD_StatusTypeDef fusb305_tcpc_set_vbus_level(uint32_t Port, USBPD_FunctionalState State)
{
    c944:	b590      	push	{r4, r7, lr}
    c946:	b085      	sub	sp, #20
    c948:	af00      	add	r7, sp, #0
    c94a:	6078      	str	r0, [r7, #4]
    c94c:	000a      	movs	r2, r1
    c94e:	1cfb      	adds	r3, r7, #3
    c950:	701a      	strb	r2, [r3, #0]
  uint8_t vbus_level = 0;
    c952:	230e      	movs	r3, #14
    c954:	18fb      	adds	r3, r7, r3
    c956:	2200      	movs	r2, #0
    c958:	701a      	strb	r2, [r3, #0]
  if (USBPD_ENABLE == State)
    c95a:	1cfb      	adds	r3, r7, #3
    c95c:	781b      	ldrb	r3, [r3, #0]
    c95e:	2b01      	cmp	r3, #1
    c960:	d000      	beq.n	c964 <fusb305_tcpc_set_vbus_level+0x20>
    c962:	e1a1      	b.n	cca8 <fusb305_tcpc_set_vbus_level+0x364>
  {
    uint8_t TimeoutSink = 0;
    c964:	230f      	movs	r3, #15
    c966:	18fb      	adds	r3, r7, r3
    c968:	2200      	movs	r2, #0
    c96a:	701a      	strb	r2, [r3, #0]
    /* Enable SINK or SOURCE VBUS*/
    if (state[Port].PowerRole == USBPD_PORTPOWERROLE_SRC)
    c96c:	49cd      	ldr	r1, [pc, #820]	; (cca4 <fusb305_tcpc_set_vbus_level+0x360>)
    c96e:	687a      	ldr	r2, [r7, #4]
    c970:	0013      	movs	r3, r2
    c972:	015b      	lsls	r3, r3, #5
    c974:	189b      	adds	r3, r3, r2
    c976:	009b      	lsls	r3, r3, #2
    c978:	18cb      	adds	r3, r1, r3
    c97a:	3368      	adds	r3, #104	; 0x68
    c97c:	681b      	ldr	r3, [r3, #0]
    c97e:	2b01      	cmp	r3, #1
    c980:	d154      	bne.n	ca2c <fusb305_tcpc_set_vbus_level+0xe8>
    {
      /* Enable VCONN */
      state[Port].Registers.Control.s.u5.b5.AUTO_DISCH  = 1;
    c982:	49c8      	ldr	r1, [pc, #800]	; (cca4 <fusb305_tcpc_set_vbus_level+0x360>)
    c984:	687a      	ldr	r2, [r7, #4]
    c986:	2010      	movs	r0, #16
    c988:	0013      	movs	r3, r2
    c98a:	015b      	lsls	r3, r3, #5
    c98c:	189b      	adds	r3, r3, r2
    c98e:	009b      	lsls	r3, r3, #2
    c990:	18cb      	adds	r3, r1, r3
    c992:	181b      	adds	r3, r3, r0
    c994:	799a      	ldrb	r2, [r3, #6]
    c996:	2110      	movs	r1, #16
    c998:	430a      	orrs	r2, r1
    c99a:	719a      	strb	r2, [r3, #6]
      USBPD_TCPCI_WriteRegister(Port, TCPC_REG_POWER_CONTROL, &state[Port].Registers.Control.s.u5.POWER_CONTROL, 1);
    c99c:	687b      	ldr	r3, [r7, #4]
    c99e:	b2d8      	uxtb	r0, r3
    c9a0:	687a      	ldr	r2, [r7, #4]
    c9a2:	0013      	movs	r3, r2
    c9a4:	015b      	lsls	r3, r3, #5
    c9a6:	189b      	adds	r3, r3, r2
    c9a8:	009b      	lsls	r3, r3, #2
    c9aa:	3310      	adds	r3, #16
    c9ac:	001a      	movs	r2, r3
    c9ae:	4bbd      	ldr	r3, [pc, #756]	; (cca4 <fusb305_tcpc_set_vbus_level+0x360>)
    c9b0:	18d3      	adds	r3, r2, r3
    c9b2:	1d9a      	adds	r2, r3, #6
    c9b4:	2301      	movs	r3, #1
    c9b6:	211c      	movs	r1, #28
    c9b8:	f001 faf6 	bl	dfa8 <USBPD_TCPCI_WriteRegister>

      /* Disable SINK VBUS */
      state[Port].Registers.Command.u.COMMAND = TCPC_REG_COMMAND_DISABLE_SINK_VBUS;
    c9bc:	49b9      	ldr	r1, [pc, #740]	; (cca4 <fusb305_tcpc_set_vbus_level+0x360>)
    c9be:	687a      	ldr	r2, [r7, #4]
    c9c0:	0013      	movs	r3, r2
    c9c2:	015b      	lsls	r3, r3, #5
    c9c4:	189b      	adds	r3, r3, r2
    c9c6:	009b      	lsls	r3, r3, #2
    c9c8:	18cb      	adds	r3, r1, r3
    c9ca:	331a      	adds	r3, #26
    c9cc:	2244      	movs	r2, #68	; 0x44
    c9ce:	701a      	strb	r2, [r3, #0]
      USBPD_TCPCI_WriteRegister(Port, TCPC_REG_COMMAND, &state[Port].Registers.Command.u.COMMAND, 1);
    c9d0:	687b      	ldr	r3, [r7, #4]
    c9d2:	b2d8      	uxtb	r0, r3
    c9d4:	687a      	ldr	r2, [r7, #4]
    c9d6:	0013      	movs	r3, r2
    c9d8:	015b      	lsls	r3, r3, #5
    c9da:	189b      	adds	r3, r3, r2
    c9dc:	009b      	lsls	r3, r3, #2
    c9de:	3318      	adds	r3, #24
    c9e0:	001a      	movs	r2, r3
    c9e2:	4bb0      	ldr	r3, [pc, #704]	; (cca4 <fusb305_tcpc_set_vbus_level+0x360>)
    c9e4:	18d3      	adds	r3, r2, r3
    c9e6:	1c9a      	adds	r2, r3, #2
    c9e8:	2301      	movs	r3, #1
    c9ea:	2123      	movs	r1, #35	; 0x23
    c9ec:	f001 fadc 	bl	dfa8 <USBPD_TCPCI_WriteRegister>

      /* Add delay between disable SINK VBUS and enable SRC VBUS */
      USBPD_TCPCI_Delay(2);
    c9f0:	2002      	movs	r0, #2
    c9f2:	f001 fc65 	bl	e2c0 <USBPD_TCPCI_Delay>

      /* Enable SOURCE VBUS */
      state[Port].Registers.Command.u.COMMAND = TCPC_REG_COMMAND_SRC_VBUS_DEFAULT;
    c9f6:	49ab      	ldr	r1, [pc, #684]	; (cca4 <fusb305_tcpc_set_vbus_level+0x360>)
    c9f8:	687a      	ldr	r2, [r7, #4]
    c9fa:	0013      	movs	r3, r2
    c9fc:	015b      	lsls	r3, r3, #5
    c9fe:	189b      	adds	r3, r3, r2
    ca00:	009b      	lsls	r3, r3, #2
    ca02:	18cb      	adds	r3, r1, r3
    ca04:	331a      	adds	r3, #26
    ca06:	2277      	movs	r2, #119	; 0x77
    ca08:	701a      	strb	r2, [r3, #0]
      USBPD_TCPCI_WriteRegister(Port, TCPC_REG_COMMAND, &state[Port].Registers.Command.u.COMMAND, 1);
    ca0a:	687b      	ldr	r3, [r7, #4]
    ca0c:	b2d8      	uxtb	r0, r3
    ca0e:	687a      	ldr	r2, [r7, #4]
    ca10:	0013      	movs	r3, r2
    ca12:	015b      	lsls	r3, r3, #5
    ca14:	189b      	adds	r3, r3, r2
    ca16:	009b      	lsls	r3, r3, #2
    ca18:	3318      	adds	r3, #24
    ca1a:	001a      	movs	r2, r3
    ca1c:	4ba1      	ldr	r3, [pc, #644]	; (cca4 <fusb305_tcpc_set_vbus_level+0x360>)
    ca1e:	18d3      	adds	r3, r2, r3
    ca20:	1c9a      	adds	r2, r3, #2
    ca22:	2301      	movs	r3, #1
    ca24:	2123      	movs	r1, #35	; 0x23
    ca26:	f001 fabf 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
    ca2a:	e033      	b.n	ca94 <fusb305_tcpc_set_vbus_level+0x150>
    }
    else
    {
      /* Disable SOURCE VBUS */
      state[Port].Registers.Command.u.COMMAND = TCPC_REG_COMMAND_DISABLE_SRC_VBUS;
    ca2c:	499d      	ldr	r1, [pc, #628]	; (cca4 <fusb305_tcpc_set_vbus_level+0x360>)
    ca2e:	687a      	ldr	r2, [r7, #4]
    ca30:	0013      	movs	r3, r2
    ca32:	015b      	lsls	r3, r3, #5
    ca34:	189b      	adds	r3, r3, r2
    ca36:	009b      	lsls	r3, r3, #2
    ca38:	18cb      	adds	r3, r1, r3
    ca3a:	331a      	adds	r3, #26
    ca3c:	2266      	movs	r2, #102	; 0x66
    ca3e:	701a      	strb	r2, [r3, #0]
      USBPD_TCPCI_WriteRegister(Port, TCPC_REG_COMMAND, &state[Port].Registers.Command.u.COMMAND, 1);
    ca40:	687b      	ldr	r3, [r7, #4]
    ca42:	b2d8      	uxtb	r0, r3
    ca44:	687a      	ldr	r2, [r7, #4]
    ca46:	0013      	movs	r3, r2
    ca48:	015b      	lsls	r3, r3, #5
    ca4a:	189b      	adds	r3, r3, r2
    ca4c:	009b      	lsls	r3, r3, #2
    ca4e:	3318      	adds	r3, #24
    ca50:	001a      	movs	r2, r3
    ca52:	4b94      	ldr	r3, [pc, #592]	; (cca4 <fusb305_tcpc_set_vbus_level+0x360>)
    ca54:	18d3      	adds	r3, r2, r3
    ca56:	1c9a      	adds	r2, r3, #2
    ca58:	2301      	movs	r3, #1
    ca5a:	2123      	movs	r1, #35	; 0x23
    ca5c:	f001 faa4 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
      /* Enable SINK VBUS */
      state[Port].Registers.Command.u.COMMAND = TCPC_REG_COMMAND_ENABLE_SINK_VBUS;
    ca60:	4990      	ldr	r1, [pc, #576]	; (cca4 <fusb305_tcpc_set_vbus_level+0x360>)
    ca62:	687a      	ldr	r2, [r7, #4]
    ca64:	0013      	movs	r3, r2
    ca66:	015b      	lsls	r3, r3, #5
    ca68:	189b      	adds	r3, r3, r2
    ca6a:	009b      	lsls	r3, r3, #2
    ca6c:	18cb      	adds	r3, r1, r3
    ca6e:	331a      	adds	r3, #26
    ca70:	2255      	movs	r2, #85	; 0x55
    ca72:	701a      	strb	r2, [r3, #0]
      USBPD_TCPCI_WriteRegister(Port, TCPC_REG_COMMAND, &state[Port].Registers.Command.u.COMMAND, 1);
    ca74:	687b      	ldr	r3, [r7, #4]
    ca76:	b2d8      	uxtb	r0, r3
    ca78:	687a      	ldr	r2, [r7, #4]
    ca7a:	0013      	movs	r3, r2
    ca7c:	015b      	lsls	r3, r3, #5
    ca7e:	189b      	adds	r3, r3, r2
    ca80:	009b      	lsls	r3, r3, #2
    ca82:	3318      	adds	r3, #24
    ca84:	001a      	movs	r2, r3
    ca86:	4b87      	ldr	r3, [pc, #540]	; (cca4 <fusb305_tcpc_set_vbus_level+0x360>)
    ca88:	18d3      	adds	r3, r2, r3
    ca8a:	1c9a      	adds	r2, r3, #2
    ca8c:	2301      	movs	r3, #1
    ca8e:	2123      	movs	r1, #35	; 0x23
    ca90:	f001 fa8a 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
    }

    /* Wait for VBUS ready */
    fusb305_tcpc_get_vbus_level(Port, &vbus_level, NULL);
    ca94:	230e      	movs	r3, #14
    ca96:	18f9      	adds	r1, r7, r3
    ca98:	687b      	ldr	r3, [r7, #4]
    ca9a:	2200      	movs	r2, #0
    ca9c:	0018      	movs	r0, r3
    ca9e:	f7ff fea1 	bl	c7e4 <fusb305_tcpc_get_vbus_level>
    while (vbus_level != 1)
    caa2:	e0f7      	b.n	cc94 <fusb305_tcpc_set_vbus_level+0x350>
    {
      /* Add a delay for CC debounce */
      USBPD_TCPCI_Delay(4);
    caa4:	2004      	movs	r0, #4
    caa6:	f001 fc0b 	bl	e2c0 <USBPD_TCPCI_Delay>

      USBPD_TCPCI_ReadRegister(Port, TCPC_REG_CC_STATUS, (uint8_t*)&state[Port].Registers.Status.u1.CC_STATUS, 1);
    caaa:	687b      	ldr	r3, [r7, #4]
    caac:	b2d8      	uxtb	r0, r3
    caae:	687a      	ldr	r2, [r7, #4]
    cab0:	0013      	movs	r3, r2
    cab2:	015b      	lsls	r3, r3, #5
    cab4:	189b      	adds	r3, r3, r2
    cab6:	009b      	lsls	r3, r3, #2
    cab8:	3310      	adds	r3, #16
    caba:	001a      	movs	r2, r3
    cabc:	4b79      	ldr	r3, [pc, #484]	; (cca4 <fusb305_tcpc_set_vbus_level+0x360>)
    cabe:	18d3      	adds	r3, r2, r3
    cac0:	1dda      	adds	r2, r3, #7
    cac2:	2301      	movs	r3, #1
    cac4:	211d      	movs	r1, #29
    cac6:	f001 fbb1 	bl	e22c <USBPD_TCPCI_ReadRegister>
      /* Check if CC line has been disconnected */
      /* or if no more VBUS after CC_DEBOUNCE_TIMER x 3 (around 12ms) */
      if (((TYPEC_CC_VOLT_OPEN == state[Port].Registers.Status.u1.b1.CC1_STAT) 
    caca:	4976      	ldr	r1, [pc, #472]	; (cca4 <fusb305_tcpc_set_vbus_level+0x360>)
    cacc:	687a      	ldr	r2, [r7, #4]
    cace:	2010      	movs	r0, #16
    cad0:	0013      	movs	r3, r2
    cad2:	015b      	lsls	r3, r3, #5
    cad4:	189b      	adds	r3, r3, r2
    cad6:	009b      	lsls	r3, r3, #2
    cad8:	18cb      	adds	r3, r1, r3
    cada:	181b      	adds	r3, r3, r0
    cadc:	79db      	ldrb	r3, [r3, #7]
    cade:	079b      	lsls	r3, r3, #30
    cae0:	0f9b      	lsrs	r3, r3, #30
    cae2:	b2db      	uxtb	r3, r3
    cae4:	2b00      	cmp	r3, #0
    cae6:	d10e      	bne.n	cb06 <fusb305_tcpc_set_vbus_level+0x1c2>
           && (state[Port].Registers.Control.s.u2.b2.PLUG_ORIENT == 0))
    cae8:	496e      	ldr	r1, [pc, #440]	; (cca4 <fusb305_tcpc_set_vbus_level+0x360>)
    caea:	687a      	ldr	r2, [r7, #4]
    caec:	2010      	movs	r0, #16
    caee:	0013      	movs	r3, r2
    caf0:	015b      	lsls	r3, r3, #5
    caf2:	189b      	adds	r3, r3, r2
    caf4:	009b      	lsls	r3, r3, #2
    caf6:	18cb      	adds	r3, r1, r3
    caf8:	181b      	adds	r3, r3, r0
    cafa:	78db      	ldrb	r3, [r3, #3]
    cafc:	07db      	lsls	r3, r3, #31
    cafe:	0fdb      	lsrs	r3, r3, #31
    cb00:	b2db      	uxtb	r3, r3
    cb02:	2b00      	cmp	r3, #0
    cb04:	d02f      	beq.n	cb66 <fusb305_tcpc_set_vbus_level+0x222>
          || ((TYPEC_CC_VOLT_OPEN == state[Port].Registers.Status.u1.b1.CC2_STAT) 
    cb06:	4967      	ldr	r1, [pc, #412]	; (cca4 <fusb305_tcpc_set_vbus_level+0x360>)
    cb08:	687a      	ldr	r2, [r7, #4]
    cb0a:	2010      	movs	r0, #16
    cb0c:	0013      	movs	r3, r2
    cb0e:	015b      	lsls	r3, r3, #5
    cb10:	189b      	adds	r3, r3, r2
    cb12:	009b      	lsls	r3, r3, #2
    cb14:	18cb      	adds	r3, r1, r3
    cb16:	181b      	adds	r3, r3, r0
    cb18:	79db      	ldrb	r3, [r3, #7]
    cb1a:	071b      	lsls	r3, r3, #28
    cb1c:	0f9b      	lsrs	r3, r3, #30
    cb1e:	b2db      	uxtb	r3, r3
    cb20:	2b00      	cmp	r3, #0
    cb22:	d10e      	bne.n	cb42 <fusb305_tcpc_set_vbus_level+0x1fe>
              && (state[Port].Registers.Control.s.u2.b2.PLUG_ORIENT == 1))
    cb24:	495f      	ldr	r1, [pc, #380]	; (cca4 <fusb305_tcpc_set_vbus_level+0x360>)
    cb26:	687a      	ldr	r2, [r7, #4]
    cb28:	2010      	movs	r0, #16
    cb2a:	0013      	movs	r3, r2
    cb2c:	015b      	lsls	r3, r3, #5
    cb2e:	189b      	adds	r3, r3, r2
    cb30:	009b      	lsls	r3, r3, #2
    cb32:	18cb      	adds	r3, r1, r3
    cb34:	181b      	adds	r3, r3, r0
    cb36:	78db      	ldrb	r3, [r3, #3]
    cb38:	07db      	lsls	r3, r3, #31
    cb3a:	0fdb      	lsrs	r3, r3, #31
    cb3c:	b2db      	uxtb	r3, r3
    cb3e:	2b01      	cmp	r3, #1
    cb40:	d011      	beq.n	cb66 <fusb305_tcpc_set_vbus_level+0x222>
        || ((state[Port].PowerRole == USBPD_PORTPOWERROLE_SNK) && (TimeoutSink > 250)))
    cb42:	4958      	ldr	r1, [pc, #352]	; (cca4 <fusb305_tcpc_set_vbus_level+0x360>)
    cb44:	687a      	ldr	r2, [r7, #4]
    cb46:	0013      	movs	r3, r2
    cb48:	015b      	lsls	r3, r3, #5
    cb4a:	189b      	adds	r3, r3, r2
    cb4c:	009b      	lsls	r3, r3, #2
    cb4e:	18cb      	adds	r3, r1, r3
    cb50:	3368      	adds	r3, #104	; 0x68
    cb52:	681b      	ldr	r3, [r3, #0]
    cb54:	2b00      	cmp	r3, #0
    cb56:	d000      	beq.n	cb5a <fusb305_tcpc_set_vbus_level+0x216>
    cb58:	e08f      	b.n	cc7a <fusb305_tcpc_set_vbus_level+0x336>
    cb5a:	230f      	movs	r3, #15
    cb5c:	18fb      	adds	r3, r7, r3
    cb5e:	781b      	ldrb	r3, [r3, #0]
    cb60:	2bfa      	cmp	r3, #250	; 0xfa
    cb62:	d800      	bhi.n	cb66 <fusb305_tcpc_set_vbus_level+0x222>
    cb64:	e089      	b.n	cc7a <fusb305_tcpc_set_vbus_level+0x336>
      {
        /* Disable SOURCE VBUS */
        state[Port].Registers.Command.u.COMMAND = TCPC_REG_COMMAND_DISABLE_SRC_VBUS;
    cb66:	494f      	ldr	r1, [pc, #316]	; (cca4 <fusb305_tcpc_set_vbus_level+0x360>)
    cb68:	687a      	ldr	r2, [r7, #4]
    cb6a:	0013      	movs	r3, r2
    cb6c:	015b      	lsls	r3, r3, #5
    cb6e:	189b      	adds	r3, r3, r2
    cb70:	009b      	lsls	r3, r3, #2
    cb72:	18cb      	adds	r3, r1, r3
    cb74:	331a      	adds	r3, #26
    cb76:	2266      	movs	r2, #102	; 0x66
    cb78:	701a      	strb	r2, [r3, #0]
        USBPD_TCPCI_WriteRegister(Port, TCPC_REG_COMMAND, &state[Port].Registers.Command.u.COMMAND, 1);
    cb7a:	687b      	ldr	r3, [r7, #4]
    cb7c:	b2d8      	uxtb	r0, r3
    cb7e:	687a      	ldr	r2, [r7, #4]
    cb80:	0013      	movs	r3, r2
    cb82:	015b      	lsls	r3, r3, #5
    cb84:	189b      	adds	r3, r3, r2
    cb86:	009b      	lsls	r3, r3, #2
    cb88:	3318      	adds	r3, #24
    cb8a:	001a      	movs	r2, r3
    cb8c:	4b45      	ldr	r3, [pc, #276]	; (cca4 <fusb305_tcpc_set_vbus_level+0x360>)
    cb8e:	18d3      	adds	r3, r2, r3
    cb90:	1c9a      	adds	r2, r3, #2
    cb92:	2301      	movs	r3, #1
    cb94:	2123      	movs	r1, #35	; 0x23
    cb96:	f001 fa07 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
        /* Disable SINK VBUS */
        state[Port].Registers.Command.u.COMMAND = TCPC_REG_COMMAND_DISABLE_SINK_VBUS;
    cb9a:	4942      	ldr	r1, [pc, #264]	; (cca4 <fusb305_tcpc_set_vbus_level+0x360>)
    cb9c:	687a      	ldr	r2, [r7, #4]
    cb9e:	0013      	movs	r3, r2
    cba0:	015b      	lsls	r3, r3, #5
    cba2:	189b      	adds	r3, r3, r2
    cba4:	009b      	lsls	r3, r3, #2
    cba6:	18cb      	adds	r3, r1, r3
    cba8:	331a      	adds	r3, #26
    cbaa:	2244      	movs	r2, #68	; 0x44
    cbac:	701a      	strb	r2, [r3, #0]
        USBPD_TCPCI_WriteRegister(Port, TCPC_REG_COMMAND, &state[Port].Registers.Command.u.COMMAND, 1);
    cbae:	687b      	ldr	r3, [r7, #4]
    cbb0:	b2d8      	uxtb	r0, r3
    cbb2:	687a      	ldr	r2, [r7, #4]
    cbb4:	0013      	movs	r3, r2
    cbb6:	015b      	lsls	r3, r3, #5
    cbb8:	189b      	adds	r3, r3, r2
    cbba:	009b      	lsls	r3, r3, #2
    cbbc:	3318      	adds	r3, #24
    cbbe:	001a      	movs	r2, r3
    cbc0:	4b38      	ldr	r3, [pc, #224]	; (cca4 <fusb305_tcpc_set_vbus_level+0x360>)
    cbc2:	18d3      	adds	r3, r2, r3
    cbc4:	1c9a      	adds	r2, r3, #2
    cbc6:	2301      	movs	r3, #1
    cbc8:	2123      	movs	r1, #35	; 0x23
    cbca:	f001 f9ed 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
        
        /* Disable VCONN */
        state[Port].Registers.Control.s.u5.b5.EN_VCONN    = 0;
    cbce:	4935      	ldr	r1, [pc, #212]	; (cca4 <fusb305_tcpc_set_vbus_level+0x360>)
    cbd0:	687a      	ldr	r2, [r7, #4]
    cbd2:	2010      	movs	r0, #16
    cbd4:	0013      	movs	r3, r2
    cbd6:	015b      	lsls	r3, r3, #5
    cbd8:	189b      	adds	r3, r3, r2
    cbda:	009b      	lsls	r3, r3, #2
    cbdc:	18cb      	adds	r3, r1, r3
    cbde:	181b      	adds	r3, r3, r0
    cbe0:	799a      	ldrb	r2, [r3, #6]
    cbe2:	2101      	movs	r1, #1
    cbe4:	438a      	bics	r2, r1
    cbe6:	719a      	strb	r2, [r3, #6]
        state[Port].Registers.Control.s.u5.b5.AUTO_DISCH  = 0;
    cbe8:	492e      	ldr	r1, [pc, #184]	; (cca4 <fusb305_tcpc_set_vbus_level+0x360>)
    cbea:	687a      	ldr	r2, [r7, #4]
    cbec:	2010      	movs	r0, #16
    cbee:	0013      	movs	r3, r2
    cbf0:	015b      	lsls	r3, r3, #5
    cbf2:	189b      	adds	r3, r3, r2
    cbf4:	009b      	lsls	r3, r3, #2
    cbf6:	18cb      	adds	r3, r1, r3
    cbf8:	181b      	adds	r3, r3, r0
    cbfa:	799a      	ldrb	r2, [r3, #6]
    cbfc:	2110      	movs	r1, #16
    cbfe:	438a      	bics	r2, r1
    cc00:	719a      	strb	r2, [r3, #6]
        state[Port].Registers.Control.s.u5.b5.DIS_VALRM   = 1;
    cc02:	4928      	ldr	r1, [pc, #160]	; (cca4 <fusb305_tcpc_set_vbus_level+0x360>)
    cc04:	687a      	ldr	r2, [r7, #4]
    cc06:	2010      	movs	r0, #16
    cc08:	0013      	movs	r3, r2
    cc0a:	015b      	lsls	r3, r3, #5
    cc0c:	189b      	adds	r3, r3, r2
    cc0e:	009b      	lsls	r3, r3, #2
    cc10:	18cb      	adds	r3, r1, r3
    cc12:	181b      	adds	r3, r3, r0
    cc14:	799a      	ldrb	r2, [r3, #6]
    cc16:	2120      	movs	r1, #32
    cc18:	430a      	orrs	r2, r1
    cc1a:	719a      	strb	r2, [r3, #6]
        USBPD_TCPCI_WriteRegister(Port, TCPC_REG_POWER_CONTROL, &state[Port].Registers.Control.s.u5.POWER_CONTROL, 1);
    cc1c:	687b      	ldr	r3, [r7, #4]
    cc1e:	b2d8      	uxtb	r0, r3
    cc20:	687a      	ldr	r2, [r7, #4]
    cc22:	0013      	movs	r3, r2
    cc24:	015b      	lsls	r3, r3, #5
    cc26:	189b      	adds	r3, r3, r2
    cc28:	009b      	lsls	r3, r3, #2
    cc2a:	3310      	adds	r3, #16
    cc2c:	001a      	movs	r2, r3
    cc2e:	4b1d      	ldr	r3, [pc, #116]	; (cca4 <fusb305_tcpc_set_vbus_level+0x360>)
    cc30:	18d3      	adds	r3, r2, r3
    cc32:	1d9a      	adds	r2, r3, #6
    cc34:	2301      	movs	r3, #1
    cc36:	211c      	movs	r1, #28
    cc38:	f001 f9b6 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
        /* Disable BIST mode */
        state[Port].Registers.Control.s.u2.b2.BIST_TMODE = 0;
    cc3c:	4919      	ldr	r1, [pc, #100]	; (cca4 <fusb305_tcpc_set_vbus_level+0x360>)
    cc3e:	687a      	ldr	r2, [r7, #4]
    cc40:	2010      	movs	r0, #16
    cc42:	0013      	movs	r3, r2
    cc44:	015b      	lsls	r3, r3, #5
    cc46:	189b      	adds	r3, r3, r2
    cc48:	009b      	lsls	r3, r3, #2
    cc4a:	18cb      	adds	r3, r1, r3
    cc4c:	181b      	adds	r3, r3, r0
    cc4e:	78da      	ldrb	r2, [r3, #3]
    cc50:	2102      	movs	r1, #2
    cc52:	438a      	bics	r2, r1
    cc54:	70da      	strb	r2, [r3, #3]
        USBPD_TCPCI_WriteRegister(Port, TCPC_REG_TCPC_CONTROL, &state[Port].Registers.Control.s.u2.TCPC_CONTROL, 1);
    cc56:	687b      	ldr	r3, [r7, #4]
    cc58:	b2d8      	uxtb	r0, r3
    cc5a:	687a      	ldr	r2, [r7, #4]
    cc5c:	0013      	movs	r3, r2
    cc5e:	015b      	lsls	r3, r3, #5
    cc60:	189b      	adds	r3, r3, r2
    cc62:	009b      	lsls	r3, r3, #2
    cc64:	3310      	adds	r3, #16
    cc66:	001a      	movs	r2, r3
    cc68:	4b0e      	ldr	r3, [pc, #56]	; (cca4 <fusb305_tcpc_set_vbus_level+0x360>)
    cc6a:	18d3      	adds	r3, r2, r3
    cc6c:	1cda      	adds	r2, r3, #3
    cc6e:	2301      	movs	r3, #1
    cc70:	2119      	movs	r1, #25
    cc72:	f001 f999 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
        return USBPD_FAIL;
    cc76:	2310      	movs	r3, #16
    cc78:	e0f3      	b.n	ce62 <fusb305_tcpc_set_vbus_level+0x51e>
      }
      TimeoutSink++;
    cc7a:	210f      	movs	r1, #15
    cc7c:	187b      	adds	r3, r7, r1
    cc7e:	781a      	ldrb	r2, [r3, #0]
    cc80:	187b      	adds	r3, r7, r1
    cc82:	3201      	adds	r2, #1
    cc84:	701a      	strb	r2, [r3, #0]
      fusb305_tcpc_get_vbus_level(Port, &vbus_level, NULL);
    cc86:	230e      	movs	r3, #14
    cc88:	18f9      	adds	r1, r7, r3
    cc8a:	687b      	ldr	r3, [r7, #4]
    cc8c:	2200      	movs	r2, #0
    cc8e:	0018      	movs	r0, r3
    cc90:	f7ff fda8 	bl	c7e4 <fusb305_tcpc_get_vbus_level>
    while (vbus_level != 1)
    cc94:	230e      	movs	r3, #14
    cc96:	18fb      	adds	r3, r7, r3
    cc98:	781b      	ldrb	r3, [r3, #0]
    cc9a:	2b01      	cmp	r3, #1
    cc9c:	d000      	beq.n	cca0 <fusb305_tcpc_set_vbus_level+0x35c>
    cc9e:	e701      	b.n	caa4 <fusb305_tcpc_set_vbus_level+0x160>
    cca0:	e0de      	b.n	ce60 <fusb305_tcpc_set_vbus_level+0x51c>
    cca2:	46c0      	nop			; (mov r8, r8)
    cca4:	000300b8 	.word	0x000300b8
    }
  }
  else
  {
    uint16_t vbus_voltage = 0;
    cca8:	240c      	movs	r4, #12
    ccaa:	193b      	adds	r3, r7, r4
    ccac:	2200      	movs	r2, #0
    ccae:	801a      	strh	r2, [r3, #0]
    /* Enable Force discharge */
    state[Port].Registers.Control.s.u5.b5.AUTO_DISCH  = 0;
    ccb0:	496e      	ldr	r1, [pc, #440]	; (ce6c <fusb305_tcpc_set_vbus_level+0x528>)
    ccb2:	687a      	ldr	r2, [r7, #4]
    ccb4:	2010      	movs	r0, #16
    ccb6:	0013      	movs	r3, r2
    ccb8:	015b      	lsls	r3, r3, #5
    ccba:	189b      	adds	r3, r3, r2
    ccbc:	009b      	lsls	r3, r3, #2
    ccbe:	18cb      	adds	r3, r1, r3
    ccc0:	181b      	adds	r3, r3, r0
    ccc2:	799a      	ldrb	r2, [r3, #6]
    ccc4:	2110      	movs	r1, #16
    ccc6:	438a      	bics	r2, r1
    ccc8:	719a      	strb	r2, [r3, #6]
    state[Port].Registers.Control.s.u5.b5.FORCE_DISCH  = 1;
    ccca:	4968      	ldr	r1, [pc, #416]	; (ce6c <fusb305_tcpc_set_vbus_level+0x528>)
    cccc:	687a      	ldr	r2, [r7, #4]
    ccce:	2010      	movs	r0, #16
    ccd0:	0013      	movs	r3, r2
    ccd2:	015b      	lsls	r3, r3, #5
    ccd4:	189b      	adds	r3, r3, r2
    ccd6:	009b      	lsls	r3, r3, #2
    ccd8:	18cb      	adds	r3, r1, r3
    ccda:	181b      	adds	r3, r3, r0
    ccdc:	799a      	ldrb	r2, [r3, #6]
    ccde:	2104      	movs	r1, #4
    cce0:	430a      	orrs	r2, r1
    cce2:	719a      	strb	r2, [r3, #6]
    USBPD_TCPCI_WriteRegister(Port, TCPC_REG_POWER_CONTROL, &state[Port].Registers.Control.s.u5.POWER_CONTROL, 1);
    cce4:	687b      	ldr	r3, [r7, #4]
    cce6:	b2d8      	uxtb	r0, r3
    cce8:	687a      	ldr	r2, [r7, #4]
    ccea:	0013      	movs	r3, r2
    ccec:	015b      	lsls	r3, r3, #5
    ccee:	189b      	adds	r3, r3, r2
    ccf0:	009b      	lsls	r3, r3, #2
    ccf2:	3310      	adds	r3, #16
    ccf4:	001a      	movs	r2, r3
    ccf6:	4b5d      	ldr	r3, [pc, #372]	; (ce6c <fusb305_tcpc_set_vbus_level+0x528>)
    ccf8:	18d3      	adds	r3, r2, r3
    ccfa:	1d9a      	adds	r2, r3, #6
    ccfc:	2301      	movs	r3, #1
    ccfe:	211c      	movs	r1, #28
    cd00:	f001 f952 	bl	dfa8 <USBPD_TCPCI_WriteRegister>

    /* Disable SOURCE VBUS */
    state[Port].Registers.Command.u.COMMAND = TCPC_REG_COMMAND_DISABLE_SRC_VBUS;
    cd04:	4959      	ldr	r1, [pc, #356]	; (ce6c <fusb305_tcpc_set_vbus_level+0x528>)
    cd06:	687a      	ldr	r2, [r7, #4]
    cd08:	0013      	movs	r3, r2
    cd0a:	015b      	lsls	r3, r3, #5
    cd0c:	189b      	adds	r3, r3, r2
    cd0e:	009b      	lsls	r3, r3, #2
    cd10:	18cb      	adds	r3, r1, r3
    cd12:	331a      	adds	r3, #26
    cd14:	2266      	movs	r2, #102	; 0x66
    cd16:	701a      	strb	r2, [r3, #0]
    USBPD_TCPCI_WriteRegister(Port, TCPC_REG_COMMAND, &state[Port].Registers.Command.u.COMMAND, 1);
    cd18:	687b      	ldr	r3, [r7, #4]
    cd1a:	b2d8      	uxtb	r0, r3
    cd1c:	687a      	ldr	r2, [r7, #4]
    cd1e:	0013      	movs	r3, r2
    cd20:	015b      	lsls	r3, r3, #5
    cd22:	189b      	adds	r3, r3, r2
    cd24:	009b      	lsls	r3, r3, #2
    cd26:	3318      	adds	r3, #24
    cd28:	001a      	movs	r2, r3
    cd2a:	4b50      	ldr	r3, [pc, #320]	; (ce6c <fusb305_tcpc_set_vbus_level+0x528>)
    cd2c:	18d3      	adds	r3, r2, r3
    cd2e:	1c9a      	adds	r2, r3, #2
    cd30:	2301      	movs	r3, #1
    cd32:	2123      	movs	r1, #35	; 0x23
    cd34:	f001 f938 	bl	dfa8 <USBPD_TCPCI_WriteRegister>

    /* Disable SINK VBUS */
    state[Port].Registers.Command.u.COMMAND = TCPC_REG_COMMAND_DISABLE_SINK_VBUS;
    cd38:	494c      	ldr	r1, [pc, #304]	; (ce6c <fusb305_tcpc_set_vbus_level+0x528>)
    cd3a:	687a      	ldr	r2, [r7, #4]
    cd3c:	0013      	movs	r3, r2
    cd3e:	015b      	lsls	r3, r3, #5
    cd40:	189b      	adds	r3, r3, r2
    cd42:	009b      	lsls	r3, r3, #2
    cd44:	18cb      	adds	r3, r1, r3
    cd46:	331a      	adds	r3, #26
    cd48:	2244      	movs	r2, #68	; 0x44
    cd4a:	701a      	strb	r2, [r3, #0]
    USBPD_TCPCI_WriteRegister(Port, TCPC_REG_COMMAND, &state[Port].Registers.Command.u.COMMAND, 1);
    cd4c:	687b      	ldr	r3, [r7, #4]
    cd4e:	b2d8      	uxtb	r0, r3
    cd50:	687a      	ldr	r2, [r7, #4]
    cd52:	0013      	movs	r3, r2
    cd54:	015b      	lsls	r3, r3, #5
    cd56:	189b      	adds	r3, r3, r2
    cd58:	009b      	lsls	r3, r3, #2
    cd5a:	3318      	adds	r3, #24
    cd5c:	001a      	movs	r2, r3
    cd5e:	4b43      	ldr	r3, [pc, #268]	; (ce6c <fusb305_tcpc_set_vbus_level+0x528>)
    cd60:	18d3      	adds	r3, r2, r3
    cd62:	1c9a      	adds	r2, r3, #2
    cd64:	2301      	movs	r3, #1
    cd66:	2123      	movs	r1, #35	; 0x23
    cd68:	f001 f91e 	bl	dfa8 <USBPD_TCPCI_WriteRegister>

    /* Wait for VBUS ready */
    fusb305_tcpc_get_vbus_level(Port, &vbus_level, &vbus_voltage);
    cd6c:	193a      	adds	r2, r7, r4
    cd6e:	230e      	movs	r3, #14
    cd70:	18f9      	adds	r1, r7, r3
    cd72:	687b      	ldr	r3, [r7, #4]
    cd74:	0018      	movs	r0, r3
    cd76:	f7ff fd35 	bl	c7e4 <fusb305_tcpc_get_vbus_level>
    while ((vbus_level != 0) || (vbus_voltage > PWR_LOW_VBUS_THRESHOLD)) {
    cd7a:	e03b      	b.n	cdf4 <fusb305_tcpc_set_vbus_level+0x4b0>
      /* Disable SOURCE VBUS */
      state[Port].Registers.Command.u.COMMAND = TCPC_REG_COMMAND_DISABLE_SRC_VBUS;
    cd7c:	493b      	ldr	r1, [pc, #236]	; (ce6c <fusb305_tcpc_set_vbus_level+0x528>)
    cd7e:	687a      	ldr	r2, [r7, #4]
    cd80:	0013      	movs	r3, r2
    cd82:	015b      	lsls	r3, r3, #5
    cd84:	189b      	adds	r3, r3, r2
    cd86:	009b      	lsls	r3, r3, #2
    cd88:	18cb      	adds	r3, r1, r3
    cd8a:	331a      	adds	r3, #26
    cd8c:	2266      	movs	r2, #102	; 0x66
    cd8e:	701a      	strb	r2, [r3, #0]
      USBPD_TCPCI_WriteRegister(Port, TCPC_REG_COMMAND, &state[Port].Registers.Command.u.COMMAND, 1);
    cd90:	687b      	ldr	r3, [r7, #4]
    cd92:	b2d8      	uxtb	r0, r3
    cd94:	687a      	ldr	r2, [r7, #4]
    cd96:	0013      	movs	r3, r2
    cd98:	015b      	lsls	r3, r3, #5
    cd9a:	189b      	adds	r3, r3, r2
    cd9c:	009b      	lsls	r3, r3, #2
    cd9e:	3318      	adds	r3, #24
    cda0:	001a      	movs	r2, r3
    cda2:	4b32      	ldr	r3, [pc, #200]	; (ce6c <fusb305_tcpc_set_vbus_level+0x528>)
    cda4:	18d3      	adds	r3, r2, r3
    cda6:	1c9a      	adds	r2, r3, #2
    cda8:	2301      	movs	r3, #1
    cdaa:	2123      	movs	r1, #35	; 0x23
    cdac:	f001 f8fc 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
      /* Disable SINK VBUS */
      state[Port].Registers.Command.u.COMMAND = TCPC_REG_COMMAND_DISABLE_SINK_VBUS;
    cdb0:	492e      	ldr	r1, [pc, #184]	; (ce6c <fusb305_tcpc_set_vbus_level+0x528>)
    cdb2:	687a      	ldr	r2, [r7, #4]
    cdb4:	0013      	movs	r3, r2
    cdb6:	015b      	lsls	r3, r3, #5
    cdb8:	189b      	adds	r3, r3, r2
    cdba:	009b      	lsls	r3, r3, #2
    cdbc:	18cb      	adds	r3, r1, r3
    cdbe:	331a      	adds	r3, #26
    cdc0:	2244      	movs	r2, #68	; 0x44
    cdc2:	701a      	strb	r2, [r3, #0]
      USBPD_TCPCI_WriteRegister(Port, TCPC_REG_COMMAND, &state[Port].Registers.Command.u.COMMAND, 1);
    cdc4:	687b      	ldr	r3, [r7, #4]
    cdc6:	b2d8      	uxtb	r0, r3
    cdc8:	687a      	ldr	r2, [r7, #4]
    cdca:	0013      	movs	r3, r2
    cdcc:	015b      	lsls	r3, r3, #5
    cdce:	189b      	adds	r3, r3, r2
    cdd0:	009b      	lsls	r3, r3, #2
    cdd2:	3318      	adds	r3, #24
    cdd4:	001a      	movs	r2, r3
    cdd6:	4b25      	ldr	r3, [pc, #148]	; (ce6c <fusb305_tcpc_set_vbus_level+0x528>)
    cdd8:	18d3      	adds	r3, r2, r3
    cdda:	1c9a      	adds	r2, r3, #2
    cddc:	2301      	movs	r3, #1
    cdde:	2123      	movs	r1, #35	; 0x23
    cde0:	f001 f8e2 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
      fusb305_tcpc_get_vbus_level(Port, &vbus_level, &vbus_voltage);
    cde4:	230c      	movs	r3, #12
    cde6:	18fa      	adds	r2, r7, r3
    cde8:	230e      	movs	r3, #14
    cdea:	18f9      	adds	r1, r7, r3
    cdec:	687b      	ldr	r3, [r7, #4]
    cdee:	0018      	movs	r0, r3
    cdf0:	f7ff fcf8 	bl	c7e4 <fusb305_tcpc_get_vbus_level>
    while ((vbus_level != 0) || (vbus_voltage > PWR_LOW_VBUS_THRESHOLD)) {
    cdf4:	230e      	movs	r3, #14
    cdf6:	18fb      	adds	r3, r7, r3
    cdf8:	781b      	ldrb	r3, [r3, #0]
    cdfa:	2b00      	cmp	r3, #0
    cdfc:	d1be      	bne.n	cd7c <fusb305_tcpc_set_vbus_level+0x438>
    cdfe:	230c      	movs	r3, #12
    ce00:	18fb      	adds	r3, r7, r3
    ce02:	881a      	ldrh	r2, [r3, #0]
    ce04:	23af      	movs	r3, #175	; 0xaf
    ce06:	009b      	lsls	r3, r3, #2
    ce08:	429a      	cmp	r2, r3
    ce0a:	d8b7      	bhi.n	cd7c <fusb305_tcpc_set_vbus_level+0x438>
    };

    state[Port].Registers.Control.s.u5.b5.FORCE_DISCH    = 0;
    ce0c:	4917      	ldr	r1, [pc, #92]	; (ce6c <fusb305_tcpc_set_vbus_level+0x528>)
    ce0e:	687a      	ldr	r2, [r7, #4]
    ce10:	2010      	movs	r0, #16
    ce12:	0013      	movs	r3, r2
    ce14:	015b      	lsls	r3, r3, #5
    ce16:	189b      	adds	r3, r3, r2
    ce18:	009b      	lsls	r3, r3, #2
    ce1a:	18cb      	adds	r3, r1, r3
    ce1c:	181b      	adds	r3, r3, r0
    ce1e:	799a      	ldrb	r2, [r3, #6]
    ce20:	2104      	movs	r1, #4
    ce22:	438a      	bics	r2, r1
    ce24:	719a      	strb	r2, [r3, #6]
    state[Port].Registers.Control.s.u5.b5.DIS_VALRM      = 1;
    ce26:	4911      	ldr	r1, [pc, #68]	; (ce6c <fusb305_tcpc_set_vbus_level+0x528>)
    ce28:	687a      	ldr	r2, [r7, #4]
    ce2a:	2010      	movs	r0, #16
    ce2c:	0013      	movs	r3, r2
    ce2e:	015b      	lsls	r3, r3, #5
    ce30:	189b      	adds	r3, r3, r2
    ce32:	009b      	lsls	r3, r3, #2
    ce34:	18cb      	adds	r3, r1, r3
    ce36:	181b      	adds	r3, r3, r0
    ce38:	799a      	ldrb	r2, [r3, #6]
    ce3a:	2120      	movs	r1, #32
    ce3c:	430a      	orrs	r2, r1
    ce3e:	719a      	strb	r2, [r3, #6]
    USBPD_TCPCI_WriteRegister(Port, TCPC_REG_POWER_CONTROL, &state[Port].Registers.Control.s.u5.POWER_CONTROL, 1);
    ce40:	687b      	ldr	r3, [r7, #4]
    ce42:	b2d8      	uxtb	r0, r3
    ce44:	687a      	ldr	r2, [r7, #4]
    ce46:	0013      	movs	r3, r2
    ce48:	015b      	lsls	r3, r3, #5
    ce4a:	189b      	adds	r3, r3, r2
    ce4c:	009b      	lsls	r3, r3, #2
    ce4e:	3310      	adds	r3, #16
    ce50:	001a      	movs	r2, r3
    ce52:	4b06      	ldr	r3, [pc, #24]	; (ce6c <fusb305_tcpc_set_vbus_level+0x528>)
    ce54:	18d3      	adds	r3, r2, r3
    ce56:	1d9a      	adds	r2, r3, #6
    ce58:	2301      	movs	r3, #1
    ce5a:	211c      	movs	r1, #28
    ce5c:	f001 f8a4 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
  }

  return USBPD_OK;
    ce60:	2300      	movs	r3, #0
}
    ce62:	0018      	movs	r0, r3
    ce64:	46bd      	mov	sp, r7
    ce66:	b005      	add	sp, #20
    ce68:	bd90      	pop	{r4, r7, pc}
    ce6a:	46c0      	nop			; (mov r8, r8)
    ce6c:	000300b8 	.word	0x000300b8

0000ce70 <tcpc_set_power>:
  * @param  State       Enable or disable VBUS level
  * @param  HardReset   Hard reset status based on @ref TCPC_hard_reset
  * @retval USBPD status
  */
static USBPD_StatusTypeDef tcpc_set_power(uint32_t Port, USBPD_FunctionalState State, TCPC_hard_reset HardReset)
{
    ce70:	b590      	push	{r4, r7, lr}
    ce72:	b08b      	sub	sp, #44	; 0x2c
    ce74:	af00      	add	r7, sp, #0
    ce76:	6078      	str	r0, [r7, #4]
    ce78:	0008      	movs	r0, r1
    ce7a:	0011      	movs	r1, r2
    ce7c:	1cfb      	adds	r3, r7, #3
    ce7e:	1c02      	adds	r2, r0, #0
    ce80:	701a      	strb	r2, [r3, #0]
    ce82:	1cbb      	adds	r3, r7, #2
    ce84:	1c0a      	adds	r2, r1, #0
    ce86:	701a      	strb	r2, [r3, #0]
  uint8_t vbus_level = 0;
    ce88:	231b      	movs	r3, #27
    ce8a:	18fb      	adds	r3, r7, r3
    ce8c:	2200      	movs	r2, #0
    ce8e:	701a      	strb	r2, [r3, #0]

  state[Port].Registers.Control.s.u5.POWER_CONTROL = 0;
    ce90:	498b      	ldr	r1, [pc, #556]	; (d0c0 <tcpc_set_power+0x250>)
    ce92:	687a      	ldr	r2, [r7, #4]
    ce94:	0013      	movs	r3, r2
    ce96:	015b      	lsls	r3, r3, #5
    ce98:	189b      	adds	r3, r3, r2
    ce9a:	009b      	lsls	r3, r3, #2
    ce9c:	18cb      	adds	r3, r1, r3
    ce9e:	3316      	adds	r3, #22
    cea0:	2200      	movs	r2, #0
    cea2:	701a      	strb	r2, [r3, #0]
  if (USBPD_ENABLE == State)
    cea4:	1cfb      	adds	r3, r7, #3
    cea6:	781b      	ldrb	r3, [r3, #0]
    cea8:	2b01      	cmp	r3, #1
    ceaa:	d000      	beq.n	ceae <tcpc_set_power+0x3e>
    ceac:	e24e      	b.n	d34c <tcpc_set_power+0x4dc>
  {
    uint16_t TimeoutSink = 0;
    ceae:	2326      	movs	r3, #38	; 0x26
    ceb0:	18fb      	adds	r3, r7, r3
    ceb2:	2200      	movs	r2, #0
    ceb4:	801a      	strh	r2, [r3, #0]

    if (state[Port].PowerRole == USBPD_PORTPOWERROLE_SRC)
    ceb6:	4982      	ldr	r1, [pc, #520]	; (d0c0 <tcpc_set_power+0x250>)
    ceb8:	687a      	ldr	r2, [r7, #4]
    ceba:	0013      	movs	r3, r2
    cebc:	015b      	lsls	r3, r3, #5
    cebe:	189b      	adds	r3, r3, r2
    cec0:	009b      	lsls	r3, r3, #2
    cec2:	18cb      	adds	r3, r1, r3
    cec4:	3368      	adds	r3, #104	; 0x68
    cec6:	681b      	ldr	r3, [r3, #0]
    cec8:	2b01      	cmp	r3, #1
    ceca:	d000      	beq.n	cece <tcpc_set_power+0x5e>
    cecc:	e0bb      	b.n	d046 <tcpc_set_power+0x1d6>
    {
      /* Function can be called after sending a hard reset.
         We should not wait for VSafe0V).*/
      if (TCPC_HARD_RESET_NONE == HardReset)
    cece:	1cbb      	adds	r3, r7, #2
    ced0:	781b      	ldrb	r3, [r3, #0]
    ced2:	2b00      	cmp	r3, #0
    ced4:	d14c      	bne.n	cf70 <tcpc_set_power+0x100>
      {
        /* In case of Ellisys test 4.5.4, VBUS is still high.
           Should wait for VSafe0V. */
        uint16_t vbus_voltage = 0;
    ced6:	2118      	movs	r1, #24
    ced8:	187b      	adds	r3, r7, r1
    ceda:	2200      	movs	r2, #0
    cedc:	801a      	strh	r2, [r3, #0]
        /* Wait for VBUS ready */
        fusb305_tcpc_get_vbus_level(Port, &vbus_level, &vbus_voltage);
    cede:	187a      	adds	r2, r7, r1
    cee0:	231b      	movs	r3, #27
    cee2:	18f9      	adds	r1, r7, r3
    cee4:	687b      	ldr	r3, [r7, #4]
    cee6:	0018      	movs	r0, r3
    cee8:	f7ff fc7c 	bl	c7e4 <fusb305_tcpc_get_vbus_level>
        while (vbus_voltage > PWR_LOW_VBUS_THRESHOLD)
    ceec:	e007      	b.n	cefe <tcpc_set_power+0x8e>
        {
          fusb305_tcpc_get_vbus_level(Port, &vbus_level, &vbus_voltage);
    ceee:	2318      	movs	r3, #24
    cef0:	18fa      	adds	r2, r7, r3
    cef2:	231b      	movs	r3, #27
    cef4:	18f9      	adds	r1, r7, r3
    cef6:	687b      	ldr	r3, [r7, #4]
    cef8:	0018      	movs	r0, r3
    cefa:	f7ff fc73 	bl	c7e4 <fusb305_tcpc_get_vbus_level>
        while (vbus_voltage > PWR_LOW_VBUS_THRESHOLD)
    cefe:	2318      	movs	r3, #24
    cf00:	18fb      	adds	r3, r7, r3
    cf02:	881a      	ldrh	r2, [r3, #0]
    cf04:	23af      	movs	r3, #175	; 0xaf
    cf06:	009b      	lsls	r3, r3, #2
    cf08:	429a      	cmp	r2, r3
    cf0a:	d8f0      	bhi.n	ceee <tcpc_set_power+0x7e>
        }
#if defined(_RTOS)
        extern uint32_t          HAL_GetTick(void);
        uint32_t CAD_tVBUSDebounce_start, CAD_tVBUSDebounce;
        /* Get the time of this event */
        CAD_tVBUSDebounce_start = HAL_GetTick();
    cf0c:	f001 fb5a 	bl	e5c4 <HAL_GetTick>
    cf10:	0003      	movs	r3, r0
    cf12:	61fb      	str	r3, [r7, #28]
        /* Evaluate elapsed time in Attach_Wait state */
        CAD_tVBUSDebounce = HAL_GetTick() - CAD_tVBUSDebounce_start;
    cf14:	f001 fb56 	bl	e5c4 <HAL_GetTick>
    cf18:	0002      	movs	r2, r0
    cf1a:	69fb      	ldr	r3, [r7, #28]
    cf1c:	1ad3      	subs	r3, r2, r3
    cf1e:	623b      	str	r3, [r7, #32]
        /* Check tCCDebounce */
        while (CAD_tVBUSDebounce < CAD_tVBUSDebounce_threshold)
    cf20:	e023      	b.n	cf6a <tcpc_set_power+0xfa>
        {
          CAD_tVBUSDebounce = HAL_GetTick() - CAD_tVBUSDebounce_start;
    cf22:	f001 fb4f 	bl	e5c4 <HAL_GetTick>
    cf26:	0002      	movs	r2, r0
    cf28:	69fb      	ldr	r3, [r7, #28]
    cf2a:	1ad3      	subs	r3, r2, r3
    cf2c:	623b      	str	r3, [r7, #32]
          /* Check tCCDebounce */
          while (USBPD_TIM_IsExpired((Port == USBPD_PORT_0 ? TIM_PORT0_TIMER1 : TIM_PORT1_TIMER1)) == 0)
          {
#endif /* _RTOS */
            /* Need to check that line is still connected */
            uint32_t cc1 = 0xFF, cc2 = 0xFF;
    cf2e:	23ff      	movs	r3, #255	; 0xff
    cf30:	617b      	str	r3, [r7, #20]
    cf32:	23ff      	movs	r3, #255	; 0xff
    cf34:	613b      	str	r3, [r7, #16]
            if (USBPD_BUSY == fusb305_tcpc_get_cc(Port, &cc1, &cc2))
    cf36:	2310      	movs	r3, #16
    cf38:	18fa      	adds	r2, r7, r3
    cf3a:	2314      	movs	r3, #20
    cf3c:	18f9      	adds	r1, r7, r3
    cf3e:	687b      	ldr	r3, [r7, #4]
    cf40:	0018      	movs	r0, r3
    cf42:	f7fe fc45 	bl	b7d0 <fusb305_tcpc_get_cc>
    cf46:	0003      	movs	r3, r0
    cf48:	2b03      	cmp	r3, #3
    cf4a:	d101      	bne.n	cf50 <tcpc_set_power+0xe0>
            {
              /* Line has been disconnected */
              return USBPD_FAIL;
    cf4c:	2310      	movs	r3, #16
    cf4e:	e2bf      	b.n	d4d0 <tcpc_set_power+0x660>
            }
            
            if (CCNONE == state[Port].CC_Pin)
    cf50:	495b      	ldr	r1, [pc, #364]	; (d0c0 <tcpc_set_power+0x250>)
    cf52:	687a      	ldr	r2, [r7, #4]
    cf54:	0013      	movs	r3, r2
    cf56:	015b      	lsls	r3, r3, #5
    cf58:	189b      	adds	r3, r3, r2
    cf5a:	009b      	lsls	r3, r3, #2
    cf5c:	18cb      	adds	r3, r1, r3
    cf5e:	337c      	adds	r3, #124	; 0x7c
    cf60:	681b      	ldr	r3, [r3, #0]
    cf62:	2b00      	cmp	r3, #0
    cf64:	d101      	bne.n	cf6a <tcpc_set_power+0xfa>
            {
              /* Line has been disconnected */
              return USBPD_FAIL;
    cf66:	2310      	movs	r3, #16
    cf68:	e2b2      	b.n	d4d0 <tcpc_set_power+0x660>
        while (CAD_tVBUSDebounce < CAD_tVBUSDebounce_threshold)
    cf6a:	6a3b      	ldr	r3, [r7, #32]
    cf6c:	2b77      	cmp	r3, #119	; 0x77
    cf6e:	d9d8      	bls.n	cf22 <tcpc_set_power+0xb2>
            }
          }
        }

      /* Enable VCONN */
      if (TYPEC_CC_RA == state[Port].VConnPresence) state[Port].Registers.Control.s.u5.b5.EN_VCONN    = 1;
    cf70:	4953      	ldr	r1, [pc, #332]	; (d0c0 <tcpc_set_power+0x250>)
    cf72:	687a      	ldr	r2, [r7, #4]
    cf74:	2073      	movs	r0, #115	; 0x73
    cf76:	0013      	movs	r3, r2
    cf78:	015b      	lsls	r3, r3, #5
    cf7a:	189b      	adds	r3, r3, r2
    cf7c:	009b      	lsls	r3, r3, #2
    cf7e:	18cb      	adds	r3, r1, r3
    cf80:	181b      	adds	r3, r3, r0
    cf82:	781b      	ldrb	r3, [r3, #0]
    cf84:	2b00      	cmp	r3, #0
    cf86:	d10c      	bne.n	cfa2 <tcpc_set_power+0x132>
    cf88:	494d      	ldr	r1, [pc, #308]	; (d0c0 <tcpc_set_power+0x250>)
    cf8a:	687a      	ldr	r2, [r7, #4]
    cf8c:	2010      	movs	r0, #16
    cf8e:	0013      	movs	r3, r2
    cf90:	015b      	lsls	r3, r3, #5
    cf92:	189b      	adds	r3, r3, r2
    cf94:	009b      	lsls	r3, r3, #2
    cf96:	18cb      	adds	r3, r1, r3
    cf98:	181b      	adds	r3, r3, r0
    cf9a:	799a      	ldrb	r2, [r3, #6]
    cf9c:	2101      	movs	r1, #1
    cf9e:	430a      	orrs	r2, r1
    cfa0:	719a      	strb	r2, [r3, #6]
      state[Port].Registers.Control.s.u5.b5.AUTO_DISCH  = 1;
    cfa2:	4947      	ldr	r1, [pc, #284]	; (d0c0 <tcpc_set_power+0x250>)
    cfa4:	687a      	ldr	r2, [r7, #4]
    cfa6:	2010      	movs	r0, #16
    cfa8:	0013      	movs	r3, r2
    cfaa:	015b      	lsls	r3, r3, #5
    cfac:	189b      	adds	r3, r3, r2
    cfae:	009b      	lsls	r3, r3, #2
    cfb0:	18cb      	adds	r3, r1, r3
    cfb2:	181b      	adds	r3, r3, r0
    cfb4:	799a      	ldrb	r2, [r3, #6]
    cfb6:	2110      	movs	r1, #16
    cfb8:	430a      	orrs	r2, r1
    cfba:	719a      	strb	r2, [r3, #6]
      USBPD_TCPCI_WriteRegister(Port, TCPC_REG_POWER_CONTROL, &state[Port].Registers.Control.s.u5.POWER_CONTROL, 1);
    cfbc:	687b      	ldr	r3, [r7, #4]
    cfbe:	b2d8      	uxtb	r0, r3
    cfc0:	687a      	ldr	r2, [r7, #4]
    cfc2:	0013      	movs	r3, r2
    cfc4:	015b      	lsls	r3, r3, #5
    cfc6:	189b      	adds	r3, r3, r2
    cfc8:	009b      	lsls	r3, r3, #2
    cfca:	3310      	adds	r3, #16
    cfcc:	001a      	movs	r2, r3
    cfce:	4b3c      	ldr	r3, [pc, #240]	; (d0c0 <tcpc_set_power+0x250>)
    cfd0:	18d3      	adds	r3, r2, r3
    cfd2:	1d9a      	adds	r2, r3, #6
    cfd4:	2301      	movs	r3, #1
    cfd6:	211c      	movs	r1, #28
    cfd8:	f000 ffe6 	bl	dfa8 <USBPD_TCPCI_WriteRegister>

      /* Disable SINK VBUS */
      state[Port].Registers.Command.u.COMMAND = TCPC_REG_COMMAND_DISABLE_SINK_VBUS;
    cfdc:	4938      	ldr	r1, [pc, #224]	; (d0c0 <tcpc_set_power+0x250>)
    cfde:	687a      	ldr	r2, [r7, #4]
    cfe0:	0013      	movs	r3, r2
    cfe2:	015b      	lsls	r3, r3, #5
    cfe4:	189b      	adds	r3, r3, r2
    cfe6:	009b      	lsls	r3, r3, #2
    cfe8:	18cb      	adds	r3, r1, r3
    cfea:	331a      	adds	r3, #26
    cfec:	2244      	movs	r2, #68	; 0x44
    cfee:	701a      	strb	r2, [r3, #0]
      USBPD_TCPCI_WriteRegister(Port, TCPC_REG_COMMAND, &state[Port].Registers.Command.u.COMMAND, 1);
    cff0:	687b      	ldr	r3, [r7, #4]
    cff2:	b2d8      	uxtb	r0, r3
    cff4:	687a      	ldr	r2, [r7, #4]
    cff6:	0013      	movs	r3, r2
    cff8:	015b      	lsls	r3, r3, #5
    cffa:	189b      	adds	r3, r3, r2
    cffc:	009b      	lsls	r3, r3, #2
    cffe:	3318      	adds	r3, #24
    d000:	001a      	movs	r2, r3
    d002:	4b2f      	ldr	r3, [pc, #188]	; (d0c0 <tcpc_set_power+0x250>)
    d004:	18d3      	adds	r3, r2, r3
    d006:	1c9a      	adds	r2, r3, #2
    d008:	2301      	movs	r3, #1
    d00a:	2123      	movs	r1, #35	; 0x23
    d00c:	f000 ffcc 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
      /* Enable SOURCE VBUS */
      state[Port].Registers.Command.u.COMMAND = TCPC_REG_COMMAND_SRC_VBUS_DEFAULT;
    d010:	492b      	ldr	r1, [pc, #172]	; (d0c0 <tcpc_set_power+0x250>)
    d012:	687a      	ldr	r2, [r7, #4]
    d014:	0013      	movs	r3, r2
    d016:	015b      	lsls	r3, r3, #5
    d018:	189b      	adds	r3, r3, r2
    d01a:	009b      	lsls	r3, r3, #2
    d01c:	18cb      	adds	r3, r1, r3
    d01e:	331a      	adds	r3, #26
    d020:	2277      	movs	r2, #119	; 0x77
    d022:	701a      	strb	r2, [r3, #0]
      USBPD_TCPCI_WriteRegister(Port, TCPC_REG_COMMAND, &state[Port].Registers.Command.u.COMMAND, 1);
    d024:	687b      	ldr	r3, [r7, #4]
    d026:	b2d8      	uxtb	r0, r3
    d028:	687a      	ldr	r2, [r7, #4]
    d02a:	0013      	movs	r3, r2
    d02c:	015b      	lsls	r3, r3, #5
    d02e:	189b      	adds	r3, r3, r2
    d030:	009b      	lsls	r3, r3, #2
    d032:	3318      	adds	r3, #24
    d034:	001a      	movs	r2, r3
    d036:	4b22      	ldr	r3, [pc, #136]	; (d0c0 <tcpc_set_power+0x250>)
    d038:	18d3      	adds	r3, r2, r3
    d03a:	1c9a      	adds	r2, r3, #2
    d03c:	2301      	movs	r3, #1
    d03e:	2123      	movs	r1, #35	; 0x23
    d040:	f000 ffb2 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
    d044:	e033      	b.n	d0ae <tcpc_set_power+0x23e>
    }
    else
    {
      /* Disable SOURCE VBUS */
      state[Port].Registers.Command.u.COMMAND = TCPC_REG_COMMAND_DISABLE_SRC_VBUS;
    d046:	491e      	ldr	r1, [pc, #120]	; (d0c0 <tcpc_set_power+0x250>)
    d048:	687a      	ldr	r2, [r7, #4]
    d04a:	0013      	movs	r3, r2
    d04c:	015b      	lsls	r3, r3, #5
    d04e:	189b      	adds	r3, r3, r2
    d050:	009b      	lsls	r3, r3, #2
    d052:	18cb      	adds	r3, r1, r3
    d054:	331a      	adds	r3, #26
    d056:	2266      	movs	r2, #102	; 0x66
    d058:	701a      	strb	r2, [r3, #0]
      USBPD_TCPCI_WriteRegister(Port, TCPC_REG_COMMAND, &state[Port].Registers.Command.u.COMMAND, 1);
    d05a:	687b      	ldr	r3, [r7, #4]
    d05c:	b2d8      	uxtb	r0, r3
    d05e:	687a      	ldr	r2, [r7, #4]
    d060:	0013      	movs	r3, r2
    d062:	015b      	lsls	r3, r3, #5
    d064:	189b      	adds	r3, r3, r2
    d066:	009b      	lsls	r3, r3, #2
    d068:	3318      	adds	r3, #24
    d06a:	001a      	movs	r2, r3
    d06c:	4b14      	ldr	r3, [pc, #80]	; (d0c0 <tcpc_set_power+0x250>)
    d06e:	18d3      	adds	r3, r2, r3
    d070:	1c9a      	adds	r2, r3, #2
    d072:	2301      	movs	r3, #1
    d074:	2123      	movs	r1, #35	; 0x23
    d076:	f000 ff97 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
      /* Enable SINK VBUS */
      state[Port].Registers.Command.u.COMMAND = TCPC_REG_COMMAND_ENABLE_SINK_VBUS;
    d07a:	4911      	ldr	r1, [pc, #68]	; (d0c0 <tcpc_set_power+0x250>)
    d07c:	687a      	ldr	r2, [r7, #4]
    d07e:	0013      	movs	r3, r2
    d080:	015b      	lsls	r3, r3, #5
    d082:	189b      	adds	r3, r3, r2
    d084:	009b      	lsls	r3, r3, #2
    d086:	18cb      	adds	r3, r1, r3
    d088:	331a      	adds	r3, #26
    d08a:	2255      	movs	r2, #85	; 0x55
    d08c:	701a      	strb	r2, [r3, #0]
      USBPD_TCPCI_WriteRegister(Port, TCPC_REG_COMMAND, &state[Port].Registers.Command.u.COMMAND, 1);
    d08e:	687b      	ldr	r3, [r7, #4]
    d090:	b2d8      	uxtb	r0, r3
    d092:	687a      	ldr	r2, [r7, #4]
    d094:	0013      	movs	r3, r2
    d096:	015b      	lsls	r3, r3, #5
    d098:	189b      	adds	r3, r3, r2
    d09a:	009b      	lsls	r3, r3, #2
    d09c:	3318      	adds	r3, #24
    d09e:	001a      	movs	r2, r3
    d0a0:	4b07      	ldr	r3, [pc, #28]	; (d0c0 <tcpc_set_power+0x250>)
    d0a2:	18d3      	adds	r3, r2, r3
    d0a4:	1c9a      	adds	r2, r3, #2
    d0a6:	2301      	movs	r3, #1
    d0a8:	2123      	movs	r1, #35	; 0x23
    d0aa:	f000 ff7d 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
    }

    /* Wait for VBUS ready */
    fusb305_tcpc_get_vbus_level(Port, &vbus_level, NULL);
    d0ae:	231b      	movs	r3, #27
    d0b0:	18f9      	adds	r1, r7, r3
    d0b2:	687b      	ldr	r3, [r7, #4]
    d0b4:	2200      	movs	r2, #0
    d0b6:	0018      	movs	r0, r3
    d0b8:	f7ff fb94 	bl	c7e4 <fusb305_tcpc_get_vbus_level>
    while (vbus_level != 1)
    d0bc:	e0fa      	b.n	d2b4 <tcpc_set_power+0x444>
    d0be:	46c0      	nop			; (mov r8, r8)
    d0c0:	000300b8 	.word	0x000300b8
    {
      /* Add a delay for CC debounce */
      USBPD_TCPCI_Delay(4);
    d0c4:	2004      	movs	r0, #4
    d0c6:	f001 f8fb 	bl	e2c0 <USBPD_TCPCI_Delay>

      USBPD_TCPCI_ReadRegister(Port, TCPC_REG_CC_STATUS, (uint8_t*)&state[Port].Registers.Status.u1.CC_STATUS, 1);
    d0ca:	687b      	ldr	r3, [r7, #4]
    d0cc:	b2d8      	uxtb	r0, r3
    d0ce:	687a      	ldr	r2, [r7, #4]
    d0d0:	0013      	movs	r3, r2
    d0d2:	015b      	lsls	r3, r3, #5
    d0d4:	189b      	adds	r3, r3, r2
    d0d6:	009b      	lsls	r3, r3, #2
    d0d8:	3310      	adds	r3, #16
    d0da:	001a      	movs	r2, r3
    d0dc:	4bbb      	ldr	r3, [pc, #748]	; (d3cc <tcpc_set_power+0x55c>)
    d0de:	18d3      	adds	r3, r2, r3
    d0e0:	1dda      	adds	r2, r3, #7
    d0e2:	2301      	movs	r3, #1
    d0e4:	211d      	movs	r1, #29
    d0e6:	f001 f8a1 	bl	e22c <USBPD_TCPCI_ReadRegister>
      /* Check if CC line has been disconnected */
      /* or if no more VBUS after CC_DEBOUNCE_TIMER x 3 (around 12ms) */
      if (((TYPEC_CC_VOLT_OPEN == state[Port].Registers.Status.u1.b1.CC1_STAT) 
    d0ea:	49b8      	ldr	r1, [pc, #736]	; (d3cc <tcpc_set_power+0x55c>)
    d0ec:	687a      	ldr	r2, [r7, #4]
    d0ee:	2010      	movs	r0, #16
    d0f0:	0013      	movs	r3, r2
    d0f2:	015b      	lsls	r3, r3, #5
    d0f4:	189b      	adds	r3, r3, r2
    d0f6:	009b      	lsls	r3, r3, #2
    d0f8:	18cb      	adds	r3, r1, r3
    d0fa:	181b      	adds	r3, r3, r0
    d0fc:	79db      	ldrb	r3, [r3, #7]
    d0fe:	079b      	lsls	r3, r3, #30
    d100:	0f9b      	lsrs	r3, r3, #30
    d102:	b2db      	uxtb	r3, r3
    d104:	2b00      	cmp	r3, #0
    d106:	d10e      	bne.n	d126 <tcpc_set_power+0x2b6>
           && (state[Port].Registers.Control.s.u2.b2.PLUG_ORIENT == 0))
    d108:	49b0      	ldr	r1, [pc, #704]	; (d3cc <tcpc_set_power+0x55c>)
    d10a:	687a      	ldr	r2, [r7, #4]
    d10c:	2010      	movs	r0, #16
    d10e:	0013      	movs	r3, r2
    d110:	015b      	lsls	r3, r3, #5
    d112:	189b      	adds	r3, r3, r2
    d114:	009b      	lsls	r3, r3, #2
    d116:	18cb      	adds	r3, r1, r3
    d118:	181b      	adds	r3, r3, r0
    d11a:	78db      	ldrb	r3, [r3, #3]
    d11c:	07db      	lsls	r3, r3, #31
    d11e:	0fdb      	lsrs	r3, r3, #31
    d120:	b2db      	uxtb	r3, r3
    d122:	2b00      	cmp	r3, #0
    d124:	d02f      	beq.n	d186 <tcpc_set_power+0x316>
          || ((TYPEC_CC_VOLT_OPEN == state[Port].Registers.Status.u1.b1.CC2_STAT) 
    d126:	49a9      	ldr	r1, [pc, #676]	; (d3cc <tcpc_set_power+0x55c>)
    d128:	687a      	ldr	r2, [r7, #4]
    d12a:	2010      	movs	r0, #16
    d12c:	0013      	movs	r3, r2
    d12e:	015b      	lsls	r3, r3, #5
    d130:	189b      	adds	r3, r3, r2
    d132:	009b      	lsls	r3, r3, #2
    d134:	18cb      	adds	r3, r1, r3
    d136:	181b      	adds	r3, r3, r0
    d138:	79db      	ldrb	r3, [r3, #7]
    d13a:	071b      	lsls	r3, r3, #28
    d13c:	0f9b      	lsrs	r3, r3, #30
    d13e:	b2db      	uxtb	r3, r3
    d140:	2b00      	cmp	r3, #0
    d142:	d10e      	bne.n	d162 <tcpc_set_power+0x2f2>
              && (state[Port].Registers.Control.s.u2.b2.PLUG_ORIENT == 1))
    d144:	49a1      	ldr	r1, [pc, #644]	; (d3cc <tcpc_set_power+0x55c>)
    d146:	687a      	ldr	r2, [r7, #4]
    d148:	2010      	movs	r0, #16
    d14a:	0013      	movs	r3, r2
    d14c:	015b      	lsls	r3, r3, #5
    d14e:	189b      	adds	r3, r3, r2
    d150:	009b      	lsls	r3, r3, #2
    d152:	18cb      	adds	r3, r1, r3
    d154:	181b      	adds	r3, r3, r0
    d156:	78db      	ldrb	r3, [r3, #3]
    d158:	07db      	lsls	r3, r3, #31
    d15a:	0fdb      	lsrs	r3, r3, #31
    d15c:	b2db      	uxtb	r3, r3
    d15e:	2b01      	cmp	r3, #1
    d160:	d011      	beq.n	d186 <tcpc_set_power+0x316>
          || ((state[Port].PowerRole == USBPD_PORTPOWERROLE_SNK) && (TimeoutSink > (1000 / CC_DEBOUNCE_TIMER))))
    d162:	499a      	ldr	r1, [pc, #616]	; (d3cc <tcpc_set_power+0x55c>)
    d164:	687a      	ldr	r2, [r7, #4]
    d166:	0013      	movs	r3, r2
    d168:	015b      	lsls	r3, r3, #5
    d16a:	189b      	adds	r3, r3, r2
    d16c:	009b      	lsls	r3, r3, #2
    d16e:	18cb      	adds	r3, r1, r3
    d170:	3368      	adds	r3, #104	; 0x68
    d172:	681b      	ldr	r3, [r3, #0]
    d174:	2b00      	cmp	r3, #0
    d176:	d000      	beq.n	d17a <tcpc_set_power+0x30a>
    d178:	e08f      	b.n	d29a <tcpc_set_power+0x42a>
    d17a:	2326      	movs	r3, #38	; 0x26
    d17c:	18fb      	adds	r3, r7, r3
    d17e:	881b      	ldrh	r3, [r3, #0]
    d180:	2bfa      	cmp	r3, #250	; 0xfa
    d182:	d800      	bhi.n	d186 <tcpc_set_power+0x316>
    d184:	e089      	b.n	d29a <tcpc_set_power+0x42a>
      {
        /* Disable SOURCE VBUS */
        state[Port].Registers.Command.u.COMMAND = TCPC_REG_COMMAND_DISABLE_SRC_VBUS;
    d186:	4991      	ldr	r1, [pc, #580]	; (d3cc <tcpc_set_power+0x55c>)
    d188:	687a      	ldr	r2, [r7, #4]
    d18a:	0013      	movs	r3, r2
    d18c:	015b      	lsls	r3, r3, #5
    d18e:	189b      	adds	r3, r3, r2
    d190:	009b      	lsls	r3, r3, #2
    d192:	18cb      	adds	r3, r1, r3
    d194:	331a      	adds	r3, #26
    d196:	2266      	movs	r2, #102	; 0x66
    d198:	701a      	strb	r2, [r3, #0]
        USBPD_TCPCI_WriteRegister(Port, TCPC_REG_COMMAND, &state[Port].Registers.Command.u.COMMAND, 1);
    d19a:	687b      	ldr	r3, [r7, #4]
    d19c:	b2d8      	uxtb	r0, r3
    d19e:	687a      	ldr	r2, [r7, #4]
    d1a0:	0013      	movs	r3, r2
    d1a2:	015b      	lsls	r3, r3, #5
    d1a4:	189b      	adds	r3, r3, r2
    d1a6:	009b      	lsls	r3, r3, #2
    d1a8:	3318      	adds	r3, #24
    d1aa:	001a      	movs	r2, r3
    d1ac:	4b87      	ldr	r3, [pc, #540]	; (d3cc <tcpc_set_power+0x55c>)
    d1ae:	18d3      	adds	r3, r2, r3
    d1b0:	1c9a      	adds	r2, r3, #2
    d1b2:	2301      	movs	r3, #1
    d1b4:	2123      	movs	r1, #35	; 0x23
    d1b6:	f000 fef7 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
        /* Disable SINK VBUS */
        state[Port].Registers.Command.u.COMMAND = TCPC_REG_COMMAND_DISABLE_SINK_VBUS;
    d1ba:	4984      	ldr	r1, [pc, #528]	; (d3cc <tcpc_set_power+0x55c>)
    d1bc:	687a      	ldr	r2, [r7, #4]
    d1be:	0013      	movs	r3, r2
    d1c0:	015b      	lsls	r3, r3, #5
    d1c2:	189b      	adds	r3, r3, r2
    d1c4:	009b      	lsls	r3, r3, #2
    d1c6:	18cb      	adds	r3, r1, r3
    d1c8:	331a      	adds	r3, #26
    d1ca:	2244      	movs	r2, #68	; 0x44
    d1cc:	701a      	strb	r2, [r3, #0]
        USBPD_TCPCI_WriteRegister(Port, TCPC_REG_COMMAND, &state[Port].Registers.Command.u.COMMAND, 1);
    d1ce:	687b      	ldr	r3, [r7, #4]
    d1d0:	b2d8      	uxtb	r0, r3
    d1d2:	687a      	ldr	r2, [r7, #4]
    d1d4:	0013      	movs	r3, r2
    d1d6:	015b      	lsls	r3, r3, #5
    d1d8:	189b      	adds	r3, r3, r2
    d1da:	009b      	lsls	r3, r3, #2
    d1dc:	3318      	adds	r3, #24
    d1de:	001a      	movs	r2, r3
    d1e0:	4b7a      	ldr	r3, [pc, #488]	; (d3cc <tcpc_set_power+0x55c>)
    d1e2:	18d3      	adds	r3, r2, r3
    d1e4:	1c9a      	adds	r2, r3, #2
    d1e6:	2301      	movs	r3, #1
    d1e8:	2123      	movs	r1, #35	; 0x23
    d1ea:	f000 fedd 	bl	dfa8 <USBPD_TCPCI_WriteRegister>

        /* Disable VCONN */
        state[Port].Registers.Control.s.u5.b5.EN_VCONN    = 0;
    d1ee:	4977      	ldr	r1, [pc, #476]	; (d3cc <tcpc_set_power+0x55c>)
    d1f0:	687a      	ldr	r2, [r7, #4]
    d1f2:	2010      	movs	r0, #16
    d1f4:	0013      	movs	r3, r2
    d1f6:	015b      	lsls	r3, r3, #5
    d1f8:	189b      	adds	r3, r3, r2
    d1fa:	009b      	lsls	r3, r3, #2
    d1fc:	18cb      	adds	r3, r1, r3
    d1fe:	181b      	adds	r3, r3, r0
    d200:	799a      	ldrb	r2, [r3, #6]
    d202:	2101      	movs	r1, #1
    d204:	438a      	bics	r2, r1
    d206:	719a      	strb	r2, [r3, #6]
        state[Port].Registers.Control.s.u5.b5.AUTO_DISCH  = 0;
    d208:	4970      	ldr	r1, [pc, #448]	; (d3cc <tcpc_set_power+0x55c>)
    d20a:	687a      	ldr	r2, [r7, #4]
    d20c:	2010      	movs	r0, #16
    d20e:	0013      	movs	r3, r2
    d210:	015b      	lsls	r3, r3, #5
    d212:	189b      	adds	r3, r3, r2
    d214:	009b      	lsls	r3, r3, #2
    d216:	18cb      	adds	r3, r1, r3
    d218:	181b      	adds	r3, r3, r0
    d21a:	799a      	ldrb	r2, [r3, #6]
    d21c:	2110      	movs	r1, #16
    d21e:	438a      	bics	r2, r1
    d220:	719a      	strb	r2, [r3, #6]
        state[Port].Registers.Control.s.u5.b5.DIS_VALRM   = 1;
    d222:	496a      	ldr	r1, [pc, #424]	; (d3cc <tcpc_set_power+0x55c>)
    d224:	687a      	ldr	r2, [r7, #4]
    d226:	2010      	movs	r0, #16
    d228:	0013      	movs	r3, r2
    d22a:	015b      	lsls	r3, r3, #5
    d22c:	189b      	adds	r3, r3, r2
    d22e:	009b      	lsls	r3, r3, #2
    d230:	18cb      	adds	r3, r1, r3
    d232:	181b      	adds	r3, r3, r0
    d234:	799a      	ldrb	r2, [r3, #6]
    d236:	2120      	movs	r1, #32
    d238:	430a      	orrs	r2, r1
    d23a:	719a      	strb	r2, [r3, #6]
        USBPD_TCPCI_WriteRegister(Port, TCPC_REG_POWER_CONTROL, &state[Port].Registers.Control.s.u5.POWER_CONTROL, 1);
    d23c:	687b      	ldr	r3, [r7, #4]
    d23e:	b2d8      	uxtb	r0, r3
    d240:	687a      	ldr	r2, [r7, #4]
    d242:	0013      	movs	r3, r2
    d244:	015b      	lsls	r3, r3, #5
    d246:	189b      	adds	r3, r3, r2
    d248:	009b      	lsls	r3, r3, #2
    d24a:	3310      	adds	r3, #16
    d24c:	001a      	movs	r2, r3
    d24e:	4b5f      	ldr	r3, [pc, #380]	; (d3cc <tcpc_set_power+0x55c>)
    d250:	18d3      	adds	r3, r2, r3
    d252:	1d9a      	adds	r2, r3, #6
    d254:	2301      	movs	r3, #1
    d256:	211c      	movs	r1, #28
    d258:	f000 fea6 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
        /* Disable BIST mode */
        state[Port].Registers.Control.s.u2.b2.BIST_TMODE = 0;
    d25c:	495b      	ldr	r1, [pc, #364]	; (d3cc <tcpc_set_power+0x55c>)
    d25e:	687a      	ldr	r2, [r7, #4]
    d260:	2010      	movs	r0, #16
    d262:	0013      	movs	r3, r2
    d264:	015b      	lsls	r3, r3, #5
    d266:	189b      	adds	r3, r3, r2
    d268:	009b      	lsls	r3, r3, #2
    d26a:	18cb      	adds	r3, r1, r3
    d26c:	181b      	adds	r3, r3, r0
    d26e:	78da      	ldrb	r2, [r3, #3]
    d270:	2102      	movs	r1, #2
    d272:	438a      	bics	r2, r1
    d274:	70da      	strb	r2, [r3, #3]
        USBPD_TCPCI_WriteRegister(Port, TCPC_REG_TCPC_CONTROL, &state[Port].Registers.Control.s.u2.TCPC_CONTROL, 1);
    d276:	687b      	ldr	r3, [r7, #4]
    d278:	b2d8      	uxtb	r0, r3
    d27a:	687a      	ldr	r2, [r7, #4]
    d27c:	0013      	movs	r3, r2
    d27e:	015b      	lsls	r3, r3, #5
    d280:	189b      	adds	r3, r3, r2
    d282:	009b      	lsls	r3, r3, #2
    d284:	3310      	adds	r3, #16
    d286:	001a      	movs	r2, r3
    d288:	4b50      	ldr	r3, [pc, #320]	; (d3cc <tcpc_set_power+0x55c>)
    d28a:	18d3      	adds	r3, r2, r3
    d28c:	1cda      	adds	r2, r3, #3
    d28e:	2301      	movs	r3, #1
    d290:	2119      	movs	r1, #25
    d292:	f000 fe89 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
        return USBPD_FAIL;
    d296:	2310      	movs	r3, #16
    d298:	e11a      	b.n	d4d0 <tcpc_set_power+0x660>
      }
      TimeoutSink++;
    d29a:	2126      	movs	r1, #38	; 0x26
    d29c:	187b      	adds	r3, r7, r1
    d29e:	881a      	ldrh	r2, [r3, #0]
    d2a0:	187b      	adds	r3, r7, r1
    d2a2:	3201      	adds	r2, #1
    d2a4:	801a      	strh	r2, [r3, #0]
      fusb305_tcpc_get_vbus_level(Port, &vbus_level, NULL);
    d2a6:	231b      	movs	r3, #27
    d2a8:	18f9      	adds	r1, r7, r3
    d2aa:	687b      	ldr	r3, [r7, #4]
    d2ac:	2200      	movs	r2, #0
    d2ae:	0018      	movs	r0, r3
    d2b0:	f7ff fa98 	bl	c7e4 <fusb305_tcpc_get_vbus_level>
    while (vbus_level != 1)
    d2b4:	231b      	movs	r3, #27
    d2b6:	18fb      	adds	r3, r7, r3
    d2b8:	781b      	ldrb	r3, [r3, #0]
    d2ba:	2b01      	cmp	r3, #1
    d2bc:	d000      	beq.n	d2c0 <tcpc_set_power+0x450>
    d2be:	e701      	b.n	d0c4 <tcpc_set_power+0x254>
    }

    /* Enable auto power discharge */
    if (state[Port].PowerRole == USBPD_PORTPOWERROLE_SRC)
    d2c0:	4942      	ldr	r1, [pc, #264]	; (d3cc <tcpc_set_power+0x55c>)
    d2c2:	687a      	ldr	r2, [r7, #4]
    d2c4:	0013      	movs	r3, r2
    d2c6:	015b      	lsls	r3, r3, #5
    d2c8:	189b      	adds	r3, r3, r2
    d2ca:	009b      	lsls	r3, r3, #2
    d2cc:	18cb      	adds	r3, r1, r3
    d2ce:	3368      	adds	r3, #104	; 0x68
    d2d0:	681b      	ldr	r3, [r3, #0]
    d2d2:	2b01      	cmp	r3, #1
    d2d4:	d11c      	bne.n	d310 <tcpc_set_power+0x4a0>
    {
      /* Disable BIST mode. Issue if AUTO_DISCH is enabled during BIST tests */
      if (state[Port].Registers.Control.s.u2.b2.BIST_TMODE == 0)
    d2d6:	493d      	ldr	r1, [pc, #244]	; (d3cc <tcpc_set_power+0x55c>)
    d2d8:	687a      	ldr	r2, [r7, #4]
    d2da:	2010      	movs	r0, #16
    d2dc:	0013      	movs	r3, r2
    d2de:	015b      	lsls	r3, r3, #5
    d2e0:	189b      	adds	r3, r3, r2
    d2e2:	009b      	lsls	r3, r3, #2
    d2e4:	18cb      	adds	r3, r1, r3
    d2e6:	181b      	adds	r3, r3, r0
    d2e8:	78db      	ldrb	r3, [r3, #3]
    d2ea:	079b      	lsls	r3, r3, #30
    d2ec:	0fdb      	lsrs	r3, r3, #31
    d2ee:	b2db      	uxtb	r3, r3
    d2f0:	2b00      	cmp	r3, #0
    d2f2:	d11a      	bne.n	d32a <tcpc_set_power+0x4ba>
        state[Port].Registers.Control.s.u5.b5.AUTO_DISCH  = 1;
    d2f4:	4935      	ldr	r1, [pc, #212]	; (d3cc <tcpc_set_power+0x55c>)
    d2f6:	687a      	ldr	r2, [r7, #4]
    d2f8:	2010      	movs	r0, #16
    d2fa:	0013      	movs	r3, r2
    d2fc:	015b      	lsls	r3, r3, #5
    d2fe:	189b      	adds	r3, r3, r2
    d300:	009b      	lsls	r3, r3, #2
    d302:	18cb      	adds	r3, r1, r3
    d304:	181b      	adds	r3, r3, r0
    d306:	799a      	ldrb	r2, [r3, #6]
    d308:	2110      	movs	r1, #16
    d30a:	430a      	orrs	r2, r1
    d30c:	719a      	strb	r2, [r3, #6]
    d30e:	e00c      	b.n	d32a <tcpc_set_power+0x4ba>
    }
    else
    {
      /* Disable VCONN */
      state[Port].Registers.Control.s.u5.b5.DIS_VALRM   = 1;
    d310:	492e      	ldr	r1, [pc, #184]	; (d3cc <tcpc_set_power+0x55c>)
    d312:	687a      	ldr	r2, [r7, #4]
    d314:	2010      	movs	r0, #16
    d316:	0013      	movs	r3, r2
    d318:	015b      	lsls	r3, r3, #5
    d31a:	189b      	adds	r3, r3, r2
    d31c:	009b      	lsls	r3, r3, #2
    d31e:	18cb      	adds	r3, r1, r3
    d320:	181b      	adds	r3, r3, r0
    d322:	799a      	ldrb	r2, [r3, #6]
    d324:	2120      	movs	r1, #32
    d326:	430a      	orrs	r2, r1
    d328:	719a      	strb	r2, [r3, #6]
    }
    USBPD_TCPCI_WriteRegister(Port, TCPC_REG_POWER_CONTROL, &state[Port].Registers.Control.s.u5.POWER_CONTROL, 1);
    d32a:	687b      	ldr	r3, [r7, #4]
    d32c:	b2d8      	uxtb	r0, r3
    d32e:	687a      	ldr	r2, [r7, #4]
    d330:	0013      	movs	r3, r2
    d332:	015b      	lsls	r3, r3, #5
    d334:	189b      	adds	r3, r3, r2
    d336:	009b      	lsls	r3, r3, #2
    d338:	3310      	adds	r3, #16
    d33a:	001a      	movs	r2, r3
    d33c:	4b23      	ldr	r3, [pc, #140]	; (d3cc <tcpc_set_power+0x55c>)
    d33e:	18d3      	adds	r3, r2, r3
    d340:	1d9a      	adds	r2, r3, #6
    d342:	2301      	movs	r3, #1
    d344:	211c      	movs	r1, #28
    d346:	f000 fe2f 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
    d34a:	e0c0      	b.n	d4ce <tcpc_set_power+0x65e>
  }
  else
  {
    uint16_t vbus_voltage = 0;
    d34c:	240e      	movs	r4, #14
    d34e:	193b      	adds	r3, r7, r4
    d350:	2200      	movs	r2, #0
    d352:	801a      	strh	r2, [r3, #0]
    /* Disable SOURCE VBUS */
    state[Port].Registers.Command.u.COMMAND = TCPC_REG_COMMAND_DISABLE_SRC_VBUS;
    d354:	491d      	ldr	r1, [pc, #116]	; (d3cc <tcpc_set_power+0x55c>)
    d356:	687a      	ldr	r2, [r7, #4]
    d358:	0013      	movs	r3, r2
    d35a:	015b      	lsls	r3, r3, #5
    d35c:	189b      	adds	r3, r3, r2
    d35e:	009b      	lsls	r3, r3, #2
    d360:	18cb      	adds	r3, r1, r3
    d362:	331a      	adds	r3, #26
    d364:	2266      	movs	r2, #102	; 0x66
    d366:	701a      	strb	r2, [r3, #0]
    USBPD_TCPCI_WriteRegister(Port, TCPC_REG_COMMAND, &state[Port].Registers.Command.u.COMMAND, 1);
    d368:	687b      	ldr	r3, [r7, #4]
    d36a:	b2d8      	uxtb	r0, r3
    d36c:	687a      	ldr	r2, [r7, #4]
    d36e:	0013      	movs	r3, r2
    d370:	015b      	lsls	r3, r3, #5
    d372:	189b      	adds	r3, r3, r2
    d374:	009b      	lsls	r3, r3, #2
    d376:	3318      	adds	r3, #24
    d378:	001a      	movs	r2, r3
    d37a:	4b14      	ldr	r3, [pc, #80]	; (d3cc <tcpc_set_power+0x55c>)
    d37c:	18d3      	adds	r3, r2, r3
    d37e:	1c9a      	adds	r2, r3, #2
    d380:	2301      	movs	r3, #1
    d382:	2123      	movs	r1, #35	; 0x23
    d384:	f000 fe10 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
    /* Disable SINK VBUS */
    state[Port].Registers.Command.u.COMMAND = TCPC_REG_COMMAND_DISABLE_SINK_VBUS;
    d388:	4910      	ldr	r1, [pc, #64]	; (d3cc <tcpc_set_power+0x55c>)
    d38a:	687a      	ldr	r2, [r7, #4]
    d38c:	0013      	movs	r3, r2
    d38e:	015b      	lsls	r3, r3, #5
    d390:	189b      	adds	r3, r3, r2
    d392:	009b      	lsls	r3, r3, #2
    d394:	18cb      	adds	r3, r1, r3
    d396:	331a      	adds	r3, #26
    d398:	2244      	movs	r2, #68	; 0x44
    d39a:	701a      	strb	r2, [r3, #0]
    USBPD_TCPCI_WriteRegister(Port, TCPC_REG_COMMAND, &state[Port].Registers.Command.u.COMMAND, 1);
    d39c:	687b      	ldr	r3, [r7, #4]
    d39e:	b2d8      	uxtb	r0, r3
    d3a0:	687a      	ldr	r2, [r7, #4]
    d3a2:	0013      	movs	r3, r2
    d3a4:	015b      	lsls	r3, r3, #5
    d3a6:	189b      	adds	r3, r3, r2
    d3a8:	009b      	lsls	r3, r3, #2
    d3aa:	3318      	adds	r3, #24
    d3ac:	001a      	movs	r2, r3
    d3ae:	4b07      	ldr	r3, [pc, #28]	; (d3cc <tcpc_set_power+0x55c>)
    d3b0:	18d3      	adds	r3, r2, r3
    d3b2:	1c9a      	adds	r2, r3, #2
    d3b4:	2301      	movs	r3, #1
    d3b6:	2123      	movs	r1, #35	; 0x23
    d3b8:	f000 fdf6 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
    
    /* Wait for VBUS ready 
       In case of 4.5.4, a CC detach is detected but value of VBUS is kept to higher than 3.76V */
    fusb305_tcpc_get_vbus_level(Port, &vbus_level, &vbus_voltage);
    d3bc:	193a      	adds	r2, r7, r4
    d3be:	231b      	movs	r3, #27
    d3c0:	18f9      	adds	r1, r7, r3
    d3c2:	687b      	ldr	r3, [r7, #4]
    d3c4:	0018      	movs	r0, r3
    d3c6:	f7ff fa0d 	bl	c7e4 <fusb305_tcpc_get_vbus_level>
    while ((vbus_level != 0) && (vbus_voltage > 4000)) {
    d3ca:	e03d      	b.n	d448 <tcpc_set_power+0x5d8>
    d3cc:	000300b8 	.word	0x000300b8
      /* Disable SOURCE VBUS */
      state[Port].Registers.Command.u.COMMAND = TCPC_REG_COMMAND_DISABLE_SRC_VBUS;
    d3d0:	4941      	ldr	r1, [pc, #260]	; (d4d8 <tcpc_set_power+0x668>)
    d3d2:	687a      	ldr	r2, [r7, #4]
    d3d4:	0013      	movs	r3, r2
    d3d6:	015b      	lsls	r3, r3, #5
    d3d8:	189b      	adds	r3, r3, r2
    d3da:	009b      	lsls	r3, r3, #2
    d3dc:	18cb      	adds	r3, r1, r3
    d3de:	331a      	adds	r3, #26
    d3e0:	2266      	movs	r2, #102	; 0x66
    d3e2:	701a      	strb	r2, [r3, #0]
      USBPD_TCPCI_WriteRegister(Port, TCPC_REG_COMMAND, &state[Port].Registers.Command.u.COMMAND, 1);
    d3e4:	687b      	ldr	r3, [r7, #4]
    d3e6:	b2d8      	uxtb	r0, r3
    d3e8:	687a      	ldr	r2, [r7, #4]
    d3ea:	0013      	movs	r3, r2
    d3ec:	015b      	lsls	r3, r3, #5
    d3ee:	189b      	adds	r3, r3, r2
    d3f0:	009b      	lsls	r3, r3, #2
    d3f2:	3318      	adds	r3, #24
    d3f4:	001a      	movs	r2, r3
    d3f6:	4b38      	ldr	r3, [pc, #224]	; (d4d8 <tcpc_set_power+0x668>)
    d3f8:	18d3      	adds	r3, r2, r3
    d3fa:	1c9a      	adds	r2, r3, #2
    d3fc:	2301      	movs	r3, #1
    d3fe:	2123      	movs	r1, #35	; 0x23
    d400:	f000 fdd2 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
      /* Disable SINK VBUS */
      state[Port].Registers.Command.u.COMMAND = TCPC_REG_COMMAND_DISABLE_SINK_VBUS;
    d404:	4934      	ldr	r1, [pc, #208]	; (d4d8 <tcpc_set_power+0x668>)
    d406:	687a      	ldr	r2, [r7, #4]
    d408:	0013      	movs	r3, r2
    d40a:	015b      	lsls	r3, r3, #5
    d40c:	189b      	adds	r3, r3, r2
    d40e:	009b      	lsls	r3, r3, #2
    d410:	18cb      	adds	r3, r1, r3
    d412:	331a      	adds	r3, #26
    d414:	2244      	movs	r2, #68	; 0x44
    d416:	701a      	strb	r2, [r3, #0]
      USBPD_TCPCI_WriteRegister(Port, TCPC_REG_COMMAND, &state[Port].Registers.Command.u.COMMAND, 1);
    d418:	687b      	ldr	r3, [r7, #4]
    d41a:	b2d8      	uxtb	r0, r3
    d41c:	687a      	ldr	r2, [r7, #4]
    d41e:	0013      	movs	r3, r2
    d420:	015b      	lsls	r3, r3, #5
    d422:	189b      	adds	r3, r3, r2
    d424:	009b      	lsls	r3, r3, #2
    d426:	3318      	adds	r3, #24
    d428:	001a      	movs	r2, r3
    d42a:	4b2b      	ldr	r3, [pc, #172]	; (d4d8 <tcpc_set_power+0x668>)
    d42c:	18d3      	adds	r3, r2, r3
    d42e:	1c9a      	adds	r2, r3, #2
    d430:	2301      	movs	r3, #1
    d432:	2123      	movs	r1, #35	; 0x23
    d434:	f000 fdb8 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
      fusb305_tcpc_get_vbus_level(Port, &vbus_level, &vbus_voltage);
    d438:	230e      	movs	r3, #14
    d43a:	18fa      	adds	r2, r7, r3
    d43c:	231b      	movs	r3, #27
    d43e:	18f9      	adds	r1, r7, r3
    d440:	687b      	ldr	r3, [r7, #4]
    d442:	0018      	movs	r0, r3
    d444:	f7ff f9ce 	bl	c7e4 <fusb305_tcpc_get_vbus_level>
    while ((vbus_level != 0) && (vbus_voltage > 4000)) {
    d448:	231b      	movs	r3, #27
    d44a:	18fb      	adds	r3, r7, r3
    d44c:	781b      	ldrb	r3, [r3, #0]
    d44e:	2b00      	cmp	r3, #0
    d450:	d006      	beq.n	d460 <tcpc_set_power+0x5f0>
    d452:	230e      	movs	r3, #14
    d454:	18fb      	adds	r3, r7, r3
    d456:	881a      	ldrh	r2, [r3, #0]
    d458:	23fa      	movs	r3, #250	; 0xfa
    d45a:	011b      	lsls	r3, r3, #4
    d45c:	429a      	cmp	r2, r3
    d45e:	d8b7      	bhi.n	d3d0 <tcpc_set_power+0x560>
    };

    /* Disable auto VBUS discharge */
    state[Port].Registers.Control.s.u5.b5.EN_VCONN    = 0;
    d460:	491d      	ldr	r1, [pc, #116]	; (d4d8 <tcpc_set_power+0x668>)
    d462:	687a      	ldr	r2, [r7, #4]
    d464:	2010      	movs	r0, #16
    d466:	0013      	movs	r3, r2
    d468:	015b      	lsls	r3, r3, #5
    d46a:	189b      	adds	r3, r3, r2
    d46c:	009b      	lsls	r3, r3, #2
    d46e:	18cb      	adds	r3, r1, r3
    d470:	181b      	adds	r3, r3, r0
    d472:	799a      	ldrb	r2, [r3, #6]
    d474:	2101      	movs	r1, #1
    d476:	438a      	bics	r2, r1
    d478:	719a      	strb	r2, [r3, #6]
    state[Port].Registers.Control.s.u5.b5.AUTO_DISCH  = 0;
    d47a:	4917      	ldr	r1, [pc, #92]	; (d4d8 <tcpc_set_power+0x668>)
    d47c:	687a      	ldr	r2, [r7, #4]
    d47e:	2010      	movs	r0, #16
    d480:	0013      	movs	r3, r2
    d482:	015b      	lsls	r3, r3, #5
    d484:	189b      	adds	r3, r3, r2
    d486:	009b      	lsls	r3, r3, #2
    d488:	18cb      	adds	r3, r1, r3
    d48a:	181b      	adds	r3, r3, r0
    d48c:	799a      	ldrb	r2, [r3, #6]
    d48e:	2110      	movs	r1, #16
    d490:	438a      	bics	r2, r1
    d492:	719a      	strb	r2, [r3, #6]
    state[Port].Registers.Control.s.u5.b5.DIS_VALRM   = 1;
    d494:	4910      	ldr	r1, [pc, #64]	; (d4d8 <tcpc_set_power+0x668>)
    d496:	687a      	ldr	r2, [r7, #4]
    d498:	2010      	movs	r0, #16
    d49a:	0013      	movs	r3, r2
    d49c:	015b      	lsls	r3, r3, #5
    d49e:	189b      	adds	r3, r3, r2
    d4a0:	009b      	lsls	r3, r3, #2
    d4a2:	18cb      	adds	r3, r1, r3
    d4a4:	181b      	adds	r3, r3, r0
    d4a6:	799a      	ldrb	r2, [r3, #6]
    d4a8:	2120      	movs	r1, #32
    d4aa:	430a      	orrs	r2, r1
    d4ac:	719a      	strb	r2, [r3, #6]
    USBPD_TCPCI_WriteRegister(Port, TCPC_REG_POWER_CONTROL, &state[Port].Registers.Control.s.u5.POWER_CONTROL, 1);
    d4ae:	687b      	ldr	r3, [r7, #4]
    d4b0:	b2d8      	uxtb	r0, r3
    d4b2:	687a      	ldr	r2, [r7, #4]
    d4b4:	0013      	movs	r3, r2
    d4b6:	015b      	lsls	r3, r3, #5
    d4b8:	189b      	adds	r3, r3, r2
    d4ba:	009b      	lsls	r3, r3, #2
    d4bc:	3310      	adds	r3, #16
    d4be:	001a      	movs	r2, r3
    d4c0:	4b05      	ldr	r3, [pc, #20]	; (d4d8 <tcpc_set_power+0x668>)
    d4c2:	18d3      	adds	r3, r2, r3
    d4c4:	1d9a      	adds	r2, r3, #6
    d4c6:	2301      	movs	r3, #1
    d4c8:	211c      	movs	r1, #28
    d4ca:	f000 fd6d 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
  }

  return USBPD_OK;
    d4ce:	2300      	movs	r3, #0
}
    d4d0:	0018      	movs	r0, r3
    d4d2:	46bd      	mov	sp, r7
    d4d4:	b00b      	add	sp, #44	; 0x2c
    d4d6:	bd90      	pop	{r4, r7, pc}
    d4d8:	000300b8 	.word	0x000300b8

0000d4dc <fusb305_tcpc_alert>:
  * @param  Port port number value
  * @param  Alert Pointer on ALERT
  * @retval USBPD status
  */
USBPD_StatusTypeDef fusb305_tcpc_alert(uint32_t Port, uint16_t *Alert)
{
    d4dc:	b5b0      	push	{r4, r5, r7, lr}
    d4de:	b08a      	sub	sp, #40	; 0x28
    d4e0:	af02      	add	r7, sp, #8
    d4e2:	6078      	str	r0, [r7, #4]
    d4e4:	6039      	str	r1, [r7, #0]
  USBPD_StatusTypeDef usbpd_status = USBPD_OK;
    d4e6:	251f      	movs	r5, #31
    d4e8:	197b      	adds	r3, r7, r5
    d4ea:	2200      	movs	r2, #0
    d4ec:	701a      	strb	r2, [r3, #0]
  
  /* Read the Alert register from the TCPC */
  usbpd_status = USBPD_TCPCI_ReadRegister(Port, TCPC_REG_ALERT, (uint8_t*)&state[Port].Registers.Alerts.word[0], 2);
    d4ee:	687b      	ldr	r3, [r7, #4]
    d4f0:	b2d8      	uxtb	r0, r3
    d4f2:	687a      	ldr	r2, [r7, #4]
    d4f4:	0013      	movs	r3, r2
    d4f6:	015b      	lsls	r3, r3, #5
    d4f8:	189b      	adds	r3, r3, r2
    d4fa:	009b      	lsls	r3, r3, #2
    d4fc:	3308      	adds	r3, #8
    d4fe:	001a      	movs	r2, r3
    d500:	4b39      	ldr	r3, [pc, #228]	; (d5e8 <fusb305_tcpc_alert+0x10c>)
    d502:	18d3      	adds	r3, r2, r3
    d504:	1d1a      	adds	r2, r3, #4
    d506:	197c      	adds	r4, r7, r5
    d508:	2302      	movs	r3, #2
    d50a:	2110      	movs	r1, #16
    d50c:	f000 fe8e 	bl	e22c <USBPD_TCPCI_ReadRegister>
    d510:	0003      	movs	r3, r0
    d512:	7023      	strb	r3, [r4, #0]

  /* Read the Alert register from the TCPC */
  usbpd_status = USBPD_TCPCI_ReadRegister(Port, TCPC_REG_ALERT_VD, (uint8_t*)&state[Port].Vendor.ALERT_VD, 1);
    d514:	687b      	ldr	r3, [r7, #4]
    d516:	b2d8      	uxtb	r0, r3
    d518:	687a      	ldr	r2, [r7, #4]
    d51a:	0013      	movs	r3, r2
    d51c:	015b      	lsls	r3, r3, #5
    d51e:	189b      	adds	r3, r3, r2
    d520:	009b      	lsls	r3, r3, #2
    d522:	3360      	adds	r3, #96	; 0x60
    d524:	001a      	movs	r2, r3
    d526:	4b30      	ldr	r3, [pc, #192]	; (d5e8 <fusb305_tcpc_alert+0x10c>)
    d528:	18d3      	adds	r3, r2, r3
    d52a:	1d5a      	adds	r2, r3, #5
    d52c:	197c      	adds	r4, r7, r5
    d52e:	2301      	movs	r3, #1
    d530:	21b3      	movs	r1, #179	; 0xb3
    d532:	f000 fe7b 	bl	e22c <USBPD_TCPCI_ReadRegister>
    d536:	0003      	movs	r3, r0
    d538:	7023      	strb	r3, [r4, #0]

  *Alert = state[Port].Registers.Alerts.word[0];
    d53a:	492b      	ldr	r1, [pc, #172]	; (d5e8 <fusb305_tcpc_alert+0x10c>)
    d53c:	687a      	ldr	r2, [r7, #4]
    d53e:	0013      	movs	r3, r2
    d540:	015b      	lsls	r3, r3, #5
    d542:	189b      	adds	r3, r3, r2
    d544:	009b      	lsls	r3, r3, #2
    d546:	18cb      	adds	r3, r1, r3
    d548:	330c      	adds	r3, #12
    d54a:	881a      	ldrh	r2, [r3, #0]
    d54c:	683b      	ldr	r3, [r7, #0]
    d54e:	801a      	strh	r2, [r3, #0]
#if defined(_TRACE)
  {
    uint8_t tab[15] = {0};
    d550:	2410      	movs	r4, #16
    d552:	193b      	adds	r3, r7, r4
    d554:	0018      	movs	r0, r3
    d556:	230f      	movs	r3, #15
    d558:	001a      	movs	r2, r3
    d55a:	2100      	movs	r1, #0
    d55c:	f011 f8a3 	bl	1e6a6 <memset>
    sprintf((char*)tab,"Alert=%2x", *Alert);
    d560:	683b      	ldr	r3, [r7, #0]
    d562:	881b      	ldrh	r3, [r3, #0]
    d564:	001a      	movs	r2, r3
    d566:	4921      	ldr	r1, [pc, #132]	; (d5ec <fusb305_tcpc_alert+0x110>)
    d568:	193b      	adds	r3, r7, r4
    d56a:	0018      	movs	r0, r3
    d56c:	f011 f95e 	bl	1e82c <siprintf>
    FUSB307_DEBUG_TRACE(Port, FUSB307_DEBUG_LEVEL_1, tab);
    d570:	4b1f      	ldr	r3, [pc, #124]	; (d5f0 <fusb305_tcpc_alert+0x114>)
    d572:	781b      	ldrb	r3, [r3, #0]
    d574:	001a      	movs	r2, r3
    d576:	2302      	movs	r3, #2
    d578:	4013      	ands	r3, r2
    d57a:	d00a      	beq.n	d592 <fusb305_tcpc_alert+0xb6>
    d57c:	687b      	ldr	r3, [r7, #4]
    d57e:	b2d9      	uxtb	r1, r3
    d580:	2310      	movs	r3, #16
    d582:	18fa      	adds	r2, r7, r3
    d584:	230e      	movs	r3, #14
    d586:	9300      	str	r3, [sp, #0]
    d588:	0013      	movs	r3, r2
    d58a:	2200      	movs	r2, #0
    d58c:	2006      	movs	r0, #6
    d58e:	f002 ffe9 	bl	10564 <USBPD_TRACE_Add>
  
  /*
  * Clear alert status for everything except RX_STATUS, which should not
  * be cleared until we have successfully retrieved message.
  */
  if (usbpd_status == USBPD_OK)
    d592:	231f      	movs	r3, #31
    d594:	18fb      	adds	r3, r7, r3
    d596:	781b      	ldrb	r3, [r3, #0]
    d598:	2b00      	cmp	r3, #0
    d59a:	d11d      	bne.n	d5d8 <fusb305_tcpc_alert+0xfc>
  {
    uint16_t alert = (TCPC_REG_ALERT_CLEAR_ALL & ~(TCPC_REG_ALERT_RECEIVE_SOP|TCPC_REG_ALERT_TRANSMIT_COMPLETE));
    d59c:	210e      	movs	r1, #14
    d59e:	187b      	adds	r3, r7, r1
    d5a0:	4a14      	ldr	r2, [pc, #80]	; (d5f4 <fusb305_tcpc_alert+0x118>)
    d5a2:	801a      	strh	r2, [r3, #0]
    usbpd_status = USBPD_TCPCI_WriteRegister(Port, TCPC_REG_ALERT, (uint8_t*)&alert, 2);
    d5a4:	687b      	ldr	r3, [r7, #4]
    d5a6:	b2d8      	uxtb	r0, r3
    d5a8:	231f      	movs	r3, #31
    d5aa:	18fc      	adds	r4, r7, r3
    d5ac:	187a      	adds	r2, r7, r1
    d5ae:	2302      	movs	r3, #2
    d5b0:	2110      	movs	r1, #16
    d5b2:	f000 fcf9 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
    d5b6:	0003      	movs	r3, r0
    d5b8:	7023      	strb	r3, [r4, #0]
    /* Keep only the relevant alerts enabled in the alert mask */
    *Alert &= state[Port].Registers.Alerts.word[1];
    d5ba:	683b      	ldr	r3, [r7, #0]
    d5bc:	8819      	ldrh	r1, [r3, #0]
    d5be:	480a      	ldr	r0, [pc, #40]	; (d5e8 <fusb305_tcpc_alert+0x10c>)
    d5c0:	687a      	ldr	r2, [r7, #4]
    d5c2:	0013      	movs	r3, r2
    d5c4:	015b      	lsls	r3, r3, #5
    d5c6:	189b      	adds	r3, r3, r2
    d5c8:	009b      	lsls	r3, r3, #2
    d5ca:	18c3      	adds	r3, r0, r3
    d5cc:	330e      	adds	r3, #14
    d5ce:	881b      	ldrh	r3, [r3, #0]
    d5d0:	400b      	ands	r3, r1
    d5d2:	b29a      	uxth	r2, r3
    d5d4:	683b      	ldr	r3, [r7, #0]
    d5d6:	801a      	strh	r2, [r3, #0]
  }
  return usbpd_status;
    d5d8:	231f      	movs	r3, #31
    d5da:	18fb      	adds	r3, r7, r3
    d5dc:	781b      	ldrb	r3, [r3, #0]
}
    d5de:	0018      	movs	r0, r3
    d5e0:	46bd      	mov	sp, r7
    d5e2:	b008      	add	sp, #32
    d5e4:	bdb0      	pop	{r4, r5, r7, pc}
    d5e6:	46c0      	nop			; (mov r8, r8)
    d5e8:	000300b8 	.word	0x000300b8
    d5ec:	0001f414 	.word	0x0001f414
    d5f0:	0002febc 	.word	0x0002febc
    d5f4:	ffff8f8b 	.word	0xffff8f8b

0000d5f8 <fusb305_tcpc_clear_alert>:
  * @param  Port  port number value
  * @param  Alert Pointer on ALERT to clear
  * @retval USBPD status
  */
USBPD_StatusTypeDef fusb305_tcpc_clear_alert(uint32_t Port, uint16_t *Alert)
{
    d5f8:	b5f0      	push	{r4, r5, r6, r7, lr}
    d5fa:	b085      	sub	sp, #20
    d5fc:	af00      	add	r7, sp, #0
    d5fe:	6078      	str	r0, [r7, #4]
    d600:	6039      	str	r1, [r7, #0]
  USBPD_StatusTypeDef usbpd_status = USBPD_OK;
    d602:	210f      	movs	r1, #15
    d604:	187b      	adds	r3, r7, r1
    d606:	2200      	movs	r2, #0
    d608:	701a      	strb	r2, [r3, #0]
  uint8_t reg = 0xFF;
    d60a:	260e      	movs	r6, #14
    d60c:	19bb      	adds	r3, r7, r6
    d60e:	22ff      	movs	r2, #255	; 0xff
    d610:	701a      	strb	r2, [r3, #0]
  usbpd_status = USBPD_TCPCI_WriteRegister(Port, TCPC_REG_ALERT, (uint8_t*)Alert, 2);
    d612:	687b      	ldr	r3, [r7, #4]
    d614:	b2d8      	uxtb	r0, r3
    d616:	000d      	movs	r5, r1
    d618:	187c      	adds	r4, r7, r1
    d61a:	683a      	ldr	r2, [r7, #0]
    d61c:	2302      	movs	r3, #2
    d61e:	2110      	movs	r1, #16
    d620:	f000 fcc2 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
    d624:	0003      	movs	r3, r0
    d626:	7023      	strb	r3, [r4, #0]

  /* Clear vendor alert */
  usbpd_status = USBPD_TCPCI_WriteRegister(Port, TCPC_REG_ALERT_VD, &reg, 1);
    d628:	687b      	ldr	r3, [r7, #4]
    d62a:	b2d8      	uxtb	r0, r3
    d62c:	197c      	adds	r4, r7, r5
    d62e:	19ba      	adds	r2, r7, r6
    d630:	2301      	movs	r3, #1
    d632:	21b3      	movs	r1, #179	; 0xb3
    d634:	f000 fcb8 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
    d638:	0003      	movs	r3, r0
    d63a:	7023      	strb	r3, [r4, #0]
  
  return usbpd_status;
    d63c:	197b      	adds	r3, r7, r5
    d63e:	781b      	ldrb	r3, [r3, #0]
}
    d640:	0018      	movs	r0, r3
    d642:	46bd      	mov	sp, r7
    d644:	b005      	add	sp, #20
    d646:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000d648 <fusb305_tcpc_set_bist_test_data>:
  * @param  Port port number value
  * @param  Enable Enable BIST Carrier mode 2 or not
  * @retval USBPD status
  */
USBPD_StatusTypeDef fusb305_tcpc_set_bist_test_data(uint32_t Port, uint8_t Enable)
{
    d648:	b590      	push	{r4, r7, lr}
    d64a:	b085      	sub	sp, #20
    d64c:	af00      	add	r7, sp, #0
    d64e:	6078      	str	r0, [r7, #4]
    d650:	000a      	movs	r2, r1
    d652:	1cfb      	adds	r3, r7, #3
    d654:	701a      	strb	r2, [r3, #0]
  USBPD_StatusTypeDef status = USBPD_FAIL;
    d656:	230f      	movs	r3, #15
    d658:	18fb      	adds	r3, r7, r3
    d65a:	2210      	movs	r2, #16
    d65c:	701a      	strb	r2, [r3, #0]
  if (Enable)
    d65e:	1cfb      	adds	r3, r7, #3
    d660:	781b      	ldrb	r3, [r3, #0]
    d662:	2b00      	cmp	r3, #0
    d664:	d021      	beq.n	d6aa <fusb305_tcpc_set_bist_test_data+0x62>
  {
    state[Port].Registers.Control.s.u2.b2.BIST_TMODE = 1;
    d666:	492c      	ldr	r1, [pc, #176]	; (d718 <fusb305_tcpc_set_bist_test_data+0xd0>)
    d668:	687a      	ldr	r2, [r7, #4]
    d66a:	2010      	movs	r0, #16
    d66c:	0013      	movs	r3, r2
    d66e:	015b      	lsls	r3, r3, #5
    d670:	189b      	adds	r3, r3, r2
    d672:	009b      	lsls	r3, r3, #2
    d674:	18cb      	adds	r3, r1, r3
    d676:	181b      	adds	r3, r3, r0
    d678:	78da      	ldrb	r2, [r3, #3]
    d67a:	2102      	movs	r1, #2
    d67c:	430a      	orrs	r2, r1
    d67e:	70da      	strb	r2, [r3, #3]
    status = USBPD_TCPCI_WriteRegister(Port, TCPC_REG_TCPC_CONTROL, &state[Port].Registers.Control.s.u2.TCPC_CONTROL, 1);
    d680:	687b      	ldr	r3, [r7, #4]
    d682:	b2d8      	uxtb	r0, r3
    d684:	687a      	ldr	r2, [r7, #4]
    d686:	0013      	movs	r3, r2
    d688:	015b      	lsls	r3, r3, #5
    d68a:	189b      	adds	r3, r3, r2
    d68c:	009b      	lsls	r3, r3, #2
    d68e:	3310      	adds	r3, #16
    d690:	001a      	movs	r2, r3
    d692:	4b21      	ldr	r3, [pc, #132]	; (d718 <fusb305_tcpc_set_bist_test_data+0xd0>)
    d694:	18d3      	adds	r3, r2, r3
    d696:	1cda      	adds	r2, r3, #3
    d698:	230f      	movs	r3, #15
    d69a:	18fc      	adds	r4, r7, r3
    d69c:	2301      	movs	r3, #1
    d69e:	2119      	movs	r1, #25
    d6a0:	f000 fc82 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
    d6a4:	0003      	movs	r3, r0
    d6a6:	7023      	strb	r3, [r4, #0]
    d6a8:	e02f      	b.n	d70a <fusb305_tcpc_set_bist_test_data+0xc2>
  }
  else
  {
    /* Disable BIST only if it was enabled */
    if (state[Port].Registers.Control.s.u2.b2.BIST_TMODE == 1)
    d6aa:	491b      	ldr	r1, [pc, #108]	; (d718 <fusb305_tcpc_set_bist_test_data+0xd0>)
    d6ac:	687a      	ldr	r2, [r7, #4]
    d6ae:	2010      	movs	r0, #16
    d6b0:	0013      	movs	r3, r2
    d6b2:	015b      	lsls	r3, r3, #5
    d6b4:	189b      	adds	r3, r3, r2
    d6b6:	009b      	lsls	r3, r3, #2
    d6b8:	18cb      	adds	r3, r1, r3
    d6ba:	181b      	adds	r3, r3, r0
    d6bc:	78db      	ldrb	r3, [r3, #3]
    d6be:	079b      	lsls	r3, r3, #30
    d6c0:	0fdb      	lsrs	r3, r3, #31
    d6c2:	b2db      	uxtb	r3, r3
    d6c4:	2b01      	cmp	r3, #1
    d6c6:	d120      	bne.n	d70a <fusb305_tcpc_set_bist_test_data+0xc2>
    {
      state[Port].Registers.Control.s.u2.b2.BIST_TMODE = 0;
    d6c8:	4913      	ldr	r1, [pc, #76]	; (d718 <fusb305_tcpc_set_bist_test_data+0xd0>)
    d6ca:	687a      	ldr	r2, [r7, #4]
    d6cc:	2010      	movs	r0, #16
    d6ce:	0013      	movs	r3, r2
    d6d0:	015b      	lsls	r3, r3, #5
    d6d2:	189b      	adds	r3, r3, r2
    d6d4:	009b      	lsls	r3, r3, #2
    d6d6:	18cb      	adds	r3, r1, r3
    d6d8:	181b      	adds	r3, r3, r0
    d6da:	78da      	ldrb	r2, [r3, #3]
    d6dc:	2102      	movs	r1, #2
    d6de:	438a      	bics	r2, r1
    d6e0:	70da      	strb	r2, [r3, #3]
      status = USBPD_TCPCI_WriteRegister(Port, TCPC_REG_TCPC_CONTROL, &state[Port].Registers.Control.s.u2.TCPC_CONTROL, 1);
    d6e2:	687b      	ldr	r3, [r7, #4]
    d6e4:	b2d8      	uxtb	r0, r3
    d6e6:	687a      	ldr	r2, [r7, #4]
    d6e8:	0013      	movs	r3, r2
    d6ea:	015b      	lsls	r3, r3, #5
    d6ec:	189b      	adds	r3, r3, r2
    d6ee:	009b      	lsls	r3, r3, #2
    d6f0:	3310      	adds	r3, #16
    d6f2:	001a      	movs	r2, r3
    d6f4:	4b08      	ldr	r3, [pc, #32]	; (d718 <fusb305_tcpc_set_bist_test_data+0xd0>)
    d6f6:	18d3      	adds	r3, r2, r3
    d6f8:	1cda      	adds	r2, r3, #3
    d6fa:	230f      	movs	r3, #15
    d6fc:	18fc      	adds	r4, r7, r3
    d6fe:	2301      	movs	r3, #1
    d700:	2119      	movs	r1, #25
    d702:	f000 fc51 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
    d706:	0003      	movs	r3, r0
    d708:	7023      	strb	r3, [r4, #0]
    }
  }
  return status;
    d70a:	230f      	movs	r3, #15
    d70c:	18fb      	adds	r3, r7, r3
    d70e:	781b      	ldrb	r3, [r3, #0]
}
    d710:	0018      	movs	r0, r3
    d712:	46bd      	mov	sp, r7
    d714:	b005      	add	sp, #20
    d716:	bd90      	pop	{r4, r7, pc}
    d718:	000300b8 	.word	0x000300b8

0000d71c <fusb305_tcpc_SinkTxNG>:
 * @brief  function to set the SinkTxNg
 * @param  PortNum  Number of the port.
 * @retval none.
  */
USBPD_StatusTypeDef fusb305_tcpc_SinkTxNG(uint32_t PortNum)
{
    d71c:	b580      	push	{r7, lr}
    d71e:	b082      	sub	sp, #8
    d720:	af00      	add	r7, sp, #0
    d722:	6078      	str	r0, [r7, #4]
#if 1
  state[PortNum].Registers.Control.s.u3.b3.RP_VAL = TYPEC_RP_VALUE_1P5A;
    d724:	4912      	ldr	r1, [pc, #72]	; (d770 <fusb305_tcpc_SinkTxNG+0x54>)
    d726:	687a      	ldr	r2, [r7, #4]
    d728:	2010      	movs	r0, #16
    d72a:	0013      	movs	r3, r2
    d72c:	015b      	lsls	r3, r3, #5
    d72e:	189b      	adds	r3, r3, r2
    d730:	009b      	lsls	r3, r3, #2
    d732:	18cb      	adds	r3, r1, r3
    d734:	181b      	adds	r3, r3, r0
    d736:	791a      	ldrb	r2, [r3, #4]
    d738:	2130      	movs	r1, #48	; 0x30
    d73a:	438a      	bics	r2, r1
    d73c:	1c11      	adds	r1, r2, #0
    d73e:	2210      	movs	r2, #16
    d740:	430a      	orrs	r2, r1
    d742:	711a      	strb	r2, [r3, #4]
  return USBPD_TCPCI_WriteRegister(PortNum, TCPC_REG_ROLE_CONTROL, &state[PortNum].Registers.Control.s.u3.ROLE_CONTROL, 1);
    d744:	687b      	ldr	r3, [r7, #4]
    d746:	b2d8      	uxtb	r0, r3
    d748:	687a      	ldr	r2, [r7, #4]
    d74a:	0013      	movs	r3, r2
    d74c:	015b      	lsls	r3, r3, #5
    d74e:	189b      	adds	r3, r3, r2
    d750:	009b      	lsls	r3, r3, #2
    d752:	3310      	adds	r3, #16
    d754:	001a      	movs	r2, r3
    d756:	4b06      	ldr	r3, [pc, #24]	; (d770 <fusb305_tcpc_SinkTxNG+0x54>)
    d758:	18d3      	adds	r3, r2, r3
    d75a:	1d1a      	adds	r2, r3, #4
    d75c:	2301      	movs	r3, #1
    d75e:	211a      	movs	r1, #26
    d760:	f000 fc22 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
    d764:	0003      	movs	r3, r0
#else
  return USBPD_OK;
#endif
}
    d766:	0018      	movs	r0, r3
    d768:	46bd      	mov	sp, r7
    d76a:	b002      	add	sp, #8
    d76c:	bd80      	pop	{r7, pc}
    d76e:	46c0      	nop			; (mov r8, r8)
    d770:	000300b8 	.word	0x000300b8

0000d774 <fusb305_tcpc_SinkTxOK>:
 * @brief  function to set the SinkTxOK
 * @param  PortNum  Number of the port.
 * @retval none.
  */
USBPD_StatusTypeDef fusb305_tcpc_SinkTxOK(uint32_t PortNum)
{
    d774:	b590      	push	{r4, r7, lr}
    d776:	b083      	sub	sp, #12
    d778:	af00      	add	r7, sp, #0
    d77a:	6078      	str	r0, [r7, #4]
#if 1
  /* Save the current RP value */
  state[PortNum].RP_Value = (TCPC_RP_Value_TypeDef)state[PortNum].Registers.Control.s.u3.b3.RP_VAL;
    d77c:	491e      	ldr	r1, [pc, #120]	; (d7f8 <fusb305_tcpc_SinkTxOK+0x84>)
    d77e:	687a      	ldr	r2, [r7, #4]
    d780:	2010      	movs	r0, #16
    d782:	0013      	movs	r3, r2
    d784:	015b      	lsls	r3, r3, #5
    d786:	189b      	adds	r3, r3, r2
    d788:	009b      	lsls	r3, r3, #2
    d78a:	18cb      	adds	r3, r1, r3
    d78c:	181b      	adds	r3, r3, r0
    d78e:	791b      	ldrb	r3, [r3, #4]
    d790:	069b      	lsls	r3, r3, #26
    d792:	0f9b      	lsrs	r3, r3, #30
    d794:	b2db      	uxtb	r3, r3
    d796:	001c      	movs	r4, r3
    d798:	4917      	ldr	r1, [pc, #92]	; (d7f8 <fusb305_tcpc_SinkTxOK+0x84>)
    d79a:	687a      	ldr	r2, [r7, #4]
    d79c:	2071      	movs	r0, #113	; 0x71
    d79e:	0013      	movs	r3, r2
    d7a0:	015b      	lsls	r3, r3, #5
    d7a2:	189b      	adds	r3, r3, r2
    d7a4:	009b      	lsls	r3, r3, #2
    d7a6:	18cb      	adds	r3, r1, r3
    d7a8:	181b      	adds	r3, r3, r0
    d7aa:	1c22      	adds	r2, r4, #0
    d7ac:	701a      	strb	r2, [r3, #0]

  /* Set the new RP value to 3.0A */
  state[PortNum].Registers.Control.s.u3.b3.RP_VAL = TYPEC_RP_VALUE_3P0A;
    d7ae:	4912      	ldr	r1, [pc, #72]	; (d7f8 <fusb305_tcpc_SinkTxOK+0x84>)
    d7b0:	687a      	ldr	r2, [r7, #4]
    d7b2:	2010      	movs	r0, #16
    d7b4:	0013      	movs	r3, r2
    d7b6:	015b      	lsls	r3, r3, #5
    d7b8:	189b      	adds	r3, r3, r2
    d7ba:	009b      	lsls	r3, r3, #2
    d7bc:	18cb      	adds	r3, r1, r3
    d7be:	181b      	adds	r3, r3, r0
    d7c0:	791a      	ldrb	r2, [r3, #4]
    d7c2:	2130      	movs	r1, #48	; 0x30
    d7c4:	438a      	bics	r2, r1
    d7c6:	1c11      	adds	r1, r2, #0
    d7c8:	2220      	movs	r2, #32
    d7ca:	430a      	orrs	r2, r1
    d7cc:	711a      	strb	r2, [r3, #4]
  return USBPD_TCPCI_WriteRegister(PortNum, TCPC_REG_ROLE_CONTROL, &state[PortNum].Registers.Control.s.u3.ROLE_CONTROL, 1);
    d7ce:	687b      	ldr	r3, [r7, #4]
    d7d0:	b2d8      	uxtb	r0, r3
    d7d2:	687a      	ldr	r2, [r7, #4]
    d7d4:	0013      	movs	r3, r2
    d7d6:	015b      	lsls	r3, r3, #5
    d7d8:	189b      	adds	r3, r3, r2
    d7da:	009b      	lsls	r3, r3, #2
    d7dc:	3310      	adds	r3, #16
    d7de:	001a      	movs	r2, r3
    d7e0:	4b05      	ldr	r3, [pc, #20]	; (d7f8 <fusb305_tcpc_SinkTxOK+0x84>)
    d7e2:	18d3      	adds	r3, r2, r3
    d7e4:	1d1a      	adds	r2, r3, #4
    d7e6:	2301      	movs	r3, #1
    d7e8:	211a      	movs	r1, #26
    d7ea:	f000 fbdd 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
    d7ee:	0003      	movs	r3, r0
#else
  return USBPD_OK;
#endif
}
    d7f0:	0018      	movs	r0, r3
    d7f2:	46bd      	mov	sp, r7
    d7f4:	b003      	add	sp, #12
    d7f6:	bd90      	pop	{r4, r7, pc}
    d7f8:	000300b8 	.word	0x000300b8

0000d7fc <fusb305_tcpc_IfSinkTxOk>:
 * @brief  function to check if SinkTxOK
 * @param  PortNum  Number of the port.
 * @retval USBPD status based on @ref USBPD_StatusTypeDef
  */
USBPD_StatusTypeDef fusb305_tcpc_IfSinkTxOk(uint32_t PortNum)
{
    d7fc:	b580      	push	{r7, lr}
    d7fe:	b082      	sub	sp, #8
    d800:	af00      	add	r7, sp, #0
    d802:	6078      	str	r0, [r7, #4]
  {
    status = USBPD_OK;
  }
  return status;
#else
  return USBPD_OK;
    d804:	2300      	movs	r3, #0
#endif
}
    d806:	0018      	movs	r0, r3
    d808:	46bd      	mov	sp, r7
    d80a:	b002      	add	sp, #8
    d80c:	bd80      	pop	{r7, pc}
	...

0000d810 <InitializeRegisters>:
  * @brief  Initialize all the FUSB305 regisiter
  * @param  Port port number value
  * @retval none
  */
static USBPD_StatusTypeDef InitializeRegisters(uint32_t Port)
{
    d810:	b5b0      	push	{r4, r5, r7, lr}
    d812:	b084      	sub	sp, #16
    d814:	af00      	add	r7, sp, #0
    d816:	6078      	str	r0, [r7, #4]
  USBPD_StatusTypeDef _status;
  uint8_t register_id = TCPC_REG_VENDOR_ID;
    d818:	210e      	movs	r1, #14
    d81a:	187b      	adds	r3, r7, r1
    d81c:	2200      	movs	r2, #0
    d81e:	701a      	strb	r2, [r3, #0]
  _status = USBPD_TCPCI_ReadRegister(Port, register_id, (uint8_t*)&state[Port].Registers.TCPC_Information.word[0], sizeof(DeviceReg_t));
    d820:	687b      	ldr	r3, [r7, #4]
    d822:	b2d8      	uxtb	r0, r3
    d824:	687a      	ldr	r2, [r7, #4]
    d826:	0013      	movs	r3, r2
    d828:	015b      	lsls	r3, r3, #5
    d82a:	189b      	adds	r3, r3, r2
    d82c:	009b      	lsls	r3, r3, #2
    d82e:	4a18      	ldr	r2, [pc, #96]	; (d890 <InitializeRegisters+0x80>)
    d830:	189a      	adds	r2, r3, r2
    d832:	250f      	movs	r5, #15
    d834:	197c      	adds	r4, r7, r5
    d836:	187b      	adds	r3, r7, r1
    d838:	7819      	ldrb	r1, [r3, #0]
    d83a:	2352      	movs	r3, #82	; 0x52
    d83c:	f000 fcf6 	bl	e22c <USBPD_TCPCI_ReadRegister>
    d840:	0003      	movs	r3, r0
    d842:	7023      	strb	r3, [r4, #0]
  if (USBPD_OK != _status)
    d844:	197b      	adds	r3, r7, r5
    d846:	781b      	ldrb	r3, [r3, #0]
    d848:	2b00      	cmp	r3, #0
    d84a:	d119      	bne.n	d880 <InitializeRegisters+0x70>
  {
    goto _exit;
  }
  register_id = TCPC_REG_VCONN_OCP;
    d84c:	210e      	movs	r1, #14
    d84e:	187b      	adds	r3, r7, r1
    d850:	22a0      	movs	r2, #160	; 0xa0
    d852:	701a      	strb	r2, [r3, #0]
  _status = USBPD_TCPCI_ReadRegister(Port, register_id, (uint8_t*)&state[Port].Vendor.byte[0], sizeof(regVendorInfo_t));
    d854:	687b      	ldr	r3, [r7, #4]
    d856:	b2d8      	uxtb	r0, r3
    d858:	687a      	ldr	r2, [r7, #4]
    d85a:	0013      	movs	r3, r2
    d85c:	015b      	lsls	r3, r3, #5
    d85e:	189b      	adds	r3, r3, r2
    d860:	009b      	lsls	r3, r3, #2
    d862:	3350      	adds	r3, #80	; 0x50
    d864:	001a      	movs	r2, r3
    d866:	4b0a      	ldr	r3, [pc, #40]	; (d890 <InitializeRegisters+0x80>)
    d868:	18d3      	adds	r3, r2, r3
    d86a:	1c9a      	adds	r2, r3, #2
    d86c:	230f      	movs	r3, #15
    d86e:	18fc      	adds	r4, r7, r3
    d870:	187b      	adds	r3, r7, r1
    d872:	7819      	ldrb	r1, [r3, #0]
    d874:	2316      	movs	r3, #22
    d876:	f000 fcd9 	bl	e22c <USBPD_TCPCI_ReadRegister>
    d87a:	0003      	movs	r3, r0
    d87c:	7023      	strb	r3, [r4, #0]
  if (USBPD_OK != _status)
  {
    goto _exit;
  }
_exit:
    d87e:	e000      	b.n	d882 <InitializeRegisters+0x72>
    goto _exit;
    d880:	46c0      	nop			; (mov r8, r8)
  return _status;
    d882:	230f      	movs	r3, #15
    d884:	18fb      	adds	r3, r7, r3
    d886:	781b      	ldrb	r3, [r3, #0]
}
    d888:	0018      	movs	r0, r3
    d88a:	46bd      	mov	sp, r7
    d88c:	b004      	add	sp, #16
    d88e:	bdb0      	pop	{r4, r5, r7, pc}
    d890:	000300b8 	.word	0x000300b8

0000d894 <tcpc_set_alert_mask>:
  * @param  PowerRole  Power role of the connection
  * @param  State      State of the connection
  * @retval USBPD status
  */
static USBPD_StatusTypeDef tcpc_set_alert_mask(uint32_t Port,  uint8_t PowerRole, USBPD_FunctionalState State)
{
    d894:	b5b0      	push	{r4, r5, r7, lr}
    d896:	b084      	sub	sp, #16
    d898:	af00      	add	r7, sp, #0
    d89a:	6078      	str	r0, [r7, #4]
    d89c:	0008      	movs	r0, r1
    d89e:	0011      	movs	r1, r2
    d8a0:	1cfb      	adds	r3, r7, #3
    d8a2:	1c02      	adds	r2, r0, #0
    d8a4:	701a      	strb	r2, [r3, #0]
    d8a6:	1cbb      	adds	r3, r7, #2
    d8a8:	1c0a      	adds	r2, r1, #0
    d8aa:	701a      	strb	r2, [r3, #0]
  USBPD_StatusTypeDef status = USBPD_FAIL;
    d8ac:	230f      	movs	r3, #15
    d8ae:	18fb      	adds	r3, r7, r3
    d8b0:	2210      	movs	r2, #16
    d8b2:	701a      	strb	r2, [r3, #0]

  /* Reset all the masks */
  state[Port].Registers.Alerts.s.u3.ALERTMSKL        = 0;
    d8b4:	495c      	ldr	r1, [pc, #368]	; (da28 <tcpc_set_alert_mask+0x194>)
    d8b6:	687a      	ldr	r2, [r7, #4]
    d8b8:	0013      	movs	r3, r2
    d8ba:	015b      	lsls	r3, r3, #5
    d8bc:	189b      	adds	r3, r3, r2
    d8be:	009b      	lsls	r3, r3, #2
    d8c0:	18cb      	adds	r3, r1, r3
    d8c2:	330e      	adds	r3, #14
    d8c4:	2200      	movs	r2, #0
    d8c6:	701a      	strb	r2, [r3, #0]
  state[Port].Registers.Alerts.s.u4.ALERTMSKH        = 0;
    d8c8:	4957      	ldr	r1, [pc, #348]	; (da28 <tcpc_set_alert_mask+0x194>)
    d8ca:	687a      	ldr	r2, [r7, #4]
    d8cc:	0013      	movs	r3, r2
    d8ce:	015b      	lsls	r3, r3, #5
    d8d0:	189b      	adds	r3, r3, r2
    d8d2:	009b      	lsls	r3, r3, #2
    d8d4:	18cb      	adds	r3, r1, r3
    d8d6:	330f      	adds	r3, #15
    d8d8:	2200      	movs	r2, #0
    d8da:	701a      	strb	r2, [r3, #0]
  
  if (USBPD_ENABLE == State)
    d8dc:	1cbb      	adds	r3, r7, #2
    d8de:	781b      	ldrb	r3, [r3, #0]
    d8e0:	2b01      	cmp	r3, #1
    d8e2:	d17a      	bne.n	d9da <tcpc_set_alert_mask+0x146>
  {
    if (PowerRole == USBPD_PORTPOWERROLE_SRC)
    d8e4:	1cfb      	adds	r3, r7, #3
    d8e6:	781b      	ldrb	r3, [r3, #0]
    d8e8:	2b01      	cmp	r3, #1
    d8ea:	d10d      	bne.n	d908 <tcpc_set_alert_mask+0x74>
    {
      state[Port].Registers.Alerts.s.u3.b3.M_CCSTAT         = 1;
    d8ec:	494e      	ldr	r1, [pc, #312]	; (da28 <tcpc_set_alert_mask+0x194>)
    d8ee:	687a      	ldr	r2, [r7, #4]
    d8f0:	2008      	movs	r0, #8
    d8f2:	0013      	movs	r3, r2
    d8f4:	015b      	lsls	r3, r3, #5
    d8f6:	189b      	adds	r3, r3, r2
    d8f8:	009b      	lsls	r3, r3, #2
    d8fa:	18cb      	adds	r3, r1, r3
    d8fc:	181b      	adds	r3, r3, r0
    d8fe:	799a      	ldrb	r2, [r3, #6]
    d900:	2101      	movs	r1, #1
    d902:	430a      	orrs	r2, r1
    d904:	719a      	strb	r2, [r3, #6]
    d906:	e026      	b.n	d956 <tcpc_set_alert_mask+0xc2>
    }
    else
    {
      state[Port].Registers.Alerts.s.u3.b3.M_CCSTAT         = 1;
    d908:	4947      	ldr	r1, [pc, #284]	; (da28 <tcpc_set_alert_mask+0x194>)
    d90a:	687a      	ldr	r2, [r7, #4]
    d90c:	2008      	movs	r0, #8
    d90e:	0013      	movs	r3, r2
    d910:	015b      	lsls	r3, r3, #5
    d912:	189b      	adds	r3, r3, r2
    d914:	009b      	lsls	r3, r3, #2
    d916:	18cb      	adds	r3, r1, r3
    d918:	181b      	adds	r3, r3, r0
    d91a:	799a      	ldrb	r2, [r3, #6]
    d91c:	2101      	movs	r1, #1
    d91e:	430a      	orrs	r2, r1
    d920:	719a      	strb	r2, [r3, #6]
      state[Port].Registers.Alerts.s.u3.b3.M_PORT_PWR       = 1;
    d922:	4941      	ldr	r1, [pc, #260]	; (da28 <tcpc_set_alert_mask+0x194>)
    d924:	687a      	ldr	r2, [r7, #4]
    d926:	2008      	movs	r0, #8
    d928:	0013      	movs	r3, r2
    d92a:	015b      	lsls	r3, r3, #5
    d92c:	189b      	adds	r3, r3, r2
    d92e:	009b      	lsls	r3, r3, #2
    d930:	18cb      	adds	r3, r1, r3
    d932:	181b      	adds	r3, r3, r0
    d934:	799a      	ldrb	r2, [r3, #6]
    d936:	2102      	movs	r1, #2
    d938:	430a      	orrs	r2, r1
    d93a:	719a      	strb	r2, [r3, #6]
      state[Port].Registers.Alerts.s.u4.b4.M_VBUS_SNK_DISC  = 1;
    d93c:	493a      	ldr	r1, [pc, #232]	; (da28 <tcpc_set_alert_mask+0x194>)
    d93e:	687a      	ldr	r2, [r7, #4]
    d940:	2008      	movs	r0, #8
    d942:	0013      	movs	r3, r2
    d944:	015b      	lsls	r3, r3, #5
    d946:	189b      	adds	r3, r3, r2
    d948:	009b      	lsls	r3, r3, #2
    d94a:	18cb      	adds	r3, r1, r3
    d94c:	181b      	adds	r3, r3, r0
    d94e:	79da      	ldrb	r2, [r3, #7]
    d950:	2108      	movs	r1, #8
    d952:	430a      	orrs	r2, r1
    d954:	71da      	strb	r2, [r3, #7]
    }
    
    state[Port].Registers.Alerts.s.u3.b3.M_TXSUCC         = 1;
    d956:	4934      	ldr	r1, [pc, #208]	; (da28 <tcpc_set_alert_mask+0x194>)
    d958:	687a      	ldr	r2, [r7, #4]
    d95a:	2008      	movs	r0, #8
    d95c:	0013      	movs	r3, r2
    d95e:	015b      	lsls	r3, r3, #5
    d960:	189b      	adds	r3, r3, r2
    d962:	009b      	lsls	r3, r3, #2
    d964:	18cb      	adds	r3, r1, r3
    d966:	181b      	adds	r3, r3, r0
    d968:	799a      	ldrb	r2, [r3, #6]
    d96a:	2140      	movs	r1, #64	; 0x40
    d96c:	430a      	orrs	r2, r1
    d96e:	719a      	strb	r2, [r3, #6]
    state[Port].Registers.Alerts.s.u3.b3.M_TXFAIL         = 1;
    d970:	492d      	ldr	r1, [pc, #180]	; (da28 <tcpc_set_alert_mask+0x194>)
    d972:	687a      	ldr	r2, [r7, #4]
    d974:	2008      	movs	r0, #8
    d976:	0013      	movs	r3, r2
    d978:	015b      	lsls	r3, r3, #5
    d97a:	189b      	adds	r3, r3, r2
    d97c:	009b      	lsls	r3, r3, #2
    d97e:	18cb      	adds	r3, r1, r3
    d980:	181b      	adds	r3, r3, r0
    d982:	799a      	ldrb	r2, [r3, #6]
    d984:	2110      	movs	r1, #16
    d986:	430a      	orrs	r2, r1
    d988:	719a      	strb	r2, [r3, #6]
    state[Port].Registers.Alerts.s.u3.b3.M_TXDISC         = 1;
    d98a:	4927      	ldr	r1, [pc, #156]	; (da28 <tcpc_set_alert_mask+0x194>)
    d98c:	687a      	ldr	r2, [r7, #4]
    d98e:	2008      	movs	r0, #8
    d990:	0013      	movs	r3, r2
    d992:	015b      	lsls	r3, r3, #5
    d994:	189b      	adds	r3, r3, r2
    d996:	009b      	lsls	r3, r3, #2
    d998:	18cb      	adds	r3, r1, r3
    d99a:	181b      	adds	r3, r3, r0
    d99c:	799a      	ldrb	r2, [r3, #6]
    d99e:	2120      	movs	r1, #32
    d9a0:	430a      	orrs	r2, r1
    d9a2:	719a      	strb	r2, [r3, #6]
    state[Port].Registers.Alerts.s.u3.b3.M_RXSTAT         = 1;
    d9a4:	4920      	ldr	r1, [pc, #128]	; (da28 <tcpc_set_alert_mask+0x194>)
    d9a6:	687a      	ldr	r2, [r7, #4]
    d9a8:	2008      	movs	r0, #8
    d9aa:	0013      	movs	r3, r2
    d9ac:	015b      	lsls	r3, r3, #5
    d9ae:	189b      	adds	r3, r3, r2
    d9b0:	009b      	lsls	r3, r3, #2
    d9b2:	18cb      	adds	r3, r1, r3
    d9b4:	181b      	adds	r3, r3, r0
    d9b6:	799a      	ldrb	r2, [r3, #6]
    d9b8:	2104      	movs	r1, #4
    d9ba:	430a      	orrs	r2, r1
    d9bc:	719a      	strb	r2, [r3, #6]
    state[Port].Registers.Alerts.s.u3.b3.M_RXHRDRST       = 1;
    d9be:	491a      	ldr	r1, [pc, #104]	; (da28 <tcpc_set_alert_mask+0x194>)
    d9c0:	687a      	ldr	r2, [r7, #4]
    d9c2:	2008      	movs	r0, #8
    d9c4:	0013      	movs	r3, r2
    d9c6:	015b      	lsls	r3, r3, #5
    d9c8:	189b      	adds	r3, r3, r2
    d9ca:	009b      	lsls	r3, r3, #2
    d9cc:	18cb      	adds	r3, r1, r3
    d9ce:	181b      	adds	r3, r3, r0
    d9d0:	799a      	ldrb	r2, [r3, #6]
    d9d2:	2108      	movs	r1, #8
    d9d4:	430a      	orrs	r2, r1
    d9d6:	719a      	strb	r2, [r3, #6]
    d9d8:	e00c      	b.n	d9f4 <tcpc_set_alert_mask+0x160>
  {
    /*
    * Create mask of alert events that will cause the TCPC to
    * signal the TCPM via the Alert# gpio line.
    */
    state[Port].Registers.Alerts.s.u3.b3.M_CCSTAT = 1;
    d9da:	4913      	ldr	r1, [pc, #76]	; (da28 <tcpc_set_alert_mask+0x194>)
    d9dc:	687a      	ldr	r2, [r7, #4]
    d9de:	2008      	movs	r0, #8
    d9e0:	0013      	movs	r3, r2
    d9e2:	015b      	lsls	r3, r3, #5
    d9e4:	189b      	adds	r3, r3, r2
    d9e6:	009b      	lsls	r3, r3, #2
    d9e8:	18cb      	adds	r3, r1, r3
    d9ea:	181b      	adds	r3, r3, r0
    d9ec:	799a      	ldrb	r2, [r3, #6]
    d9ee:	2101      	movs	r1, #1
    d9f0:	430a      	orrs	r2, r1
    d9f2:	719a      	strb	r2, [r3, #6]
  }

  status = USBPD_TCPCI_WriteRegister(Port, TCPC_REG_ALERT_MASK, (uint8_t*)&state[Port].Registers.Alerts.word[1], 2);
    d9f4:	687b      	ldr	r3, [r7, #4]
    d9f6:	b2d8      	uxtb	r0, r3
    d9f8:	687a      	ldr	r2, [r7, #4]
    d9fa:	0013      	movs	r3, r2
    d9fc:	015b      	lsls	r3, r3, #5
    d9fe:	189b      	adds	r3, r3, r2
    da00:	009b      	lsls	r3, r3, #2
    da02:	330a      	adds	r3, #10
    da04:	001a      	movs	r2, r3
    da06:	4b08      	ldr	r3, [pc, #32]	; (da28 <tcpc_set_alert_mask+0x194>)
    da08:	18d3      	adds	r3, r2, r3
    da0a:	1d1a      	adds	r2, r3, #4
    da0c:	250f      	movs	r5, #15
    da0e:	197c      	adds	r4, r7, r5
    da10:	2302      	movs	r3, #2
    da12:	2112      	movs	r1, #18
    da14:	f000 fac8 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
    da18:	0003      	movs	r3, r0
    da1a:	7023      	strb	r3, [r4, #0]
  /* Set the alert mask in TCPC */
  return status;
    da1c:	197b      	adds	r3, r7, r5
    da1e:	781b      	ldrb	r3, [r3, #0]
}
    da20:	0018      	movs	r0, r3
    da22:	46bd      	mov	sp, r7
    da24:	b004      	add	sp, #16
    da26:	bdb0      	pop	{r4, r5, r7, pc}
    da28:	000300b8 	.word	0x000300b8

0000da2c <tcpc_init_power_status_mask>:
  * @brief  Initialize power status mask
  * @param  Port port number value
  * @retval USBPD status
  */
static USBPD_StatusTypeDef tcpc_init_power_status_mask(uint32_t Port)
{
    da2c:	b5b0      	push	{r4, r5, r7, lr}
    da2e:	b084      	sub	sp, #16
    da30:	af00      	add	r7, sp, #0
    da32:	6078      	str	r0, [r7, #4]
  USBPD_StatusTypeDef status = USBPD_FAIL;
    da34:	240f      	movs	r4, #15
    da36:	193b      	adds	r3, r7, r4
    da38:	2210      	movs	r2, #16
    da3a:	701a      	strb	r2, [r3, #0]
  
  state[Port].Registers.StatusMask.s.u1.POWER_STATUS_MASK = TCPC_REG_POWER_STATUS_MASK_VBUS_PRES;
    da3c:	491d      	ldr	r1, [pc, #116]	; (dab4 <tcpc_init_power_status_mask+0x88>)
    da3e:	687a      	ldr	r2, [r7, #4]
    da40:	0013      	movs	r3, r2
    da42:	015b      	lsls	r3, r3, #5
    da44:	189b      	adds	r3, r3, r2
    da46:	009b      	lsls	r3, r3, #2
    da48:	18cb      	adds	r3, r1, r3
    da4a:	3310      	adds	r3, #16
    da4c:	2204      	movs	r2, #4
    da4e:	701a      	strb	r2, [r3, #0]
  status = USBPD_TCPCI_WriteRegister(Port, TCPC_REG_POWER_STATUS_MASK , &state[Port].Registers.StatusMask.s.u1.POWER_STATUS_MASK, 1);
    da50:	687b      	ldr	r3, [r7, #4]
    da52:	b2d8      	uxtb	r0, r3
    da54:	687a      	ldr	r2, [r7, #4]
    da56:	0013      	movs	r3, r2
    da58:	015b      	lsls	r3, r3, #5
    da5a:	189b      	adds	r3, r3, r2
    da5c:	009b      	lsls	r3, r3, #2
    da5e:	3310      	adds	r3, #16
    da60:	001a      	movs	r2, r3
    da62:	4b14      	ldr	r3, [pc, #80]	; (dab4 <tcpc_init_power_status_mask+0x88>)
    da64:	18d2      	adds	r2, r2, r3
    da66:	0025      	movs	r5, r4
    da68:	193c      	adds	r4, r7, r4
    da6a:	2301      	movs	r3, #1
    da6c:	2114      	movs	r1, #20
    da6e:	f000 fa9b 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
    da72:	0003      	movs	r3, r0
    da74:	7023      	strb	r3, [r4, #0]
  if (status == USBPD_OK)
    da76:	002c      	movs	r4, r5
    da78:	193b      	adds	r3, r7, r4
    da7a:	781b      	ldrb	r3, [r3, #0]
    da7c:	2b00      	cmp	r3, #0
    da7e:	d112      	bne.n	daa6 <tcpc_init_power_status_mask+0x7a>
  {
    status =   USBPD_TCPCI_ReadRegister(Port, TCPC_REG_POWER_STATUS_MASK, &state[Port].Registers.StatusMask.s.u1.POWER_STATUS_MASK, 1);
    da80:	687b      	ldr	r3, [r7, #4]
    da82:	b2d8      	uxtb	r0, r3
    da84:	687a      	ldr	r2, [r7, #4]
    da86:	0013      	movs	r3, r2
    da88:	015b      	lsls	r3, r3, #5
    da8a:	189b      	adds	r3, r3, r2
    da8c:	009b      	lsls	r3, r3, #2
    da8e:	3310      	adds	r3, #16
    da90:	001a      	movs	r2, r3
    da92:	4b08      	ldr	r3, [pc, #32]	; (dab4 <tcpc_init_power_status_mask+0x88>)
    da94:	18d2      	adds	r2, r2, r3
    da96:	230f      	movs	r3, #15
    da98:	18fc      	adds	r4, r7, r3
    da9a:	2301      	movs	r3, #1
    da9c:	2114      	movs	r1, #20
    da9e:	f000 fbc5 	bl	e22c <USBPD_TCPCI_ReadRegister>
    daa2:	0003      	movs	r3, r0
    daa4:	7023      	strb	r3, [r4, #0]
  }
  /* Set the alert mask in TCPC */
  return status;
    daa6:	230f      	movs	r3, #15
    daa8:	18fb      	adds	r3, r7, r3
    daaa:	781b      	ldrb	r3, [r3, #0]
}
    daac:	0018      	movs	r0, r3
    daae:	46bd      	mov	sp, r7
    dab0:	b004      	add	sp, #16
    dab2:	bdb0      	pop	{r4, r5, r7, pc}
    dab4:	000300b8 	.word	0x000300b8

0000dab8 <tcpc_set_pin_role>:
  * @param  Pull CC pin value
  * @param  State  State of the connection
  * @retval USBPD status
  */
static void tcpc_set_pin_role(uint32_t Port, uint8_t Pull, USBPD_FunctionalState State)
{
    dab8:	b590      	push	{r4, r7, lr}
    daba:	b087      	sub	sp, #28
    dabc:	af02      	add	r7, sp, #8
    dabe:	6078      	str	r0, [r7, #4]
    dac0:	0008      	movs	r0, r1
    dac2:	0011      	movs	r1, r2
    dac4:	1cfb      	adds	r3, r7, #3
    dac6:	1c02      	adds	r2, r0, #0
    dac8:	701a      	strb	r2, [r3, #0]
    daca:	1cbb      	adds	r3, r7, #2
    dacc:	1c0a      	adds	r2, r1, #0
    dace:	701a      	strb	r2, [r3, #0]
  uint8_t wasAWSnk = (state[Port].TypeC_State == AttachWaitSink) ? 1 : 0;
    dad0:	49a7      	ldr	r1, [pc, #668]	; (dd70 <tcpc_set_pin_role+0x2b8>)
    dad2:	687a      	ldr	r2, [r7, #4]
    dad4:	2072      	movs	r0, #114	; 0x72
    dad6:	0013      	movs	r3, r2
    dad8:	015b      	lsls	r3, r3, #5
    dada:	189b      	adds	r3, r3, r2
    dadc:	009b      	lsls	r3, r3, #2
    dade:	18cb      	adds	r3, r1, r3
    dae0:	181b      	adds	r3, r3, r0
    dae2:	781b      	ldrb	r3, [r3, #0]
    dae4:	3b03      	subs	r3, #3
    dae6:	425a      	negs	r2, r3
    dae8:	4153      	adcs	r3, r2
    daea:	b2da      	uxtb	r2, r3
    daec:	230f      	movs	r3, #15
    daee:	18fb      	adds	r3, r7, r3
    daf0:	701a      	strb	r2, [r3, #0]

  if (USBPD_ENABLE == State)
    daf2:	1cbb      	adds	r3, r7, #2
    daf4:	781b      	ldrb	r3, [r3, #0]
    daf6:	2b01      	cmp	r3, #1
    daf8:	d000      	beq.n	dafc <tcpc_set_pin_role+0x44>
    dafa:	e089      	b.n	dc10 <tcpc_set_pin_role+0x158>
  {
#if defined(_TRACE)
        switch (Pull)
    dafc:	1cfb      	adds	r3, r7, #3
    dafe:	781b      	ldrb	r3, [r3, #0]
    db00:	2b01      	cmp	r3, #1
    db02:	d019      	beq.n	db38 <tcpc_set_pin_role+0x80>
    db04:	dc02      	bgt.n	db0c <tcpc_set_pin_role+0x54>
    db06:	2b00      	cmp	r3, #0
    db08:	d005      	beq.n	db16 <tcpc_set_pin_role+0x5e>
    db0a:	e04f      	b.n	dbac <tcpc_set_pin_role+0xf4>
    db0c:	2b02      	cmp	r3, #2
    db0e:	d024      	beq.n	db5a <tcpc_set_pin_role+0xa2>
    db10:	2b03      	cmp	r3, #3
    db12:	d033      	beq.n	db7c <tcpc_set_pin_role+0xc4>
    db14:	e04a      	b.n	dbac <tcpc_set_pin_role+0xf4>
        {
          case TYPEC_CC_RA:
            FUSB307_DEBUG_TRACE(Port, FUSB307_DEBUG_LEVEL_0, "tcpc_set_pin_role(EN, RA)");
    db16:	4b97      	ldr	r3, [pc, #604]	; (dd74 <tcpc_set_pin_role+0x2bc>)
    db18:	781b      	ldrb	r3, [r3, #0]
    db1a:	001a      	movs	r2, r3
    db1c:	2301      	movs	r3, #1
    db1e:	4013      	ands	r3, r2
    db20:	d03d      	beq.n	db9e <tcpc_set_pin_role+0xe6>
    db22:	687b      	ldr	r3, [r7, #4]
    db24:	b2d9      	uxtb	r1, r3
    db26:	4a94      	ldr	r2, [pc, #592]	; (dd78 <tcpc_set_pin_role+0x2c0>)
    db28:	2319      	movs	r3, #25
    db2a:	9300      	str	r3, [sp, #0]
    db2c:	0013      	movs	r3, r2
    db2e:	2200      	movs	r2, #0
    db30:	2006      	movs	r0, #6
    db32:	f002 fd17 	bl	10564 <USBPD_TRACE_Add>
            break;
    db36:	e032      	b.n	db9e <tcpc_set_pin_role+0xe6>
          case TYPEC_CC_RP:
            FUSB307_DEBUG_TRACE(Port, FUSB307_DEBUG_LEVEL_0, "tcpc_set_pin_role(EN, RP)");
    db38:	4b8e      	ldr	r3, [pc, #568]	; (dd74 <tcpc_set_pin_role+0x2bc>)
    db3a:	781b      	ldrb	r3, [r3, #0]
    db3c:	001a      	movs	r2, r3
    db3e:	2301      	movs	r3, #1
    db40:	4013      	ands	r3, r2
    db42:	d02e      	beq.n	dba2 <tcpc_set_pin_role+0xea>
    db44:	687b      	ldr	r3, [r7, #4]
    db46:	b2d9      	uxtb	r1, r3
    db48:	4a8c      	ldr	r2, [pc, #560]	; (dd7c <tcpc_set_pin_role+0x2c4>)
    db4a:	2319      	movs	r3, #25
    db4c:	9300      	str	r3, [sp, #0]
    db4e:	0013      	movs	r3, r2
    db50:	2200      	movs	r2, #0
    db52:	2006      	movs	r0, #6
    db54:	f002 fd06 	bl	10564 <USBPD_TRACE_Add>
            break;
    db58:	e023      	b.n	dba2 <tcpc_set_pin_role+0xea>
          case TYPEC_CC_RD:
            FUSB307_DEBUG_TRACE(Port, FUSB307_DEBUG_LEVEL_0, "tcpc_set_pin_role(EN, RD)");
    db5a:	4b86      	ldr	r3, [pc, #536]	; (dd74 <tcpc_set_pin_role+0x2bc>)
    db5c:	781b      	ldrb	r3, [r3, #0]
    db5e:	001a      	movs	r2, r3
    db60:	2301      	movs	r3, #1
    db62:	4013      	ands	r3, r2
    db64:	d01f      	beq.n	dba6 <tcpc_set_pin_role+0xee>
    db66:	687b      	ldr	r3, [r7, #4]
    db68:	b2d9      	uxtb	r1, r3
    db6a:	4a85      	ldr	r2, [pc, #532]	; (dd80 <tcpc_set_pin_role+0x2c8>)
    db6c:	2319      	movs	r3, #25
    db6e:	9300      	str	r3, [sp, #0]
    db70:	0013      	movs	r3, r2
    db72:	2200      	movs	r2, #0
    db74:	2006      	movs	r0, #6
    db76:	f002 fcf5 	bl	10564 <USBPD_TRACE_Add>
            break;
    db7a:	e014      	b.n	dba6 <tcpc_set_pin_role+0xee>
          case TYPEC_CC_OPEN:
            FUSB307_DEBUG_TRACE(Port, FUSB307_DEBUG_LEVEL_0, "tcpc_set_pin_role(EN, OPEN)");
    db7c:	4b7d      	ldr	r3, [pc, #500]	; (dd74 <tcpc_set_pin_role+0x2bc>)
    db7e:	781b      	ldrb	r3, [r3, #0]
    db80:	001a      	movs	r2, r3
    db82:	2301      	movs	r3, #1
    db84:	4013      	ands	r3, r2
    db86:	d010      	beq.n	dbaa <tcpc_set_pin_role+0xf2>
    db88:	687b      	ldr	r3, [r7, #4]
    db8a:	b2d9      	uxtb	r1, r3
    db8c:	4a7d      	ldr	r2, [pc, #500]	; (dd84 <tcpc_set_pin_role+0x2cc>)
    db8e:	231b      	movs	r3, #27
    db90:	9300      	str	r3, [sp, #0]
    db92:	0013      	movs	r3, r2
    db94:	2200      	movs	r2, #0
    db96:	2006      	movs	r0, #6
    db98:	f002 fce4 	bl	10564 <USBPD_TRACE_Add>
            break;
    db9c:	e005      	b.n	dbaa <tcpc_set_pin_role+0xf2>
            break;
    db9e:	46c0      	nop			; (mov r8, r8)
    dba0:	e004      	b.n	dbac <tcpc_set_pin_role+0xf4>
            break;
    dba2:	46c0      	nop			; (mov r8, r8)
    dba4:	e002      	b.n	dbac <tcpc_set_pin_role+0xf4>
            break;
    dba6:	46c0      	nop			; (mov r8, r8)
    dba8:	e000      	b.n	dbac <tcpc_set_pin_role+0xf4>
            break;
    dbaa:	46c0      	nop			; (mov r8, r8)
    }
    else
#endif
    {
      /* Set role depending on polarity */
      if (state[Port].Registers.Control.s.u2.b2.PLUG_ORIENT == 0)
    dbac:	4970      	ldr	r1, [pc, #448]	; (dd70 <tcpc_set_pin_role+0x2b8>)
    dbae:	687a      	ldr	r2, [r7, #4]
    dbb0:	2010      	movs	r0, #16
    dbb2:	0013      	movs	r3, r2
    dbb4:	015b      	lsls	r3, r3, #5
    dbb6:	189b      	adds	r3, r3, r2
    dbb8:	009b      	lsls	r3, r3, #2
    dbba:	18cb      	adds	r3, r1, r3
    dbbc:	181b      	adds	r3, r3, r0
    dbbe:	78db      	ldrb	r3, [r3, #3]
    dbc0:	07db      	lsls	r3, r3, #31
    dbc2:	0fdb      	lsrs	r3, r3, #31
    dbc4:	b2db      	uxtb	r3, r3
    dbc6:	2b00      	cmp	r3, #0
    dbc8:	d10f      	bne.n	dbea <tcpc_set_pin_role+0x132>
      {
        /* PD communication set on CC1 */
        state[Port].Registers.Control.s.u3.ROLE_CONTROL = TCPC_REG_ROLE_CONTROL_SET(0, TYPEC_RP_VALUE_1P5A, Pull, TYPEC_CC_OPEN);
    dbca:	1cfb      	adds	r3, r7, #3
    dbcc:	781b      	ldrb	r3, [r3, #0]
    dbce:	221c      	movs	r2, #28
    dbd0:	4313      	orrs	r3, r2
    dbd2:	b2d8      	uxtb	r0, r3
    dbd4:	4966      	ldr	r1, [pc, #408]	; (dd70 <tcpc_set_pin_role+0x2b8>)
    dbd6:	687a      	ldr	r2, [r7, #4]
    dbd8:	0013      	movs	r3, r2
    dbda:	015b      	lsls	r3, r3, #5
    dbdc:	189b      	adds	r3, r3, r2
    dbde:	009b      	lsls	r3, r3, #2
    dbe0:	18cb      	adds	r3, r1, r3
    dbe2:	3314      	adds	r3, #20
    dbe4:	1c02      	adds	r2, r0, #0
    dbe6:	701a      	strb	r2, [r3, #0]
    dbe8:	e117      	b.n	de1a <tcpc_set_pin_role+0x362>
      }
      else
      {
        /* PD communication set on CC2 */
        state[Port].Registers.Control.s.u3.ROLE_CONTROL = TCPC_REG_ROLE_CONTROL_SET(0, TYPEC_RP_VALUE_1P5A, TYPEC_CC_OPEN, Pull);
    dbea:	1cfb      	adds	r3, r7, #3
    dbec:	781b      	ldrb	r3, [r3, #0]
    dbee:	009b      	lsls	r3, r3, #2
    dbf0:	b25b      	sxtb	r3, r3
    dbf2:	2213      	movs	r2, #19
    dbf4:	4313      	orrs	r3, r2
    dbf6:	b25b      	sxtb	r3, r3
    dbf8:	b2d8      	uxtb	r0, r3
    dbfa:	495d      	ldr	r1, [pc, #372]	; (dd70 <tcpc_set_pin_role+0x2b8>)
    dbfc:	687a      	ldr	r2, [r7, #4]
    dbfe:	0013      	movs	r3, r2
    dc00:	015b      	lsls	r3, r3, #5
    dc02:	189b      	adds	r3, r3, r2
    dc04:	009b      	lsls	r3, r3, #2
    dc06:	18cb      	adds	r3, r1, r3
    dc08:	3314      	adds	r3, #20
    dc0a:	1c02      	adds	r2, r0, #0
    dc0c:	701a      	strb	r2, [r3, #0]
    dc0e:	e104      	b.n	de1a <tcpc_set_pin_role+0x362>
      }
    }
  }
  else
  {
    if (state[Port].TogglingEnable == 1)
    dc10:	4957      	ldr	r1, [pc, #348]	; (dd70 <tcpc_set_pin_role+0x2b8>)
    dc12:	687a      	ldr	r2, [r7, #4]
    dc14:	2074      	movs	r0, #116	; 0x74
    dc16:	0013      	movs	r3, r2
    dc18:	015b      	lsls	r3, r3, #5
    dc1a:	189b      	adds	r3, r3, r2
    dc1c:	009b      	lsls	r3, r3, #2
    dc1e:	18cb      	adds	r3, r1, r3
    dc20:	181b      	adds	r3, r3, r0
    dc22:	781b      	ldrb	r3, [r3, #0]
    dc24:	2b01      	cmp	r3, #1
    dc26:	d143      	bne.n	dcb0 <tcpc_set_pin_role+0x1f8>
    {
      if (wasAWSnk)
    dc28:	230f      	movs	r3, #15
    dc2a:	18fb      	adds	r3, r7, r3
    dc2c:	781b      	ldrb	r3, [r3, #0]
    dc2e:	2b00      	cmp	r3, #0
    dc30:	d01f      	beq.n	dc72 <tcpc_set_pin_role+0x1ba>
      {
        state[Port].PowerRole = USBPD_PORTPOWERROLE_SRC;
    dc32:	494f      	ldr	r1, [pc, #316]	; (dd70 <tcpc_set_pin_role+0x2b8>)
    dc34:	687a      	ldr	r2, [r7, #4]
    dc36:	0013      	movs	r3, r2
    dc38:	015b      	lsls	r3, r3, #5
    dc3a:	189b      	adds	r3, r3, r2
    dc3c:	009b      	lsls	r3, r3, #2
    dc3e:	18cb      	adds	r3, r1, r3
    dc40:	3368      	adds	r3, #104	; 0x68
    dc42:	2201      	movs	r2, #1
    dc44:	601a      	str	r2, [r3, #0]
        state[Port].DataRole  = USBPD_PORTDATAROLE_DFP;
    dc46:	494a      	ldr	r1, [pc, #296]	; (dd70 <tcpc_set_pin_role+0x2b8>)
    dc48:	687a      	ldr	r2, [r7, #4]
    dc4a:	0013      	movs	r3, r2
    dc4c:	015b      	lsls	r3, r3, #5
    dc4e:	189b      	adds	r3, r3, r2
    dc50:	009b      	lsls	r3, r3, #2
    dc52:	18cb      	adds	r3, r1, r3
    dc54:	336c      	adds	r3, #108	; 0x6c
    dc56:	2201      	movs	r2, #1
    dc58:	601a      	str	r2, [r3, #0]
        state[Port].CC_Pull   = TYPEC_CC_RP;
    dc5a:	4945      	ldr	r1, [pc, #276]	; (dd70 <tcpc_set_pin_role+0x2b8>)
    dc5c:	687a      	ldr	r2, [r7, #4]
    dc5e:	2070      	movs	r0, #112	; 0x70
    dc60:	0013      	movs	r3, r2
    dc62:	015b      	lsls	r3, r3, #5
    dc64:	189b      	adds	r3, r3, r2
    dc66:	009b      	lsls	r3, r3, #2
    dc68:	18cb      	adds	r3, r1, r3
    dc6a:	181b      	adds	r3, r3, r0
    dc6c:	2201      	movs	r2, #1
    dc6e:	701a      	strb	r2, [r3, #0]
    dc70:	e01e      	b.n	dcb0 <tcpc_set_pin_role+0x1f8>
      }
      else
      {
        state[Port].PowerRole = USBPD_PORTPOWERROLE_SNK;
    dc72:	493f      	ldr	r1, [pc, #252]	; (dd70 <tcpc_set_pin_role+0x2b8>)
    dc74:	687a      	ldr	r2, [r7, #4]
    dc76:	0013      	movs	r3, r2
    dc78:	015b      	lsls	r3, r3, #5
    dc7a:	189b      	adds	r3, r3, r2
    dc7c:	009b      	lsls	r3, r3, #2
    dc7e:	18cb      	adds	r3, r1, r3
    dc80:	3368      	adds	r3, #104	; 0x68
    dc82:	2200      	movs	r2, #0
    dc84:	601a      	str	r2, [r3, #0]
        state[Port].DataRole  = USBPD_PORTDATAROLE_UFP;
    dc86:	493a      	ldr	r1, [pc, #232]	; (dd70 <tcpc_set_pin_role+0x2b8>)
    dc88:	687a      	ldr	r2, [r7, #4]
    dc8a:	0013      	movs	r3, r2
    dc8c:	015b      	lsls	r3, r3, #5
    dc8e:	189b      	adds	r3, r3, r2
    dc90:	009b      	lsls	r3, r3, #2
    dc92:	18cb      	adds	r3, r1, r3
    dc94:	336c      	adds	r3, #108	; 0x6c
    dc96:	2200      	movs	r2, #0
    dc98:	601a      	str	r2, [r3, #0]
        state[Port].CC_Pull   = TYPEC_CC_RD;
    dc9a:	4935      	ldr	r1, [pc, #212]	; (dd70 <tcpc_set_pin_role+0x2b8>)
    dc9c:	687a      	ldr	r2, [r7, #4]
    dc9e:	2070      	movs	r0, #112	; 0x70
    dca0:	0013      	movs	r3, r2
    dca2:	015b      	lsls	r3, r3, #5
    dca4:	189b      	adds	r3, r3, r2
    dca6:	009b      	lsls	r3, r3, #2
    dca8:	18cb      	adds	r3, r1, r3
    dcaa:	181b      	adds	r3, r3, r0
    dcac:	2202      	movs	r2, #2
    dcae:	701a      	strb	r2, [r3, #0]
      }
    }

#if defined(_TRACE)
  switch (state[Port].CC_Pull)
    dcb0:	492f      	ldr	r1, [pc, #188]	; (dd70 <tcpc_set_pin_role+0x2b8>)
    dcb2:	687a      	ldr	r2, [r7, #4]
    dcb4:	2070      	movs	r0, #112	; 0x70
    dcb6:	0013      	movs	r3, r2
    dcb8:	015b      	lsls	r3, r3, #5
    dcba:	189b      	adds	r3, r3, r2
    dcbc:	009b      	lsls	r3, r3, #2
    dcbe:	18cb      	adds	r3, r1, r3
    dcc0:	181b      	adds	r3, r3, r0
    dcc2:	781b      	ldrb	r3, [r3, #0]
    dcc4:	2b01      	cmp	r3, #1
    dcc6:	d019      	beq.n	dcfc <tcpc_set_pin_role+0x244>
    dcc8:	dc02      	bgt.n	dcd0 <tcpc_set_pin_role+0x218>
    dcca:	2b00      	cmp	r3, #0
    dccc:	d005      	beq.n	dcda <tcpc_set_pin_role+0x222>
    dcce:	e064      	b.n	dd9a <tcpc_set_pin_role+0x2e2>
    dcd0:	2b02      	cmp	r3, #2
    dcd2:	d024      	beq.n	dd1e <tcpc_set_pin_role+0x266>
    dcd4:	2b03      	cmp	r3, #3
    dcd6:	d033      	beq.n	dd40 <tcpc_set_pin_role+0x288>
    dcd8:	e05f      	b.n	dd9a <tcpc_set_pin_role+0x2e2>
  {
    case TYPEC_CC_RA:
      FUSB307_DEBUG_TRACE(Port, FUSB307_DEBUG_LEVEL_0, "tcpc_set_pin_role(DIS, RA)");
    dcda:	4b26      	ldr	r3, [pc, #152]	; (dd74 <tcpc_set_pin_role+0x2bc>)
    dcdc:	781b      	ldrb	r3, [r3, #0]
    dcde:	001a      	movs	r2, r3
    dce0:	2301      	movs	r3, #1
    dce2:	4013      	ands	r3, r2
    dce4:	d03d      	beq.n	dd62 <tcpc_set_pin_role+0x2aa>
    dce6:	687b      	ldr	r3, [r7, #4]
    dce8:	b2d9      	uxtb	r1, r3
    dcea:	4a27      	ldr	r2, [pc, #156]	; (dd88 <tcpc_set_pin_role+0x2d0>)
    dcec:	231a      	movs	r3, #26
    dcee:	9300      	str	r3, [sp, #0]
    dcf0:	0013      	movs	r3, r2
    dcf2:	2200      	movs	r2, #0
    dcf4:	2006      	movs	r0, #6
    dcf6:	f002 fc35 	bl	10564 <USBPD_TRACE_Add>
      break;
    dcfa:	e032      	b.n	dd62 <tcpc_set_pin_role+0x2aa>
    case TYPEC_CC_RP:
      FUSB307_DEBUG_TRACE(Port, FUSB307_DEBUG_LEVEL_0, "tcpc_set_pin_role(DIS, RP)");
    dcfc:	4b1d      	ldr	r3, [pc, #116]	; (dd74 <tcpc_set_pin_role+0x2bc>)
    dcfe:	781b      	ldrb	r3, [r3, #0]
    dd00:	001a      	movs	r2, r3
    dd02:	2301      	movs	r3, #1
    dd04:	4013      	ands	r3, r2
    dd06:	d02e      	beq.n	dd66 <tcpc_set_pin_role+0x2ae>
    dd08:	687b      	ldr	r3, [r7, #4]
    dd0a:	b2d9      	uxtb	r1, r3
    dd0c:	4a1f      	ldr	r2, [pc, #124]	; (dd8c <tcpc_set_pin_role+0x2d4>)
    dd0e:	231a      	movs	r3, #26
    dd10:	9300      	str	r3, [sp, #0]
    dd12:	0013      	movs	r3, r2
    dd14:	2200      	movs	r2, #0
    dd16:	2006      	movs	r0, #6
    dd18:	f002 fc24 	bl	10564 <USBPD_TRACE_Add>
      break;
    dd1c:	e023      	b.n	dd66 <tcpc_set_pin_role+0x2ae>
    case TYPEC_CC_RD:
      FUSB307_DEBUG_TRACE(Port, FUSB307_DEBUG_LEVEL_0, "tcpc_set_pin_role(DIS, RD)");
    dd1e:	4b15      	ldr	r3, [pc, #84]	; (dd74 <tcpc_set_pin_role+0x2bc>)
    dd20:	781b      	ldrb	r3, [r3, #0]
    dd22:	001a      	movs	r2, r3
    dd24:	2301      	movs	r3, #1
    dd26:	4013      	ands	r3, r2
    dd28:	d01f      	beq.n	dd6a <tcpc_set_pin_role+0x2b2>
    dd2a:	687b      	ldr	r3, [r7, #4]
    dd2c:	b2d9      	uxtb	r1, r3
    dd2e:	4a18      	ldr	r2, [pc, #96]	; (dd90 <tcpc_set_pin_role+0x2d8>)
    dd30:	231a      	movs	r3, #26
    dd32:	9300      	str	r3, [sp, #0]
    dd34:	0013      	movs	r3, r2
    dd36:	2200      	movs	r2, #0
    dd38:	2006      	movs	r0, #6
    dd3a:	f002 fc13 	bl	10564 <USBPD_TRACE_Add>
      break;
    dd3e:	e014      	b.n	dd6a <tcpc_set_pin_role+0x2b2>
    case TYPEC_CC_OPEN:
      FUSB307_DEBUG_TRACE(Port, FUSB307_DEBUG_LEVEL_0, "tcpc_set_pin_role(DIS, OPEN)");
    dd40:	4b0c      	ldr	r3, [pc, #48]	; (dd74 <tcpc_set_pin_role+0x2bc>)
    dd42:	781b      	ldrb	r3, [r3, #0]
    dd44:	001a      	movs	r2, r3
    dd46:	2301      	movs	r3, #1
    dd48:	4013      	ands	r3, r2
    dd4a:	d025      	beq.n	dd98 <tcpc_set_pin_role+0x2e0>
    dd4c:	687b      	ldr	r3, [r7, #4]
    dd4e:	b2d9      	uxtb	r1, r3
    dd50:	4a10      	ldr	r2, [pc, #64]	; (dd94 <tcpc_set_pin_role+0x2dc>)
    dd52:	231c      	movs	r3, #28
    dd54:	9300      	str	r3, [sp, #0]
    dd56:	0013      	movs	r3, r2
    dd58:	2200      	movs	r2, #0
    dd5a:	2006      	movs	r0, #6
    dd5c:	f002 fc02 	bl	10564 <USBPD_TRACE_Add>
      break;
    dd60:	e01a      	b.n	dd98 <tcpc_set_pin_role+0x2e0>
      break;
    dd62:	46c0      	nop			; (mov r8, r8)
    dd64:	e019      	b.n	dd9a <tcpc_set_pin_role+0x2e2>
      break;
    dd66:	46c0      	nop			; (mov r8, r8)
    dd68:	e017      	b.n	dd9a <tcpc_set_pin_role+0x2e2>
      break;
    dd6a:	46c0      	nop			; (mov r8, r8)
    dd6c:	e015      	b.n	dd9a <tcpc_set_pin_role+0x2e2>
    dd6e:	46c0      	nop			; (mov r8, r8)
    dd70:	000300b8 	.word	0x000300b8
    dd74:	0002febc 	.word	0x0002febc
    dd78:	0001f420 	.word	0x0001f420
    dd7c:	0001f43c 	.word	0x0001f43c
    dd80:	0001f458 	.word	0x0001f458
    dd84:	0001f474 	.word	0x0001f474
    dd88:	0001f490 	.word	0x0001f490
    dd8c:	0001f4ac 	.word	0x0001f4ac
    dd90:	0001f4c8 	.word	0x0001f4c8
    dd94:	0001f4e4 	.word	0x0001f4e4
      break;
    dd98:	46c0      	nop			; (mov r8, r8)
    }
#endif /* _TRACE */
    /* Set RP value to 0 to save power */
    state[Port].Registers.Control.s.u3.ROLE_CONTROL = TCPC_REG_ROLE_CONTROL_SET(state[Port].TogglingEnable, TYPEC_RP_VALUE_1P5A, state[Port].CC_Pull, state[Port].CC_Pull);
    dd9a:	492a      	ldr	r1, [pc, #168]	; (de44 <tcpc_set_pin_role+0x38c>)
    dd9c:	687a      	ldr	r2, [r7, #4]
    dd9e:	2074      	movs	r0, #116	; 0x74
    dda0:	0013      	movs	r3, r2
    dda2:	015b      	lsls	r3, r3, #5
    dda4:	189b      	adds	r3, r3, r2
    dda6:	009b      	lsls	r3, r3, #2
    dda8:	18cb      	adds	r3, r1, r3
    ddaa:	181b      	adds	r3, r3, r0
    ddac:	781b      	ldrb	r3, [r3, #0]
    ddae:	019b      	lsls	r3, r3, #6
    ddb0:	b25b      	sxtb	r3, r3
    ddb2:	2210      	movs	r2, #16
    ddb4:	4313      	orrs	r3, r2
    ddb6:	b259      	sxtb	r1, r3
    ddb8:	4822      	ldr	r0, [pc, #136]	; (de44 <tcpc_set_pin_role+0x38c>)
    ddba:	687a      	ldr	r2, [r7, #4]
    ddbc:	2470      	movs	r4, #112	; 0x70
    ddbe:	0013      	movs	r3, r2
    ddc0:	015b      	lsls	r3, r3, #5
    ddc2:	189b      	adds	r3, r3, r2
    ddc4:	009b      	lsls	r3, r3, #2
    ddc6:	18c3      	adds	r3, r0, r3
    ddc8:	191b      	adds	r3, r3, r4
    ddca:	781b      	ldrb	r3, [r3, #0]
    ddcc:	009b      	lsls	r3, r3, #2
    ddce:	b25b      	sxtb	r3, r3
    ddd0:	430b      	orrs	r3, r1
    ddd2:	b259      	sxtb	r1, r3
    ddd4:	481b      	ldr	r0, [pc, #108]	; (de44 <tcpc_set_pin_role+0x38c>)
    ddd6:	687a      	ldr	r2, [r7, #4]
    ddd8:	2470      	movs	r4, #112	; 0x70
    ddda:	0013      	movs	r3, r2
    dddc:	015b      	lsls	r3, r3, #5
    ddde:	189b      	adds	r3, r3, r2
    dde0:	009b      	lsls	r3, r3, #2
    dde2:	18c3      	adds	r3, r0, r3
    dde4:	191b      	adds	r3, r3, r4
    dde6:	781b      	ldrb	r3, [r3, #0]
    dde8:	b25b      	sxtb	r3, r3
    ddea:	430b      	orrs	r3, r1
    ddec:	b25b      	sxtb	r3, r3
    ddee:	b2d8      	uxtb	r0, r3
    ddf0:	4914      	ldr	r1, [pc, #80]	; (de44 <tcpc_set_pin_role+0x38c>)
    ddf2:	687a      	ldr	r2, [r7, #4]
    ddf4:	0013      	movs	r3, r2
    ddf6:	015b      	lsls	r3, r3, #5
    ddf8:	189b      	adds	r3, r3, r2
    ddfa:	009b      	lsls	r3, r3, #2
    ddfc:	18cb      	adds	r3, r1, r3
    ddfe:	3314      	adds	r3, #20
    de00:	1c02      	adds	r2, r0, #0
    de02:	701a      	strb	r2, [r3, #0]
    state[Port].TypeC_State = Unattached;
    de04:	490f      	ldr	r1, [pc, #60]	; (de44 <tcpc_set_pin_role+0x38c>)
    de06:	687a      	ldr	r2, [r7, #4]
    de08:	2072      	movs	r0, #114	; 0x72
    de0a:	0013      	movs	r3, r2
    de0c:	015b      	lsls	r3, r3, #5
    de0e:	189b      	adds	r3, r3, r2
    de10:	009b      	lsls	r3, r3, #2
    de12:	18cb      	adds	r3, r1, r3
    de14:	181b      	adds	r3, r3, r0
    de16:	2202      	movs	r2, #2
    de18:	701a      	strb	r2, [r3, #0]
  }
  USBPD_TCPCI_WriteRegister(Port, TCPC_REG_ROLE_CONTROL, &state[Port].Registers.Control.s.u3.ROLE_CONTROL, 1);
    de1a:	687b      	ldr	r3, [r7, #4]
    de1c:	b2d8      	uxtb	r0, r3
    de1e:	687a      	ldr	r2, [r7, #4]
    de20:	0013      	movs	r3, r2
    de22:	015b      	lsls	r3, r3, #5
    de24:	189b      	adds	r3, r3, r2
    de26:	009b      	lsls	r3, r3, #2
    de28:	3310      	adds	r3, #16
    de2a:	001a      	movs	r2, r3
    de2c:	4b05      	ldr	r3, [pc, #20]	; (de44 <tcpc_set_pin_role+0x38c>)
    de2e:	18d3      	adds	r3, r2, r3
    de30:	1d1a      	adds	r2, r3, #4
    de32:	2301      	movs	r3, #1
    de34:	211a      	movs	r1, #26
    de36:	f000 f8b7 	bl	dfa8 <USBPD_TCPCI_WriteRegister>
}
    de3a:	46c0      	nop			; (mov r8, r8)
    de3c:	46bd      	mov	sp, r7
    de3e:	b005      	add	sp, #20
    de40:	bd90      	pop	{r4, r7, pc}
    de42:	46c0      	nop			; (mov r8, r8)
    de44:	000300b8 	.word	0x000300b8

0000de48 <BSP_GetHWBoardVersionName>:
/**
  * @brief  This method returns HW board version name
  * @retval HW Board version name
  */
const uint8_t* BSP_GetHWBoardVersionName(void)
{
    de48:	b580      	push	{r7, lr}
    de4a:	af00      	add	r7, sp, #0
  return HWBoardVersionName;
    de4c:	4b01      	ldr	r3, [pc, #4]	; (de54 <BSP_GetHWBoardVersionName+0xc>)
}
    de4e:	0018      	movs	r0, r3
    de50:	46bd      	mov	sp, r7
    de52:	bd80      	pop	{r7, pc}
    de54:	0001f50c 	.word	0x0001f50c

0000de58 <BSP_GetPDTypeName>:
/**
  * @brief  This method returns HW PD Type name
  * @retval HW Board version name
  */
const uint8_t* BSP_GetPDTypeName(void)
{
    de58:	b580      	push	{r7, lr}
    de5a:	af00      	add	r7, sp, #0
  return PDTypeName;
    de5c:	4b01      	ldr	r3, [pc, #4]	; (de64 <BSP_GetPDTypeName+0xc>)
}
    de5e:	0018      	movs	r0, r3
    de60:	46bd      	mov	sp, r7
    de62:	bd80      	pop	{r7, pc}
    de64:	0001f518 	.word	0x0001f518

0000de68 <USBPD_TCPI_AlertInit>:
/** @defgroup STM32F0XX_NUCLEO_TCPI_Functions_Grp1 TCPI Exported Functions for I2C Link
  * @{
  */

void USBPD_TCPI_AlertInit(void)
{
    de68:	b580      	push	{r7, lr}
    de6a:	b086      	sub	sp, #24
    de6c:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef   GPIO_InitStructure;

  /* Enable GPIOC clock */
  ALERT_PORT0_GPIO_CLK_ENABLE();
    de6e:	4b15      	ldr	r3, [pc, #84]	; (dec4 <USBPD_TCPI_AlertInit+0x5c>)
    de70:	695a      	ldr	r2, [r3, #20]
    de72:	4b14      	ldr	r3, [pc, #80]	; (dec4 <USBPD_TCPI_AlertInit+0x5c>)
    de74:	2180      	movs	r1, #128	; 0x80
    de76:	0289      	lsls	r1, r1, #10
    de78:	430a      	orrs	r2, r1
    de7a:	615a      	str	r2, [r3, #20]
    de7c:	4b11      	ldr	r3, [pc, #68]	; (dec4 <USBPD_TCPI_AlertInit+0x5c>)
    de7e:	695a      	ldr	r2, [r3, #20]
    de80:	2380      	movs	r3, #128	; 0x80
    de82:	029b      	lsls	r3, r3, #10
    de84:	4013      	ands	r3, r2
    de86:	603b      	str	r3, [r7, #0]
    de88:	683b      	ldr	r3, [r7, #0]
#if USBPD_PORT_COUNT==2
  ALERT_PORT1_GPIO_CLK_ENABLE();
#endif /* USBPD_PORT_COUNT==2 */

  /* Configure PC.13 pin as input floating */
  GPIO_InitStructure.Mode = GPIO_MODE_IT_FALLING;
    de8a:	1d3b      	adds	r3, r7, #4
    de8c:	4a0e      	ldr	r2, [pc, #56]	; (dec8 <USBPD_TCPI_AlertInit+0x60>)
    de8e:	605a      	str	r2, [r3, #4]
  GPIO_InitStructure.Pull = GPIO_PULLUP;
    de90:	1d3b      	adds	r3, r7, #4
    de92:	2201      	movs	r2, #1
    de94:	609a      	str	r2, [r3, #8]
  GPIO_InitStructure.Pin = ALERT_PORT0_GPIO_PIN;
    de96:	1d3b      	adds	r3, r7, #4
    de98:	2280      	movs	r2, #128	; 0x80
    de9a:	0052      	lsls	r2, r2, #1
    de9c:	601a      	str	r2, [r3, #0]
  HAL_GPIO_Init(ALERT_PORT0_GPIO_PORT, &GPIO_InitStructure);
    de9e:	1d3a      	adds	r2, r7, #4
    dea0:	2390      	movs	r3, #144	; 0x90
    dea2:	05db      	lsls	r3, r3, #23
    dea4:	0011      	movs	r1, r2
    dea6:	0018      	movs	r0, r3
    dea8:	f000 fe9c 	bl	ebe4 <HAL_GPIO_Init>
  GPIO_InitStructure.Pin = ALERT_PORT1_GPIO_PIN;
  HAL_GPIO_Init(ALERT_PORT1_GPIO_PORT, &GPIO_InitStructure);
#endif /* USBPD_PORT_COUNT==2 */
  
  /* Enable and set EXTI line 2_3 Interrupt to the lowest priority */
  HAL_NVIC_SetPriority(ALERT_PORT0_EXTI_IRQn, 3, 0);
    deac:	2200      	movs	r2, #0
    deae:	2103      	movs	r1, #3
    deb0:	2007      	movs	r0, #7
    deb2:	f000 fc6b 	bl	e78c <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(ALERT_PORT0_EXTI_IRQn);
    deb6:	2007      	movs	r0, #7
    deb8:	f000 fc7d 	bl	e7b6 <HAL_NVIC_EnableIRQ>
#if USBPD_PORT_COUNT==2
  /* Enable and set EXTI line 0_1 Interrupt to the lowest priority */
  HAL_NVIC_SetPriority(ALERT_PORT1_EXTI_IRQn, 3, 0);
  HAL_NVIC_EnableIRQ(ALERT_PORT1_EXTI_IRQn);
#endif /* USBPD_PORT_COUNT==2 */
}
    debc:	46c0      	nop			; (mov r8, r8)
    debe:	46bd      	mov	sp, r7
    dec0:	b006      	add	sp, #24
    dec2:	bd80      	pop	{r7, pc}
    dec4:	40021000 	.word	0x40021000
    dec8:	10210000 	.word	0x10210000

0000decc <USBPD_TCPCI_Init>:

USBPD_StatusTypeDef USBPD_TCPCI_Init(void)
{
    decc:	b580      	push	{r7, lr}
    dece:	b082      	sub	sp, #8
    ded0:	af00      	add	r7, sp, #0
  USBPD_StatusTypeDef _retr = USBPD_OK;
    ded2:	1dfb      	adds	r3, r7, #7
    ded4:	2200      	movs	r2, #0
    ded6:	701a      	strb	r2, [r3, #0]

  for(uint32_t i= 0 ; i< USBPD_PORT_COUNT; i++)
    ded8:	2300      	movs	r3, #0
    deda:	603b      	str	r3, [r7, #0]
    dedc:	e007      	b.n	deee <USBPD_TCPCI_Init+0x22>
  {
    port_list[i].i2c_addr = 0;
    dede:	4b21      	ldr	r3, [pc, #132]	; (df64 <USBPD_TCPCI_Init+0x98>)
    dee0:	683a      	ldr	r2, [r7, #0]
    dee2:	0052      	lsls	r2, r2, #1
    dee4:	2100      	movs	r1, #0
    dee6:	52d1      	strh	r1, [r2, r3]
  for(uint32_t i= 0 ; i< USBPD_PORT_COUNT; i++)
    dee8:	683b      	ldr	r3, [r7, #0]
    deea:	3301      	adds	r3, #1
    deec:	603b      	str	r3, [r7, #0]
    deee:	683b      	ldr	r3, [r7, #0]
    def0:	2b00      	cmp	r3, #0
    def2:	d0f4      	beq.n	dede <USBPD_TCPCI_Init+0x12>
  }

  if( 0 != TCPI_Init(&hI2cHandle))
    def4:	4b1c      	ldr	r3, [pc, #112]	; (df68 <USBPD_TCPCI_Init+0x9c>)
    def6:	0018      	movs	r0, r3
    def8:	f000 faa0 	bl	e43c <TCPI_Init>
    defc:	1e03      	subs	r3, r0, #0
    defe:	d002      	beq.n	df06 <USBPD_TCPCI_Init+0x3a>
  {
    _retr = USBPD_FAIL;
    df00:	1dfb      	adds	r3, r7, #7
    df02:	2210      	movs	r2, #16
    df04:	701a      	strb	r2, [r3, #0]

#ifdef TCPC_FL7101
  Initial_FL7101();
#endif /* TCPC_FL7101 */
  
  port_list[USBPD_PORT_0].i2c_addr = I2C_SLAVE_ADDRESS_PORT0;
    df06:	4b17      	ldr	r3, [pc, #92]	; (df64 <USBPD_TCPCI_Init+0x98>)
    df08:	22a0      	movs	r2, #160	; 0xa0
    df0a:	801a      	strh	r2, [r3, #0]
  port_list[USBPD_PORT_1].i2c_addr = I2C_SLAVE_ADDRESS_PORT1;
#endif /* USBPD_PORT_COUNT == 2 */

#if defined(_RTOS)
  /* Init the I2C semaphores */
  if((sem_i2c_res_id = osSemaphoreCreate(osSemaphore(sem_i2c_res), 1)) == 0)
    df0c:	4b17      	ldr	r3, [pc, #92]	; (df6c <USBPD_TCPCI_Init+0xa0>)
    df0e:	2101      	movs	r1, #1
    df10:	0018      	movs	r0, r3
    df12:	f002 fce4 	bl	108de <osSemaphoreCreate>
    df16:	0002      	movs	r2, r0
    df18:	4b15      	ldr	r3, [pc, #84]	; (df70 <USBPD_TCPCI_Init+0xa4>)
    df1a:	601a      	str	r2, [r3, #0]
    df1c:	4b14      	ldr	r3, [pc, #80]	; (df70 <USBPD_TCPCI_Init+0xa4>)
    df1e:	681b      	ldr	r3, [r3, #0]
    df20:	2b00      	cmp	r3, #0
    df22:	d102      	bne.n	df2a <USBPD_TCPCI_Init+0x5e>
  {
    _retr = USBPD_FAIL;
    df24:	1dfb      	adds	r3, r7, #7
    df26:	2210      	movs	r2, #16
    df28:	701a      	strb	r2, [r3, #0]
  }

  if((sem_i2c_cplt_id = osSemaphoreCreate(osSemaphore(sem_i2c_cplt), 1)) == 0)
    df2a:	4b12      	ldr	r3, [pc, #72]	; (df74 <USBPD_TCPCI_Init+0xa8>)
    df2c:	2101      	movs	r1, #1
    df2e:	0018      	movs	r0, r3
    df30:	f002 fcd5 	bl	108de <osSemaphoreCreate>
    df34:	0002      	movs	r2, r0
    df36:	4b10      	ldr	r3, [pc, #64]	; (df78 <USBPD_TCPCI_Init+0xac>)
    df38:	601a      	str	r2, [r3, #0]
    df3a:	4b0f      	ldr	r3, [pc, #60]	; (df78 <USBPD_TCPCI_Init+0xac>)
    df3c:	681b      	ldr	r3, [r3, #0]
    df3e:	2b00      	cmp	r3, #0
    df40:	d102      	bne.n	df48 <USBPD_TCPCI_Init+0x7c>
  {
    _retr = USBPD_FAIL;
    df42:	1dfb      	adds	r3, r7, #7
    df44:	2210      	movs	r2, #16
    df46:	701a      	strb	r2, [r3, #0]
  }

  /* take the mutex_I2C_CPLT semaphores */
  osSemaphoreWait(sem_i2c_cplt_id, osWaitForever);
    df48:	4b0b      	ldr	r3, [pc, #44]	; (df78 <USBPD_TCPCI_Init+0xac>)
    df4a:	681a      	ldr	r2, [r3, #0]
    df4c:	2301      	movs	r3, #1
    df4e:	425b      	negs	r3, r3
    df50:	0019      	movs	r1, r3
    df52:	0010      	movs	r0, r2
    df54:	f002 fce2 	bl	1091c <osSemaphoreWait>
#else
  USBPD_TCPI_AlertInit();
#endif /* _RTOS */

  return _retr;
    df58:	1dfb      	adds	r3, r7, #7
    df5a:	781b      	ldrb	r3, [r3, #0]
}
    df5c:	0018      	movs	r0, r3
    df5e:	46bd      	mov	sp, r7
    df60:	b002      	add	sp, #8
    df62:	bd80      	pop	{r7, pc}
    df64:	00030140 	.word	0x00030140
    df68:	00032154 	.word	0x00032154
    df6c:	0001f504 	.word	0x0001f504
    df70:	000321a0 	.word	0x000321a0
    df74:	0001f508 	.word	0x0001f508
    df78:	00032150 	.word	0x00032150

0000df7c <USBPD_TCPCI_GetDevicesDrivers>:
  
  return _retr;
}

USBPD_StatusTypeDef USBPD_TCPCI_GetDevicesDrivers(uint8_t PortNum, TCPC_DrvTypeDef **TCPC_Driver)
{
    df7c:	b580      	push	{r7, lr}
    df7e:	b082      	sub	sp, #8
    df80:	af00      	add	r7, sp, #0
    df82:	0002      	movs	r2, r0
    df84:	6039      	str	r1, [r7, #0]
    df86:	1dfb      	adds	r3, r7, #7
    df88:	701a      	strb	r2, [r3, #0]
  *TCPC_Driver = DevicesDrivers[PortNum];
    df8a:	1dfb      	adds	r3, r7, #7
    df8c:	781a      	ldrb	r2, [r3, #0]
    df8e:	4b05      	ldr	r3, [pc, #20]	; (dfa4 <USBPD_TCPCI_GetDevicesDrivers+0x28>)
    df90:	0092      	lsls	r2, r2, #2
    df92:	58d2      	ldr	r2, [r2, r3]
    df94:	683b      	ldr	r3, [r7, #0]
    df96:	601a      	str	r2, [r3, #0]

  return USBPD_OK;
    df98:	2300      	movs	r3, #0
}
    df9a:	0018      	movs	r0, r3
    df9c:	46bd      	mov	sp, r7
    df9e:	b002      	add	sp, #8
    dfa0:	bd80      	pop	{r7, pc}
    dfa2:	46c0      	nop			; (mov r8, r8)
    dfa4:	0002fec0 	.word	0x0002fec0

0000dfa8 <USBPD_TCPCI_WriteRegister>:

USBPD_StatusTypeDef USBPD_TCPCI_WriteRegister(uint8_t port, uint8_t RegisterId, uint8_t *prtData, uint8_t datasize)
{
    dfa8:	b590      	push	{r4, r7, lr}
    dfaa:	b089      	sub	sp, #36	; 0x24
    dfac:	af04      	add	r7, sp, #16
    dfae:	0004      	movs	r4, r0
    dfb0:	0008      	movs	r0, r1
    dfb2:	603a      	str	r2, [r7, #0]
    dfb4:	0019      	movs	r1, r3
    dfb6:	1dfb      	adds	r3, r7, #7
    dfb8:	1c22      	adds	r2, r4, #0
    dfba:	701a      	strb	r2, [r3, #0]
    dfbc:	1dbb      	adds	r3, r7, #6
    dfbe:	1c02      	adds	r2, r0, #0
    dfc0:	701a      	strb	r2, [r3, #0]
    dfc2:	1d7b      	adds	r3, r7, #5
    dfc4:	1c0a      	adds	r2, r1, #0
    dfc6:	701a      	strb	r2, [r3, #0]
  USBPD_StatusTypeDef _retr = USBPD_OK;
    dfc8:	230f      	movs	r3, #15
    dfca:	18fb      	adds	r3, r7, r3
    dfcc:	2200      	movs	r2, #0
    dfce:	701a      	strb	r2, [r3, #0]
#ifdef TCPC_FL7101
  uint16_t w_reg;
#endif /* TCPC_FL7101 */

  /* Reserve the I2C ressource */
  LOCK_I2C_RESOURCE();
    dfd0:	4b17      	ldr	r3, [pc, #92]	; (e030 <USBPD_TCPCI_WriteRegister+0x88>)
    dfd2:	681a      	ldr	r2, [r3, #0]
    dfd4:	2301      	movs	r3, #1
    dfd6:	425b      	negs	r3, r3
    dfd8:	0019      	movs	r1, r3
    dfda:	0010      	movs	r0, r2
    dfdc:	f002 fc9e 	bl	1091c <osSemaphoreWait>
#endif /* TCPC_FL7101 */
  
#ifdef TCPC_FL7101
  if(HAL_OK != HAL_I2C_Mem_Write(&hI2cHandle, port_list[port].i2c_addr, w_reg, 2, prtData, datasize, 100 ))
#else
  if(HAL_OK != HAL_I2C_Mem_Write(&hI2cHandle, port_list[port].i2c_addr, RegisterId, 1,
    dfe0:	1dfb      	adds	r3, r7, #7
    dfe2:	781a      	ldrb	r2, [r3, #0]
    dfe4:	4b13      	ldr	r3, [pc, #76]	; (e034 <USBPD_TCPCI_WriteRegister+0x8c>)
    dfe6:	0052      	lsls	r2, r2, #1
    dfe8:	5ad1      	ldrh	r1, [r2, r3]
    dfea:	1dbb      	adds	r3, r7, #6
    dfec:	781b      	ldrb	r3, [r3, #0]
    dfee:	b29c      	uxth	r4, r3
    dff0:	1d7b      	adds	r3, r7, #5
    dff2:	781b      	ldrb	r3, [r3, #0]
    dff4:	b29b      	uxth	r3, r3
    dff6:	4810      	ldr	r0, [pc, #64]	; (e038 <USBPD_TCPCI_WriteRegister+0x90>)
    dff8:	2264      	movs	r2, #100	; 0x64
    dffa:	9202      	str	r2, [sp, #8]
    dffc:	9301      	str	r3, [sp, #4]
    dffe:	683b      	ldr	r3, [r7, #0]
    e000:	9300      	str	r3, [sp, #0]
    e002:	2301      	movs	r3, #1
    e004:	0022      	movs	r2, r4
    e006:	f000 ffff 	bl	f008 <HAL_I2C_Mem_Write>
    e00a:	1e03      	subs	r3, r0, #0
    e00c:	d003      	beq.n	e016 <USBPD_TCPCI_WriteRegister+0x6e>
                                     prtData, datasize, 100 ))
#endif /* TCPC_FL7101 */
  {
    _retr = USBPD_FAIL;
    e00e:	230f      	movs	r3, #15
    e010:	18fb      	adds	r3, r7, r3
    e012:	2210      	movs	r2, #16
    e014:	701a      	strb	r2, [r3, #0]
  }
  
  /* free the I2C ressource */
  UNLOCK_I2C_RESOURCE();
    e016:	4b06      	ldr	r3, [pc, #24]	; (e030 <USBPD_TCPCI_WriteRegister+0x88>)
    e018:	681b      	ldr	r3, [r3, #0]
    e01a:	0018      	movs	r0, r3
    e01c:	f002 fcc8 	bl	109b0 <osSemaphoreRelease>
  
  return _retr;
    e020:	230f      	movs	r3, #15
    e022:	18fb      	adds	r3, r7, r3
    e024:	781b      	ldrb	r3, [r3, #0]
}
    e026:	0018      	movs	r0, r3
    e028:	46bd      	mov	sp, r7
    e02a:	b005      	add	sp, #20
    e02c:	bd90      	pop	{r4, r7, pc}
    e02e:	46c0      	nop			; (mov r8, r8)
    e030:	000321a0 	.word	0x000321a0
    e034:	00030140 	.word	0x00030140
    e038:	00032154 	.word	0x00032154

0000e03c <USBPD_TCPCI_SendTransmitBuffer>:

USBPD_StatusTypeDef USBPD_TCPCI_SendTransmitBuffer(uint32_t Port, uint8_t RegisterId, uint8_t TransmitByteCount, uint16_t Header, uint8_t *pData)
{
    e03c:	b590      	push	{r4, r7, lr}
    e03e:	b089      	sub	sp, #36	; 0x24
    e040:	af04      	add	r7, sp, #16
    e042:	6078      	str	r0, [r7, #4]
    e044:	000c      	movs	r4, r1
    e046:	0010      	movs	r0, r2
    e048:	0019      	movs	r1, r3
    e04a:	1cfb      	adds	r3, r7, #3
    e04c:	1c22      	adds	r2, r4, #0
    e04e:	701a      	strb	r2, [r3, #0]
    e050:	1cbb      	adds	r3, r7, #2
    e052:	1c02      	adds	r2, r0, #0
    e054:	701a      	strb	r2, [r3, #0]
    e056:	003b      	movs	r3, r7
    e058:	1c0a      	adds	r2, r1, #0
    e05a:	801a      	strh	r2, [r3, #0]
#if defined(_TCPM_FUSB302)
#else
  USBPD_StatusTypeDef _retr = USBPD_OK;
    e05c:	230f      	movs	r3, #15
    e05e:	18fb      	adds	r3, r7, r3
    e060:	2200      	movs	r2, #0
    e062:	701a      	strb	r2, [r3, #0]
#ifdef TCPC_FL7101
  uint16_t w_reg;
#endif /* TCPC_FL7101 */

  /* Reserve the I2C ressource */
  LOCK_I2C_RESOURCE();
    e064:	4b30      	ldr	r3, [pc, #192]	; (e128 <USBPD_TCPCI_SendTransmitBuffer+0xec>)
    e066:	681a      	ldr	r2, [r3, #0]
    e068:	2301      	movs	r3, #1
    e06a:	425b      	negs	r3, r3
    e06c:	0019      	movs	r1, r3
    e06e:	0010      	movs	r0, r2
    e070:	f002 fc54 	bl	1091c <osSemaphoreWait>
      _retr = USBPD_FAIL;
      goto exit;
    }
  }
#else
    if(HAL_OK != HAL_I2C_Mem_Write(&hI2cHandle, port_list[Port].i2c_addr, RegisterId, 1,
    e074:	4b2d      	ldr	r3, [pc, #180]	; (e12c <USBPD_TCPCI_SendTransmitBuffer+0xf0>)
    e076:	687a      	ldr	r2, [r7, #4]
    e078:	0052      	lsls	r2, r2, #1
    e07a:	5ad1      	ldrh	r1, [r2, r3]
    e07c:	1cfb      	adds	r3, r7, #3
    e07e:	781b      	ldrb	r3, [r3, #0]
    e080:	b29a      	uxth	r2, r3
    e082:	482b      	ldr	r0, [pc, #172]	; (e130 <USBPD_TCPCI_SendTransmitBuffer+0xf4>)
    e084:	2364      	movs	r3, #100	; 0x64
    e086:	9302      	str	r3, [sp, #8]
    e088:	2301      	movs	r3, #1
    e08a:	9301      	str	r3, [sp, #4]
    e08c:	1cbb      	adds	r3, r7, #2
    e08e:	9300      	str	r3, [sp, #0]
    e090:	2301      	movs	r3, #1
    e092:	f000 ffb9 	bl	f008 <HAL_I2C_Mem_Write>
    e096:	1e03      	subs	r3, r0, #0
    e098:	d004      	beq.n	e0a4 <USBPD_TCPCI_SendTransmitBuffer+0x68>
                                       &TransmitByteCount, 1, 100 ))
    {
      _retr = USBPD_FAIL;
    e09a:	230f      	movs	r3, #15
    e09c:	18fb      	adds	r3, r7, r3
    e09e:	2210      	movs	r2, #16
    e0a0:	701a      	strb	r2, [r3, #0]
      goto exit;
    e0a2:	e034      	b.n	e10e <USBPD_TCPCI_SendTransmitBuffer+0xd2>
    }
    
    if(HAL_OK != HAL_I2C_Mem_Write(&hI2cHandle, port_list[Port].i2c_addr, TCPC_REG_TX_HEADER, 1,
    e0a4:	4b21      	ldr	r3, [pc, #132]	; (e12c <USBPD_TCPCI_SendTransmitBuffer+0xf0>)
    e0a6:	687a      	ldr	r2, [r7, #4]
    e0a8:	0052      	lsls	r2, r2, #1
    e0aa:	5ad1      	ldrh	r1, [r2, r3]
    e0ac:	4820      	ldr	r0, [pc, #128]	; (e130 <USBPD_TCPCI_SendTransmitBuffer+0xf4>)
    e0ae:	2364      	movs	r3, #100	; 0x64
    e0b0:	9302      	str	r3, [sp, #8]
    e0b2:	2302      	movs	r3, #2
    e0b4:	9301      	str	r3, [sp, #4]
    e0b6:	003b      	movs	r3, r7
    e0b8:	9300      	str	r3, [sp, #0]
    e0ba:	2301      	movs	r3, #1
    e0bc:	2252      	movs	r2, #82	; 0x52
    e0be:	f000 ffa3 	bl	f008 <HAL_I2C_Mem_Write>
    e0c2:	1e03      	subs	r3, r0, #0
    e0c4:	d004      	beq.n	e0d0 <USBPD_TCPCI_SendTransmitBuffer+0x94>
                                       (uint8_t*)&Header, 2, 100 ))
    {
      _retr = USBPD_FAIL;
    e0c6:	230f      	movs	r3, #15
    e0c8:	18fb      	adds	r3, r7, r3
    e0ca:	2210      	movs	r2, #16
    e0cc:	701a      	strb	r2, [r3, #0]
      goto exit;
    e0ce:	e01e      	b.n	e10e <USBPD_TCPCI_SendTransmitBuffer+0xd2>
    }
    
    if (TransmitByteCount > 2)
    e0d0:	1cbb      	adds	r3, r7, #2
    e0d2:	781b      	ldrb	r3, [r3, #0]
    e0d4:	2b02      	cmp	r3, #2
    e0d6:	d919      	bls.n	e10c <USBPD_TCPCI_SendTransmitBuffer+0xd0>
    {
      if(HAL_OK != HAL_I2C_Mem_Write(&hI2cHandle, port_list[Port].i2c_addr, TCPC_REG_TX_DATA, 1,
    e0d8:	4b14      	ldr	r3, [pc, #80]	; (e12c <USBPD_TCPCI_SendTransmitBuffer+0xf0>)
    e0da:	687a      	ldr	r2, [r7, #4]
    e0dc:	0052      	lsls	r2, r2, #1
    e0de:	5ad1      	ldrh	r1, [r2, r3]
    e0e0:	1cbb      	adds	r3, r7, #2
    e0e2:	781b      	ldrb	r3, [r3, #0]
    e0e4:	b29b      	uxth	r3, r3
    e0e6:	3b02      	subs	r3, #2
    e0e8:	b29b      	uxth	r3, r3
    e0ea:	4811      	ldr	r0, [pc, #68]	; (e130 <USBPD_TCPCI_SendTransmitBuffer+0xf4>)
    e0ec:	2264      	movs	r2, #100	; 0x64
    e0ee:	9202      	str	r2, [sp, #8]
    e0f0:	9301      	str	r3, [sp, #4]
    e0f2:	6a3b      	ldr	r3, [r7, #32]
    e0f4:	9300      	str	r3, [sp, #0]
    e0f6:	2301      	movs	r3, #1
    e0f8:	2254      	movs	r2, #84	; 0x54
    e0fa:	f000 ff85 	bl	f008 <HAL_I2C_Mem_Write>
    e0fe:	1e03      	subs	r3, r0, #0
    e100:	d004      	beq.n	e10c <USBPD_TCPCI_SendTransmitBuffer+0xd0>
                                         pData, (TransmitByteCount - 2), 100 ))
      {
        _retr = USBPD_FAIL;
    e102:	230f      	movs	r3, #15
    e104:	18fb      	adds	r3, r7, r3
    e106:	2210      	movs	r2, #16
    e108:	701a      	strb	r2, [r3, #0]
        goto exit;
    e10a:	e000      	b.n	e10e <USBPD_TCPCI_SendTransmitBuffer+0xd2>
      }
    }
#endif /* TCPC_FL7101 */

exit :  
    e10c:	46c0      	nop			; (mov r8, r8)
  /* free the I2C ressource */
  UNLOCK_I2C_RESOURCE();
    e10e:	4b06      	ldr	r3, [pc, #24]	; (e128 <USBPD_TCPCI_SendTransmitBuffer+0xec>)
    e110:	681b      	ldr	r3, [r3, #0]
    e112:	0018      	movs	r0, r3
    e114:	f002 fc4c 	bl	109b0 <osSemaphoreRelease>
#endif /* _TCPM_FUSB302 */
  
  return _retr;
    e118:	230f      	movs	r3, #15
    e11a:	18fb      	adds	r3, r7, r3
    e11c:	781b      	ldrb	r3, [r3, #0]
}
    e11e:	0018      	movs	r0, r3
    e120:	46bd      	mov	sp, r7
    e122:	b005      	add	sp, #20
    e124:	bd90      	pop	{r4, r7, pc}
    e126:	46c0      	nop			; (mov r8, r8)
    e128:	000321a0 	.word	0x000321a0
    e12c:	00030140 	.word	0x00030140
    e130:	00032154 	.word	0x00032154

0000e134 <USBPD_TCPCI_ReceiveBuffer>:

USBPD_StatusTypeDef USBPD_TCPCI_ReceiveBuffer(uint32_t Port, uint8_t RegisterId, uint8_t *Buffer, uint8_t *SOPType)
{
    e134:	b5b0      	push	{r4, r5, r7, lr}
    e136:	b08a      	sub	sp, #40	; 0x28
    e138:	af04      	add	r7, sp, #16
    e13a:	60f8      	str	r0, [r7, #12]
    e13c:	607a      	str	r2, [r7, #4]
    e13e:	603b      	str	r3, [r7, #0]
    e140:	240b      	movs	r4, #11
    e142:	193b      	adds	r3, r7, r4
    e144:	1c0a      	adds	r2, r1, #0
    e146:	701a      	strb	r2, [r3, #0]
  USBPD_StatusTypeDef _retr = USBPD_OK;
    e148:	2317      	movs	r3, #23
    e14a:	18fb      	adds	r3, r7, r3
    e14c:	2200      	movs	r2, #0
    e14e:	701a      	strb	r2, [r3, #0]
#if defined(_TCPM_FUSB302)
#else
  uint8_t count = 0;
    e150:	2516      	movs	r5, #22
    e152:	197b      	adds	r3, r7, r5
    e154:	2200      	movs	r2, #0
    e156:	701a      	strb	r2, [r3, #0]
#ifdef TCPC_FL7101
  uint16_t w_reg;
#endif /* TCPC_FL7101 */

  /* Reserve the I2C ressource */
  LOCK_I2C_RESOURCE();
    e158:	4b31      	ldr	r3, [pc, #196]	; (e220 <USBPD_TCPCI_ReceiveBuffer+0xec>)
    e15a:	681a      	ldr	r2, [r3, #0]
    e15c:	2301      	movs	r3, #1
    e15e:	425b      	negs	r3, r3
    e160:	0019      	movs	r1, r3
    e162:	0010      	movs	r0, r2
    e164:	f002 fbda 	bl	1091c <osSemaphoreWait>
      _retr = USBPD_FAIL;
      goto exit;
    }
  }
#else
  if(HAL_OK != HAL_I2C_Mem_Read(&hI2cHandle, port_list[Port].i2c_addr, RegisterId, 1,
    e168:	4b2e      	ldr	r3, [pc, #184]	; (e224 <USBPD_TCPCI_ReceiveBuffer+0xf0>)
    e16a:	68fa      	ldr	r2, [r7, #12]
    e16c:	0052      	lsls	r2, r2, #1
    e16e:	5ad1      	ldrh	r1, [r2, r3]
    e170:	193b      	adds	r3, r7, r4
    e172:	781b      	ldrb	r3, [r3, #0]
    e174:	b29a      	uxth	r2, r3
    e176:	482c      	ldr	r0, [pc, #176]	; (e228 <USBPD_TCPCI_ReceiveBuffer+0xf4>)
    e178:	2364      	movs	r3, #100	; 0x64
    e17a:	9302      	str	r3, [sp, #8]
    e17c:	2301      	movs	r3, #1
    e17e:	9301      	str	r3, [sp, #4]
    e180:	197b      	adds	r3, r7, r5
    e182:	9300      	str	r3, [sp, #0]
    e184:	2301      	movs	r3, #1
    e186:	f001 f87f 	bl	f288 <HAL_I2C_Mem_Read>
    e18a:	1e03      	subs	r3, r0, #0
    e18c:	d004      	beq.n	e198 <USBPD_TCPCI_ReceiveBuffer+0x64>
                                     &count, 1, 100 ))
  {
    _retr = USBPD_FAIL;
    e18e:	2317      	movs	r3, #23
    e190:	18fb      	adds	r3, r7, r3
    e192:	2210      	movs	r2, #16
    e194:	701a      	strb	r2, [r3, #0]
    goto exit;
    e196:	e036      	b.n	e206 <USBPD_TCPCI_ReceiveBuffer+0xd2>
  }
  if(HAL_OK != HAL_I2C_Mem_Read(&hI2cHandle, port_list[Port].i2c_addr, TCPC_REG_RX_BUFFER_FRAME_TYPE, 1,
    e198:	4b22      	ldr	r3, [pc, #136]	; (e224 <USBPD_TCPCI_ReceiveBuffer+0xf0>)
    e19a:	68fa      	ldr	r2, [r7, #12]
    e19c:	0052      	lsls	r2, r2, #1
    e19e:	5ad1      	ldrh	r1, [r2, r3]
    e1a0:	4821      	ldr	r0, [pc, #132]	; (e228 <USBPD_TCPCI_ReceiveBuffer+0xf4>)
    e1a2:	2364      	movs	r3, #100	; 0x64
    e1a4:	9302      	str	r3, [sp, #8]
    e1a6:	2301      	movs	r3, #1
    e1a8:	9301      	str	r3, [sp, #4]
    e1aa:	683b      	ldr	r3, [r7, #0]
    e1ac:	9300      	str	r3, [sp, #0]
    e1ae:	2301      	movs	r3, #1
    e1b0:	2231      	movs	r2, #49	; 0x31
    e1b2:	f001 f869 	bl	f288 <HAL_I2C_Mem_Read>
    e1b6:	1e03      	subs	r3, r0, #0
    e1b8:	d004      	beq.n	e1c4 <USBPD_TCPCI_ReceiveBuffer+0x90>
                                     SOPType, 1, 100 ))
  {
    _retr = USBPD_FAIL;
    e1ba:	2317      	movs	r3, #23
    e1bc:	18fb      	adds	r3, r7, r3
    e1be:	2210      	movs	r2, #16
    e1c0:	701a      	strb	r2, [r3, #0]
    goto exit;
    e1c2:	e020      	b.n	e206 <USBPD_TCPCI_ReceiveBuffer+0xd2>
  }
  
  if (count != 0)
    e1c4:	2316      	movs	r3, #22
    e1c6:	18fb      	adds	r3, r7, r3
    e1c8:	781b      	ldrb	r3, [r3, #0]
    e1ca:	2b00      	cmp	r3, #0
    e1cc:	d01a      	beq.n	e204 <USBPD_TCPCI_ReceiveBuffer+0xd0>
  {
    if(HAL_OK != HAL_I2C_Mem_Read(&hI2cHandle, port_list[Port].i2c_addr, TCPC_REG_RX_HEADER, 1,
    e1ce:	4b15      	ldr	r3, [pc, #84]	; (e224 <USBPD_TCPCI_ReceiveBuffer+0xf0>)
    e1d0:	68fa      	ldr	r2, [r7, #12]
    e1d2:	0052      	lsls	r2, r2, #1
    e1d4:	5ad1      	ldrh	r1, [r2, r3]
    e1d6:	2316      	movs	r3, #22
    e1d8:	18fb      	adds	r3, r7, r3
    e1da:	781b      	ldrb	r3, [r3, #0]
    e1dc:	b29b      	uxth	r3, r3
    e1de:	3b01      	subs	r3, #1
    e1e0:	b29b      	uxth	r3, r3
    e1e2:	4811      	ldr	r0, [pc, #68]	; (e228 <USBPD_TCPCI_ReceiveBuffer+0xf4>)
    e1e4:	2264      	movs	r2, #100	; 0x64
    e1e6:	9202      	str	r2, [sp, #8]
    e1e8:	9301      	str	r3, [sp, #4]
    e1ea:	687b      	ldr	r3, [r7, #4]
    e1ec:	9300      	str	r3, [sp, #0]
    e1ee:	2301      	movs	r3, #1
    e1f0:	2232      	movs	r2, #50	; 0x32
    e1f2:	f001 f849 	bl	f288 <HAL_I2C_Mem_Read>
    e1f6:	1e03      	subs	r3, r0, #0
    e1f8:	d004      	beq.n	e204 <USBPD_TCPCI_ReceiveBuffer+0xd0>
                                  Buffer, (count - 1), 100 ))
    {
      _retr = USBPD_FAIL;
    e1fa:	2317      	movs	r3, #23
    e1fc:	18fb      	adds	r3, r7, r3
    e1fe:	2210      	movs	r2, #16
    e200:	701a      	strb	r2, [r3, #0]
      goto exit;
    e202:	e000      	b.n	e206 <USBPD_TCPCI_ReceiveBuffer+0xd2>
    }
  }
#endif /* TCPC_FL7101 */
exit :  
    e204:	46c0      	nop			; (mov r8, r8)
  /* free the I2C ressource */
  UNLOCK_I2C_RESOURCE();
    e206:	4b06      	ldr	r3, [pc, #24]	; (e220 <USBPD_TCPCI_ReceiveBuffer+0xec>)
    e208:	681b      	ldr	r3, [r3, #0]
    e20a:	0018      	movs	r0, r3
    e20c:	f002 fbd0 	bl	109b0 <osSemaphoreRelease>
#endif /* _TCPM_FUSB302 */
  
  return _retr;
    e210:	2317      	movs	r3, #23
    e212:	18fb      	adds	r3, r7, r3
    e214:	781b      	ldrb	r3, [r3, #0]
}
    e216:	0018      	movs	r0, r3
    e218:	46bd      	mov	sp, r7
    e21a:	b006      	add	sp, #24
    e21c:	bdb0      	pop	{r4, r5, r7, pc}
    e21e:	46c0      	nop			; (mov r8, r8)
    e220:	000321a0 	.word	0x000321a0
    e224:	00030140 	.word	0x00030140
    e228:	00032154 	.word	0x00032154

0000e22c <USBPD_TCPCI_ReadRegister>:
  return _retr;
}
#endif /* _TCPM_FUSB302 */

USBPD_StatusTypeDef USBPD_TCPCI_ReadRegister(uint8_t Port, uint8_t RegisterId, uint8_t *prtData, uint8_t datasize)
{
    e22c:	b590      	push	{r4, r7, lr}
    e22e:	b089      	sub	sp, #36	; 0x24
    e230:	af04      	add	r7, sp, #16
    e232:	0004      	movs	r4, r0
    e234:	0008      	movs	r0, r1
    e236:	603a      	str	r2, [r7, #0]
    e238:	0019      	movs	r1, r3
    e23a:	1dfb      	adds	r3, r7, #7
    e23c:	1c22      	adds	r2, r4, #0
    e23e:	701a      	strb	r2, [r3, #0]
    e240:	1dbb      	adds	r3, r7, #6
    e242:	1c02      	adds	r2, r0, #0
    e244:	701a      	strb	r2, [r3, #0]
    e246:	1d7b      	adds	r3, r7, #5
    e248:	1c0a      	adds	r2, r1, #0
    e24a:	701a      	strb	r2, [r3, #0]
  USBPD_StatusTypeDef _retr = USBPD_OK;
    e24c:	230f      	movs	r3, #15
    e24e:	18fb      	adds	r3, r7, r3
    e250:	2200      	movs	r2, #0
    e252:	701a      	strb	r2, [r3, #0]
#ifdef TCPC_FL7101
  uint16_t w_reg;
#endif /* TCPC_FL7101 */

  /* Reserve the I2C ressource */
  LOCK_I2C_RESOURCE();
    e254:	4b17      	ldr	r3, [pc, #92]	; (e2b4 <USBPD_TCPCI_ReadRegister+0x88>)
    e256:	681a      	ldr	r2, [r3, #0]
    e258:	2301      	movs	r3, #1
    e25a:	425b      	negs	r3, r3
    e25c:	0019      	movs	r1, r3
    e25e:	0010      	movs	r0, r2
    e260:	f002 fb5c 	bl	1091c <osSemaphoreWait>
#endif /* TCPC_FL7101 */

#ifdef TCPC_FL7101
  if(HAL_OK != HAL_I2C_Mem_Read(&hI2cHandle, port_list[Port].i2c_addr, w_reg, 2, prtData, datasize, 100 ))
#else
  if(HAL_OK != HAL_I2C_Mem_Read(&hI2cHandle, port_list[Port].i2c_addr, RegisterId, 1,
    e264:	1dfb      	adds	r3, r7, #7
    e266:	781a      	ldrb	r2, [r3, #0]
    e268:	4b13      	ldr	r3, [pc, #76]	; (e2b8 <USBPD_TCPCI_ReadRegister+0x8c>)
    e26a:	0052      	lsls	r2, r2, #1
    e26c:	5ad1      	ldrh	r1, [r2, r3]
    e26e:	1dbb      	adds	r3, r7, #6
    e270:	781b      	ldrb	r3, [r3, #0]
    e272:	b29c      	uxth	r4, r3
    e274:	1d7b      	adds	r3, r7, #5
    e276:	781b      	ldrb	r3, [r3, #0]
    e278:	b29b      	uxth	r3, r3
    e27a:	4810      	ldr	r0, [pc, #64]	; (e2bc <USBPD_TCPCI_ReadRegister+0x90>)
    e27c:	2264      	movs	r2, #100	; 0x64
    e27e:	9202      	str	r2, [sp, #8]
    e280:	9301      	str	r3, [sp, #4]
    e282:	683b      	ldr	r3, [r7, #0]
    e284:	9300      	str	r3, [sp, #0]
    e286:	2301      	movs	r3, #1
    e288:	0022      	movs	r2, r4
    e28a:	f000 fffd 	bl	f288 <HAL_I2C_Mem_Read>
    e28e:	1e03      	subs	r3, r0, #0
    e290:	d003      	beq.n	e29a <USBPD_TCPCI_ReadRegister+0x6e>
                                     prtData, datasize, 100 ))
#endif
  {
    _retr = USBPD_FAIL;
    e292:	230f      	movs	r3, #15
    e294:	18fb      	adds	r3, r7, r3
    e296:	2210      	movs	r2, #16
    e298:	701a      	strb	r2, [r3, #0]
  }

  /* free the I2C ressource */
  UNLOCK_I2C_RESOURCE();
    e29a:	4b06      	ldr	r3, [pc, #24]	; (e2b4 <USBPD_TCPCI_ReadRegister+0x88>)
    e29c:	681b      	ldr	r3, [r3, #0]
    e29e:	0018      	movs	r0, r3
    e2a0:	f002 fb86 	bl	109b0 <osSemaphoreRelease>

  return _retr;
    e2a4:	230f      	movs	r3, #15
    e2a6:	18fb      	adds	r3, r7, r3
    e2a8:	781b      	ldrb	r3, [r3, #0]
}
    e2aa:	0018      	movs	r0, r3
    e2ac:	46bd      	mov	sp, r7
    e2ae:	b005      	add	sp, #20
    e2b0:	bd90      	pop	{r4, r7, pc}
    e2b2:	46c0      	nop			; (mov r8, r8)
    e2b4:	000321a0 	.word	0x000321a0
    e2b8:	00030140 	.word	0x00030140
    e2bc:	00032154 	.word	0x00032154

0000e2c0 <USBPD_TCPCI_Delay>:

void USBPD_TCPCI_Delay(uint32_t Delay)
{
    e2c0:	b580      	push	{r7, lr}
    e2c2:	b082      	sub	sp, #8
    e2c4:	af00      	add	r7, sp, #0
    e2c6:	6078      	str	r0, [r7, #4]
  HAL_Delay(Delay);
    e2c8:	687b      	ldr	r3, [r7, #4]
    e2ca:	0018      	movs	r0, r3
    e2cc:	f000 f984 	bl	e5d8 <HAL_Delay>
}
    e2d0:	46c0      	nop			; (mov r8, r8)
    e2d2:	46bd      	mov	sp, r7
    e2d4:	b002      	add	sp, #8
    e2d6:	bd80      	pop	{r7, pc}

0000e2d8 <HW_IF_PWR_SetVoltage>:
/** @defgroup STM32F0XX_NUCLEO_TCPI_Functions_Grp2 TCPI Exported function for PWR
  * @{
  */

USBPD_StatusTypeDef HW_IF_PWR_SetVoltage(uint8_t PortNum, uint16_t voltage)
{
    e2d8:	b580      	push	{r7, lr}
    e2da:	b082      	sub	sp, #8
    e2dc:	af00      	add	r7, sp, #0
    e2de:	0002      	movs	r2, r0
    e2e0:	1dfb      	adds	r3, r7, #7
    e2e2:	701a      	strb	r2, [r3, #0]
    e2e4:	1d3b      	adds	r3, r7, #4
    e2e6:	1c0a      	adds	r2, r1, #0
    e2e8:	801a      	strh	r2, [r3, #0]
#ifdef TCPC_FL7101
  PV2105_Set_Output_Voltage(Port, Voltage);
#endif /* TCPC_FL7101 */
  return USBPD_OK;
    e2ea:	2300      	movs	r3, #0
}
    e2ec:	0018      	movs	r0, r3
    e2ee:	46bd      	mov	sp, r7
    e2f0:	b002      	add	sp, #8
    e2f2:	bd80      	pop	{r7, pc}

0000e2f4 <HW_IF_PWR_GetVoltage>:

uint16_t HW_IF_PWR_GetVoltage(uint8_t PortNum)
{
    e2f4:	b580      	push	{r7, lr}
    e2f6:	b082      	sub	sp, #8
    e2f8:	af00      	add	r7, sp, #0
    e2fa:	0002      	movs	r2, r0
    e2fc:	1dfb      	adds	r3, r7, #7
    e2fe:	701a      	strb	r2, [r3, #0]
  return USBPD_TCPM_VBUS_GetVoltage(PortNum);
    e300:	1dfb      	adds	r3, r7, #7
    e302:	781b      	ldrb	r3, [r3, #0]
    e304:	0018      	movs	r0, r3
    e306:	f00f fdb8 	bl	1de7a <USBPD_TCPM_VBUS_GetVoltage>
    e30a:	0003      	movs	r3, r0
}
    e30c:	0018      	movs	r0, r3
    e30e:	46bd      	mov	sp, r7
    e310:	b002      	add	sp, #8
    e312:	bd80      	pop	{r7, pc}

0000e314 <HW_IF_PWR_GetCurrent>:

int16_t HW_IF_PWR_GetCurrent(uint8_t PortNum)
{
    e314:	b580      	push	{r7, lr}
    e316:	b082      	sub	sp, #8
    e318:	af00      	add	r7, sp, #0
    e31a:	0002      	movs	r2, r0
    e31c:	1dfb      	adds	r3, r7, #7
    e31e:	701a      	strb	r2, [r3, #0]
  return 0;
    e320:	2300      	movs	r3, #0
}
    e322:	0018      	movs	r0, r3
    e324:	46bd      	mov	sp, r7
    e326:	b002      	add	sp, #8
    e328:	bd80      	pop	{r7, pc}
	...

0000e32c <HW_IF_PWR_Enable>:

USBPD_StatusTypeDef HW_IF_PWR_Enable(uint8_t PortNum, USBPD_FunctionalState state, CCxPin_TypeDef Cc, uint32_t VconnState, USBPD_PortPowerRole_TypeDef role)
{
    e32c:	b590      	push	{r4, r7, lr}
    e32e:	b089      	sub	sp, #36	; 0x24
    e330:	af02      	add	r7, sp, #8
    e332:	60ba      	str	r2, [r7, #8]
    e334:	607b      	str	r3, [r7, #4]
    e336:	230f      	movs	r3, #15
    e338:	18fb      	adds	r3, r7, r3
    e33a:	1c02      	adds	r2, r0, #0
    e33c:	701a      	strb	r2, [r3, #0]
    e33e:	200e      	movs	r0, #14
    e340:	183b      	adds	r3, r7, r0
    e342:	1c0a      	adds	r2, r1, #0
    e344:	701a      	strb	r2, [r3, #0]
  USBPD_StatusTypeDef status;
  if(USBPD_ENABLE == state)
    e346:	183b      	adds	r3, r7, r0
    e348:	781b      	ldrb	r3, [r3, #0]
    e34a:	2b01      	cmp	r3, #1
    e34c:	d129      	bne.n	e3a2 <HW_IF_PWR_Enable+0x76>
  {
    POWER_DEBUG("VBUS ON", 7);
    e34e:	4a2d      	ldr	r2, [pc, #180]	; (e404 <HW_IF_PWR_Enable+0xd8>)
    e350:	230f      	movs	r3, #15
    e352:	18fb      	adds	r3, r7, r3
    e354:	7819      	ldrb	r1, [r3, #0]
    e356:	2307      	movs	r3, #7
    e358:	9300      	str	r3, [sp, #0]
    e35a:	0013      	movs	r3, r2
    e35c:	2200      	movs	r2, #0
    e35e:	2006      	movs	r0, #6
    e360:	f002 f900 	bl	10564 <USBPD_TRACE_Add>
    if (USBPD_TRUE == VconnState)
    e364:	687b      	ldr	r3, [r7, #4]
    e366:	2b01      	cmp	r3, #1
    e368:	d110      	bne.n	e38c <HW_IF_PWR_Enable+0x60>
    {
      POWER_DEBUG("VCONN ON", 8);
    e36a:	4a27      	ldr	r2, [pc, #156]	; (e408 <HW_IF_PWR_Enable+0xdc>)
    e36c:	240f      	movs	r4, #15
    e36e:	193b      	adds	r3, r7, r4
    e370:	7819      	ldrb	r1, [r3, #0]
    e372:	2308      	movs	r3, #8
    e374:	9300      	str	r3, [sp, #0]
    e376:	0013      	movs	r3, r2
    e378:	2200      	movs	r2, #0
    e37a:	2006      	movs	r0, #6
    e37c:	f002 f8f2 	bl	10564 <USBPD_TRACE_Add>
      /* Enable VConn */
      USBPD_TCPM_set_vconn(PortNum, USBPD_ENABLE);
    e380:	193b      	adds	r3, r7, r4
    e382:	781b      	ldrb	r3, [r3, #0]
    e384:	2101      	movs	r1, #1
    e386:	0018      	movs	r0, r3
    e388:	f00f ff7c 	bl	1e284 <USBPD_TCPM_set_vconn>
    }
    status = USBPD_TCPM_VBUS_Enable(PortNum);
    e38c:	230f      	movs	r3, #15
    e38e:	18fb      	adds	r3, r7, r3
    e390:	781b      	ldrb	r3, [r3, #0]
    e392:	2217      	movs	r2, #23
    e394:	18bc      	adds	r4, r7, r2
    e396:	0018      	movs	r0, r3
    e398:	f00f fdb4 	bl	1df04 <USBPD_TCPM_VBUS_Enable>
    e39c:	0003      	movs	r3, r0
    e39e:	7023      	strb	r3, [r4, #0]
    e3a0:	e028      	b.n	e3f4 <HW_IF_PWR_Enable+0xc8>
  }
  else
  {
    POWER_DEBUG("VBUS OFF", 8);
    e3a2:	4a1a      	ldr	r2, [pc, #104]	; (e40c <HW_IF_PWR_Enable+0xe0>)
    e3a4:	230f      	movs	r3, #15
    e3a6:	18fb      	adds	r3, r7, r3
    e3a8:	7819      	ldrb	r1, [r3, #0]
    e3aa:	2308      	movs	r3, #8
    e3ac:	9300      	str	r3, [sp, #0]
    e3ae:	0013      	movs	r3, r2
    e3b0:	2200      	movs	r2, #0
    e3b2:	2006      	movs	r0, #6
    e3b4:	f002 f8d6 	bl	10564 <USBPD_TRACE_Add>
    if (USBPD_TRUE == VconnState)
    e3b8:	687b      	ldr	r3, [r7, #4]
    e3ba:	2b01      	cmp	r3, #1
    e3bc:	d110      	bne.n	e3e0 <HW_IF_PWR_Enable+0xb4>
    {
      POWER_DEBUG("VCONN OFF", 9);
    e3be:	4a14      	ldr	r2, [pc, #80]	; (e410 <HW_IF_PWR_Enable+0xe4>)
    e3c0:	240f      	movs	r4, #15
    e3c2:	193b      	adds	r3, r7, r4
    e3c4:	7819      	ldrb	r1, [r3, #0]
    e3c6:	2309      	movs	r3, #9
    e3c8:	9300      	str	r3, [sp, #0]
    e3ca:	0013      	movs	r3, r2
    e3cc:	2200      	movs	r2, #0
    e3ce:	2006      	movs	r0, #6
    e3d0:	f002 f8c8 	bl	10564 <USBPD_TRACE_Add>
      USBPD_TCPM_set_vconn(PortNum, USBPD_DISABLE);
    e3d4:	193b      	adds	r3, r7, r4
    e3d6:	781b      	ldrb	r3, [r3, #0]
    e3d8:	2100      	movs	r1, #0
    e3da:	0018      	movs	r0, r3
    e3dc:	f00f ff52 	bl	1e284 <USBPD_TCPM_set_vconn>
    }
    status = USBPD_TCPM_VBUS_Disable(PortNum);
    e3e0:	230f      	movs	r3, #15
    e3e2:	18fb      	adds	r3, r7, r3
    e3e4:	781b      	ldrb	r3, [r3, #0]
    e3e6:	2217      	movs	r2, #23
    e3e8:	18bc      	adds	r4, r7, r2
    e3ea:	0018      	movs	r0, r3
    e3ec:	f00f fd8d 	bl	1df0a <USBPD_TCPM_VBUS_Disable>
    e3f0:	0003      	movs	r3, r0
    e3f2:	7023      	strb	r3, [r4, #0]
  }
  return status;
    e3f4:	2317      	movs	r3, #23
    e3f6:	18fb      	adds	r3, r7, r3
    e3f8:	781b      	ldrb	r3, [r3, #0]
}
    e3fa:	0018      	movs	r0, r3
    e3fc:	46bd      	mov	sp, r7
    e3fe:	b007      	add	sp, #28
    e400:	bd90      	pop	{r4, r7, pc}
    e402:	46c0      	nop			; (mov r8, r8)
    e404:	0001f520 	.word	0x0001f520
    e408:	0001f528 	.word	0x0001f528
    e40c:	0001f534 	.word	0x0001f534
    e410:	0001f540 	.word	0x0001f540

0000e414 <HW_IF_PWR_VBUSIsEnabled>:

USBPD_FunctionalState HW_IF_PWR_VBUSIsEnabled(uint8_t PortNum)
{
    e414:	b580      	push	{r7, lr}
    e416:	b082      	sub	sp, #8
    e418:	af00      	add	r7, sp, #0
    e41a:	0002      	movs	r2, r0
    e41c:	1dfb      	adds	r3, r7, #7
    e41e:	701a      	strb	r2, [r3, #0]
  return ((USBPD_OK == USBPD_TCPM_VBUS_IsVsafe5V(PortNum)) ? USBPD_ENABLE : USBPD_DISABLE);
    e420:	1dfb      	adds	r3, r7, #7
    e422:	781b      	ldrb	r3, [r3, #0]
    e424:	0018      	movs	r0, r3
    e426:	f00f fd57 	bl	1ded8 <USBPD_TCPM_VBUS_IsVsafe5V>
    e42a:	0003      	movs	r3, r0
    e42c:	425a      	negs	r2, r3
    e42e:	4153      	adcs	r3, r2
    e430:	b2db      	uxtb	r3, r3
}
    e432:	0018      	movs	r0, r3
    e434:	46bd      	mov	sp, r7
    e436:	b002      	add	sp, #8
    e438:	bd80      	pop	{r7, pc}
	...

0000e43c <TCPI_Init>:
  * @brief  Initialize TCPI 
  * @param  portnum: Index of current used port
  * @retval USBPD status
  */
static uint32_t TCPI_Init(I2C_HandleTypeDef *hi2c)
{
    e43c:	b580      	push	{r7, lr}
    e43e:	b084      	sub	sp, #16
    e440:	af00      	add	r7, sp, #0
    e442:	6078      	str	r0, [r7, #4]
  uint32_t _retr = 0;
    e444:	2300      	movs	r3, #0
    e446:	60fb      	str	r3, [r7, #12]

  /*##-1- Configure the I2C peripheral ######################################*/
  hi2c->Instance             = I2Cx;
    e448:	687b      	ldr	r3, [r7, #4]
    e44a:	4a16      	ldr	r2, [pc, #88]	; (e4a4 <TCPI_Init+0x68>)
    e44c:	601a      	str	r2, [r3, #0]
  hi2c->Init.Timing          = I2C_TIMING;
    e44e:	687b      	ldr	r3, [r7, #4]
    e450:	4a15      	ldr	r2, [pc, #84]	; (e4a8 <TCPI_Init+0x6c>)
    e452:	605a      	str	r2, [r3, #4]
  hi2c->Init.OwnAddress1     = 0;
    e454:	687b      	ldr	r3, [r7, #4]
    e456:	2200      	movs	r2, #0
    e458:	609a      	str	r2, [r3, #8]
  hi2c->Init.AddressingMode  = I2C_ADDRESSINGMODE_7BIT;
    e45a:	687b      	ldr	r3, [r7, #4]
    e45c:	2201      	movs	r2, #1
    e45e:	60da      	str	r2, [r3, #12]
  hi2c->Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
    e460:	687b      	ldr	r3, [r7, #4]
    e462:	2200      	movs	r2, #0
    e464:	611a      	str	r2, [r3, #16]
  hi2c->Init.OwnAddress2     = 0;
    e466:	687b      	ldr	r3, [r7, #4]
    e468:	2200      	movs	r2, #0
    e46a:	615a      	str	r2, [r3, #20]
  hi2c->Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
    e46c:	687b      	ldr	r3, [r7, #4]
    e46e:	2200      	movs	r2, #0
    e470:	61da      	str	r2, [r3, #28]
  hi2c->Init.NoStretchMode   = I2C_NOSTRETCH_DISABLE;
    e472:	687b      	ldr	r3, [r7, #4]
    e474:	2200      	movs	r2, #0
    e476:	621a      	str	r2, [r3, #32]
  
  if(HAL_OK != HAL_I2C_Init(hi2c))
    e478:	687b      	ldr	r3, [r7, #4]
    e47a:	0018      	movs	r0, r3
    e47c:	f000 fd2e 	bl	eedc <HAL_I2C_Init>
    e480:	1e03      	subs	r3, r0, #0
    e482:	d001      	beq.n	e488 <TCPI_Init+0x4c>
  {
    _retr = 1;
    e484:	2301      	movs	r3, #1
    e486:	60fb      	str	r3, [r7, #12]
  }
  
  /* Enable the Analog I2C Filter */
  if(HAL_OK != HAL_I2CEx_ConfigAnalogFilter(hi2c,I2C_ANALOGFILTER_ENABLE))
    e488:	687b      	ldr	r3, [r7, #4]
    e48a:	2100      	movs	r1, #0
    e48c:	0018      	movs	r0, r3
    e48e:	f001 fa7f 	bl	f990 <HAL_I2CEx_ConfigAnalogFilter>
    e492:	1e03      	subs	r3, r0, #0
    e494:	d001      	beq.n	e49a <TCPI_Init+0x5e>
  {
    _retr = 1;
    e496:	2301      	movs	r3, #1
    e498:	60fb      	str	r3, [r7, #12]
  }
  
  return _retr;
    e49a:	68fb      	ldr	r3, [r7, #12]
}
    e49c:	0018      	movs	r0, r3
    e49e:	46bd      	mov	sp, r7
    e4a0:	b004      	add	sp, #16
    e4a2:	bd80      	pop	{r7, pc}
    e4a4:	40005800 	.word	0x40005800
    e4a8:	00200b19 	.word	0x00200b19

0000e4ac <HAL_I2C_MspInit>:
  *           - NVIC configuration for DMA interrupt request enable
  * @param hi2c: I2C handle pointer
  * @retval None
  */
void HAL_I2C_MspInit(I2C_HandleTypeDef *hi2c)
{
    e4ac:	b590      	push	{r4, r7, lr}
    e4ae:	b08b      	sub	sp, #44	; 0x2c
    e4b0:	af00      	add	r7, sp, #0
    e4b2:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef  GPIO_InitStruct;

  /*##-2- Enable peripherals and GPIO Clocks #################################*/
  /* Enable GPIO TX/RX clock */
  I2Cx_SCL_GPIO_CLK_ENABLE();
    e4b4:	4b29      	ldr	r3, [pc, #164]	; (e55c <HAL_I2C_MspInit+0xb0>)
    e4b6:	695a      	ldr	r2, [r3, #20]
    e4b8:	4b28      	ldr	r3, [pc, #160]	; (e55c <HAL_I2C_MspInit+0xb0>)
    e4ba:	2180      	movs	r1, #128	; 0x80
    e4bc:	02c9      	lsls	r1, r1, #11
    e4be:	430a      	orrs	r2, r1
    e4c0:	615a      	str	r2, [r3, #20]
    e4c2:	4b26      	ldr	r3, [pc, #152]	; (e55c <HAL_I2C_MspInit+0xb0>)
    e4c4:	695a      	ldr	r2, [r3, #20]
    e4c6:	2380      	movs	r3, #128	; 0x80
    e4c8:	02db      	lsls	r3, r3, #11
    e4ca:	4013      	ands	r3, r2
    e4cc:	613b      	str	r3, [r7, #16]
    e4ce:	693b      	ldr	r3, [r7, #16]
  I2Cx_SDA_GPIO_CLK_ENABLE();
    e4d0:	4b22      	ldr	r3, [pc, #136]	; (e55c <HAL_I2C_MspInit+0xb0>)
    e4d2:	695a      	ldr	r2, [r3, #20]
    e4d4:	4b21      	ldr	r3, [pc, #132]	; (e55c <HAL_I2C_MspInit+0xb0>)
    e4d6:	2180      	movs	r1, #128	; 0x80
    e4d8:	02c9      	lsls	r1, r1, #11
    e4da:	430a      	orrs	r2, r1
    e4dc:	615a      	str	r2, [r3, #20]
    e4de:	4b1f      	ldr	r3, [pc, #124]	; (e55c <HAL_I2C_MspInit+0xb0>)
    e4e0:	695a      	ldr	r2, [r3, #20]
    e4e2:	2380      	movs	r3, #128	; 0x80
    e4e4:	02db      	lsls	r3, r3, #11
    e4e6:	4013      	ands	r3, r2
    e4e8:	60fb      	str	r3, [r7, #12]
    e4ea:	68fb      	ldr	r3, [r7, #12]
  /* Enable I2Cx clock */
  I2Cx_CLK_ENABLE();
    e4ec:	4b1b      	ldr	r3, [pc, #108]	; (e55c <HAL_I2C_MspInit+0xb0>)
    e4ee:	69da      	ldr	r2, [r3, #28]
    e4f0:	4b1a      	ldr	r3, [pc, #104]	; (e55c <HAL_I2C_MspInit+0xb0>)
    e4f2:	2180      	movs	r1, #128	; 0x80
    e4f4:	03c9      	lsls	r1, r1, #15
    e4f6:	430a      	orrs	r2, r1
    e4f8:	61da      	str	r2, [r3, #28]
    e4fa:	4b18      	ldr	r3, [pc, #96]	; (e55c <HAL_I2C_MspInit+0xb0>)
    e4fc:	69da      	ldr	r2, [r3, #28]
    e4fe:	2380      	movs	r3, #128	; 0x80
    e500:	03db      	lsls	r3, r3, #15
    e502:	4013      	ands	r3, r2
    e504:	60bb      	str	r3, [r7, #8]
    e506:	68bb      	ldr	r3, [r7, #8]

  /*##-3- Configure peripheral GPIO ##########################################*/  
  /* I2C TX GPIO pin configuration  */
  GPIO_InitStruct.Pin       = I2Cx_SCL_PIN;
    e508:	2114      	movs	r1, #20
    e50a:	187b      	adds	r3, r7, r1
    e50c:	2280      	movs	r2, #128	; 0x80
    e50e:	00d2      	lsls	r2, r2, #3
    e510:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_OD;
    e512:	187b      	adds	r3, r7, r1
    e514:	2212      	movs	r2, #18
    e516:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
    e518:	187b      	adds	r3, r7, r1
    e51a:	2201      	movs	r2, #1
    e51c:	609a      	str	r2, [r3, #8]
  GPIO_InitStruct.Speed     = GPIO_SPEED_FREQ_HIGH;
    e51e:	187b      	adds	r3, r7, r1
    e520:	2203      	movs	r2, #3
    e522:	60da      	str	r2, [r3, #12]
  GPIO_InitStruct.Alternate = I2Cx_SCL_SDA_AF;
    e524:	187b      	adds	r3, r7, r1
    e526:	2201      	movs	r2, #1
    e528:	611a      	str	r2, [r3, #16]
  HAL_GPIO_Init(I2Cx_SCL_GPIO_PORT, &GPIO_InitStruct);
    e52a:	000c      	movs	r4, r1
    e52c:	187b      	adds	r3, r7, r1
    e52e:	4a0c      	ldr	r2, [pc, #48]	; (e560 <HAL_I2C_MspInit+0xb4>)
    e530:	0019      	movs	r1, r3
    e532:	0010      	movs	r0, r2
    e534:	f000 fb56 	bl	ebe4 <HAL_GPIO_Init>
    
  /* I2C RX GPIO pin configuration  */
  GPIO_InitStruct.Pin       = I2Cx_SDA_PIN;
    e538:	0021      	movs	r1, r4
    e53a:	187b      	adds	r3, r7, r1
    e53c:	2280      	movs	r2, #128	; 0x80
    e53e:	0112      	lsls	r2, r2, #4
    e540:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct.Alternate = I2Cx_SCL_SDA_AF;
    e542:	187b      	adds	r3, r7, r1
    e544:	2201      	movs	r2, #1
    e546:	611a      	str	r2, [r3, #16]
  HAL_GPIO_Init(I2Cx_SDA_GPIO_PORT, &GPIO_InitStruct);
    e548:	187b      	adds	r3, r7, r1
    e54a:	4a05      	ldr	r2, [pc, #20]	; (e560 <HAL_I2C_MspInit+0xb4>)
    e54c:	0019      	movs	r1, r3
    e54e:	0010      	movs	r0, r2
    e550:	f000 fb48 	bl	ebe4 <HAL_GPIO_Init>
}
    e554:	46c0      	nop			; (mov r8, r8)
    e556:	46bd      	mov	sp, r7
    e558:	b00b      	add	sp, #44	; 0x2c
    e55a:	bd90      	pop	{r4, r7, pc}
    e55c:	40021000 	.word	0x40021000
    e560:	48000400 	.word	0x48000400

0000e564 <HAL_Init>:
  *       In the default implementation,Systick is used as source of time base.
  *       The tick variable is incremented each 1ms in its ISR.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
    e564:	b580      	push	{r7, lr}
    e566:	af00      	add	r7, sp, #0
  /* Configure Flash prefetch */ 
#if (PREFETCH_ENABLE != 0)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
    e568:	4b07      	ldr	r3, [pc, #28]	; (e588 <HAL_Init+0x24>)
    e56a:	681a      	ldr	r2, [r3, #0]
    e56c:	4b06      	ldr	r3, [pc, #24]	; (e588 <HAL_Init+0x24>)
    e56e:	2110      	movs	r1, #16
    e570:	430a      	orrs	r2, r1
    e572:	601a      	str	r2, [r3, #0]
#endif /* PREFETCH_ENABLE */

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */

  HAL_InitTick(TICK_INT_PRIORITY);
    e574:	2003      	movs	r0, #3
    e576:	f000 f809 	bl	e58c <HAL_InitTick>

  /* Init the low level hardware */
  HAL_MspInit();
    e57a:	f7f9 fefb 	bl	8374 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
    e57e:	2300      	movs	r3, #0
}
    e580:	0018      	movs	r0, r3
    e582:	46bd      	mov	sp, r7
    e584:	bd80      	pop	{r7, pc}
    e586:	46c0      	nop			; (mov r8, r8)
    e588:	40022000 	.word	0x40022000

0000e58c <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
    e58c:	b580      	push	{r7, lr}
    e58e:	b082      	sub	sp, #8
    e590:	af00      	add	r7, sp, #0
    e592:	6078      	str	r0, [r7, #4]
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000U);
    e594:	f001 fa48 	bl	fa28 <HAL_RCC_GetHCLKFreq>
    e598:	0002      	movs	r2, r0
    e59a:	23fa      	movs	r3, #250	; 0xfa
    e59c:	0099      	lsls	r1, r3, #2
    e59e:	0010      	movs	r0, r2
    e5a0:	f010 fc90 	bl	1eec4 <__udivsi3>
    e5a4:	0003      	movs	r3, r0
    e5a6:	0018      	movs	r0, r3
    e5a8:	f000 f919 	bl	e7de <HAL_SYSTICK_Config>

  /*Configure the SysTick IRQ priority */
  HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority ,0U);
    e5ac:	6879      	ldr	r1, [r7, #4]
    e5ae:	2301      	movs	r3, #1
    e5b0:	425b      	negs	r3, r3
    e5b2:	2200      	movs	r2, #0
    e5b4:	0018      	movs	r0, r3
    e5b6:	f000 f8e9 	bl	e78c <HAL_NVIC_SetPriority>

   /* Return function status */
  return HAL_OK;
    e5ba:	2300      	movs	r3, #0
}
    e5bc:	0018      	movs	r0, r3
    e5be:	46bd      	mov	sp, r7
    e5c0:	b002      	add	sp, #8
    e5c2:	bd80      	pop	{r7, pc}

0000e5c4 <HAL_GetTick>:
  * @note   This function is declared as __weak  to be overwritten  in case of other 
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
    e5c4:	b580      	push	{r7, lr}
    e5c6:	af00      	add	r7, sp, #0
  return uwTick;
    e5c8:	4b02      	ldr	r3, [pc, #8]	; (e5d4 <HAL_GetTick+0x10>)
    e5ca:	681b      	ldr	r3, [r3, #0]
}
    e5cc:	0018      	movs	r0, r3
    e5ce:	46bd      	mov	sp, r7
    e5d0:	bd80      	pop	{r7, pc}
    e5d2:	46c0      	nop			; (mov r8, r8)
    e5d4:	000321a4 	.word	0x000321a4

0000e5d8 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay: specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(__IO uint32_t Delay)
{
    e5d8:	b580      	push	{r7, lr}
    e5da:	b084      	sub	sp, #16
    e5dc:	af00      	add	r7, sp, #0
    e5de:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
    e5e0:	f7ff fff0 	bl	e5c4 <HAL_GetTick>
    e5e4:	0003      	movs	r3, r0
    e5e6:	60bb      	str	r3, [r7, #8]
  uint32_t wait = Delay;
    e5e8:	687b      	ldr	r3, [r7, #4]
    e5ea:	60fb      	str	r3, [r7, #12]
  
  /* Add a period to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
    e5ec:	68fb      	ldr	r3, [r7, #12]
    e5ee:	3301      	adds	r3, #1
    e5f0:	d002      	beq.n	e5f8 <HAL_Delay+0x20>
  {
     wait++;
    e5f2:	68fb      	ldr	r3, [r7, #12]
    e5f4:	3301      	adds	r3, #1
    e5f6:	60fb      	str	r3, [r7, #12]
  }
  
  while((HAL_GetTick() - tickstart) < wait)
    e5f8:	46c0      	nop			; (mov r8, r8)
    e5fa:	f7ff ffe3 	bl	e5c4 <HAL_GetTick>
    e5fe:	0002      	movs	r2, r0
    e600:	68bb      	ldr	r3, [r7, #8]
    e602:	1ad3      	subs	r3, r2, r3
    e604:	68fa      	ldr	r2, [r7, #12]
    e606:	429a      	cmp	r2, r3
    e608:	d8f7      	bhi.n	e5fa <HAL_Delay+0x22>
  {
  }
}
    e60a:	46c0      	nop			; (mov r8, r8)
    e60c:	46bd      	mov	sp, r7
    e60e:	b004      	add	sp, #16
    e610:	bd80      	pop	{r7, pc}
	...

0000e614 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
    e614:	b580      	push	{r7, lr}
    e616:	b082      	sub	sp, #8
    e618:	af00      	add	r7, sp, #0
    e61a:	0002      	movs	r2, r0
    e61c:	1dfb      	adds	r3, r7, #7
    e61e:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
    e620:	1dfb      	adds	r3, r7, #7
    e622:	781b      	ldrb	r3, [r3, #0]
    e624:	2b7f      	cmp	r3, #127	; 0x7f
    e626:	d809      	bhi.n	e63c <__NVIC_EnableIRQ+0x28>
  {
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e628:	1dfb      	adds	r3, r7, #7
    e62a:	781b      	ldrb	r3, [r3, #0]
    e62c:	001a      	movs	r2, r3
    e62e:	231f      	movs	r3, #31
    e630:	401a      	ands	r2, r3
    e632:	4b04      	ldr	r3, [pc, #16]	; (e644 <__NVIC_EnableIRQ+0x30>)
    e634:	2101      	movs	r1, #1
    e636:	4091      	lsls	r1, r2
    e638:	000a      	movs	r2, r1
    e63a:	601a      	str	r2, [r3, #0]
  }
}
    e63c:	46c0      	nop			; (mov r8, r8)
    e63e:	46bd      	mov	sp, r7
    e640:	b002      	add	sp, #8
    e642:	bd80      	pop	{r7, pc}
    e644:	e000e100 	.word	0xe000e100

0000e648 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
    e648:	b590      	push	{r4, r7, lr}
    e64a:	b083      	sub	sp, #12
    e64c:	af00      	add	r7, sp, #0
    e64e:	0002      	movs	r2, r0
    e650:	6039      	str	r1, [r7, #0]
    e652:	1dfb      	adds	r3, r7, #7
    e654:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
    e656:	1dfb      	adds	r3, r7, #7
    e658:	781b      	ldrb	r3, [r3, #0]
    e65a:	2b7f      	cmp	r3, #127	; 0x7f
    e65c:	d828      	bhi.n	e6b0 <__NVIC_SetPriority+0x68>
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
    e65e:	4a2f      	ldr	r2, [pc, #188]	; (e71c <__NVIC_SetPriority+0xd4>)
    e660:	1dfb      	adds	r3, r7, #7
    e662:	781b      	ldrb	r3, [r3, #0]
    e664:	b25b      	sxtb	r3, r3
    e666:	089b      	lsrs	r3, r3, #2
    e668:	33c0      	adds	r3, #192	; 0xc0
    e66a:	009b      	lsls	r3, r3, #2
    e66c:	589b      	ldr	r3, [r3, r2]
    e66e:	1dfa      	adds	r2, r7, #7
    e670:	7812      	ldrb	r2, [r2, #0]
    e672:	0011      	movs	r1, r2
    e674:	2203      	movs	r2, #3
    e676:	400a      	ands	r2, r1
    e678:	00d2      	lsls	r2, r2, #3
    e67a:	21ff      	movs	r1, #255	; 0xff
    e67c:	4091      	lsls	r1, r2
    e67e:	000a      	movs	r2, r1
    e680:	43d2      	mvns	r2, r2
    e682:	401a      	ands	r2, r3
    e684:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
    e686:	683b      	ldr	r3, [r7, #0]
    e688:	019b      	lsls	r3, r3, #6
    e68a:	22ff      	movs	r2, #255	; 0xff
    e68c:	401a      	ands	r2, r3
    e68e:	1dfb      	adds	r3, r7, #7
    e690:	781b      	ldrb	r3, [r3, #0]
    e692:	0018      	movs	r0, r3
    e694:	2303      	movs	r3, #3
    e696:	4003      	ands	r3, r0
    e698:	00db      	lsls	r3, r3, #3
    e69a:	409a      	lsls	r2, r3
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
    e69c:	481f      	ldr	r0, [pc, #124]	; (e71c <__NVIC_SetPriority+0xd4>)
    e69e:	1dfb      	adds	r3, r7, #7
    e6a0:	781b      	ldrb	r3, [r3, #0]
    e6a2:	b25b      	sxtb	r3, r3
    e6a4:	089b      	lsrs	r3, r3, #2
    e6a6:	430a      	orrs	r2, r1
    e6a8:	33c0      	adds	r3, #192	; 0xc0
    e6aa:	009b      	lsls	r3, r3, #2
    e6ac:	501a      	str	r2, [r3, r0]
  else
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
}
    e6ae:	e031      	b.n	e714 <__NVIC_SetPriority+0xcc>
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
    e6b0:	4a1b      	ldr	r2, [pc, #108]	; (e720 <__NVIC_SetPriority+0xd8>)
    e6b2:	1dfb      	adds	r3, r7, #7
    e6b4:	781b      	ldrb	r3, [r3, #0]
    e6b6:	0019      	movs	r1, r3
    e6b8:	230f      	movs	r3, #15
    e6ba:	400b      	ands	r3, r1
    e6bc:	3b08      	subs	r3, #8
    e6be:	089b      	lsrs	r3, r3, #2
    e6c0:	3306      	adds	r3, #6
    e6c2:	009b      	lsls	r3, r3, #2
    e6c4:	18d3      	adds	r3, r2, r3
    e6c6:	3304      	adds	r3, #4
    e6c8:	681b      	ldr	r3, [r3, #0]
    e6ca:	1dfa      	adds	r2, r7, #7
    e6cc:	7812      	ldrb	r2, [r2, #0]
    e6ce:	0011      	movs	r1, r2
    e6d0:	2203      	movs	r2, #3
    e6d2:	400a      	ands	r2, r1
    e6d4:	00d2      	lsls	r2, r2, #3
    e6d6:	21ff      	movs	r1, #255	; 0xff
    e6d8:	4091      	lsls	r1, r2
    e6da:	000a      	movs	r2, r1
    e6dc:	43d2      	mvns	r2, r2
    e6de:	401a      	ands	r2, r3
    e6e0:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
    e6e2:	683b      	ldr	r3, [r7, #0]
    e6e4:	019b      	lsls	r3, r3, #6
    e6e6:	22ff      	movs	r2, #255	; 0xff
    e6e8:	401a      	ands	r2, r3
    e6ea:	1dfb      	adds	r3, r7, #7
    e6ec:	781b      	ldrb	r3, [r3, #0]
    e6ee:	0018      	movs	r0, r3
    e6f0:	2303      	movs	r3, #3
    e6f2:	4003      	ands	r3, r0
    e6f4:	00db      	lsls	r3, r3, #3
    e6f6:	409a      	lsls	r2, r3
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
    e6f8:	4809      	ldr	r0, [pc, #36]	; (e720 <__NVIC_SetPriority+0xd8>)
    e6fa:	1dfb      	adds	r3, r7, #7
    e6fc:	781b      	ldrb	r3, [r3, #0]
    e6fe:	001c      	movs	r4, r3
    e700:	230f      	movs	r3, #15
    e702:	4023      	ands	r3, r4
    e704:	3b08      	subs	r3, #8
    e706:	089b      	lsrs	r3, r3, #2
    e708:	430a      	orrs	r2, r1
    e70a:	3306      	adds	r3, #6
    e70c:	009b      	lsls	r3, r3, #2
    e70e:	18c3      	adds	r3, r0, r3
    e710:	3304      	adds	r3, #4
    e712:	601a      	str	r2, [r3, #0]
}
    e714:	46c0      	nop			; (mov r8, r8)
    e716:	46bd      	mov	sp, r7
    e718:	b003      	add	sp, #12
    e71a:	bd90      	pop	{r4, r7, pc}
    e71c:	e000e100 	.word	0xe000e100
    e720:	e000ed00 	.word	0xe000ed00

0000e724 <__NVIC_SystemReset>:
/**
  \brief   System Reset
  \details Initiates a system reset request to reset the MCU.
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
    e724:	b580      	push	{r7, lr}
    e726:	af00      	add	r7, sp, #0
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
    e728:	f3bf 8f4f 	dsb	sy
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
    e72c:	4b03      	ldr	r3, [pc, #12]	; (e73c <__NVIC_SystemReset+0x18>)
    e72e:	4a04      	ldr	r2, [pc, #16]	; (e740 <__NVIC_SystemReset+0x1c>)
    e730:	60da      	str	r2, [r3, #12]
    e732:	f3bf 8f4f 	dsb	sy
                 SCB_AIRCR_SYSRESETREQ_Msk);
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
    e736:	46c0      	nop			; (mov r8, r8)
    e738:	e7fd      	b.n	e736 <__NVIC_SystemReset+0x12>
    e73a:	46c0      	nop			; (mov r8, r8)
    e73c:	e000ed00 	.word	0xe000ed00
    e740:	05fa0004 	.word	0x05fa0004

0000e744 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
    e744:	b580      	push	{r7, lr}
    e746:	b082      	sub	sp, #8
    e748:	af00      	add	r7, sp, #0
    e74a:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
    e74c:	687b      	ldr	r3, [r7, #4]
    e74e:	3b01      	subs	r3, #1
    e750:	4a0c      	ldr	r2, [pc, #48]	; (e784 <SysTick_Config+0x40>)
    e752:	4293      	cmp	r3, r2
    e754:	d901      	bls.n	e75a <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
    e756:	2301      	movs	r3, #1
    e758:	e010      	b.n	e77c <SysTick_Config+0x38>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
    e75a:	4b0b      	ldr	r3, [pc, #44]	; (e788 <SysTick_Config+0x44>)
    e75c:	687a      	ldr	r2, [r7, #4]
    e75e:	3a01      	subs	r2, #1
    e760:	605a      	str	r2, [r3, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
    e762:	2301      	movs	r3, #1
    e764:	425b      	negs	r3, r3
    e766:	2103      	movs	r1, #3
    e768:	0018      	movs	r0, r3
    e76a:	f7ff ff6d 	bl	e648 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
    e76e:	4b06      	ldr	r3, [pc, #24]	; (e788 <SysTick_Config+0x44>)
    e770:	2200      	movs	r2, #0
    e772:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
    e774:	4b04      	ldr	r3, [pc, #16]	; (e788 <SysTick_Config+0x44>)
    e776:	2207      	movs	r2, #7
    e778:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
    e77a:	2300      	movs	r3, #0
}
    e77c:	0018      	movs	r0, r3
    e77e:	46bd      	mov	sp, r7
    e780:	b002      	add	sp, #8
    e782:	bd80      	pop	{r7, pc}
    e784:	00ffffff 	.word	0x00ffffff
    e788:	e000e010 	.word	0xe000e010

0000e78c <HAL_NVIC_SetPriority>:
  *         with stm32f0xx devices, this parameter is a dummy value and it is ignored, because 
  *         no subpriority supported in Cortex M0 based products.   
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
    e78c:	b580      	push	{r7, lr}
    e78e:	b084      	sub	sp, #16
    e790:	af00      	add	r7, sp, #0
    e792:	60b9      	str	r1, [r7, #8]
    e794:	607a      	str	r2, [r7, #4]
    e796:	210f      	movs	r1, #15
    e798:	187b      	adds	r3, r7, r1
    e79a:	1c02      	adds	r2, r0, #0
    e79c:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  NVIC_SetPriority(IRQn,PreemptPriority);
    e79e:	68ba      	ldr	r2, [r7, #8]
    e7a0:	187b      	adds	r3, r7, r1
    e7a2:	781b      	ldrb	r3, [r3, #0]
    e7a4:	b25b      	sxtb	r3, r3
    e7a6:	0011      	movs	r1, r2
    e7a8:	0018      	movs	r0, r3
    e7aa:	f7ff ff4d 	bl	e648 <__NVIC_SetPriority>
}
    e7ae:	46c0      	nop			; (mov r8, r8)
    e7b0:	46bd      	mov	sp, r7
    e7b2:	b004      	add	sp, #16
    e7b4:	bd80      	pop	{r7, pc}

0000e7b6 <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f0xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
    e7b6:	b580      	push	{r7, lr}
    e7b8:	b082      	sub	sp, #8
    e7ba:	af00      	add	r7, sp, #0
    e7bc:	0002      	movs	r2, r0
    e7be:	1dfb      	adds	r3, r7, #7
    e7c0:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
    e7c2:	1dfb      	adds	r3, r7, #7
    e7c4:	781b      	ldrb	r3, [r3, #0]
    e7c6:	b25b      	sxtb	r3, r3
    e7c8:	0018      	movs	r0, r3
    e7ca:	f7ff ff23 	bl	e614 <__NVIC_EnableIRQ>
}
    e7ce:	46c0      	nop			; (mov r8, r8)
    e7d0:	46bd      	mov	sp, r7
    e7d2:	b002      	add	sp, #8
    e7d4:	bd80      	pop	{r7, pc}

0000e7d6 <HAL_NVIC_SystemReset>:
/**
  * @brief  Initiates a system reset request to reset the MCU.
  * @retval None
  */
void HAL_NVIC_SystemReset(void)
{
    e7d6:	b580      	push	{r7, lr}
    e7d8:	af00      	add	r7, sp, #0
  /* System Reset */
  NVIC_SystemReset();
    e7da:	f7ff ffa3 	bl	e724 <__NVIC_SystemReset>

0000e7de <HAL_SYSTICK_Config>:
  * @param  TicksNumb: Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
    e7de:	b580      	push	{r7, lr}
    e7e0:	b082      	sub	sp, #8
    e7e2:	af00      	add	r7, sp, #0
    e7e4:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
    e7e6:	687b      	ldr	r3, [r7, #4]
    e7e8:	0018      	movs	r0, r3
    e7ea:	f7ff ffab 	bl	e744 <SysTick_Config>
    e7ee:	0003      	movs	r3, r0
}
    e7f0:	0018      	movs	r0, r3
    e7f2:	46bd      	mov	sp, r7
    e7f4:	b002      	add	sp, #8
    e7f6:	bd80      	pop	{r7, pc}

0000e7f8 <HAL_FLASH_Program>:
  * @param  Data          Specifie the data to be programmed
  * 
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint64_t Data)
{
    e7f8:	b5f0      	push	{r4, r5, r6, r7, lr}
    e7fa:	b087      	sub	sp, #28
    e7fc:	af00      	add	r7, sp, #0
    e7fe:	60f8      	str	r0, [r7, #12]
    e800:	60b9      	str	r1, [r7, #8]
    e802:	603a      	str	r2, [r7, #0]
    e804:	607b      	str	r3, [r7, #4]
  HAL_StatusTypeDef status = HAL_ERROR;
    e806:	2317      	movs	r3, #23
    e808:	18fb      	adds	r3, r7, r3
    e80a:	2201      	movs	r2, #1
    e80c:	701a      	strb	r2, [r3, #0]
  uint8_t index = 0U;
    e80e:	2316      	movs	r3, #22
    e810:	18fb      	adds	r3, r7, r3
    e812:	2200      	movs	r2, #0
    e814:	701a      	strb	r2, [r3, #0]
  uint8_t nbiterations = 0U;
    e816:	2315      	movs	r3, #21
    e818:	18fb      	adds	r3, r7, r3
    e81a:	2200      	movs	r2, #0
    e81c:	701a      	strb	r2, [r3, #0]
  
  /* Process Locked */
  __HAL_LOCK(&pFlash);
    e81e:	4b3e      	ldr	r3, [pc, #248]	; (e918 <HAL_FLASH_Program+0x120>)
    e820:	7e1b      	ldrb	r3, [r3, #24]
    e822:	2b01      	cmp	r3, #1
    e824:	d101      	bne.n	e82a <HAL_FLASH_Program+0x32>
    e826:	2302      	movs	r3, #2
    e828:	e072      	b.n	e910 <HAL_FLASH_Program+0x118>
    e82a:	4b3b      	ldr	r3, [pc, #236]	; (e918 <HAL_FLASH_Program+0x120>)
    e82c:	2201      	movs	r2, #1
    e82e:	761a      	strb	r2, [r3, #24]
  /* Check the parameters */
  assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
  assert_param(IS_FLASH_PROGRAM_ADDRESS(Address));

    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
    e830:	2317      	movs	r3, #23
    e832:	18fe      	adds	r6, r7, r3
    e834:	4b39      	ldr	r3, [pc, #228]	; (e91c <HAL_FLASH_Program+0x124>)
    e836:	0018      	movs	r0, r3
    e838:	f000 f8b8 	bl	e9ac <FLASH_WaitForLastOperation>
    e83c:	0003      	movs	r3, r0
    e83e:	7033      	strb	r3, [r6, #0]
  
  if(status == HAL_OK)
    e840:	2317      	movs	r3, #23
    e842:	18fb      	adds	r3, r7, r3
    e844:	781b      	ldrb	r3, [r3, #0]
    e846:	2b00      	cmp	r3, #0
    e848:	d15c      	bne.n	e904 <HAL_FLASH_Program+0x10c>
  {
    if(TypeProgram == FLASH_TYPEPROGRAM_HALFWORD)
    e84a:	68fb      	ldr	r3, [r7, #12]
    e84c:	2b01      	cmp	r3, #1
    e84e:	d104      	bne.n	e85a <HAL_FLASH_Program+0x62>
    {
      /* Program halfword (16-bit) at a specified address. */
      nbiterations = 1U;
    e850:	2315      	movs	r3, #21
    e852:	18fb      	adds	r3, r7, r3
    e854:	2201      	movs	r2, #1
    e856:	701a      	strb	r2, [r3, #0]
    e858:	e00b      	b.n	e872 <HAL_FLASH_Program+0x7a>
    }
    else if(TypeProgram == FLASH_TYPEPROGRAM_WORD)
    e85a:	68fb      	ldr	r3, [r7, #12]
    e85c:	2b02      	cmp	r3, #2
    e85e:	d104      	bne.n	e86a <HAL_FLASH_Program+0x72>
    {
      /* Program word (32-bit = 2*16-bit) at a specified address. */
      nbiterations = 2U;
    e860:	2315      	movs	r3, #21
    e862:	18fb      	adds	r3, r7, r3
    e864:	2202      	movs	r2, #2
    e866:	701a      	strb	r2, [r3, #0]
    e868:	e003      	b.n	e872 <HAL_FLASH_Program+0x7a>
    }
    else
    {
      /* Program double word (64-bit = 4*16-bit) at a specified address. */
      nbiterations = 4U;
    e86a:	2315      	movs	r3, #21
    e86c:	18fb      	adds	r3, r7, r3
    e86e:	2204      	movs	r2, #4
    e870:	701a      	strb	r2, [r3, #0]
    }

    for (index = 0U; index < nbiterations; index++)
    e872:	2316      	movs	r3, #22
    e874:	18fb      	adds	r3, r7, r3
    e876:	2200      	movs	r2, #0
    e878:	701a      	strb	r2, [r3, #0]
    e87a:	e039      	b.n	e8f0 <HAL_FLASH_Program+0xf8>
    {
      FLASH_Program_HalfWord((Address + (2U*index)), (uint16_t)(Data >> (16U*index)));
    e87c:	2116      	movs	r1, #22
    e87e:	187b      	adds	r3, r7, r1
    e880:	781b      	ldrb	r3, [r3, #0]
    e882:	005a      	lsls	r2, r3, #1
    e884:	68bb      	ldr	r3, [r7, #8]
    e886:	18d0      	adds	r0, r2, r3
    e888:	187b      	adds	r3, r7, r1
    e88a:	781b      	ldrb	r3, [r3, #0]
    e88c:	011b      	lsls	r3, r3, #4
    e88e:	001a      	movs	r2, r3
    e890:	3a20      	subs	r2, #32
    e892:	2a00      	cmp	r2, #0
    e894:	db03      	blt.n	e89e <HAL_FLASH_Program+0xa6>
    e896:	6879      	ldr	r1, [r7, #4]
    e898:	40d1      	lsrs	r1, r2
    e89a:	000c      	movs	r4, r1
    e89c:	e008      	b.n	e8b0 <HAL_FLASH_Program+0xb8>
    e89e:	2220      	movs	r2, #32
    e8a0:	1ad2      	subs	r2, r2, r3
    e8a2:	6879      	ldr	r1, [r7, #4]
    e8a4:	4091      	lsls	r1, r2
    e8a6:	000a      	movs	r2, r1
    e8a8:	6839      	ldr	r1, [r7, #0]
    e8aa:	40d9      	lsrs	r1, r3
    e8ac:	000c      	movs	r4, r1
    e8ae:	4314      	orrs	r4, r2
    e8b0:	687a      	ldr	r2, [r7, #4]
    e8b2:	40da      	lsrs	r2, r3
    e8b4:	0015      	movs	r5, r2
    e8b6:	b2a3      	uxth	r3, r4
    e8b8:	0019      	movs	r1, r3
    e8ba:	f000 f85b 	bl	e974 <FLASH_Program_HalfWord>

        /* Wait for last operation to be completed */
        status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
    e8be:	2317      	movs	r3, #23
    e8c0:	18fe      	adds	r6, r7, r3
    e8c2:	4b16      	ldr	r3, [pc, #88]	; (e91c <HAL_FLASH_Program+0x124>)
    e8c4:	0018      	movs	r0, r3
    e8c6:	f000 f871 	bl	e9ac <FLASH_WaitForLastOperation>
    e8ca:	0003      	movs	r3, r0
    e8cc:	7033      	strb	r3, [r6, #0]
    
        /* If the program operation is completed, disable the PG Bit */
        CLEAR_BIT(FLASH->CR, FLASH_CR_PG);
    e8ce:	4b14      	ldr	r3, [pc, #80]	; (e920 <HAL_FLASH_Program+0x128>)
    e8d0:	691a      	ldr	r2, [r3, #16]
    e8d2:	4b13      	ldr	r3, [pc, #76]	; (e920 <HAL_FLASH_Program+0x128>)
    e8d4:	2101      	movs	r1, #1
    e8d6:	438a      	bics	r2, r1
    e8d8:	611a      	str	r2, [r3, #16]
      /* In case of error, stop programation procedure */
      if (status != HAL_OK)
    e8da:	2317      	movs	r3, #23
    e8dc:	18fb      	adds	r3, r7, r3
    e8de:	781b      	ldrb	r3, [r3, #0]
    e8e0:	2b00      	cmp	r3, #0
    e8e2:	d10e      	bne.n	e902 <HAL_FLASH_Program+0x10a>
    for (index = 0U; index < nbiterations; index++)
    e8e4:	2116      	movs	r1, #22
    e8e6:	187b      	adds	r3, r7, r1
    e8e8:	781a      	ldrb	r2, [r3, #0]
    e8ea:	187b      	adds	r3, r7, r1
    e8ec:	3201      	adds	r2, #1
    e8ee:	701a      	strb	r2, [r3, #0]
    e8f0:	2316      	movs	r3, #22
    e8f2:	18fa      	adds	r2, r7, r3
    e8f4:	2315      	movs	r3, #21
    e8f6:	18fb      	adds	r3, r7, r3
    e8f8:	7812      	ldrb	r2, [r2, #0]
    e8fa:	781b      	ldrb	r3, [r3, #0]
    e8fc:	429a      	cmp	r2, r3
    e8fe:	d3bd      	bcc.n	e87c <HAL_FLASH_Program+0x84>
    e900:	e000      	b.n	e904 <HAL_FLASH_Program+0x10c>
      {
        break;
    e902:	46c0      	nop			; (mov r8, r8)
      }
    }
  }

  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);
    e904:	4b04      	ldr	r3, [pc, #16]	; (e918 <HAL_FLASH_Program+0x120>)
    e906:	2200      	movs	r2, #0
    e908:	761a      	strb	r2, [r3, #24]

  return status;
    e90a:	2317      	movs	r3, #23
    e90c:	18fb      	adds	r3, r7, r3
    e90e:	781b      	ldrb	r3, [r3, #0]
}
    e910:	0018      	movs	r0, r3
    e912:	46bd      	mov	sp, r7
    e914:	b007      	add	sp, #28
    e916:	bdf0      	pop	{r4, r5, r6, r7, pc}
    e918:	000321a8 	.word	0x000321a8
    e91c:	0000c350 	.word	0x0000c350
    e920:	40022000 	.word	0x40022000

0000e924 <HAL_FLASH_Unlock>:
/**
  * @brief  Unlock the FLASH control register access
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Unlock(void)
{
    e924:	b580      	push	{r7, lr}
    e926:	af00      	add	r7, sp, #0
  if (HAL_IS_BIT_SET(FLASH->CR, FLASH_CR_LOCK))
    e928:	4b08      	ldr	r3, [pc, #32]	; (e94c <HAL_FLASH_Unlock+0x28>)
    e92a:	691b      	ldr	r3, [r3, #16]
    e92c:	2280      	movs	r2, #128	; 0x80
    e92e:	4013      	ands	r3, r2
    e930:	d007      	beq.n	e942 <HAL_FLASH_Unlock+0x1e>
  {
    /* Authorize the FLASH Registers access */
    WRITE_REG(FLASH->KEYR, FLASH_KEY1);
    e932:	4b06      	ldr	r3, [pc, #24]	; (e94c <HAL_FLASH_Unlock+0x28>)
    e934:	4a06      	ldr	r2, [pc, #24]	; (e950 <HAL_FLASH_Unlock+0x2c>)
    e936:	605a      	str	r2, [r3, #4]
    WRITE_REG(FLASH->KEYR, FLASH_KEY2);
    e938:	4b04      	ldr	r3, [pc, #16]	; (e94c <HAL_FLASH_Unlock+0x28>)
    e93a:	4a06      	ldr	r2, [pc, #24]	; (e954 <HAL_FLASH_Unlock+0x30>)
    e93c:	605a      	str	r2, [r3, #4]
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK; 
    e93e:	2300      	movs	r3, #0
    e940:	e000      	b.n	e944 <HAL_FLASH_Unlock+0x20>
    return HAL_ERROR;
    e942:	2301      	movs	r3, #1
}
    e944:	0018      	movs	r0, r3
    e946:	46bd      	mov	sp, r7
    e948:	bd80      	pop	{r7, pc}
    e94a:	46c0      	nop			; (mov r8, r8)
    e94c:	40022000 	.word	0x40022000
    e950:	45670123 	.word	0x45670123
    e954:	cdef89ab 	.word	0xcdef89ab

0000e958 <HAL_FLASH_Lock>:
/**
  * @brief  Locks the FLASH control register access
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Lock(void)
{
    e958:	b580      	push	{r7, lr}
    e95a:	af00      	add	r7, sp, #0
  /* Set the LOCK Bit to lock the FLASH Registers access */
  SET_BIT(FLASH->CR, FLASH_CR_LOCK);
    e95c:	4b04      	ldr	r3, [pc, #16]	; (e970 <HAL_FLASH_Lock+0x18>)
    e95e:	691a      	ldr	r2, [r3, #16]
    e960:	4b03      	ldr	r3, [pc, #12]	; (e970 <HAL_FLASH_Lock+0x18>)
    e962:	2180      	movs	r1, #128	; 0x80
    e964:	430a      	orrs	r2, r1
    e966:	611a      	str	r2, [r3, #16]
  
  return HAL_OK;  
    e968:	2300      	movs	r3, #0
}
    e96a:	0018      	movs	r0, r3
    e96c:	46bd      	mov	sp, r7
    e96e:	bd80      	pop	{r7, pc}
    e970:	40022000 	.word	0x40022000

0000e974 <FLASH_Program_HalfWord>:
  * @param  Address specify the address to be programmed.
  * @param  Data    specify the data to be programmed.
  * @retval None
  */
static void FLASH_Program_HalfWord(uint32_t Address, uint16_t Data)
{
    e974:	b580      	push	{r7, lr}
    e976:	b082      	sub	sp, #8
    e978:	af00      	add	r7, sp, #0
    e97a:	6078      	str	r0, [r7, #4]
    e97c:	000a      	movs	r2, r1
    e97e:	1cbb      	adds	r3, r7, #2
    e980:	801a      	strh	r2, [r3, #0]
  /* Clean the error context */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
    e982:	4b08      	ldr	r3, [pc, #32]	; (e9a4 <FLASH_Program_HalfWord+0x30>)
    e984:	2200      	movs	r2, #0
    e986:	61da      	str	r2, [r3, #28]
  
    /* Proceed to program the new data */
    SET_BIT(FLASH->CR, FLASH_CR_PG);
    e988:	4b07      	ldr	r3, [pc, #28]	; (e9a8 <FLASH_Program_HalfWord+0x34>)
    e98a:	691a      	ldr	r2, [r3, #16]
    e98c:	4b06      	ldr	r3, [pc, #24]	; (e9a8 <FLASH_Program_HalfWord+0x34>)
    e98e:	2101      	movs	r1, #1
    e990:	430a      	orrs	r2, r1
    e992:	611a      	str	r2, [r3, #16]

  /* Write data in the address */
  *(__IO uint16_t*)Address = Data;
    e994:	687b      	ldr	r3, [r7, #4]
    e996:	1cba      	adds	r2, r7, #2
    e998:	8812      	ldrh	r2, [r2, #0]
    e99a:	801a      	strh	r2, [r3, #0]
}
    e99c:	46c0      	nop			; (mov r8, r8)
    e99e:	46bd      	mov	sp, r7
    e9a0:	b002      	add	sp, #8
    e9a2:	bd80      	pop	{r7, pc}
    e9a4:	000321a8 	.word	0x000321a8
    e9a8:	40022000 	.word	0x40022000

0000e9ac <FLASH_WaitForLastOperation>:
  * @brief  Wait for a FLASH operation to complete.
  * @param  Timeout  maximum flash operation timeout
  * @retval HAL Status
  */
HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout)
{
    e9ac:	b580      	push	{r7, lr}
    e9ae:	b084      	sub	sp, #16
    e9b0:	af00      	add	r7, sp, #0
    e9b2:	6078      	str	r0, [r7, #4]
  /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
     Even if the FLASH operation fails, the BUSY flag will be reset and an error
     flag will be set */
     
  uint32_t tickstart = HAL_GetTick();
    e9b4:	f7ff fe06 	bl	e5c4 <HAL_GetTick>
    e9b8:	0003      	movs	r3, r0
    e9ba:	60fb      	str	r3, [r7, #12]
     
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) 
    e9bc:	e00f      	b.n	e9de <FLASH_WaitForLastOperation+0x32>
  { 
    if (Timeout != HAL_MAX_DELAY)
    e9be:	687b      	ldr	r3, [r7, #4]
    e9c0:	3301      	adds	r3, #1
    e9c2:	d00c      	beq.n	e9de <FLASH_WaitForLastOperation+0x32>
    {
      if((Timeout == 0U) || ((HAL_GetTick()-tickstart) > Timeout))
    e9c4:	687b      	ldr	r3, [r7, #4]
    e9c6:	2b00      	cmp	r3, #0
    e9c8:	d007      	beq.n	e9da <FLASH_WaitForLastOperation+0x2e>
    e9ca:	f7ff fdfb 	bl	e5c4 <HAL_GetTick>
    e9ce:	0002      	movs	r2, r0
    e9d0:	68fb      	ldr	r3, [r7, #12]
    e9d2:	1ad3      	subs	r3, r2, r3
    e9d4:	687a      	ldr	r2, [r7, #4]
    e9d6:	429a      	cmp	r2, r3
    e9d8:	d201      	bcs.n	e9de <FLASH_WaitForLastOperation+0x32>
      {
        return HAL_TIMEOUT;
    e9da:	2303      	movs	r3, #3
    e9dc:	e01f      	b.n	ea1e <FLASH_WaitForLastOperation+0x72>
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) 
    e9de:	4b12      	ldr	r3, [pc, #72]	; (ea28 <FLASH_WaitForLastOperation+0x7c>)
    e9e0:	68db      	ldr	r3, [r3, #12]
    e9e2:	2201      	movs	r2, #1
    e9e4:	4013      	ands	r3, r2
    e9e6:	2b01      	cmp	r3, #1
    e9e8:	d0e9      	beq.n	e9be <FLASH_WaitForLastOperation+0x12>
      }
    }
  }
  
  /* Check FLASH End of Operation flag  */
  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP))
    e9ea:	4b0f      	ldr	r3, [pc, #60]	; (ea28 <FLASH_WaitForLastOperation+0x7c>)
    e9ec:	68db      	ldr	r3, [r3, #12]
    e9ee:	2220      	movs	r2, #32
    e9f0:	4013      	ands	r3, r2
    e9f2:	2b20      	cmp	r3, #32
    e9f4:	d102      	bne.n	e9fc <FLASH_WaitForLastOperation+0x50>
  {
    /* Clear FLASH End of Operation pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
    e9f6:	4b0c      	ldr	r3, [pc, #48]	; (ea28 <FLASH_WaitForLastOperation+0x7c>)
    e9f8:	2220      	movs	r2, #32
    e9fa:	60da      	str	r2, [r3, #12]
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR)  || 
    e9fc:	4b0a      	ldr	r3, [pc, #40]	; (ea28 <FLASH_WaitForLastOperation+0x7c>)
    e9fe:	68db      	ldr	r3, [r3, #12]
    ea00:	2210      	movs	r2, #16
    ea02:	4013      	ands	r3, r2
    ea04:	2b10      	cmp	r3, #16
    ea06:	d005      	beq.n	ea14 <FLASH_WaitForLastOperation+0x68>
     __HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR))
    ea08:	4b07      	ldr	r3, [pc, #28]	; (ea28 <FLASH_WaitForLastOperation+0x7c>)
    ea0a:	68db      	ldr	r3, [r3, #12]
    ea0c:	2204      	movs	r2, #4
    ea0e:	4013      	ands	r3, r2
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR)  || 
    ea10:	2b04      	cmp	r3, #4
    ea12:	d103      	bne.n	ea1c <FLASH_WaitForLastOperation+0x70>
  {
    /*Save the error code*/
    FLASH_SetErrorCode();
    ea14:	f000 f80a 	bl	ea2c <FLASH_SetErrorCode>
    return HAL_ERROR;
    ea18:	2301      	movs	r3, #1
    ea1a:	e000      	b.n	ea1e <FLASH_WaitForLastOperation+0x72>
  }

  /* There is no error flag set */
  return HAL_OK;
    ea1c:	2300      	movs	r3, #0
}
    ea1e:	0018      	movs	r0, r3
    ea20:	46bd      	mov	sp, r7
    ea22:	b004      	add	sp, #16
    ea24:	bd80      	pop	{r7, pc}
    ea26:	46c0      	nop			; (mov r8, r8)
    ea28:	40022000 	.word	0x40022000

0000ea2c <FLASH_SetErrorCode>:
/**
  * @brief  Set the specific FLASH error flag.
  * @retval None
  */
static void FLASH_SetErrorCode(void)
{
    ea2c:	b580      	push	{r7, lr}
    ea2e:	b082      	sub	sp, #8
    ea30:	af00      	add	r7, sp, #0
  uint32_t flags = 0U;
    ea32:	2300      	movs	r3, #0
    ea34:	607b      	str	r3, [r7, #4]
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR))
    ea36:	4b13      	ldr	r3, [pc, #76]	; (ea84 <FLASH_SetErrorCode+0x58>)
    ea38:	68db      	ldr	r3, [r3, #12]
    ea3a:	2210      	movs	r2, #16
    ea3c:	4013      	ands	r3, r2
    ea3e:	2b10      	cmp	r3, #16
    ea40:	d109      	bne.n	ea56 <FLASH_SetErrorCode+0x2a>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;
    ea42:	4b11      	ldr	r3, [pc, #68]	; (ea88 <FLASH_SetErrorCode+0x5c>)
    ea44:	69db      	ldr	r3, [r3, #28]
    ea46:	2202      	movs	r2, #2
    ea48:	431a      	orrs	r2, r3
    ea4a:	4b0f      	ldr	r3, [pc, #60]	; (ea88 <FLASH_SetErrorCode+0x5c>)
    ea4c:	61da      	str	r2, [r3, #28]
    flags |= FLASH_FLAG_WRPERR;
    ea4e:	687b      	ldr	r3, [r7, #4]
    ea50:	2210      	movs	r2, #16
    ea52:	4313      	orrs	r3, r2
    ea54:	607b      	str	r3, [r7, #4]
  }
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR))
    ea56:	4b0b      	ldr	r3, [pc, #44]	; (ea84 <FLASH_SetErrorCode+0x58>)
    ea58:	68db      	ldr	r3, [r3, #12]
    ea5a:	2204      	movs	r2, #4
    ea5c:	4013      	ands	r3, r2
    ea5e:	2b04      	cmp	r3, #4
    ea60:	d109      	bne.n	ea76 <FLASH_SetErrorCode+0x4a>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_PROG;
    ea62:	4b09      	ldr	r3, [pc, #36]	; (ea88 <FLASH_SetErrorCode+0x5c>)
    ea64:	69db      	ldr	r3, [r3, #28]
    ea66:	2201      	movs	r2, #1
    ea68:	431a      	orrs	r2, r3
    ea6a:	4b07      	ldr	r3, [pc, #28]	; (ea88 <FLASH_SetErrorCode+0x5c>)
    ea6c:	61da      	str	r2, [r3, #28]
    flags |= FLASH_FLAG_PGERR;
    ea6e:	687b      	ldr	r3, [r7, #4]
    ea70:	2204      	movs	r2, #4
    ea72:	4313      	orrs	r3, r2
    ea74:	607b      	str	r3, [r7, #4]
  }
  /* Clear FLASH error pending bits */
  __HAL_FLASH_CLEAR_FLAG(flags);
    ea76:	4b03      	ldr	r3, [pc, #12]	; (ea84 <FLASH_SetErrorCode+0x58>)
    ea78:	687a      	ldr	r2, [r7, #4]
    ea7a:	60da      	str	r2, [r3, #12]
}  
    ea7c:	46c0      	nop			; (mov r8, r8)
    ea7e:	46bd      	mov	sp, r7
    ea80:	b002      	add	sp, #8
    ea82:	bd80      	pop	{r7, pc}
    ea84:	40022000 	.word	0x40022000
    ea88:	000321a8 	.word	0x000321a8

0000ea8c <HAL_FLASHEx_Erase>:
  *         (0xFFFFFFFF means that all the pages have been correctly erased)
  *
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *PageError)
{
    ea8c:	b5b0      	push	{r4, r5, r7, lr}
    ea8e:	b084      	sub	sp, #16
    ea90:	af00      	add	r7, sp, #0
    ea92:	6078      	str	r0, [r7, #4]
    ea94:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_ERROR;
    ea96:	230f      	movs	r3, #15
    ea98:	18fb      	adds	r3, r7, r3
    ea9a:	2201      	movs	r2, #1
    ea9c:	701a      	strb	r2, [r3, #0]
  uint32_t address = 0U;
    ea9e:	2300      	movs	r3, #0
    eaa0:	60bb      	str	r3, [r7, #8]

  /* Process Locked */
  __HAL_LOCK(&pFlash);
    eaa2:	4b32      	ldr	r3, [pc, #200]	; (eb6c <HAL_FLASHEx_Erase+0xe0>)
    eaa4:	7e1b      	ldrb	r3, [r3, #24]
    eaa6:	2b01      	cmp	r3, #1
    eaa8:	d101      	bne.n	eaae <HAL_FLASHEx_Erase+0x22>
    eaaa:	2302      	movs	r3, #2
    eaac:	e05a      	b.n	eb64 <HAL_FLASHEx_Erase+0xd8>
    eaae:	4b2f      	ldr	r3, [pc, #188]	; (eb6c <HAL_FLASHEx_Erase+0xe0>)
    eab0:	2201      	movs	r2, #1
    eab2:	761a      	strb	r2, [r3, #24]

  /* Check the parameters */
  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));

  if (pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
    eab4:	687b      	ldr	r3, [r7, #4]
    eab6:	681b      	ldr	r3, [r3, #0]
    eab8:	2b01      	cmp	r3, #1
    eaba:	d116      	bne.n	eaea <HAL_FLASHEx_Erase+0x5e>
  {
      /* Mass Erase requested for Bank1 */
      /* Wait for last operation to be completed */
      if (FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE) == HAL_OK)
    eabc:	4b2c      	ldr	r3, [pc, #176]	; (eb70 <HAL_FLASHEx_Erase+0xe4>)
    eabe:	0018      	movs	r0, r3
    eac0:	f7ff ff74 	bl	e9ac <FLASH_WaitForLastOperation>
    eac4:	1e03      	subs	r3, r0, #0
    eac6:	d147      	bne.n	eb58 <HAL_FLASHEx_Erase+0xcc>
      {
        /*Mass erase to be done*/
        FLASH_MassErase();
    eac8:	f000 f856 	bl	eb78 <FLASH_MassErase>
        
        /* Wait for last operation to be completed */
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
    eacc:	230f      	movs	r3, #15
    eace:	18fc      	adds	r4, r7, r3
    ead0:	4b27      	ldr	r3, [pc, #156]	; (eb70 <HAL_FLASHEx_Erase+0xe4>)
    ead2:	0018      	movs	r0, r3
    ead4:	f7ff ff6a 	bl	e9ac <FLASH_WaitForLastOperation>
    ead8:	0003      	movs	r3, r0
    eada:	7023      	strb	r3, [r4, #0]
        
        /* If the erase operation is completed, disable the MER Bit */
        CLEAR_BIT(FLASH->CR, FLASH_CR_MER);
    eadc:	4b25      	ldr	r3, [pc, #148]	; (eb74 <HAL_FLASHEx_Erase+0xe8>)
    eade:	691a      	ldr	r2, [r3, #16]
    eae0:	4b24      	ldr	r3, [pc, #144]	; (eb74 <HAL_FLASHEx_Erase+0xe8>)
    eae2:	2104      	movs	r1, #4
    eae4:	438a      	bics	r2, r1
    eae6:	611a      	str	r2, [r3, #16]
    eae8:	e036      	b.n	eb58 <HAL_FLASHEx_Erase+0xcc>
    assert_param(IS_FLASH_PROGRAM_ADDRESS(pEraseInit->PageAddress));
    assert_param(IS_FLASH_NB_PAGES(pEraseInit->PageAddress, pEraseInit->NbPages));
    
      /* Page Erase requested on address located on bank1 */
      /* Wait for last operation to be completed */
      if (FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE) == HAL_OK)
    eaea:	4b21      	ldr	r3, [pc, #132]	; (eb70 <HAL_FLASHEx_Erase+0xe4>)
    eaec:	0018      	movs	r0, r3
    eaee:	f7ff ff5d 	bl	e9ac <FLASH_WaitForLastOperation>
    eaf2:	1e03      	subs	r3, r0, #0
    eaf4:	d130      	bne.n	eb58 <HAL_FLASHEx_Erase+0xcc>
      {
        /*Initialization of PageError variable*/
        *PageError = 0xFFFFFFFFU;
    eaf6:	683b      	ldr	r3, [r7, #0]
    eaf8:	2201      	movs	r2, #1
    eafa:	4252      	negs	r2, r2
    eafc:	601a      	str	r2, [r3, #0]
        
        /* Erase page by page to be done*/
        for(address = pEraseInit->PageAddress;
    eafe:	687b      	ldr	r3, [r7, #4]
    eb00:	685b      	ldr	r3, [r3, #4]
    eb02:	60bb      	str	r3, [r7, #8]
    eb04:	e01f      	b.n	eb46 <HAL_FLASHEx_Erase+0xba>
            address < ((pEraseInit->NbPages * FLASH_PAGE_SIZE) + pEraseInit->PageAddress);
            address += FLASH_PAGE_SIZE)
        {
          FLASH_PageErase(address);
    eb06:	68bb      	ldr	r3, [r7, #8]
    eb08:	0018      	movs	r0, r3
    eb0a:	f000 f84d 	bl	eba8 <FLASH_PageErase>
          
          /* Wait for last operation to be completed */
          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
    eb0e:	250f      	movs	r5, #15
    eb10:	197c      	adds	r4, r7, r5
    eb12:	4b17      	ldr	r3, [pc, #92]	; (eb70 <HAL_FLASHEx_Erase+0xe4>)
    eb14:	0018      	movs	r0, r3
    eb16:	f7ff ff49 	bl	e9ac <FLASH_WaitForLastOperation>
    eb1a:	0003      	movs	r3, r0
    eb1c:	7023      	strb	r3, [r4, #0]
          
          /* If the erase operation is completed, disable the PER Bit */
          CLEAR_BIT(FLASH->CR, FLASH_CR_PER);
    eb1e:	4b15      	ldr	r3, [pc, #84]	; (eb74 <HAL_FLASHEx_Erase+0xe8>)
    eb20:	691a      	ldr	r2, [r3, #16]
    eb22:	4b14      	ldr	r3, [pc, #80]	; (eb74 <HAL_FLASHEx_Erase+0xe8>)
    eb24:	2102      	movs	r1, #2
    eb26:	438a      	bics	r2, r1
    eb28:	611a      	str	r2, [r3, #16]
          
          if (status != HAL_OK)
    eb2a:	197b      	adds	r3, r7, r5
    eb2c:	781b      	ldrb	r3, [r3, #0]
    eb2e:	2b00      	cmp	r3, #0
    eb30:	d003      	beq.n	eb3a <HAL_FLASHEx_Erase+0xae>
          {
            /* In case of error, stop erase procedure and return the faulty address */
            *PageError = address;
    eb32:	683b      	ldr	r3, [r7, #0]
    eb34:	68ba      	ldr	r2, [r7, #8]
    eb36:	601a      	str	r2, [r3, #0]
            break;
    eb38:	e00e      	b.n	eb58 <HAL_FLASHEx_Erase+0xcc>
            address += FLASH_PAGE_SIZE)
    eb3a:	68bb      	ldr	r3, [r7, #8]
    eb3c:	2280      	movs	r2, #128	; 0x80
    eb3e:	0112      	lsls	r2, r2, #4
    eb40:	4694      	mov	ip, r2
    eb42:	4463      	add	r3, ip
    eb44:	60bb      	str	r3, [r7, #8]
            address < ((pEraseInit->NbPages * FLASH_PAGE_SIZE) + pEraseInit->PageAddress);
    eb46:	687b      	ldr	r3, [r7, #4]
    eb48:	689b      	ldr	r3, [r3, #8]
    eb4a:	02da      	lsls	r2, r3, #11
    eb4c:	687b      	ldr	r3, [r7, #4]
    eb4e:	685b      	ldr	r3, [r3, #4]
    eb50:	18d3      	adds	r3, r2, r3
        for(address = pEraseInit->PageAddress;
    eb52:	68ba      	ldr	r2, [r7, #8]
    eb54:	429a      	cmp	r2, r3
    eb56:	d3d6      	bcc.n	eb06 <HAL_FLASHEx_Erase+0x7a>
        }
      }
  }

  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);
    eb58:	4b04      	ldr	r3, [pc, #16]	; (eb6c <HAL_FLASHEx_Erase+0xe0>)
    eb5a:	2200      	movs	r2, #0
    eb5c:	761a      	strb	r2, [r3, #24]

  return status;
    eb5e:	230f      	movs	r3, #15
    eb60:	18fb      	adds	r3, r7, r3
    eb62:	781b      	ldrb	r3, [r3, #0]
}
    eb64:	0018      	movs	r0, r3
    eb66:	46bd      	mov	sp, r7
    eb68:	b004      	add	sp, #16
    eb6a:	bdb0      	pop	{r4, r5, r7, pc}
    eb6c:	000321a8 	.word	0x000321a8
    eb70:	0000c350 	.word	0x0000c350
    eb74:	40022000 	.word	0x40022000

0000eb78 <FLASH_MassErase>:
  * @brief  Full erase of FLASH memory Bank 
  *
  * @retval None
  */
static void FLASH_MassErase(void)
{
    eb78:	b580      	push	{r7, lr}
    eb7a:	af00      	add	r7, sp, #0
  /* Clean the error context */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
    eb7c:	4b08      	ldr	r3, [pc, #32]	; (eba0 <FLASH_MassErase+0x28>)
    eb7e:	2200      	movs	r2, #0
    eb80:	61da      	str	r2, [r3, #28]

    /* Only bank1 will be erased*/
    SET_BIT(FLASH->CR, FLASH_CR_MER);
    eb82:	4b08      	ldr	r3, [pc, #32]	; (eba4 <FLASH_MassErase+0x2c>)
    eb84:	691a      	ldr	r2, [r3, #16]
    eb86:	4b07      	ldr	r3, [pc, #28]	; (eba4 <FLASH_MassErase+0x2c>)
    eb88:	2104      	movs	r1, #4
    eb8a:	430a      	orrs	r2, r1
    eb8c:	611a      	str	r2, [r3, #16]
    SET_BIT(FLASH->CR, FLASH_CR_STRT);
    eb8e:	4b05      	ldr	r3, [pc, #20]	; (eba4 <FLASH_MassErase+0x2c>)
    eb90:	691a      	ldr	r2, [r3, #16]
    eb92:	4b04      	ldr	r3, [pc, #16]	; (eba4 <FLASH_MassErase+0x2c>)
    eb94:	2140      	movs	r1, #64	; 0x40
    eb96:	430a      	orrs	r2, r1
    eb98:	611a      	str	r2, [r3, #16]
}
    eb9a:	46c0      	nop			; (mov r8, r8)
    eb9c:	46bd      	mov	sp, r7
    eb9e:	bd80      	pop	{r7, pc}
    eba0:	000321a8 	.word	0x000321a8
    eba4:	40022000 	.word	0x40022000

0000eba8 <FLASH_PageErase>:
  *         The value of this parameter depend on device used within the same series      
  * 
  * @retval None
  */
void FLASH_PageErase(uint32_t PageAddress)
{
    eba8:	b580      	push	{r7, lr}
    ebaa:	b082      	sub	sp, #8
    ebac:	af00      	add	r7, sp, #0
    ebae:	6078      	str	r0, [r7, #4]
  /* Clean the error context */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
    ebb0:	4b0a      	ldr	r3, [pc, #40]	; (ebdc <FLASH_PageErase+0x34>)
    ebb2:	2200      	movs	r2, #0
    ebb4:	61da      	str	r2, [r3, #28]

    /* Proceed to erase the page */
    SET_BIT(FLASH->CR, FLASH_CR_PER);
    ebb6:	4b0a      	ldr	r3, [pc, #40]	; (ebe0 <FLASH_PageErase+0x38>)
    ebb8:	691a      	ldr	r2, [r3, #16]
    ebba:	4b09      	ldr	r3, [pc, #36]	; (ebe0 <FLASH_PageErase+0x38>)
    ebbc:	2102      	movs	r1, #2
    ebbe:	430a      	orrs	r2, r1
    ebc0:	611a      	str	r2, [r3, #16]
    WRITE_REG(FLASH->AR, PageAddress);
    ebc2:	4b07      	ldr	r3, [pc, #28]	; (ebe0 <FLASH_PageErase+0x38>)
    ebc4:	687a      	ldr	r2, [r7, #4]
    ebc6:	615a      	str	r2, [r3, #20]
    SET_BIT(FLASH->CR, FLASH_CR_STRT);
    ebc8:	4b05      	ldr	r3, [pc, #20]	; (ebe0 <FLASH_PageErase+0x38>)
    ebca:	691a      	ldr	r2, [r3, #16]
    ebcc:	4b04      	ldr	r3, [pc, #16]	; (ebe0 <FLASH_PageErase+0x38>)
    ebce:	2140      	movs	r1, #64	; 0x40
    ebd0:	430a      	orrs	r2, r1
    ebd2:	611a      	str	r2, [r3, #16]
}
    ebd4:	46c0      	nop			; (mov r8, r8)
    ebd6:	46bd      	mov	sp, r7
    ebd8:	b002      	add	sp, #8
    ebda:	bd80      	pop	{r7, pc}
    ebdc:	000321a8 	.word	0x000321a8
    ebe0:	40022000 	.word	0x40022000

0000ebe4 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{ 
    ebe4:	b580      	push	{r7, lr}
    ebe6:	b086      	sub	sp, #24
    ebe8:	af00      	add	r7, sp, #0
    ebea:	6078      	str	r0, [r7, #4]
    ebec:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00U;
    ebee:	2300      	movs	r3, #0
    ebf0:	617b      	str	r3, [r7, #20]
  uint32_t iocurrent = 0x00U;
    ebf2:	2300      	movs	r3, #0
    ebf4:	60fb      	str	r3, [r7, #12]
  uint32_t temp = 0x00U;
    ebf6:	2300      	movs	r3, #0
    ebf8:	613b      	str	r3, [r7, #16]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull)); 

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != RESET)
    ebfa:	e155      	b.n	eea8 <HAL_GPIO_Init+0x2c4>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1U << position);
    ebfc:	683b      	ldr	r3, [r7, #0]
    ebfe:	681b      	ldr	r3, [r3, #0]
    ec00:	2101      	movs	r1, #1
    ec02:	697a      	ldr	r2, [r7, #20]
    ec04:	4091      	lsls	r1, r2
    ec06:	000a      	movs	r2, r1
    ec08:	4013      	ands	r3, r2
    ec0a:	60fb      	str	r3, [r7, #12]
    
    if(iocurrent)
    ec0c:	68fb      	ldr	r3, [r7, #12]
    ec0e:	2b00      	cmp	r3, #0
    ec10:	d100      	bne.n	ec14 <HAL_GPIO_Init+0x30>
    ec12:	e146      	b.n	eea2 <HAL_GPIO_Init+0x2be>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD)) 
    ec14:	683b      	ldr	r3, [r7, #0]
    ec16:	685b      	ldr	r3, [r3, #4]
    ec18:	2b02      	cmp	r3, #2
    ec1a:	d003      	beq.n	ec24 <HAL_GPIO_Init+0x40>
    ec1c:	683b      	ldr	r3, [r7, #0]
    ec1e:	685b      	ldr	r3, [r3, #4]
    ec20:	2b12      	cmp	r3, #18
    ec22:	d123      	bne.n	ec6c <HAL_GPIO_Init+0x88>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        
        /* Configure Alternate function mapped with the current IO */ 
        temp = GPIOx->AFR[position >> 3];
    ec24:	697b      	ldr	r3, [r7, #20]
    ec26:	08da      	lsrs	r2, r3, #3
    ec28:	687b      	ldr	r3, [r7, #4]
    ec2a:	3208      	adds	r2, #8
    ec2c:	0092      	lsls	r2, r2, #2
    ec2e:	58d3      	ldr	r3, [r2, r3]
    ec30:	613b      	str	r3, [r7, #16]
        CLEAR_BIT(temp, 0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;      
    ec32:	697b      	ldr	r3, [r7, #20]
    ec34:	2207      	movs	r2, #7
    ec36:	4013      	ands	r3, r2
    ec38:	009b      	lsls	r3, r3, #2
    ec3a:	220f      	movs	r2, #15
    ec3c:	409a      	lsls	r2, r3
    ec3e:	0013      	movs	r3, r2
    ec40:	43da      	mvns	r2, r3
    ec42:	693b      	ldr	r3, [r7, #16]
    ec44:	4013      	ands	r3, r2
    ec46:	613b      	str	r3, [r7, #16]
        SET_BIT(temp, (uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));       
    ec48:	683b      	ldr	r3, [r7, #0]
    ec4a:	691a      	ldr	r2, [r3, #16]
    ec4c:	697b      	ldr	r3, [r7, #20]
    ec4e:	2107      	movs	r1, #7
    ec50:	400b      	ands	r3, r1
    ec52:	009b      	lsls	r3, r3, #2
    ec54:	409a      	lsls	r2, r3
    ec56:	0013      	movs	r3, r2
    ec58:	693a      	ldr	r2, [r7, #16]
    ec5a:	4313      	orrs	r3, r2
    ec5c:	613b      	str	r3, [r7, #16]
        GPIOx->AFR[position >> 3U] = temp;
    ec5e:	697b      	ldr	r3, [r7, #20]
    ec60:	08da      	lsrs	r2, r3, #3
    ec62:	687b      	ldr	r3, [r7, #4]
    ec64:	3208      	adds	r2, #8
    ec66:	0092      	lsls	r2, r2, #2
    ec68:	6939      	ldr	r1, [r7, #16]
    ec6a:	50d1      	str	r1, [r2, r3]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
    ec6c:	687b      	ldr	r3, [r7, #4]
    ec6e:	681b      	ldr	r3, [r3, #0]
    ec70:	613b      	str	r3, [r7, #16]
      CLEAR_BIT(temp, GPIO_MODER_MODER0 << (position * 2U));   
    ec72:	697b      	ldr	r3, [r7, #20]
    ec74:	005b      	lsls	r3, r3, #1
    ec76:	2203      	movs	r2, #3
    ec78:	409a      	lsls	r2, r3
    ec7a:	0013      	movs	r3, r2
    ec7c:	43da      	mvns	r2, r3
    ec7e:	693b      	ldr	r3, [r7, #16]
    ec80:	4013      	ands	r3, r2
    ec82:	613b      	str	r3, [r7, #16]
      SET_BIT(temp, (GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
    ec84:	683b      	ldr	r3, [r7, #0]
    ec86:	685b      	ldr	r3, [r3, #4]
    ec88:	2203      	movs	r2, #3
    ec8a:	401a      	ands	r2, r3
    ec8c:	697b      	ldr	r3, [r7, #20]
    ec8e:	005b      	lsls	r3, r3, #1
    ec90:	409a      	lsls	r2, r3
    ec92:	0013      	movs	r3, r2
    ec94:	693a      	ldr	r2, [r7, #16]
    ec96:	4313      	orrs	r3, r2
    ec98:	613b      	str	r3, [r7, #16]
      GPIOx->MODER = temp;
    ec9a:	687b      	ldr	r3, [r7, #4]
    ec9c:	693a      	ldr	r2, [r7, #16]
    ec9e:	601a      	str	r2, [r3, #0]

      /* In case of Output or Alternate function mode selection */
      if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
    eca0:	683b      	ldr	r3, [r7, #0]
    eca2:	685b      	ldr	r3, [r3, #4]
    eca4:	2b01      	cmp	r3, #1
    eca6:	d00b      	beq.n	ecc0 <HAL_GPIO_Init+0xdc>
    eca8:	683b      	ldr	r3, [r7, #0]
    ecaa:	685b      	ldr	r3, [r3, #4]
    ecac:	2b02      	cmp	r3, #2
    ecae:	d007      	beq.n	ecc0 <HAL_GPIO_Init+0xdc>
          (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
    ecb0:	683b      	ldr	r3, [r7, #0]
    ecb2:	685b      	ldr	r3, [r3, #4]
      if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
    ecb4:	2b11      	cmp	r3, #17
    ecb6:	d003      	beq.n	ecc0 <HAL_GPIO_Init+0xdc>
          (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
    ecb8:	683b      	ldr	r3, [r7, #0]
    ecba:	685b      	ldr	r3, [r3, #4]
    ecbc:	2b12      	cmp	r3, #18
    ecbe:	d130      	bne.n	ed22 <HAL_GPIO_Init+0x13e>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
    ecc0:	687b      	ldr	r3, [r7, #4]
    ecc2:	689b      	ldr	r3, [r3, #8]
    ecc4:	613b      	str	r3, [r7, #16]
        CLEAR_BIT(temp, GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
    ecc6:	697b      	ldr	r3, [r7, #20]
    ecc8:	005b      	lsls	r3, r3, #1
    ecca:	2203      	movs	r2, #3
    eccc:	409a      	lsls	r2, r3
    ecce:	0013      	movs	r3, r2
    ecd0:	43da      	mvns	r2, r3
    ecd2:	693b      	ldr	r3, [r7, #16]
    ecd4:	4013      	ands	r3, r2
    ecd6:	613b      	str	r3, [r7, #16]
        SET_BIT(temp, GPIO_Init->Speed << (position * 2U));
    ecd8:	683b      	ldr	r3, [r7, #0]
    ecda:	68da      	ldr	r2, [r3, #12]
    ecdc:	697b      	ldr	r3, [r7, #20]
    ecde:	005b      	lsls	r3, r3, #1
    ece0:	409a      	lsls	r2, r3
    ece2:	0013      	movs	r3, r2
    ece4:	693a      	ldr	r2, [r7, #16]
    ece6:	4313      	orrs	r3, r2
    ece8:	613b      	str	r3, [r7, #16]
        GPIOx->OSPEEDR = temp;
    ecea:	687b      	ldr	r3, [r7, #4]
    ecec:	693a      	ldr	r2, [r7, #16]
    ecee:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
    ecf0:	687b      	ldr	r3, [r7, #4]
    ecf2:	685b      	ldr	r3, [r3, #4]
    ecf4:	613b      	str	r3, [r7, #16]
        CLEAR_BIT(temp, GPIO_OTYPER_OT_0 << position) ;
    ecf6:	2201      	movs	r2, #1
    ecf8:	697b      	ldr	r3, [r7, #20]
    ecfa:	409a      	lsls	r2, r3
    ecfc:	0013      	movs	r3, r2
    ecfe:	43da      	mvns	r2, r3
    ed00:	693b      	ldr	r3, [r7, #16]
    ed02:	4013      	ands	r3, r2
    ed04:	613b      	str	r3, [r7, #16]
        SET_BIT(temp, ((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
    ed06:	683b      	ldr	r3, [r7, #0]
    ed08:	685b      	ldr	r3, [r3, #4]
    ed0a:	091b      	lsrs	r3, r3, #4
    ed0c:	2201      	movs	r2, #1
    ed0e:	401a      	ands	r2, r3
    ed10:	697b      	ldr	r3, [r7, #20]
    ed12:	409a      	lsls	r2, r3
    ed14:	0013      	movs	r3, r2
    ed16:	693a      	ldr	r2, [r7, #16]
    ed18:	4313      	orrs	r3, r2
    ed1a:	613b      	str	r3, [r7, #16]
        GPIOx->OTYPER = temp;
    ed1c:	687b      	ldr	r3, [r7, #4]
    ed1e:	693a      	ldr	r2, [r7, #16]
    ed20:	605a      	str	r2, [r3, #4]
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
    ed22:	687b      	ldr	r3, [r7, #4]
    ed24:	68db      	ldr	r3, [r3, #12]
    ed26:	613b      	str	r3, [r7, #16]
      CLEAR_BIT(temp, GPIO_PUPDR_PUPDR0 << (position * 2U));
    ed28:	697b      	ldr	r3, [r7, #20]
    ed2a:	005b      	lsls	r3, r3, #1
    ed2c:	2203      	movs	r2, #3
    ed2e:	409a      	lsls	r2, r3
    ed30:	0013      	movs	r3, r2
    ed32:	43da      	mvns	r2, r3
    ed34:	693b      	ldr	r3, [r7, #16]
    ed36:	4013      	ands	r3, r2
    ed38:	613b      	str	r3, [r7, #16]
      SET_BIT(temp, (GPIO_Init->Pull) << (position * 2U));
    ed3a:	683b      	ldr	r3, [r7, #0]
    ed3c:	689a      	ldr	r2, [r3, #8]
    ed3e:	697b      	ldr	r3, [r7, #20]
    ed40:	005b      	lsls	r3, r3, #1
    ed42:	409a      	lsls	r2, r3
    ed44:	0013      	movs	r3, r2
    ed46:	693a      	ldr	r2, [r7, #16]
    ed48:	4313      	orrs	r3, r2
    ed4a:	613b      	str	r3, [r7, #16]
      GPIOx->PUPDR = temp;
    ed4c:	687b      	ldr	r3, [r7, #4]
    ed4e:	693a      	ldr	r2, [r7, #16]
    ed50:	60da      	str	r2, [r3, #12]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE) 
    ed52:	683b      	ldr	r3, [r7, #0]
    ed54:	685a      	ldr	r2, [r3, #4]
    ed56:	2380      	movs	r3, #128	; 0x80
    ed58:	055b      	lsls	r3, r3, #21
    ed5a:	4013      	ands	r3, r2
    ed5c:	d100      	bne.n	ed60 <HAL_GPIO_Init+0x17c>
    ed5e:	e0a0      	b.n	eea2 <HAL_GPIO_Init+0x2be>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
    ed60:	4b57      	ldr	r3, [pc, #348]	; (eec0 <HAL_GPIO_Init+0x2dc>)
    ed62:	699a      	ldr	r2, [r3, #24]
    ed64:	4b56      	ldr	r3, [pc, #344]	; (eec0 <HAL_GPIO_Init+0x2dc>)
    ed66:	2101      	movs	r1, #1
    ed68:	430a      	orrs	r2, r1
    ed6a:	619a      	str	r2, [r3, #24]
    ed6c:	4b54      	ldr	r3, [pc, #336]	; (eec0 <HAL_GPIO_Init+0x2dc>)
    ed6e:	699b      	ldr	r3, [r3, #24]
    ed70:	2201      	movs	r2, #1
    ed72:	4013      	ands	r3, r2
    ed74:	60bb      	str	r3, [r7, #8]
    ed76:	68bb      	ldr	r3, [r7, #8]
  
        temp = SYSCFG->EXTICR[position >> 2];
    ed78:	4a52      	ldr	r2, [pc, #328]	; (eec4 <HAL_GPIO_Init+0x2e0>)
    ed7a:	697b      	ldr	r3, [r7, #20]
    ed7c:	089b      	lsrs	r3, r3, #2
    ed7e:	3302      	adds	r3, #2
    ed80:	009b      	lsls	r3, r3, #2
    ed82:	589b      	ldr	r3, [r3, r2]
    ed84:	613b      	str	r3, [r7, #16]
        CLEAR_BIT(temp, (0x0FU) << (4U * (position & 0x03U)));
    ed86:	697b      	ldr	r3, [r7, #20]
    ed88:	2203      	movs	r2, #3
    ed8a:	4013      	ands	r3, r2
    ed8c:	009b      	lsls	r3, r3, #2
    ed8e:	220f      	movs	r2, #15
    ed90:	409a      	lsls	r2, r3
    ed92:	0013      	movs	r3, r2
    ed94:	43da      	mvns	r2, r3
    ed96:	693b      	ldr	r3, [r7, #16]
    ed98:	4013      	ands	r3, r2
    ed9a:	613b      	str	r3, [r7, #16]
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
    ed9c:	687a      	ldr	r2, [r7, #4]
    ed9e:	2390      	movs	r3, #144	; 0x90
    eda0:	05db      	lsls	r3, r3, #23
    eda2:	429a      	cmp	r2, r3
    eda4:	d019      	beq.n	edda <HAL_GPIO_Init+0x1f6>
    eda6:	687b      	ldr	r3, [r7, #4]
    eda8:	4a47      	ldr	r2, [pc, #284]	; (eec8 <HAL_GPIO_Init+0x2e4>)
    edaa:	4293      	cmp	r3, r2
    edac:	d013      	beq.n	edd6 <HAL_GPIO_Init+0x1f2>
    edae:	687b      	ldr	r3, [r7, #4]
    edb0:	4a46      	ldr	r2, [pc, #280]	; (eecc <HAL_GPIO_Init+0x2e8>)
    edb2:	4293      	cmp	r3, r2
    edb4:	d00d      	beq.n	edd2 <HAL_GPIO_Init+0x1ee>
    edb6:	687b      	ldr	r3, [r7, #4]
    edb8:	4a45      	ldr	r2, [pc, #276]	; (eed0 <HAL_GPIO_Init+0x2ec>)
    edba:	4293      	cmp	r3, r2
    edbc:	d007      	beq.n	edce <HAL_GPIO_Init+0x1ea>
    edbe:	687b      	ldr	r3, [r7, #4]
    edc0:	4a44      	ldr	r2, [pc, #272]	; (eed4 <HAL_GPIO_Init+0x2f0>)
    edc2:	4293      	cmp	r3, r2
    edc4:	d101      	bne.n	edca <HAL_GPIO_Init+0x1e6>
    edc6:	2304      	movs	r3, #4
    edc8:	e008      	b.n	eddc <HAL_GPIO_Init+0x1f8>
    edca:	2305      	movs	r3, #5
    edcc:	e006      	b.n	eddc <HAL_GPIO_Init+0x1f8>
    edce:	2303      	movs	r3, #3
    edd0:	e004      	b.n	eddc <HAL_GPIO_Init+0x1f8>
    edd2:	2302      	movs	r3, #2
    edd4:	e002      	b.n	eddc <HAL_GPIO_Init+0x1f8>
    edd6:	2301      	movs	r3, #1
    edd8:	e000      	b.n	eddc <HAL_GPIO_Init+0x1f8>
    edda:	2300      	movs	r3, #0
    eddc:	697a      	ldr	r2, [r7, #20]
    edde:	2103      	movs	r1, #3
    ede0:	400a      	ands	r2, r1
    ede2:	0092      	lsls	r2, r2, #2
    ede4:	4093      	lsls	r3, r2
    ede6:	693a      	ldr	r2, [r7, #16]
    ede8:	4313      	orrs	r3, r2
    edea:	613b      	str	r3, [r7, #16]
        SYSCFG->EXTICR[position >> 2] = temp;
    edec:	4935      	ldr	r1, [pc, #212]	; (eec4 <HAL_GPIO_Init+0x2e0>)
    edee:	697b      	ldr	r3, [r7, #20]
    edf0:	089b      	lsrs	r3, r3, #2
    edf2:	3302      	adds	r3, #2
    edf4:	009b      	lsls	r3, r3, #2
    edf6:	693a      	ldr	r2, [r7, #16]
    edf8:	505a      	str	r2, [r3, r1]
                  
        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
    edfa:	4b37      	ldr	r3, [pc, #220]	; (eed8 <HAL_GPIO_Init+0x2f4>)
    edfc:	681b      	ldr	r3, [r3, #0]
    edfe:	613b      	str	r3, [r7, #16]
        CLEAR_BIT(temp, (uint32_t)iocurrent);
    ee00:	68fb      	ldr	r3, [r7, #12]
    ee02:	43da      	mvns	r2, r3
    ee04:	693b      	ldr	r3, [r7, #16]
    ee06:	4013      	ands	r3, r2
    ee08:	613b      	str	r3, [r7, #16]
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
    ee0a:	683b      	ldr	r3, [r7, #0]
    ee0c:	685a      	ldr	r2, [r3, #4]
    ee0e:	2380      	movs	r3, #128	; 0x80
    ee10:	025b      	lsls	r3, r3, #9
    ee12:	4013      	ands	r3, r2
    ee14:	d003      	beq.n	ee1e <HAL_GPIO_Init+0x23a>
        {
          SET_BIT(temp, iocurrent); 
    ee16:	693a      	ldr	r2, [r7, #16]
    ee18:	68fb      	ldr	r3, [r7, #12]
    ee1a:	4313      	orrs	r3, r2
    ee1c:	613b      	str	r3, [r7, #16]
        }
        EXTI->IMR = temp;
    ee1e:	4b2e      	ldr	r3, [pc, #184]	; (eed8 <HAL_GPIO_Init+0x2f4>)
    ee20:	693a      	ldr	r2, [r7, #16]
    ee22:	601a      	str	r2, [r3, #0]

        temp = EXTI->EMR;
    ee24:	4b2c      	ldr	r3, [pc, #176]	; (eed8 <HAL_GPIO_Init+0x2f4>)
    ee26:	685b      	ldr	r3, [r3, #4]
    ee28:	613b      	str	r3, [r7, #16]
        CLEAR_BIT(temp, (uint32_t)iocurrent);      
    ee2a:	68fb      	ldr	r3, [r7, #12]
    ee2c:	43da      	mvns	r2, r3
    ee2e:	693b      	ldr	r3, [r7, #16]
    ee30:	4013      	ands	r3, r2
    ee32:	613b      	str	r3, [r7, #16]
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
    ee34:	683b      	ldr	r3, [r7, #0]
    ee36:	685a      	ldr	r2, [r3, #4]
    ee38:	2380      	movs	r3, #128	; 0x80
    ee3a:	029b      	lsls	r3, r3, #10
    ee3c:	4013      	ands	r3, r2
    ee3e:	d003      	beq.n	ee48 <HAL_GPIO_Init+0x264>
        { 
          SET_BIT(temp, iocurrent); 
    ee40:	693a      	ldr	r2, [r7, #16]
    ee42:	68fb      	ldr	r3, [r7, #12]
    ee44:	4313      	orrs	r3, r2
    ee46:	613b      	str	r3, [r7, #16]
        }
        EXTI->EMR = temp;
    ee48:	4b23      	ldr	r3, [pc, #140]	; (eed8 <HAL_GPIO_Init+0x2f4>)
    ee4a:	693a      	ldr	r2, [r7, #16]
    ee4c:	605a      	str	r2, [r3, #4]
  
        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
    ee4e:	4b22      	ldr	r3, [pc, #136]	; (eed8 <HAL_GPIO_Init+0x2f4>)
    ee50:	689b      	ldr	r3, [r3, #8]
    ee52:	613b      	str	r3, [r7, #16]
        CLEAR_BIT(temp, (uint32_t)iocurrent); 
    ee54:	68fb      	ldr	r3, [r7, #12]
    ee56:	43da      	mvns	r2, r3
    ee58:	693b      	ldr	r3, [r7, #16]
    ee5a:	4013      	ands	r3, r2
    ee5c:	613b      	str	r3, [r7, #16]
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
    ee5e:	683b      	ldr	r3, [r7, #0]
    ee60:	685a      	ldr	r2, [r3, #4]
    ee62:	2380      	movs	r3, #128	; 0x80
    ee64:	035b      	lsls	r3, r3, #13
    ee66:	4013      	ands	r3, r2
    ee68:	d003      	beq.n	ee72 <HAL_GPIO_Init+0x28e>
        {
          SET_BIT(temp, iocurrent); 
    ee6a:	693a      	ldr	r2, [r7, #16]
    ee6c:	68fb      	ldr	r3, [r7, #12]
    ee6e:	4313      	orrs	r3, r2
    ee70:	613b      	str	r3, [r7, #16]
        }
        EXTI->RTSR = temp;
    ee72:	4b19      	ldr	r3, [pc, #100]	; (eed8 <HAL_GPIO_Init+0x2f4>)
    ee74:	693a      	ldr	r2, [r7, #16]
    ee76:	609a      	str	r2, [r3, #8]

        temp = EXTI->FTSR;
    ee78:	4b17      	ldr	r3, [pc, #92]	; (eed8 <HAL_GPIO_Init+0x2f4>)
    ee7a:	68db      	ldr	r3, [r3, #12]
    ee7c:	613b      	str	r3, [r7, #16]
        CLEAR_BIT(temp, (uint32_t)iocurrent); 
    ee7e:	68fb      	ldr	r3, [r7, #12]
    ee80:	43da      	mvns	r2, r3
    ee82:	693b      	ldr	r3, [r7, #16]
    ee84:	4013      	ands	r3, r2
    ee86:	613b      	str	r3, [r7, #16]
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
    ee88:	683b      	ldr	r3, [r7, #0]
    ee8a:	685a      	ldr	r2, [r3, #4]
    ee8c:	2380      	movs	r3, #128	; 0x80
    ee8e:	039b      	lsls	r3, r3, #14
    ee90:	4013      	ands	r3, r2
    ee92:	d003      	beq.n	ee9c <HAL_GPIO_Init+0x2b8>
        {
          SET_BIT(temp, iocurrent); 
    ee94:	693a      	ldr	r2, [r7, #16]
    ee96:	68fb      	ldr	r3, [r7, #12]
    ee98:	4313      	orrs	r3, r2
    ee9a:	613b      	str	r3, [r7, #16]
        }
        EXTI->FTSR = temp;
    ee9c:	4b0e      	ldr	r3, [pc, #56]	; (eed8 <HAL_GPIO_Init+0x2f4>)
    ee9e:	693a      	ldr	r2, [r7, #16]
    eea0:	60da      	str	r2, [r3, #12]
      }
    }
    
    position++;
    eea2:	697b      	ldr	r3, [r7, #20]
    eea4:	3301      	adds	r3, #1
    eea6:	617b      	str	r3, [r7, #20]
  while (((GPIO_Init->Pin) >> position) != RESET)
    eea8:	683b      	ldr	r3, [r7, #0]
    eeaa:	681a      	ldr	r2, [r3, #0]
    eeac:	697b      	ldr	r3, [r7, #20]
    eeae:	40da      	lsrs	r2, r3
    eeb0:	1e13      	subs	r3, r2, #0
    eeb2:	d000      	beq.n	eeb6 <HAL_GPIO_Init+0x2d2>
    eeb4:	e6a2      	b.n	ebfc <HAL_GPIO_Init+0x18>
  } 
}
    eeb6:	46c0      	nop			; (mov r8, r8)
    eeb8:	46bd      	mov	sp, r7
    eeba:	b006      	add	sp, #24
    eebc:	bd80      	pop	{r7, pc}
    eebe:	46c0      	nop			; (mov r8, r8)
    eec0:	40021000 	.word	0x40021000
    eec4:	40010000 	.word	0x40010000
    eec8:	48000400 	.word	0x48000400
    eecc:	48000800 	.word	0x48000800
    eed0:	48000c00 	.word	0x48000c00
    eed4:	48001000 	.word	0x48001000
    eed8:	40010400 	.word	0x40010400

0000eedc <HAL_I2C_Init>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
{
    eedc:	b580      	push	{r7, lr}
    eede:	b082      	sub	sp, #8
    eee0:	af00      	add	r7, sp, #0
    eee2:	6078      	str	r0, [r7, #4]
  /* Check the I2C handle allocation */
  if(hi2c == NULL)
    eee4:	687b      	ldr	r3, [r7, #4]
    eee6:	2b00      	cmp	r3, #0
    eee8:	d101      	bne.n	eeee <HAL_I2C_Init+0x12>
  {
    return HAL_ERROR;
    eeea:	2301      	movs	r3, #1
    eeec:	e082      	b.n	eff4 <HAL_I2C_Init+0x118>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));

  if(hi2c->State == HAL_I2C_STATE_RESET)
    eeee:	687b      	ldr	r3, [r7, #4]
    eef0:	2241      	movs	r2, #65	; 0x41
    eef2:	5c9b      	ldrb	r3, [r3, r2]
    eef4:	b2db      	uxtb	r3, r3
    eef6:	2b00      	cmp	r3, #0
    eef8:	d107      	bne.n	ef0a <HAL_I2C_Init+0x2e>
  {
    /* Allocate lock resource and initialize it */
    hi2c->Lock = HAL_UNLOCKED;
    eefa:	687b      	ldr	r3, [r7, #4]
    eefc:	2240      	movs	r2, #64	; 0x40
    eefe:	2100      	movs	r1, #0
    ef00:	5499      	strb	r1, [r3, r2]

    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    HAL_I2C_MspInit(hi2c);
    ef02:	687b      	ldr	r3, [r7, #4]
    ef04:	0018      	movs	r0, r3
    ef06:	f7ff fad1 	bl	e4ac <HAL_I2C_MspInit>
  }

  hi2c->State = HAL_I2C_STATE_BUSY;
    ef0a:	687b      	ldr	r3, [r7, #4]
    ef0c:	2241      	movs	r2, #65	; 0x41
    ef0e:	2124      	movs	r1, #36	; 0x24
    ef10:	5499      	strb	r1, [r3, r2]

  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
    ef12:	687b      	ldr	r3, [r7, #4]
    ef14:	681b      	ldr	r3, [r3, #0]
    ef16:	681a      	ldr	r2, [r3, #0]
    ef18:	687b      	ldr	r3, [r7, #4]
    ef1a:	681b      	ldr	r3, [r3, #0]
    ef1c:	2101      	movs	r1, #1
    ef1e:	438a      	bics	r2, r1
    ef20:	601a      	str	r2, [r3, #0]

  /*---------------------------- I2Cx TIMINGR Configuration ------------------*/
  /* Configure I2Cx: Frequency range */
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
    ef22:	687b      	ldr	r3, [r7, #4]
    ef24:	685a      	ldr	r2, [r3, #4]
    ef26:	687b      	ldr	r3, [r7, #4]
    ef28:	681b      	ldr	r3, [r3, #0]
    ef2a:	4934      	ldr	r1, [pc, #208]	; (effc <HAL_I2C_Init+0x120>)
    ef2c:	400a      	ands	r2, r1
    ef2e:	611a      	str	r2, [r3, #16]

  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Disable Own Address1 before set the Own Address1 configuration */
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
    ef30:	687b      	ldr	r3, [r7, #4]
    ef32:	681b      	ldr	r3, [r3, #0]
    ef34:	689a      	ldr	r2, [r3, #8]
    ef36:	687b      	ldr	r3, [r7, #4]
    ef38:	681b      	ldr	r3, [r3, #0]
    ef3a:	4931      	ldr	r1, [pc, #196]	; (f000 <HAL_I2C_Init+0x124>)
    ef3c:	400a      	ands	r2, r1
    ef3e:	609a      	str	r2, [r3, #8]

  /* Configure I2Cx: Own Address1 and ack own address1 mode */
  if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
    ef40:	687b      	ldr	r3, [r7, #4]
    ef42:	68db      	ldr	r3, [r3, #12]
    ef44:	2b01      	cmp	r3, #1
    ef46:	d108      	bne.n	ef5a <HAL_I2C_Init+0x7e>
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
    ef48:	687b      	ldr	r3, [r7, #4]
    ef4a:	689a      	ldr	r2, [r3, #8]
    ef4c:	687b      	ldr	r3, [r7, #4]
    ef4e:	681b      	ldr	r3, [r3, #0]
    ef50:	2180      	movs	r1, #128	; 0x80
    ef52:	0209      	lsls	r1, r1, #8
    ef54:	430a      	orrs	r2, r1
    ef56:	609a      	str	r2, [r3, #8]
    ef58:	e007      	b.n	ef6a <HAL_I2C_Init+0x8e>
  }
  else /* I2C_ADDRESSINGMODE_10BIT */
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
    ef5a:	687b      	ldr	r3, [r7, #4]
    ef5c:	689a      	ldr	r2, [r3, #8]
    ef5e:	687b      	ldr	r3, [r7, #4]
    ef60:	681b      	ldr	r3, [r3, #0]
    ef62:	2184      	movs	r1, #132	; 0x84
    ef64:	0209      	lsls	r1, r1, #8
    ef66:	430a      	orrs	r2, r1
    ef68:	609a      	str	r2, [r3, #8]
  }

  /*---------------------------- I2Cx CR2 Configuration ----------------------*/
  /* Configure I2Cx: Addressing Master mode */
  if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
    ef6a:	687b      	ldr	r3, [r7, #4]
    ef6c:	68db      	ldr	r3, [r3, #12]
    ef6e:	2b02      	cmp	r3, #2
    ef70:	d104      	bne.n	ef7c <HAL_I2C_Init+0xa0>
  {
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
    ef72:	687b      	ldr	r3, [r7, #4]
    ef74:	681b      	ldr	r3, [r3, #0]
    ef76:	2280      	movs	r2, #128	; 0x80
    ef78:	0112      	lsls	r2, r2, #4
    ef7a:	605a      	str	r2, [r3, #4]
  }
  /* Enable the AUTOEND by default, and enable NACK (should be disable only during Slave process */
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
    ef7c:	687b      	ldr	r3, [r7, #4]
    ef7e:	681b      	ldr	r3, [r3, #0]
    ef80:	685a      	ldr	r2, [r3, #4]
    ef82:	687b      	ldr	r3, [r7, #4]
    ef84:	681b      	ldr	r3, [r3, #0]
    ef86:	491f      	ldr	r1, [pc, #124]	; (f004 <HAL_I2C_Init+0x128>)
    ef88:	430a      	orrs	r2, r1
    ef8a:	605a      	str	r2, [r3, #4]

  /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
  /* Disable Own Address2 before set the Own Address2 configuration */
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
    ef8c:	687b      	ldr	r3, [r7, #4]
    ef8e:	681b      	ldr	r3, [r3, #0]
    ef90:	68da      	ldr	r2, [r3, #12]
    ef92:	687b      	ldr	r3, [r7, #4]
    ef94:	681b      	ldr	r3, [r3, #0]
    ef96:	491a      	ldr	r1, [pc, #104]	; (f000 <HAL_I2C_Init+0x124>)
    ef98:	400a      	ands	r2, r1
    ef9a:	60da      	str	r2, [r3, #12]

  /* Configure I2Cx: Dual mode and Own Address2 */
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
    ef9c:	687b      	ldr	r3, [r7, #4]
    ef9e:	691a      	ldr	r2, [r3, #16]
    efa0:	687b      	ldr	r3, [r7, #4]
    efa2:	695b      	ldr	r3, [r3, #20]
    efa4:	431a      	orrs	r2, r3
    efa6:	0011      	movs	r1, r2
    efa8:	687b      	ldr	r3, [r7, #4]
    efaa:	699b      	ldr	r3, [r3, #24]
    efac:	021a      	lsls	r2, r3, #8
    efae:	687b      	ldr	r3, [r7, #4]
    efb0:	681b      	ldr	r3, [r3, #0]
    efb2:	430a      	orrs	r2, r1
    efb4:	60da      	str	r2, [r3, #12]

  /*---------------------------- I2Cx CR1 Configuration ----------------------*/
  /* Configure I2Cx: Generalcall and NoStretch mode */
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
    efb6:	687b      	ldr	r3, [r7, #4]
    efb8:	69d9      	ldr	r1, [r3, #28]
    efba:	687b      	ldr	r3, [r7, #4]
    efbc:	6a1a      	ldr	r2, [r3, #32]
    efbe:	687b      	ldr	r3, [r7, #4]
    efc0:	681b      	ldr	r3, [r3, #0]
    efc2:	430a      	orrs	r2, r1
    efc4:	601a      	str	r2, [r3, #0]

  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);
    efc6:	687b      	ldr	r3, [r7, #4]
    efc8:	681b      	ldr	r3, [r3, #0]
    efca:	681a      	ldr	r2, [r3, #0]
    efcc:	687b      	ldr	r3, [r7, #4]
    efce:	681b      	ldr	r3, [r3, #0]
    efd0:	2101      	movs	r1, #1
    efd2:	430a      	orrs	r2, r1
    efd4:	601a      	str	r2, [r3, #0]

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
    efd6:	687b      	ldr	r3, [r7, #4]
    efd8:	2200      	movs	r2, #0
    efda:	645a      	str	r2, [r3, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_READY;
    efdc:	687b      	ldr	r3, [r7, #4]
    efde:	2241      	movs	r2, #65	; 0x41
    efe0:	2120      	movs	r1, #32
    efe2:	5499      	strb	r1, [r3, r2]
  hi2c->PreviousState = I2C_STATE_NONE;
    efe4:	687b      	ldr	r3, [r7, #4]
    efe6:	2200      	movs	r2, #0
    efe8:	631a      	str	r2, [r3, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
    efea:	687b      	ldr	r3, [r7, #4]
    efec:	2242      	movs	r2, #66	; 0x42
    efee:	2100      	movs	r1, #0
    eff0:	5499      	strb	r1, [r3, r2]

  return HAL_OK;
    eff2:	2300      	movs	r3, #0
}
    eff4:	0018      	movs	r0, r3
    eff6:	46bd      	mov	sp, r7
    eff8:	b002      	add	sp, #8
    effa:	bd80      	pop	{r7, pc}
    effc:	f0ffffff 	.word	0xf0ffffff
    f000:	ffff7fff 	.word	0xffff7fff
    f004:	02008000 	.word	0x02008000

0000f008 <HAL_I2C_Mem_Write>:
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
    f008:	b590      	push	{r4, r7, lr}
    f00a:	b089      	sub	sp, #36	; 0x24
    f00c:	af02      	add	r7, sp, #8
    f00e:	60f8      	str	r0, [r7, #12]
    f010:	000c      	movs	r4, r1
    f012:	0010      	movs	r0, r2
    f014:	0019      	movs	r1, r3
    f016:	230a      	movs	r3, #10
    f018:	18fb      	adds	r3, r7, r3
    f01a:	1c22      	adds	r2, r4, #0
    f01c:	801a      	strh	r2, [r3, #0]
    f01e:	2308      	movs	r3, #8
    f020:	18fb      	adds	r3, r7, r3
    f022:	1c02      	adds	r2, r0, #0
    f024:	801a      	strh	r2, [r3, #0]
    f026:	1dbb      	adds	r3, r7, #6
    f028:	1c0a      	adds	r2, r1, #0
    f02a:	801a      	strh	r2, [r3, #0]
  uint32_t tickstart = 0U;
    f02c:	2300      	movs	r3, #0
    f02e:	617b      	str	r3, [r7, #20]

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if(hi2c->State == HAL_I2C_STATE_READY)
    f030:	68fb      	ldr	r3, [r7, #12]
    f032:	2241      	movs	r2, #65	; 0x41
    f034:	5c9b      	ldrb	r3, [r3, r2]
    f036:	b2db      	uxtb	r3, r3
    f038:	2b20      	cmp	r3, #32
    f03a:	d000      	beq.n	f03e <HAL_I2C_Mem_Write+0x36>
    f03c:	e11c      	b.n	f278 <HAL_I2C_Mem_Write+0x270>
  {
    if((pData == NULL) || (Size == 0U))
    f03e:	6abb      	ldr	r3, [r7, #40]	; 0x28
    f040:	2b00      	cmp	r3, #0
    f042:	d004      	beq.n	f04e <HAL_I2C_Mem_Write+0x46>
    f044:	232c      	movs	r3, #44	; 0x2c
    f046:	18fb      	adds	r3, r7, r3
    f048:	881b      	ldrh	r3, [r3, #0]
    f04a:	2b00      	cmp	r3, #0
    f04c:	d101      	bne.n	f052 <HAL_I2C_Mem_Write+0x4a>
    {
      return  HAL_ERROR;
    f04e:	2301      	movs	r3, #1
    f050:	e113      	b.n	f27a <HAL_I2C_Mem_Write+0x272>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
    f052:	68fb      	ldr	r3, [r7, #12]
    f054:	2240      	movs	r2, #64	; 0x40
    f056:	5c9b      	ldrb	r3, [r3, r2]
    f058:	2b01      	cmp	r3, #1
    f05a:	d101      	bne.n	f060 <HAL_I2C_Mem_Write+0x58>
    f05c:	2302      	movs	r3, #2
    f05e:	e10c      	b.n	f27a <HAL_I2C_Mem_Write+0x272>
    f060:	68fb      	ldr	r3, [r7, #12]
    f062:	2240      	movs	r2, #64	; 0x40
    f064:	2101      	movs	r1, #1
    f066:	5499      	strb	r1, [r3, r2]

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
    f068:	f7ff faac 	bl	e5c4 <HAL_GetTick>
    f06c:	0003      	movs	r3, r0
    f06e:	617b      	str	r3, [r7, #20]

    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
    f070:	2380      	movs	r3, #128	; 0x80
    f072:	0219      	lsls	r1, r3, #8
    f074:	68f8      	ldr	r0, [r7, #12]
    f076:	697b      	ldr	r3, [r7, #20]
    f078:	9300      	str	r3, [sp, #0]
    f07a:	2319      	movs	r3, #25
    f07c:	2201      	movs	r2, #1
    f07e:	f000 fb3f 	bl	f700 <I2C_WaitOnFlagUntilTimeout>
    f082:	1e03      	subs	r3, r0, #0
    f084:	d001      	beq.n	f08a <HAL_I2C_Mem_Write+0x82>
    {
      return HAL_TIMEOUT;
    f086:	2303      	movs	r3, #3
    f088:	e0f7      	b.n	f27a <HAL_I2C_Mem_Write+0x272>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
    f08a:	68fb      	ldr	r3, [r7, #12]
    f08c:	2241      	movs	r2, #65	; 0x41
    f08e:	2121      	movs	r1, #33	; 0x21
    f090:	5499      	strb	r1, [r3, r2]
    hi2c->Mode      = HAL_I2C_MODE_MEM;
    f092:	68fb      	ldr	r3, [r7, #12]
    f094:	2242      	movs	r2, #66	; 0x42
    f096:	2140      	movs	r1, #64	; 0x40
    f098:	5499      	strb	r1, [r3, r2]
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
    f09a:	68fb      	ldr	r3, [r7, #12]
    f09c:	2200      	movs	r2, #0
    f09e:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
    f0a0:	68fb      	ldr	r3, [r7, #12]
    f0a2:	6aba      	ldr	r2, [r7, #40]	; 0x28
    f0a4:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
    f0a6:	68fb      	ldr	r3, [r7, #12]
    f0a8:	222c      	movs	r2, #44	; 0x2c
    f0aa:	18ba      	adds	r2, r7, r2
    f0ac:	8812      	ldrh	r2, [r2, #0]
    f0ae:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
    f0b0:	68fb      	ldr	r3, [r7, #12]
    f0b2:	2200      	movs	r2, #0
    f0b4:	635a      	str	r2, [r3, #52]	; 0x34

    /* Send Slave Address and Memory Address */
    if(I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
    f0b6:	1dbb      	adds	r3, r7, #6
    f0b8:	881c      	ldrh	r4, [r3, #0]
    f0ba:	2308      	movs	r3, #8
    f0bc:	18fb      	adds	r3, r7, r3
    f0be:	881a      	ldrh	r2, [r3, #0]
    f0c0:	230a      	movs	r3, #10
    f0c2:	18fb      	adds	r3, r7, r3
    f0c4:	8819      	ldrh	r1, [r3, #0]
    f0c6:	68f8      	ldr	r0, [r7, #12]
    f0c8:	697b      	ldr	r3, [r7, #20]
    f0ca:	9301      	str	r3, [sp, #4]
    f0cc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    f0ce:	9300      	str	r3, [sp, #0]
    f0d0:	0023      	movs	r3, r4
    f0d2:	f000 fa19 	bl	f508 <I2C_RequestMemoryWrite>
    f0d6:	1e03      	subs	r3, r0, #0
    f0d8:	d00f      	beq.n	f0fa <HAL_I2C_Mem_Write+0xf2>
    {
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
    f0da:	68fb      	ldr	r3, [r7, #12]
    f0dc:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    f0de:	2b04      	cmp	r3, #4
    f0e0:	d105      	bne.n	f0ee <HAL_I2C_Mem_Write+0xe6>
      {
        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
    f0e2:	68fb      	ldr	r3, [r7, #12]
    f0e4:	2240      	movs	r2, #64	; 0x40
    f0e6:	2100      	movs	r1, #0
    f0e8:	5499      	strb	r1, [r3, r2]
        return HAL_ERROR;
    f0ea:	2301      	movs	r3, #1
    f0ec:	e0c5      	b.n	f27a <HAL_I2C_Mem_Write+0x272>
      }
      else
      {
        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
    f0ee:	68fb      	ldr	r3, [r7, #12]
    f0f0:	2240      	movs	r2, #64	; 0x40
    f0f2:	2100      	movs	r1, #0
    f0f4:	5499      	strb	r1, [r3, r2]
        return HAL_TIMEOUT;
    f0f6:	2303      	movs	r3, #3
    f0f8:	e0bf      	b.n	f27a <HAL_I2C_Mem_Write+0x272>
      }
    }

    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
    if(hi2c->XferCount > MAX_NBYTE_SIZE)
    f0fa:	68fb      	ldr	r3, [r7, #12]
    f0fc:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
    f0fe:	b29b      	uxth	r3, r3
    f100:	2bff      	cmp	r3, #255	; 0xff
    f102:	d911      	bls.n	f128 <HAL_I2C_Mem_Write+0x120>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
    f104:	68fb      	ldr	r3, [r7, #12]
    f106:	22ff      	movs	r2, #255	; 0xff
    f108:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
    f10a:	68fb      	ldr	r3, [r7, #12]
    f10c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    f10e:	b2da      	uxtb	r2, r3
    f110:	2380      	movs	r3, #128	; 0x80
    f112:	045c      	lsls	r4, r3, #17
    f114:	230a      	movs	r3, #10
    f116:	18fb      	adds	r3, r7, r3
    f118:	8819      	ldrh	r1, [r3, #0]
    f11a:	68f8      	ldr	r0, [r7, #12]
    f11c:	2300      	movs	r3, #0
    f11e:	9300      	str	r3, [sp, #0]
    f120:	0023      	movs	r3, r4
    f122:	f000 fbff 	bl	f924 <I2C_TransferConfig>
    f126:	e012      	b.n	f14e <HAL_I2C_Mem_Write+0x146>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
    f128:	68fb      	ldr	r3, [r7, #12]
    f12a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
    f12c:	b29a      	uxth	r2, r3
    f12e:	68fb      	ldr	r3, [r7, #12]
    f130:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
    f132:	68fb      	ldr	r3, [r7, #12]
    f134:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    f136:	b2da      	uxtb	r2, r3
    f138:	2380      	movs	r3, #128	; 0x80
    f13a:	049c      	lsls	r4, r3, #18
    f13c:	230a      	movs	r3, #10
    f13e:	18fb      	adds	r3, r7, r3
    f140:	8819      	ldrh	r1, [r3, #0]
    f142:	68f8      	ldr	r0, [r7, #12]
    f144:	2300      	movs	r3, #0
    f146:	9300      	str	r3, [sp, #0]
    f148:	0023      	movs	r3, r4
    f14a:	f000 fbeb 	bl	f924 <I2C_TransferConfig>
    }

    do
    {
      /* Wait until TXIS flag is set */
      if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
    f14e:	697a      	ldr	r2, [r7, #20]
    f150:	6b39      	ldr	r1, [r7, #48]	; 0x30
    f152:	68fb      	ldr	r3, [r7, #12]
    f154:	0018      	movs	r0, r3
    f156:	f000 fb0c 	bl	f772 <I2C_WaitOnTXISFlagUntilTimeout>
    f15a:	1e03      	subs	r3, r0, #0
    f15c:	d007      	beq.n	f16e <HAL_I2C_Mem_Write+0x166>
      {
        if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
    f15e:	68fb      	ldr	r3, [r7, #12]
    f160:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    f162:	2b04      	cmp	r3, #4
    f164:	d101      	bne.n	f16a <HAL_I2C_Mem_Write+0x162>
        {
          return HAL_ERROR;
    f166:	2301      	movs	r3, #1
    f168:	e087      	b.n	f27a <HAL_I2C_Mem_Write+0x272>
        }
        else
        {
          return HAL_TIMEOUT;
    f16a:	2303      	movs	r3, #3
    f16c:	e085      	b.n	f27a <HAL_I2C_Mem_Write+0x272>
        }
      }

      /* Write data to TXDR */
      hi2c->Instance->TXDR = (*hi2c->pBuffPtr++);
    f16e:	68fb      	ldr	r3, [r7, #12]
    f170:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    f172:	1c59      	adds	r1, r3, #1
    f174:	68fa      	ldr	r2, [r7, #12]
    f176:	6251      	str	r1, [r2, #36]	; 0x24
    f178:	781a      	ldrb	r2, [r3, #0]
    f17a:	68fb      	ldr	r3, [r7, #12]
    f17c:	681b      	ldr	r3, [r3, #0]
    f17e:	629a      	str	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
    f180:	68fb      	ldr	r3, [r7, #12]
    f182:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
    f184:	b29b      	uxth	r3, r3
    f186:	3b01      	subs	r3, #1
    f188:	b29a      	uxth	r2, r3
    f18a:	68fb      	ldr	r3, [r7, #12]
    f18c:	855a      	strh	r2, [r3, #42]	; 0x2a
      hi2c->XferSize--;
    f18e:	68fb      	ldr	r3, [r7, #12]
    f190:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    f192:	3b01      	subs	r3, #1
    f194:	b29a      	uxth	r2, r3
    f196:	68fb      	ldr	r3, [r7, #12]
    f198:	851a      	strh	r2, [r3, #40]	; 0x28

      if((hi2c->XferSize == 0U) && (hi2c->XferCount!=0U))
    f19a:	68fb      	ldr	r3, [r7, #12]
    f19c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    f19e:	2b00      	cmp	r3, #0
    f1a0:	d13b      	bne.n	f21a <HAL_I2C_Mem_Write+0x212>
    f1a2:	68fb      	ldr	r3, [r7, #12]
    f1a4:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
    f1a6:	b29b      	uxth	r3, r3
    f1a8:	2b00      	cmp	r3, #0
    f1aa:	d036      	beq.n	f21a <HAL_I2C_Mem_Write+0x212>
      {
        /* Wait until TCR flag is set */
        if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
    f1ac:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    f1ae:	68f8      	ldr	r0, [r7, #12]
    f1b0:	697b      	ldr	r3, [r7, #20]
    f1b2:	9300      	str	r3, [sp, #0]
    f1b4:	0013      	movs	r3, r2
    f1b6:	2200      	movs	r2, #0
    f1b8:	2180      	movs	r1, #128	; 0x80
    f1ba:	f000 faa1 	bl	f700 <I2C_WaitOnFlagUntilTimeout>
    f1be:	1e03      	subs	r3, r0, #0
    f1c0:	d001      	beq.n	f1c6 <HAL_I2C_Mem_Write+0x1be>
        {
          return HAL_TIMEOUT;
    f1c2:	2303      	movs	r3, #3
    f1c4:	e059      	b.n	f27a <HAL_I2C_Mem_Write+0x272>
        }

        if(hi2c->XferCount > MAX_NBYTE_SIZE)
    f1c6:	68fb      	ldr	r3, [r7, #12]
    f1c8:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
    f1ca:	b29b      	uxth	r3, r3
    f1cc:	2bff      	cmp	r3, #255	; 0xff
    f1ce:	d911      	bls.n	f1f4 <HAL_I2C_Mem_Write+0x1ec>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
    f1d0:	68fb      	ldr	r3, [r7, #12]
    f1d2:	22ff      	movs	r2, #255	; 0xff
    f1d4:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
    f1d6:	68fb      	ldr	r3, [r7, #12]
    f1d8:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    f1da:	b2da      	uxtb	r2, r3
    f1dc:	2380      	movs	r3, #128	; 0x80
    f1de:	045c      	lsls	r4, r3, #17
    f1e0:	230a      	movs	r3, #10
    f1e2:	18fb      	adds	r3, r7, r3
    f1e4:	8819      	ldrh	r1, [r3, #0]
    f1e6:	68f8      	ldr	r0, [r7, #12]
    f1e8:	2300      	movs	r3, #0
    f1ea:	9300      	str	r3, [sp, #0]
    f1ec:	0023      	movs	r3, r4
    f1ee:	f000 fb99 	bl	f924 <I2C_TransferConfig>
    f1f2:	e012      	b.n	f21a <HAL_I2C_Mem_Write+0x212>
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
    f1f4:	68fb      	ldr	r3, [r7, #12]
    f1f6:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
    f1f8:	b29a      	uxth	r2, r3
    f1fa:	68fb      	ldr	r3, [r7, #12]
    f1fc:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
    f1fe:	68fb      	ldr	r3, [r7, #12]
    f200:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    f202:	b2da      	uxtb	r2, r3
    f204:	2380      	movs	r3, #128	; 0x80
    f206:	049c      	lsls	r4, r3, #18
    f208:	230a      	movs	r3, #10
    f20a:	18fb      	adds	r3, r7, r3
    f20c:	8819      	ldrh	r1, [r3, #0]
    f20e:	68f8      	ldr	r0, [r7, #12]
    f210:	2300      	movs	r3, #0
    f212:	9300      	str	r3, [sp, #0]
    f214:	0023      	movs	r3, r4
    f216:	f000 fb85 	bl	f924 <I2C_TransferConfig>
        }
      }

    }while(hi2c->XferCount > 0U);
    f21a:	68fb      	ldr	r3, [r7, #12]
    f21c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
    f21e:	b29b      	uxth	r3, r3
    f220:	2b00      	cmp	r3, #0
    f222:	d194      	bne.n	f14e <HAL_I2C_Mem_Write+0x146>

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */ 
    if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
    f224:	697a      	ldr	r2, [r7, #20]
    f226:	6b39      	ldr	r1, [r7, #48]	; 0x30
    f228:	68fb      	ldr	r3, [r7, #12]
    f22a:	0018      	movs	r0, r3
    f22c:	f000 fae0 	bl	f7f0 <I2C_WaitOnSTOPFlagUntilTimeout>
    f230:	1e03      	subs	r3, r0, #0
    f232:	d007      	beq.n	f244 <HAL_I2C_Mem_Write+0x23c>
    {
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
    f234:	68fb      	ldr	r3, [r7, #12]
    f236:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    f238:	2b04      	cmp	r3, #4
    f23a:	d101      	bne.n	f240 <HAL_I2C_Mem_Write+0x238>
      {
        return HAL_ERROR;
    f23c:	2301      	movs	r3, #1
    f23e:	e01c      	b.n	f27a <HAL_I2C_Mem_Write+0x272>
      }
      else
      {
        return HAL_TIMEOUT;
    f240:	2303      	movs	r3, #3
    f242:	e01a      	b.n	f27a <HAL_I2C_Mem_Write+0x272>
      }
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
    f244:	68fb      	ldr	r3, [r7, #12]
    f246:	681b      	ldr	r3, [r3, #0]
    f248:	2220      	movs	r2, #32
    f24a:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
    f24c:	68fb      	ldr	r3, [r7, #12]
    f24e:	681b      	ldr	r3, [r3, #0]
    f250:	685a      	ldr	r2, [r3, #4]
    f252:	68fb      	ldr	r3, [r7, #12]
    f254:	681b      	ldr	r3, [r3, #0]
    f256:	490b      	ldr	r1, [pc, #44]	; (f284 <HAL_I2C_Mem_Write+0x27c>)
    f258:	400a      	ands	r2, r1
    f25a:	605a      	str	r2, [r3, #4]

    hi2c->State = HAL_I2C_STATE_READY;
    f25c:	68fb      	ldr	r3, [r7, #12]
    f25e:	2241      	movs	r2, #65	; 0x41
    f260:	2120      	movs	r1, #32
    f262:	5499      	strb	r1, [r3, r2]
    hi2c->Mode  = HAL_I2C_MODE_NONE;
    f264:	68fb      	ldr	r3, [r7, #12]
    f266:	2242      	movs	r2, #66	; 0x42
    f268:	2100      	movs	r1, #0
    f26a:	5499      	strb	r1, [r3, r2]

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
    f26c:	68fb      	ldr	r3, [r7, #12]
    f26e:	2240      	movs	r2, #64	; 0x40
    f270:	2100      	movs	r1, #0
    f272:	5499      	strb	r1, [r3, r2]

    return HAL_OK;
    f274:	2300      	movs	r3, #0
    f276:	e000      	b.n	f27a <HAL_I2C_Mem_Write+0x272>
  }
  else
  {
    return HAL_BUSY;
    f278:	2302      	movs	r3, #2
  }
}
    f27a:	0018      	movs	r0, r3
    f27c:	46bd      	mov	sp, r7
    f27e:	b007      	add	sp, #28
    f280:	bd90      	pop	{r4, r7, pc}
    f282:	46c0      	nop			; (mov r8, r8)
    f284:	fe00e800 	.word	0xfe00e800

0000f288 <HAL_I2C_Mem_Read>:
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
    f288:	b590      	push	{r4, r7, lr}
    f28a:	b089      	sub	sp, #36	; 0x24
    f28c:	af02      	add	r7, sp, #8
    f28e:	60f8      	str	r0, [r7, #12]
    f290:	000c      	movs	r4, r1
    f292:	0010      	movs	r0, r2
    f294:	0019      	movs	r1, r3
    f296:	230a      	movs	r3, #10
    f298:	18fb      	adds	r3, r7, r3
    f29a:	1c22      	adds	r2, r4, #0
    f29c:	801a      	strh	r2, [r3, #0]
    f29e:	2308      	movs	r3, #8
    f2a0:	18fb      	adds	r3, r7, r3
    f2a2:	1c02      	adds	r2, r0, #0
    f2a4:	801a      	strh	r2, [r3, #0]
    f2a6:	1dbb      	adds	r3, r7, #6
    f2a8:	1c0a      	adds	r2, r1, #0
    f2aa:	801a      	strh	r2, [r3, #0]
  uint32_t tickstart = 0U;
    f2ac:	2300      	movs	r3, #0
    f2ae:	617b      	str	r3, [r7, #20]

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if(hi2c->State == HAL_I2C_STATE_READY)
    f2b0:	68fb      	ldr	r3, [r7, #12]
    f2b2:	2241      	movs	r2, #65	; 0x41
    f2b4:	5c9b      	ldrb	r3, [r3, r2]
    f2b6:	b2db      	uxtb	r3, r3
    f2b8:	2b20      	cmp	r3, #32
    f2ba:	d000      	beq.n	f2be <HAL_I2C_Mem_Read+0x36>
    f2bc:	e11c      	b.n	f4f8 <HAL_I2C_Mem_Read+0x270>
  {
    if((pData == NULL) || (Size == 0U))
    f2be:	6abb      	ldr	r3, [r7, #40]	; 0x28
    f2c0:	2b00      	cmp	r3, #0
    f2c2:	d004      	beq.n	f2ce <HAL_I2C_Mem_Read+0x46>
    f2c4:	232c      	movs	r3, #44	; 0x2c
    f2c6:	18fb      	adds	r3, r7, r3
    f2c8:	881b      	ldrh	r3, [r3, #0]
    f2ca:	2b00      	cmp	r3, #0
    f2cc:	d101      	bne.n	f2d2 <HAL_I2C_Mem_Read+0x4a>
    {
      return  HAL_ERROR;
    f2ce:	2301      	movs	r3, #1
    f2d0:	e113      	b.n	f4fa <HAL_I2C_Mem_Read+0x272>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
    f2d2:	68fb      	ldr	r3, [r7, #12]
    f2d4:	2240      	movs	r2, #64	; 0x40
    f2d6:	5c9b      	ldrb	r3, [r3, r2]
    f2d8:	2b01      	cmp	r3, #1
    f2da:	d101      	bne.n	f2e0 <HAL_I2C_Mem_Read+0x58>
    f2dc:	2302      	movs	r3, #2
    f2de:	e10c      	b.n	f4fa <HAL_I2C_Mem_Read+0x272>
    f2e0:	68fb      	ldr	r3, [r7, #12]
    f2e2:	2240      	movs	r2, #64	; 0x40
    f2e4:	2101      	movs	r1, #1
    f2e6:	5499      	strb	r1, [r3, r2]

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
    f2e8:	f7ff f96c 	bl	e5c4 <HAL_GetTick>
    f2ec:	0003      	movs	r3, r0
    f2ee:	617b      	str	r3, [r7, #20]

    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
    f2f0:	2380      	movs	r3, #128	; 0x80
    f2f2:	0219      	lsls	r1, r3, #8
    f2f4:	68f8      	ldr	r0, [r7, #12]
    f2f6:	697b      	ldr	r3, [r7, #20]
    f2f8:	9300      	str	r3, [sp, #0]
    f2fa:	2319      	movs	r3, #25
    f2fc:	2201      	movs	r2, #1
    f2fe:	f000 f9ff 	bl	f700 <I2C_WaitOnFlagUntilTimeout>
    f302:	1e03      	subs	r3, r0, #0
    f304:	d001      	beq.n	f30a <HAL_I2C_Mem_Read+0x82>
    {
      return HAL_TIMEOUT;
    f306:	2303      	movs	r3, #3
    f308:	e0f7      	b.n	f4fa <HAL_I2C_Mem_Read+0x272>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
    f30a:	68fb      	ldr	r3, [r7, #12]
    f30c:	2241      	movs	r2, #65	; 0x41
    f30e:	2122      	movs	r1, #34	; 0x22
    f310:	5499      	strb	r1, [r3, r2]
    hi2c->Mode      = HAL_I2C_MODE_MEM;
    f312:	68fb      	ldr	r3, [r7, #12]
    f314:	2242      	movs	r2, #66	; 0x42
    f316:	2140      	movs	r1, #64	; 0x40
    f318:	5499      	strb	r1, [r3, r2]
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
    f31a:	68fb      	ldr	r3, [r7, #12]
    f31c:	2200      	movs	r2, #0
    f31e:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
    f320:	68fb      	ldr	r3, [r7, #12]
    f322:	6aba      	ldr	r2, [r7, #40]	; 0x28
    f324:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
    f326:	68fb      	ldr	r3, [r7, #12]
    f328:	222c      	movs	r2, #44	; 0x2c
    f32a:	18ba      	adds	r2, r7, r2
    f32c:	8812      	ldrh	r2, [r2, #0]
    f32e:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
    f330:	68fb      	ldr	r3, [r7, #12]
    f332:	2200      	movs	r2, #0
    f334:	635a      	str	r2, [r3, #52]	; 0x34

    /* Send Slave Address and Memory Address */
    if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
    f336:	1dbb      	adds	r3, r7, #6
    f338:	881c      	ldrh	r4, [r3, #0]
    f33a:	2308      	movs	r3, #8
    f33c:	18fb      	adds	r3, r7, r3
    f33e:	881a      	ldrh	r2, [r3, #0]
    f340:	230a      	movs	r3, #10
    f342:	18fb      	adds	r3, r7, r3
    f344:	8819      	ldrh	r1, [r3, #0]
    f346:	68f8      	ldr	r0, [r7, #12]
    f348:	697b      	ldr	r3, [r7, #20]
    f34a:	9301      	str	r3, [sp, #4]
    f34c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    f34e:	9300      	str	r3, [sp, #0]
    f350:	0023      	movs	r3, r4
    f352:	f000 f947 	bl	f5e4 <I2C_RequestMemoryRead>
    f356:	1e03      	subs	r3, r0, #0
    f358:	d00f      	beq.n	f37a <HAL_I2C_Mem_Read+0xf2>
    {
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
    f35a:	68fb      	ldr	r3, [r7, #12]
    f35c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    f35e:	2b04      	cmp	r3, #4
    f360:	d105      	bne.n	f36e <HAL_I2C_Mem_Read+0xe6>
      {
        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
    f362:	68fb      	ldr	r3, [r7, #12]
    f364:	2240      	movs	r2, #64	; 0x40
    f366:	2100      	movs	r1, #0
    f368:	5499      	strb	r1, [r3, r2]
        return HAL_ERROR;
    f36a:	2301      	movs	r3, #1
    f36c:	e0c5      	b.n	f4fa <HAL_I2C_Mem_Read+0x272>
      }
      else
      {
        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
    f36e:	68fb      	ldr	r3, [r7, #12]
    f370:	2240      	movs	r2, #64	; 0x40
    f372:	2100      	movs	r1, #0
    f374:	5499      	strb	r1, [r3, r2]
        return HAL_TIMEOUT;
    f376:	2303      	movs	r3, #3
    f378:	e0bf      	b.n	f4fa <HAL_I2C_Mem_Read+0x272>
      }
    }

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if(hi2c->XferCount > MAX_NBYTE_SIZE)
    f37a:	68fb      	ldr	r3, [r7, #12]
    f37c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
    f37e:	b29b      	uxth	r3, r3
    f380:	2bff      	cmp	r3, #255	; 0xff
    f382:	d912      	bls.n	f3aa <HAL_I2C_Mem_Read+0x122>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
    f384:	68fb      	ldr	r3, [r7, #12]
    f386:	22ff      	movs	r2, #255	; 0xff
    f388:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
    f38a:	68fb      	ldr	r3, [r7, #12]
    f38c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    f38e:	b2da      	uxtb	r2, r3
    f390:	2380      	movs	r3, #128	; 0x80
    f392:	045c      	lsls	r4, r3, #17
    f394:	230a      	movs	r3, #10
    f396:	18fb      	adds	r3, r7, r3
    f398:	8819      	ldrh	r1, [r3, #0]
    f39a:	68f8      	ldr	r0, [r7, #12]
    f39c:	2390      	movs	r3, #144	; 0x90
    f39e:	019b      	lsls	r3, r3, #6
    f3a0:	9300      	str	r3, [sp, #0]
    f3a2:	0023      	movs	r3, r4
    f3a4:	f000 fabe 	bl	f924 <I2C_TransferConfig>
    f3a8:	e013      	b.n	f3d2 <HAL_I2C_Mem_Read+0x14a>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
    f3aa:	68fb      	ldr	r3, [r7, #12]
    f3ac:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
    f3ae:	b29a      	uxth	r2, r3
    f3b0:	68fb      	ldr	r3, [r7, #12]
    f3b2:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
    f3b4:	68fb      	ldr	r3, [r7, #12]
    f3b6:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    f3b8:	b2da      	uxtb	r2, r3
    f3ba:	2380      	movs	r3, #128	; 0x80
    f3bc:	049c      	lsls	r4, r3, #18
    f3be:	230a      	movs	r3, #10
    f3c0:	18fb      	adds	r3, r7, r3
    f3c2:	8819      	ldrh	r1, [r3, #0]
    f3c4:	68f8      	ldr	r0, [r7, #12]
    f3c6:	2390      	movs	r3, #144	; 0x90
    f3c8:	019b      	lsls	r3, r3, #6
    f3ca:	9300      	str	r3, [sp, #0]
    f3cc:	0023      	movs	r3, r4
    f3ce:	f000 faa9 	bl	f924 <I2C_TransferConfig>
    }

    do
    {
      /* Wait until RXNE flag is set */
      if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout, tickstart) != HAL_OK)
    f3d2:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    f3d4:	68f8      	ldr	r0, [r7, #12]
    f3d6:	697b      	ldr	r3, [r7, #20]
    f3d8:	9300      	str	r3, [sp, #0]
    f3da:	0013      	movs	r3, r2
    f3dc:	2200      	movs	r2, #0
    f3de:	2104      	movs	r1, #4
    f3e0:	f000 f98e 	bl	f700 <I2C_WaitOnFlagUntilTimeout>
    f3e4:	1e03      	subs	r3, r0, #0
    f3e6:	d001      	beq.n	f3ec <HAL_I2C_Mem_Read+0x164>
      {
        return HAL_TIMEOUT;
    f3e8:	2303      	movs	r3, #3
    f3ea:	e086      	b.n	f4fa <HAL_I2C_Mem_Read+0x272>
      }

      /* Read data from RXDR */
      (*hi2c->pBuffPtr++) = hi2c->Instance->RXDR;
    f3ec:	68fb      	ldr	r3, [r7, #12]
    f3ee:	681b      	ldr	r3, [r3, #0]
    f3f0:	6a58      	ldr	r0, [r3, #36]	; 0x24
    f3f2:	68fb      	ldr	r3, [r7, #12]
    f3f4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    f3f6:	1c59      	adds	r1, r3, #1
    f3f8:	68fa      	ldr	r2, [r7, #12]
    f3fa:	6251      	str	r1, [r2, #36]	; 0x24
    f3fc:	b2c2      	uxtb	r2, r0
    f3fe:	701a      	strb	r2, [r3, #0]
      hi2c->XferSize--;
    f400:	68fb      	ldr	r3, [r7, #12]
    f402:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    f404:	3b01      	subs	r3, #1
    f406:	b29a      	uxth	r2, r3
    f408:	68fb      	ldr	r3, [r7, #12]
    f40a:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
    f40c:	68fb      	ldr	r3, [r7, #12]
    f40e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
    f410:	b29b      	uxth	r3, r3
    f412:	3b01      	subs	r3, #1
    f414:	b29a      	uxth	r2, r3
    f416:	68fb      	ldr	r3, [r7, #12]
    f418:	855a      	strh	r2, [r3, #42]	; 0x2a

      if((hi2c->XferSize == 0U) && (hi2c->XferCount != 0U))
    f41a:	68fb      	ldr	r3, [r7, #12]
    f41c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    f41e:	2b00      	cmp	r3, #0
    f420:	d13b      	bne.n	f49a <HAL_I2C_Mem_Read+0x212>
    f422:	68fb      	ldr	r3, [r7, #12]
    f424:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
    f426:	b29b      	uxth	r3, r3
    f428:	2b00      	cmp	r3, #0
    f42a:	d036      	beq.n	f49a <HAL_I2C_Mem_Read+0x212>
      {
        /* Wait until TCR flag is set */
        if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
    f42c:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    f42e:	68f8      	ldr	r0, [r7, #12]
    f430:	697b      	ldr	r3, [r7, #20]
    f432:	9300      	str	r3, [sp, #0]
    f434:	0013      	movs	r3, r2
    f436:	2200      	movs	r2, #0
    f438:	2180      	movs	r1, #128	; 0x80
    f43a:	f000 f961 	bl	f700 <I2C_WaitOnFlagUntilTimeout>
    f43e:	1e03      	subs	r3, r0, #0
    f440:	d001      	beq.n	f446 <HAL_I2C_Mem_Read+0x1be>
        {
          return HAL_TIMEOUT;
    f442:	2303      	movs	r3, #3
    f444:	e059      	b.n	f4fa <HAL_I2C_Mem_Read+0x272>
        }

        if(hi2c->XferCount > MAX_NBYTE_SIZE)
    f446:	68fb      	ldr	r3, [r7, #12]
    f448:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
    f44a:	b29b      	uxth	r3, r3
    f44c:	2bff      	cmp	r3, #255	; 0xff
    f44e:	d911      	bls.n	f474 <HAL_I2C_Mem_Read+0x1ec>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
    f450:	68fb      	ldr	r3, [r7, #12]
    f452:	22ff      	movs	r2, #255	; 0xff
    f454:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
    f456:	68fb      	ldr	r3, [r7, #12]
    f458:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    f45a:	b2da      	uxtb	r2, r3
    f45c:	2380      	movs	r3, #128	; 0x80
    f45e:	045c      	lsls	r4, r3, #17
    f460:	230a      	movs	r3, #10
    f462:	18fb      	adds	r3, r7, r3
    f464:	8819      	ldrh	r1, [r3, #0]
    f466:	68f8      	ldr	r0, [r7, #12]
    f468:	2300      	movs	r3, #0
    f46a:	9300      	str	r3, [sp, #0]
    f46c:	0023      	movs	r3, r4
    f46e:	f000 fa59 	bl	f924 <I2C_TransferConfig>
    f472:	e012      	b.n	f49a <HAL_I2C_Mem_Read+0x212>
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
    f474:	68fb      	ldr	r3, [r7, #12]
    f476:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
    f478:	b29a      	uxth	r2, r3
    f47a:	68fb      	ldr	r3, [r7, #12]
    f47c:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
    f47e:	68fb      	ldr	r3, [r7, #12]
    f480:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    f482:	b2da      	uxtb	r2, r3
    f484:	2380      	movs	r3, #128	; 0x80
    f486:	049c      	lsls	r4, r3, #18
    f488:	230a      	movs	r3, #10
    f48a:	18fb      	adds	r3, r7, r3
    f48c:	8819      	ldrh	r1, [r3, #0]
    f48e:	68f8      	ldr	r0, [r7, #12]
    f490:	2300      	movs	r3, #0
    f492:	9300      	str	r3, [sp, #0]
    f494:	0023      	movs	r3, r4
    f496:	f000 fa45 	bl	f924 <I2C_TransferConfig>
        }
      }
    }while(hi2c->XferCount > 0U);
    f49a:	68fb      	ldr	r3, [r7, #12]
    f49c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
    f49e:	b29b      	uxth	r3, r3
    f4a0:	2b00      	cmp	r3, #0
    f4a2:	d196      	bne.n	f3d2 <HAL_I2C_Mem_Read+0x14a>

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */ 
    if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
    f4a4:	697a      	ldr	r2, [r7, #20]
    f4a6:	6b39      	ldr	r1, [r7, #48]	; 0x30
    f4a8:	68fb      	ldr	r3, [r7, #12]
    f4aa:	0018      	movs	r0, r3
    f4ac:	f000 f9a0 	bl	f7f0 <I2C_WaitOnSTOPFlagUntilTimeout>
    f4b0:	1e03      	subs	r3, r0, #0
    f4b2:	d007      	beq.n	f4c4 <HAL_I2C_Mem_Read+0x23c>
    {
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
    f4b4:	68fb      	ldr	r3, [r7, #12]
    f4b6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    f4b8:	2b04      	cmp	r3, #4
    f4ba:	d101      	bne.n	f4c0 <HAL_I2C_Mem_Read+0x238>
      {
        return HAL_ERROR;
    f4bc:	2301      	movs	r3, #1
    f4be:	e01c      	b.n	f4fa <HAL_I2C_Mem_Read+0x272>
      }
      else
      {
        return HAL_TIMEOUT;
    f4c0:	2303      	movs	r3, #3
    f4c2:	e01a      	b.n	f4fa <HAL_I2C_Mem_Read+0x272>
      }
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
    f4c4:	68fb      	ldr	r3, [r7, #12]
    f4c6:	681b      	ldr	r3, [r3, #0]
    f4c8:	2220      	movs	r2, #32
    f4ca:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
    f4cc:	68fb      	ldr	r3, [r7, #12]
    f4ce:	681b      	ldr	r3, [r3, #0]
    f4d0:	685a      	ldr	r2, [r3, #4]
    f4d2:	68fb      	ldr	r3, [r7, #12]
    f4d4:	681b      	ldr	r3, [r3, #0]
    f4d6:	490b      	ldr	r1, [pc, #44]	; (f504 <HAL_I2C_Mem_Read+0x27c>)
    f4d8:	400a      	ands	r2, r1
    f4da:	605a      	str	r2, [r3, #4]

    hi2c->State = HAL_I2C_STATE_READY;
    f4dc:	68fb      	ldr	r3, [r7, #12]
    f4de:	2241      	movs	r2, #65	; 0x41
    f4e0:	2120      	movs	r1, #32
    f4e2:	5499      	strb	r1, [r3, r2]
    hi2c->Mode  = HAL_I2C_MODE_NONE;
    f4e4:	68fb      	ldr	r3, [r7, #12]
    f4e6:	2242      	movs	r2, #66	; 0x42
    f4e8:	2100      	movs	r1, #0
    f4ea:	5499      	strb	r1, [r3, r2]

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
    f4ec:	68fb      	ldr	r3, [r7, #12]
    f4ee:	2240      	movs	r2, #64	; 0x40
    f4f0:	2100      	movs	r1, #0
    f4f2:	5499      	strb	r1, [r3, r2]

    return HAL_OK;
    f4f4:	2300      	movs	r3, #0
    f4f6:	e000      	b.n	f4fa <HAL_I2C_Mem_Read+0x272>
  }
  else
  {
    return HAL_BUSY;
    f4f8:	2302      	movs	r3, #2
  }
}
    f4fa:	0018      	movs	r0, r3
    f4fc:	46bd      	mov	sp, r7
    f4fe:	b007      	add	sp, #28
    f500:	bd90      	pop	{r4, r7, pc}
    f502:	46c0      	nop			; (mov r8, r8)
    f504:	fe00e800 	.word	0xfe00e800

0000f508 <I2C_RequestMemoryWrite>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
{
    f508:	b5b0      	push	{r4, r5, r7, lr}
    f50a:	b086      	sub	sp, #24
    f50c:	af02      	add	r7, sp, #8
    f50e:	60f8      	str	r0, [r7, #12]
    f510:	000c      	movs	r4, r1
    f512:	0010      	movs	r0, r2
    f514:	0019      	movs	r1, r3
    f516:	250a      	movs	r5, #10
    f518:	197b      	adds	r3, r7, r5
    f51a:	1c22      	adds	r2, r4, #0
    f51c:	801a      	strh	r2, [r3, #0]
    f51e:	2308      	movs	r3, #8
    f520:	18fb      	adds	r3, r7, r3
    f522:	1c02      	adds	r2, r0, #0
    f524:	801a      	strh	r2, [r3, #0]
    f526:	1dbb      	adds	r3, r7, #6
    f528:	1c0a      	adds	r2, r1, #0
    f52a:	801a      	strh	r2, [r3, #0]
  I2C_TransferConfig(hi2c,DevAddress,MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
    f52c:	1dbb      	adds	r3, r7, #6
    f52e:	881b      	ldrh	r3, [r3, #0]
    f530:	b2da      	uxtb	r2, r3
    f532:	2380      	movs	r3, #128	; 0x80
    f534:	045c      	lsls	r4, r3, #17
    f536:	197b      	adds	r3, r7, r5
    f538:	8819      	ldrh	r1, [r3, #0]
    f53a:	68f8      	ldr	r0, [r7, #12]
    f53c:	2380      	movs	r3, #128	; 0x80
    f53e:	019b      	lsls	r3, r3, #6
    f540:	9300      	str	r3, [sp, #0]
    f542:	0023      	movs	r3, r4
    f544:	f000 f9ee 	bl	f924 <I2C_TransferConfig>

  /* Wait until TXIS flag is set */
  if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
    f548:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    f54a:	6a39      	ldr	r1, [r7, #32]
    f54c:	68fb      	ldr	r3, [r7, #12]
    f54e:	0018      	movs	r0, r3
    f550:	f000 f90f 	bl	f772 <I2C_WaitOnTXISFlagUntilTimeout>
    f554:	1e03      	subs	r3, r0, #0
    f556:	d007      	beq.n	f568 <I2C_RequestMemoryWrite+0x60>
  {
    if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
    f558:	68fb      	ldr	r3, [r7, #12]
    f55a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    f55c:	2b04      	cmp	r3, #4
    f55e:	d101      	bne.n	f564 <I2C_RequestMemoryWrite+0x5c>
    {
      return HAL_ERROR;
    f560:	2301      	movs	r3, #1
    f562:	e03b      	b.n	f5dc <I2C_RequestMemoryWrite+0xd4>
    }
    else
    {
      return HAL_TIMEOUT;
    f564:	2303      	movs	r3, #3
    f566:	e039      	b.n	f5dc <I2C_RequestMemoryWrite+0xd4>
    }
  }

  /* If Memory address size is 8Bit */
  if(MemAddSize == I2C_MEMADD_SIZE_8BIT)
    f568:	1dbb      	adds	r3, r7, #6
    f56a:	881b      	ldrh	r3, [r3, #0]
    f56c:	2b01      	cmp	r3, #1
    f56e:	d107      	bne.n	f580 <I2C_RequestMemoryWrite+0x78>
  {
    /* Send Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
    f570:	2308      	movs	r3, #8
    f572:	18fb      	adds	r3, r7, r3
    f574:	881b      	ldrh	r3, [r3, #0]
    f576:	b2da      	uxtb	r2, r3
    f578:	68fb      	ldr	r3, [r7, #12]
    f57a:	681b      	ldr	r3, [r3, #0]
    f57c:	629a      	str	r2, [r3, #40]	; 0x28
    f57e:	e01f      	b.n	f5c0 <I2C_RequestMemoryWrite+0xb8>
  }
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
    f580:	2308      	movs	r3, #8
    f582:	18fb      	adds	r3, r7, r3
    f584:	881b      	ldrh	r3, [r3, #0]
    f586:	0a1b      	lsrs	r3, r3, #8
    f588:	b29b      	uxth	r3, r3
    f58a:	b2da      	uxtb	r2, r3
    f58c:	68fb      	ldr	r3, [r7, #12]
    f58e:	681b      	ldr	r3, [r3, #0]
    f590:	629a      	str	r2, [r3, #40]	; 0x28

    /* Wait until TXIS flag is set */
    if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
    f592:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    f594:	6a39      	ldr	r1, [r7, #32]
    f596:	68fb      	ldr	r3, [r7, #12]
    f598:	0018      	movs	r0, r3
    f59a:	f000 f8ea 	bl	f772 <I2C_WaitOnTXISFlagUntilTimeout>
    f59e:	1e03      	subs	r3, r0, #0
    f5a0:	d007      	beq.n	f5b2 <I2C_RequestMemoryWrite+0xaa>
    {
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
    f5a2:	68fb      	ldr	r3, [r7, #12]
    f5a4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    f5a6:	2b04      	cmp	r3, #4
    f5a8:	d101      	bne.n	f5ae <I2C_RequestMemoryWrite+0xa6>
      {
        return HAL_ERROR;
    f5aa:	2301      	movs	r3, #1
    f5ac:	e016      	b.n	f5dc <I2C_RequestMemoryWrite+0xd4>
      }
      else
      {
        return HAL_TIMEOUT;
    f5ae:	2303      	movs	r3, #3
    f5b0:	e014      	b.n	f5dc <I2C_RequestMemoryWrite+0xd4>
      }
    }
    
    /* Send LSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
    f5b2:	2308      	movs	r3, #8
    f5b4:	18fb      	adds	r3, r7, r3
    f5b6:	881b      	ldrh	r3, [r3, #0]
    f5b8:	b2da      	uxtb	r2, r3
    f5ba:	68fb      	ldr	r3, [r7, #12]
    f5bc:	681b      	ldr	r3, [r3, #0]
    f5be:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Wait until TCR flag is set */
  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, Tickstart) != HAL_OK)
    f5c0:	6a3a      	ldr	r2, [r7, #32]
    f5c2:	68f8      	ldr	r0, [r7, #12]
    f5c4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    f5c6:	9300      	str	r3, [sp, #0]
    f5c8:	0013      	movs	r3, r2
    f5ca:	2200      	movs	r2, #0
    f5cc:	2180      	movs	r1, #128	; 0x80
    f5ce:	f000 f897 	bl	f700 <I2C_WaitOnFlagUntilTimeout>
    f5d2:	1e03      	subs	r3, r0, #0
    f5d4:	d001      	beq.n	f5da <I2C_RequestMemoryWrite+0xd2>
  {
    return HAL_TIMEOUT;
    f5d6:	2303      	movs	r3, #3
    f5d8:	e000      	b.n	f5dc <I2C_RequestMemoryWrite+0xd4>
  }

return HAL_OK;
    f5da:	2300      	movs	r3, #0
}
    f5dc:	0018      	movs	r0, r3
    f5de:	46bd      	mov	sp, r7
    f5e0:	b004      	add	sp, #16
    f5e2:	bdb0      	pop	{r4, r5, r7, pc}

0000f5e4 <I2C_RequestMemoryRead>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
{
    f5e4:	b5b0      	push	{r4, r5, r7, lr}
    f5e6:	b086      	sub	sp, #24
    f5e8:	af02      	add	r7, sp, #8
    f5ea:	60f8      	str	r0, [r7, #12]
    f5ec:	000c      	movs	r4, r1
    f5ee:	0010      	movs	r0, r2
    f5f0:	0019      	movs	r1, r3
    f5f2:	250a      	movs	r5, #10
    f5f4:	197b      	adds	r3, r7, r5
    f5f6:	1c22      	adds	r2, r4, #0
    f5f8:	801a      	strh	r2, [r3, #0]
    f5fa:	2308      	movs	r3, #8
    f5fc:	18fb      	adds	r3, r7, r3
    f5fe:	1c02      	adds	r2, r0, #0
    f600:	801a      	strh	r2, [r3, #0]
    f602:	1dbb      	adds	r3, r7, #6
    f604:	1c0a      	adds	r2, r1, #0
    f606:	801a      	strh	r2, [r3, #0]
  I2C_TransferConfig(hi2c,DevAddress,MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
    f608:	1dbb      	adds	r3, r7, #6
    f60a:	881b      	ldrh	r3, [r3, #0]
    f60c:	b2da      	uxtb	r2, r3
    f60e:	197b      	adds	r3, r7, r5
    f610:	8819      	ldrh	r1, [r3, #0]
    f612:	68f8      	ldr	r0, [r7, #12]
    f614:	2380      	movs	r3, #128	; 0x80
    f616:	019b      	lsls	r3, r3, #6
    f618:	9300      	str	r3, [sp, #0]
    f61a:	2300      	movs	r3, #0
    f61c:	f000 f982 	bl	f924 <I2C_TransferConfig>

  /* Wait until TXIS flag is set */
  if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
    f620:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    f622:	6a39      	ldr	r1, [r7, #32]
    f624:	68fb      	ldr	r3, [r7, #12]
    f626:	0018      	movs	r0, r3
    f628:	f000 f8a3 	bl	f772 <I2C_WaitOnTXISFlagUntilTimeout>
    f62c:	1e03      	subs	r3, r0, #0
    f62e:	d007      	beq.n	f640 <I2C_RequestMemoryRead+0x5c>
  {
    if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
    f630:	68fb      	ldr	r3, [r7, #12]
    f632:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    f634:	2b04      	cmp	r3, #4
    f636:	d101      	bne.n	f63c <I2C_RequestMemoryRead+0x58>
    {
      return HAL_ERROR;
    f638:	2301      	movs	r3, #1
    f63a:	e03b      	b.n	f6b4 <I2C_RequestMemoryRead+0xd0>
    }
    else
    {
      return HAL_TIMEOUT;
    f63c:	2303      	movs	r3, #3
    f63e:	e039      	b.n	f6b4 <I2C_RequestMemoryRead+0xd0>
    }
  }

  /* If Memory address size is 8Bit */
  if(MemAddSize == I2C_MEMADD_SIZE_8BIT)
    f640:	1dbb      	adds	r3, r7, #6
    f642:	881b      	ldrh	r3, [r3, #0]
    f644:	2b01      	cmp	r3, #1
    f646:	d107      	bne.n	f658 <I2C_RequestMemoryRead+0x74>
  {
    /* Send Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
    f648:	2308      	movs	r3, #8
    f64a:	18fb      	adds	r3, r7, r3
    f64c:	881b      	ldrh	r3, [r3, #0]
    f64e:	b2da      	uxtb	r2, r3
    f650:	68fb      	ldr	r3, [r7, #12]
    f652:	681b      	ldr	r3, [r3, #0]
    f654:	629a      	str	r2, [r3, #40]	; 0x28
    f656:	e01f      	b.n	f698 <I2C_RequestMemoryRead+0xb4>
  }
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
    f658:	2308      	movs	r3, #8
    f65a:	18fb      	adds	r3, r7, r3
    f65c:	881b      	ldrh	r3, [r3, #0]
    f65e:	0a1b      	lsrs	r3, r3, #8
    f660:	b29b      	uxth	r3, r3
    f662:	b2da      	uxtb	r2, r3
    f664:	68fb      	ldr	r3, [r7, #12]
    f666:	681b      	ldr	r3, [r3, #0]
    f668:	629a      	str	r2, [r3, #40]	; 0x28

    /* Wait until TXIS flag is set */
    if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
    f66a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    f66c:	6a39      	ldr	r1, [r7, #32]
    f66e:	68fb      	ldr	r3, [r7, #12]
    f670:	0018      	movs	r0, r3
    f672:	f000 f87e 	bl	f772 <I2C_WaitOnTXISFlagUntilTimeout>
    f676:	1e03      	subs	r3, r0, #0
    f678:	d007      	beq.n	f68a <I2C_RequestMemoryRead+0xa6>
    {
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
    f67a:	68fb      	ldr	r3, [r7, #12]
    f67c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    f67e:	2b04      	cmp	r3, #4
    f680:	d101      	bne.n	f686 <I2C_RequestMemoryRead+0xa2>
      {
        return HAL_ERROR;
    f682:	2301      	movs	r3, #1
    f684:	e016      	b.n	f6b4 <I2C_RequestMemoryRead+0xd0>
      }
      else
      {
        return HAL_TIMEOUT;
    f686:	2303      	movs	r3, #3
    f688:	e014      	b.n	f6b4 <I2C_RequestMemoryRead+0xd0>
      }
    }
    
    /* Send LSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
    f68a:	2308      	movs	r3, #8
    f68c:	18fb      	adds	r3, r7, r3
    f68e:	881b      	ldrh	r3, [r3, #0]
    f690:	b2da      	uxtb	r2, r3
    f692:	68fb      	ldr	r3, [r7, #12]
    f694:	681b      	ldr	r3, [r3, #0]
    f696:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Wait until TC flag is set */
  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout, Tickstart) != HAL_OK)
    f698:	6a3a      	ldr	r2, [r7, #32]
    f69a:	68f8      	ldr	r0, [r7, #12]
    f69c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    f69e:	9300      	str	r3, [sp, #0]
    f6a0:	0013      	movs	r3, r2
    f6a2:	2200      	movs	r2, #0
    f6a4:	2140      	movs	r1, #64	; 0x40
    f6a6:	f000 f82b 	bl	f700 <I2C_WaitOnFlagUntilTimeout>
    f6aa:	1e03      	subs	r3, r0, #0
    f6ac:	d001      	beq.n	f6b2 <I2C_RequestMemoryRead+0xce>
  {
    return HAL_TIMEOUT;
    f6ae:	2303      	movs	r3, #3
    f6b0:	e000      	b.n	f6b4 <I2C_RequestMemoryRead+0xd0>
  }
  
  return HAL_OK;
    f6b2:	2300      	movs	r3, #0
}
    f6b4:	0018      	movs	r0, r3
    f6b6:	46bd      	mov	sp, r7
    f6b8:	b004      	add	sp, #16
    f6ba:	bdb0      	pop	{r4, r5, r7, pc}

0000f6bc <I2C_Flush_TXDR>:
  * @brief  I2C Tx data register flush process.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
{
    f6bc:	b580      	push	{r7, lr}
    f6be:	b082      	sub	sp, #8
    f6c0:	af00      	add	r7, sp, #0
    f6c2:	6078      	str	r0, [r7, #4]
  /* If a pending TXIS flag is set */
  /* Write a dummy data in TXDR to clear it */
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
    f6c4:	687b      	ldr	r3, [r7, #4]
    f6c6:	681b      	ldr	r3, [r3, #0]
    f6c8:	699b      	ldr	r3, [r3, #24]
    f6ca:	2202      	movs	r2, #2
    f6cc:	4013      	ands	r3, r2
    f6ce:	2b02      	cmp	r3, #2
    f6d0:	d103      	bne.n	f6da <I2C_Flush_TXDR+0x1e>
  {
     hi2c->Instance->TXDR = 0x00U;
    f6d2:	687b      	ldr	r3, [r7, #4]
    f6d4:	681b      	ldr	r3, [r3, #0]
    f6d6:	2200      	movs	r2, #0
    f6d8:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Flush TX register if not empty */
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
    f6da:	687b      	ldr	r3, [r7, #4]
    f6dc:	681b      	ldr	r3, [r3, #0]
    f6de:	699b      	ldr	r3, [r3, #24]
    f6e0:	2201      	movs	r2, #1
    f6e2:	4013      	ands	r3, r2
    f6e4:	2b01      	cmp	r3, #1
    f6e6:	d007      	beq.n	f6f8 <I2C_Flush_TXDR+0x3c>
  {
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
    f6e8:	687b      	ldr	r3, [r7, #4]
    f6ea:	681b      	ldr	r3, [r3, #0]
    f6ec:	699a      	ldr	r2, [r3, #24]
    f6ee:	687b      	ldr	r3, [r7, #4]
    f6f0:	681b      	ldr	r3, [r3, #0]
    f6f2:	2101      	movs	r1, #1
    f6f4:	430a      	orrs	r2, r1
    f6f6:	619a      	str	r2, [r3, #24]
  }
}
    f6f8:	46c0      	nop			; (mov r8, r8)
    f6fa:	46bd      	mov	sp, r7
    f6fc:	b002      	add	sp, #8
    f6fe:	bd80      	pop	{r7, pc}

0000f700 <I2C_WaitOnFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status, uint32_t Timeout, uint32_t Tickstart)
{
    f700:	b580      	push	{r7, lr}
    f702:	b084      	sub	sp, #16
    f704:	af00      	add	r7, sp, #0
    f706:	60f8      	str	r0, [r7, #12]
    f708:	60b9      	str	r1, [r7, #8]
    f70a:	603b      	str	r3, [r7, #0]
    f70c:	1dfb      	adds	r3, r7, #7
    f70e:	701a      	strb	r2, [r3, #0]
  while(__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
    f710:	e01b      	b.n	f74a <I2C_WaitOnFlagUntilTimeout+0x4a>
  {
    /* Check for the Timeout */
    if(Timeout != HAL_MAX_DELAY)
    f712:	683b      	ldr	r3, [r7, #0]
    f714:	3301      	adds	r3, #1
    f716:	d018      	beq.n	f74a <I2C_WaitOnFlagUntilTimeout+0x4a>
    {
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart ) > Timeout))
    f718:	683b      	ldr	r3, [r7, #0]
    f71a:	2b00      	cmp	r3, #0
    f71c:	d007      	beq.n	f72e <I2C_WaitOnFlagUntilTimeout+0x2e>
    f71e:	f7fe ff51 	bl	e5c4 <HAL_GetTick>
    f722:	0002      	movs	r2, r0
    f724:	69bb      	ldr	r3, [r7, #24]
    f726:	1ad3      	subs	r3, r2, r3
    f728:	683a      	ldr	r2, [r7, #0]
    f72a:	429a      	cmp	r2, r3
    f72c:	d20d      	bcs.n	f74a <I2C_WaitOnFlagUntilTimeout+0x4a>
      {
        hi2c->State= HAL_I2C_STATE_READY;
    f72e:	68fb      	ldr	r3, [r7, #12]
    f730:	2241      	movs	r2, #65	; 0x41
    f732:	2120      	movs	r1, #32
    f734:	5499      	strb	r1, [r3, r2]
        hi2c->Mode = HAL_I2C_MODE_NONE;
    f736:	68fb      	ldr	r3, [r7, #12]
    f738:	2242      	movs	r2, #66	; 0x42
    f73a:	2100      	movs	r1, #0
    f73c:	5499      	strb	r1, [r3, r2]

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
    f73e:	68fb      	ldr	r3, [r7, #12]
    f740:	2240      	movs	r2, #64	; 0x40
    f742:	2100      	movs	r1, #0
    f744:	5499      	strb	r1, [r3, r2]
        return HAL_TIMEOUT;
    f746:	2303      	movs	r3, #3
    f748:	e00f      	b.n	f76a <I2C_WaitOnFlagUntilTimeout+0x6a>
  while(__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
    f74a:	68fb      	ldr	r3, [r7, #12]
    f74c:	681b      	ldr	r3, [r3, #0]
    f74e:	699b      	ldr	r3, [r3, #24]
    f750:	68ba      	ldr	r2, [r7, #8]
    f752:	4013      	ands	r3, r2
    f754:	68ba      	ldr	r2, [r7, #8]
    f756:	1ad3      	subs	r3, r2, r3
    f758:	425a      	negs	r2, r3
    f75a:	4153      	adcs	r3, r2
    f75c:	b2db      	uxtb	r3, r3
    f75e:	001a      	movs	r2, r3
    f760:	1dfb      	adds	r3, r7, #7
    f762:	781b      	ldrb	r3, [r3, #0]
    f764:	429a      	cmp	r2, r3
    f766:	d0d4      	beq.n	f712 <I2C_WaitOnFlagUntilTimeout+0x12>
      }
    }
  }
  return HAL_OK;
    f768:	2300      	movs	r3, #0
}
    f76a:	0018      	movs	r0, r3
    f76c:	46bd      	mov	sp, r7
    f76e:	b004      	add	sp, #16
    f770:	bd80      	pop	{r7, pc}

0000f772 <I2C_WaitOnTXISFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
    f772:	b580      	push	{r7, lr}
    f774:	b084      	sub	sp, #16
    f776:	af00      	add	r7, sp, #0
    f778:	60f8      	str	r0, [r7, #12]
    f77a:	60b9      	str	r1, [r7, #8]
    f77c:	607a      	str	r2, [r7, #4]
  while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
    f77e:	e02b      	b.n	f7d8 <I2C_WaitOnTXISFlagUntilTimeout+0x66>
  {
    /* Check if a NACK is detected */
    if(I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
    f780:	687a      	ldr	r2, [r7, #4]
    f782:	68b9      	ldr	r1, [r7, #8]
    f784:	68fb      	ldr	r3, [r7, #12]
    f786:	0018      	movs	r0, r3
    f788:	f000 f86e 	bl	f868 <I2C_IsAcknowledgeFailed>
    f78c:	1e03      	subs	r3, r0, #0
    f78e:	d001      	beq.n	f794 <I2C_WaitOnTXISFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
    f790:	2301      	movs	r3, #1
    f792:	e029      	b.n	f7e8 <I2C_WaitOnTXISFlagUntilTimeout+0x76>
    }

    /* Check for the Timeout */
    if(Timeout != HAL_MAX_DELAY)
    f794:	68bb      	ldr	r3, [r7, #8]
    f796:	3301      	adds	r3, #1
    f798:	d01e      	beq.n	f7d8 <I2C_WaitOnTXISFlagUntilTimeout+0x66>
    {
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart) > Timeout))
    f79a:	68bb      	ldr	r3, [r7, #8]
    f79c:	2b00      	cmp	r3, #0
    f79e:	d007      	beq.n	f7b0 <I2C_WaitOnTXISFlagUntilTimeout+0x3e>
    f7a0:	f7fe ff10 	bl	e5c4 <HAL_GetTick>
    f7a4:	0002      	movs	r2, r0
    f7a6:	687b      	ldr	r3, [r7, #4]
    f7a8:	1ad3      	subs	r3, r2, r3
    f7aa:	68ba      	ldr	r2, [r7, #8]
    f7ac:	429a      	cmp	r2, r3
    f7ae:	d213      	bcs.n	f7d8 <I2C_WaitOnTXISFlagUntilTimeout+0x66>
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
    f7b0:	68fb      	ldr	r3, [r7, #12]
    f7b2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    f7b4:	2220      	movs	r2, #32
    f7b6:	431a      	orrs	r2, r3
    f7b8:	68fb      	ldr	r3, [r7, #12]
    f7ba:	645a      	str	r2, [r3, #68]	; 0x44
        hi2c->State= HAL_I2C_STATE_READY;
    f7bc:	68fb      	ldr	r3, [r7, #12]
    f7be:	2241      	movs	r2, #65	; 0x41
    f7c0:	2120      	movs	r1, #32
    f7c2:	5499      	strb	r1, [r3, r2]
        hi2c->Mode = HAL_I2C_MODE_NONE;
    f7c4:	68fb      	ldr	r3, [r7, #12]
    f7c6:	2242      	movs	r2, #66	; 0x42
    f7c8:	2100      	movs	r1, #0
    f7ca:	5499      	strb	r1, [r3, r2]

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
    f7cc:	68fb      	ldr	r3, [r7, #12]
    f7ce:	2240      	movs	r2, #64	; 0x40
    f7d0:	2100      	movs	r1, #0
    f7d2:	5499      	strb	r1, [r3, r2]

        return HAL_TIMEOUT;
    f7d4:	2303      	movs	r3, #3
    f7d6:	e007      	b.n	f7e8 <I2C_WaitOnTXISFlagUntilTimeout+0x76>
  while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
    f7d8:	68fb      	ldr	r3, [r7, #12]
    f7da:	681b      	ldr	r3, [r3, #0]
    f7dc:	699b      	ldr	r3, [r3, #24]
    f7de:	2202      	movs	r2, #2
    f7e0:	4013      	ands	r3, r2
    f7e2:	2b02      	cmp	r3, #2
    f7e4:	d1cc      	bne.n	f780 <I2C_WaitOnTXISFlagUntilTimeout+0xe>
      }
    }
  }
  return HAL_OK;
    f7e6:	2300      	movs	r3, #0
}
    f7e8:	0018      	movs	r0, r3
    f7ea:	46bd      	mov	sp, r7
    f7ec:	b004      	add	sp, #16
    f7ee:	bd80      	pop	{r7, pc}

0000f7f0 <I2C_WaitOnSTOPFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
    f7f0:	b580      	push	{r7, lr}
    f7f2:	b084      	sub	sp, #16
    f7f4:	af00      	add	r7, sp, #0
    f7f6:	60f8      	str	r0, [r7, #12]
    f7f8:	60b9      	str	r1, [r7, #8]
    f7fa:	607a      	str	r2, [r7, #4]
  while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
    f7fc:	e028      	b.n	f850 <I2C_WaitOnSTOPFlagUntilTimeout+0x60>
  {
    /* Check if a NACK is detected */
    if(I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
    f7fe:	687a      	ldr	r2, [r7, #4]
    f800:	68b9      	ldr	r1, [r7, #8]
    f802:	68fb      	ldr	r3, [r7, #12]
    f804:	0018      	movs	r0, r3
    f806:	f000 f82f 	bl	f868 <I2C_IsAcknowledgeFailed>
    f80a:	1e03      	subs	r3, r0, #0
    f80c:	d001      	beq.n	f812 <I2C_WaitOnSTOPFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
    f80e:	2301      	movs	r3, #1
    f810:	e026      	b.n	f860 <I2C_WaitOnSTOPFlagUntilTimeout+0x70>
    }

    /* Check for the Timeout */
    if((Timeout == 0U)||((HAL_GetTick() - Tickstart) > Timeout))
    f812:	68bb      	ldr	r3, [r7, #8]
    f814:	2b00      	cmp	r3, #0
    f816:	d007      	beq.n	f828 <I2C_WaitOnSTOPFlagUntilTimeout+0x38>
    f818:	f7fe fed4 	bl	e5c4 <HAL_GetTick>
    f81c:	0002      	movs	r2, r0
    f81e:	687b      	ldr	r3, [r7, #4]
    f820:	1ad3      	subs	r3, r2, r3
    f822:	68ba      	ldr	r2, [r7, #8]
    f824:	429a      	cmp	r2, r3
    f826:	d213      	bcs.n	f850 <I2C_WaitOnSTOPFlagUntilTimeout+0x60>
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
    f828:	68fb      	ldr	r3, [r7, #12]
    f82a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    f82c:	2220      	movs	r2, #32
    f82e:	431a      	orrs	r2, r3
    f830:	68fb      	ldr	r3, [r7, #12]
    f832:	645a      	str	r2, [r3, #68]	; 0x44
      hi2c->State= HAL_I2C_STATE_READY;
    f834:	68fb      	ldr	r3, [r7, #12]
    f836:	2241      	movs	r2, #65	; 0x41
    f838:	2120      	movs	r1, #32
    f83a:	5499      	strb	r1, [r3, r2]
      hi2c->Mode = HAL_I2C_MODE_NONE;
    f83c:	68fb      	ldr	r3, [r7, #12]
    f83e:	2242      	movs	r2, #66	; 0x42
    f840:	2100      	movs	r1, #0
    f842:	5499      	strb	r1, [r3, r2]

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
    f844:	68fb      	ldr	r3, [r7, #12]
    f846:	2240      	movs	r2, #64	; 0x40
    f848:	2100      	movs	r1, #0
    f84a:	5499      	strb	r1, [r3, r2]

      return HAL_TIMEOUT;
    f84c:	2303      	movs	r3, #3
    f84e:	e007      	b.n	f860 <I2C_WaitOnSTOPFlagUntilTimeout+0x70>
  while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
    f850:	68fb      	ldr	r3, [r7, #12]
    f852:	681b      	ldr	r3, [r3, #0]
    f854:	699b      	ldr	r3, [r3, #24]
    f856:	2220      	movs	r2, #32
    f858:	4013      	ands	r3, r2
    f85a:	2b20      	cmp	r3, #32
    f85c:	d1cf      	bne.n	f7fe <I2C_WaitOnSTOPFlagUntilTimeout+0xe>
    }
  }
  return HAL_OK;
    f85e:	2300      	movs	r3, #0
}
    f860:	0018      	movs	r0, r3
    f862:	46bd      	mov	sp, r7
    f864:	b004      	add	sp, #16
    f866:	bd80      	pop	{r7, pc}

0000f868 <I2C_IsAcknowledgeFailed>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
    f868:	b580      	push	{r7, lr}
    f86a:	b084      	sub	sp, #16
    f86c:	af00      	add	r7, sp, #0
    f86e:	60f8      	str	r0, [r7, #12]
    f870:	60b9      	str	r1, [r7, #8]
    f872:	607a      	str	r2, [r7, #4]
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
    f874:	68fb      	ldr	r3, [r7, #12]
    f876:	681b      	ldr	r3, [r3, #0]
    f878:	699b      	ldr	r3, [r3, #24]
    f87a:	2210      	movs	r2, #16
    f87c:	4013      	ands	r3, r2
    f87e:	2b10      	cmp	r3, #16
    f880:	d148      	bne.n	f914 <I2C_IsAcknowledgeFailed+0xac>
  {
    /* Wait until STOP Flag is reset */
    /* AutoEnd should be initiate after AF */
    while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
    f882:	e01b      	b.n	f8bc <I2C_IsAcknowledgeFailed+0x54>
    {
      /* Check for the Timeout */
      if(Timeout != HAL_MAX_DELAY)
    f884:	68bb      	ldr	r3, [r7, #8]
    f886:	3301      	adds	r3, #1
    f888:	d018      	beq.n	f8bc <I2C_IsAcknowledgeFailed+0x54>
      {
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart) > Timeout))
    f88a:	68bb      	ldr	r3, [r7, #8]
    f88c:	2b00      	cmp	r3, #0
    f88e:	d007      	beq.n	f8a0 <I2C_IsAcknowledgeFailed+0x38>
    f890:	f7fe fe98 	bl	e5c4 <HAL_GetTick>
    f894:	0002      	movs	r2, r0
    f896:	687b      	ldr	r3, [r7, #4]
    f898:	1ad3      	subs	r3, r2, r3
    f89a:	68ba      	ldr	r2, [r7, #8]
    f89c:	429a      	cmp	r2, r3
    f89e:	d20d      	bcs.n	f8bc <I2C_IsAcknowledgeFailed+0x54>
        {
          hi2c->State= HAL_I2C_STATE_READY;
    f8a0:	68fb      	ldr	r3, [r7, #12]
    f8a2:	2241      	movs	r2, #65	; 0x41
    f8a4:	2120      	movs	r1, #32
    f8a6:	5499      	strb	r1, [r3, r2]
          hi2c->Mode = HAL_I2C_MODE_NONE;
    f8a8:	68fb      	ldr	r3, [r7, #12]
    f8aa:	2242      	movs	r2, #66	; 0x42
    f8ac:	2100      	movs	r1, #0
    f8ae:	5499      	strb	r1, [r3, r2]

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
    f8b0:	68fb      	ldr	r3, [r7, #12]
    f8b2:	2240      	movs	r2, #64	; 0x40
    f8b4:	2100      	movs	r1, #0
    f8b6:	5499      	strb	r1, [r3, r2]
          return HAL_TIMEOUT;
    f8b8:	2303      	movs	r3, #3
    f8ba:	e02c      	b.n	f916 <I2C_IsAcknowledgeFailed+0xae>
    while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
    f8bc:	68fb      	ldr	r3, [r7, #12]
    f8be:	681b      	ldr	r3, [r3, #0]
    f8c0:	699b      	ldr	r3, [r3, #24]
    f8c2:	2220      	movs	r2, #32
    f8c4:	4013      	ands	r3, r2
    f8c6:	2b20      	cmp	r3, #32
    f8c8:	d1dc      	bne.n	f884 <I2C_IsAcknowledgeFailed+0x1c>
        }
      }
    }

    /* Clear NACKF Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    f8ca:	68fb      	ldr	r3, [r7, #12]
    f8cc:	681b      	ldr	r3, [r3, #0]
    f8ce:	2210      	movs	r2, #16
    f8d0:	61da      	str	r2, [r3, #28]

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
    f8d2:	68fb      	ldr	r3, [r7, #12]
    f8d4:	681b      	ldr	r3, [r3, #0]
    f8d6:	2220      	movs	r2, #32
    f8d8:	61da      	str	r2, [r3, #28]

    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
    f8da:	68fb      	ldr	r3, [r7, #12]
    f8dc:	0018      	movs	r0, r3
    f8de:	f7ff feed 	bl	f6bc <I2C_Flush_TXDR>

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
    f8e2:	68fb      	ldr	r3, [r7, #12]
    f8e4:	681b      	ldr	r3, [r3, #0]
    f8e6:	685a      	ldr	r2, [r3, #4]
    f8e8:	68fb      	ldr	r3, [r7, #12]
    f8ea:	681b      	ldr	r3, [r3, #0]
    f8ec:	490c      	ldr	r1, [pc, #48]	; (f920 <I2C_IsAcknowledgeFailed+0xb8>)
    f8ee:	400a      	ands	r2, r1
    f8f0:	605a      	str	r2, [r3, #4]

    hi2c->ErrorCode = HAL_I2C_ERROR_AF;
    f8f2:	68fb      	ldr	r3, [r7, #12]
    f8f4:	2204      	movs	r2, #4
    f8f6:	645a      	str	r2, [r3, #68]	; 0x44
    hi2c->State= HAL_I2C_STATE_READY;
    f8f8:	68fb      	ldr	r3, [r7, #12]
    f8fa:	2241      	movs	r2, #65	; 0x41
    f8fc:	2120      	movs	r1, #32
    f8fe:	5499      	strb	r1, [r3, r2]
    hi2c->Mode = HAL_I2C_MODE_NONE;
    f900:	68fb      	ldr	r3, [r7, #12]
    f902:	2242      	movs	r2, #66	; 0x42
    f904:	2100      	movs	r1, #0
    f906:	5499      	strb	r1, [r3, r2]

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
    f908:	68fb      	ldr	r3, [r7, #12]
    f90a:	2240      	movs	r2, #64	; 0x40
    f90c:	2100      	movs	r1, #0
    f90e:	5499      	strb	r1, [r3, r2]

    return HAL_ERROR;
    f910:	2301      	movs	r3, #1
    f912:	e000      	b.n	f916 <I2C_IsAcknowledgeFailed+0xae>
  }
  return HAL_OK;
    f914:	2300      	movs	r3, #0
}
    f916:	0018      	movs	r0, r3
    f918:	46bd      	mov	sp, r7
    f91a:	b004      	add	sp, #16
    f91c:	bd80      	pop	{r7, pc}
    f91e:	46c0      	nop			; (mov r8, r8)
    f920:	fe00e800 	.word	0xfe00e800

0000f924 <I2C_TransferConfig>:
  *     @arg @ref I2C_GENERATE_START_READ Generate Restart for read request.
  *     @arg @ref I2C_GENERATE_START_WRITE Generate Restart for write request.
  * @retval None
  */
static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c,  uint16_t DevAddress, uint8_t Size, uint32_t Mode, uint32_t Request)
{
    f924:	b590      	push	{r4, r7, lr}
    f926:	b087      	sub	sp, #28
    f928:	af00      	add	r7, sp, #0
    f92a:	60f8      	str	r0, [r7, #12]
    f92c:	0008      	movs	r0, r1
    f92e:	0011      	movs	r1, r2
    f930:	607b      	str	r3, [r7, #4]
    f932:	240a      	movs	r4, #10
    f934:	193b      	adds	r3, r7, r4
    f936:	1c02      	adds	r2, r0, #0
    f938:	801a      	strh	r2, [r3, #0]
    f93a:	2009      	movs	r0, #9
    f93c:	183b      	adds	r3, r7, r0
    f93e:	1c0a      	adds	r2, r1, #0
    f940:	701a      	strb	r2, [r3, #0]
  uint32_t tmpreg = 0U;
    f942:	2300      	movs	r3, #0
    f944:	617b      	str	r3, [r7, #20]
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));

  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
    f946:	68fb      	ldr	r3, [r7, #12]
    f948:	681b      	ldr	r3, [r3, #0]
    f94a:	685b      	ldr	r3, [r3, #4]
    f94c:	617b      	str	r3, [r7, #20]

  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
    f94e:	697b      	ldr	r3, [r7, #20]
    f950:	4a0e      	ldr	r2, [pc, #56]	; (f98c <I2C_TransferConfig+0x68>)
    f952:	4013      	ands	r3, r2
    f954:	617b      	str	r3, [r7, #20]

  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
    f956:	193b      	adds	r3, r7, r4
    f958:	881b      	ldrh	r3, [r3, #0]
    f95a:	059b      	lsls	r3, r3, #22
    f95c:	0d9a      	lsrs	r2, r3, #22
    f95e:	183b      	adds	r3, r7, r0
    f960:	781b      	ldrb	r3, [r3, #0]
    f962:	0419      	lsls	r1, r3, #16
    f964:	23ff      	movs	r3, #255	; 0xff
    f966:	041b      	lsls	r3, r3, #16
    f968:	400b      	ands	r3, r1
    f96a:	431a      	orrs	r2, r3
    f96c:	687b      	ldr	r3, [r7, #4]
    f96e:	431a      	orrs	r2, r3
    f970:	6abb      	ldr	r3, [r7, #40]	; 0x28
    f972:	4313      	orrs	r3, r2
    f974:	697a      	ldr	r2, [r7, #20]
    f976:	4313      	orrs	r3, r2
    f978:	617b      	str	r3, [r7, #20]
            (uint32_t)Mode | (uint32_t)Request);

  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;
    f97a:	68fb      	ldr	r3, [r7, #12]
    f97c:	681b      	ldr	r3, [r3, #0]
    f97e:	697a      	ldr	r2, [r7, #20]
    f980:	605a      	str	r2, [r3, #4]
}
    f982:	46c0      	nop			; (mov r8, r8)
    f984:	46bd      	mov	sp, r7
    f986:	b007      	add	sp, #28
    f988:	bd90      	pop	{r4, r7, pc}
    f98a:	46c0      	nop			; (mov r8, r8)
    f98c:	fc009800 	.word	0xfc009800

0000f990 <HAL_I2CEx_ConfigAnalogFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  AnalogFilter New state of the Analog filter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter)
{
    f990:	b580      	push	{r7, lr}
    f992:	b082      	sub	sp, #8
    f994:	af00      	add	r7, sp, #0
    f996:	6078      	str	r0, [r7, #4]
    f998:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));

  if(hi2c->State == HAL_I2C_STATE_READY)
    f99a:	687b      	ldr	r3, [r7, #4]
    f99c:	2241      	movs	r2, #65	; 0x41
    f99e:	5c9b      	ldrb	r3, [r3, r2]
    f9a0:	b2db      	uxtb	r3, r3
    f9a2:	2b20      	cmp	r3, #32
    f9a4:	d138      	bne.n	fa18 <HAL_I2CEx_ConfigAnalogFilter+0x88>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
    f9a6:	687b      	ldr	r3, [r7, #4]
    f9a8:	2240      	movs	r2, #64	; 0x40
    f9aa:	5c9b      	ldrb	r3, [r3, r2]
    f9ac:	2b01      	cmp	r3, #1
    f9ae:	d101      	bne.n	f9b4 <HAL_I2CEx_ConfigAnalogFilter+0x24>
    f9b0:	2302      	movs	r3, #2
    f9b2:	e032      	b.n	fa1a <HAL_I2CEx_ConfigAnalogFilter+0x8a>
    f9b4:	687b      	ldr	r3, [r7, #4]
    f9b6:	2240      	movs	r2, #64	; 0x40
    f9b8:	2101      	movs	r1, #1
    f9ba:	5499      	strb	r1, [r3, r2]

    hi2c->State = HAL_I2C_STATE_BUSY;
    f9bc:	687b      	ldr	r3, [r7, #4]
    f9be:	2241      	movs	r2, #65	; 0x41
    f9c0:	2124      	movs	r1, #36	; 0x24
    f9c2:	5499      	strb	r1, [r3, r2]

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
    f9c4:	687b      	ldr	r3, [r7, #4]
    f9c6:	681b      	ldr	r3, [r3, #0]
    f9c8:	681a      	ldr	r2, [r3, #0]
    f9ca:	687b      	ldr	r3, [r7, #4]
    f9cc:	681b      	ldr	r3, [r3, #0]
    f9ce:	2101      	movs	r1, #1
    f9d0:	438a      	bics	r2, r1
    f9d2:	601a      	str	r2, [r3, #0]

    /* Reset I2Cx ANOFF bit */
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
    f9d4:	687b      	ldr	r3, [r7, #4]
    f9d6:	681b      	ldr	r3, [r3, #0]
    f9d8:	681a      	ldr	r2, [r3, #0]
    f9da:	687b      	ldr	r3, [r7, #4]
    f9dc:	681b      	ldr	r3, [r3, #0]
    f9de:	4911      	ldr	r1, [pc, #68]	; (fa24 <HAL_I2CEx_ConfigAnalogFilter+0x94>)
    f9e0:	400a      	ands	r2, r1
    f9e2:	601a      	str	r2, [r3, #0]

    /* Set analog filter bit*/
    hi2c->Instance->CR1 |= AnalogFilter;
    f9e4:	687b      	ldr	r3, [r7, #4]
    f9e6:	681b      	ldr	r3, [r3, #0]
    f9e8:	6819      	ldr	r1, [r3, #0]
    f9ea:	687b      	ldr	r3, [r7, #4]
    f9ec:	681b      	ldr	r3, [r3, #0]
    f9ee:	683a      	ldr	r2, [r7, #0]
    f9f0:	430a      	orrs	r2, r1
    f9f2:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
    f9f4:	687b      	ldr	r3, [r7, #4]
    f9f6:	681b      	ldr	r3, [r3, #0]
    f9f8:	681a      	ldr	r2, [r3, #0]
    f9fa:	687b      	ldr	r3, [r7, #4]
    f9fc:	681b      	ldr	r3, [r3, #0]
    f9fe:	2101      	movs	r1, #1
    fa00:	430a      	orrs	r2, r1
    fa02:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
    fa04:	687b      	ldr	r3, [r7, #4]
    fa06:	2241      	movs	r2, #65	; 0x41
    fa08:	2120      	movs	r1, #32
    fa0a:	5499      	strb	r1, [r3, r2]

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
    fa0c:	687b      	ldr	r3, [r7, #4]
    fa0e:	2240      	movs	r2, #64	; 0x40
    fa10:	2100      	movs	r1, #0
    fa12:	5499      	strb	r1, [r3, r2]

    return HAL_OK;
    fa14:	2300      	movs	r3, #0
    fa16:	e000      	b.n	fa1a <HAL_I2CEx_ConfigAnalogFilter+0x8a>
  }
  else
  {
    return HAL_BUSY;
    fa18:	2302      	movs	r3, #2
  }
}
    fa1a:	0018      	movs	r0, r3
    fa1c:	46bd      	mov	sp, r7
    fa1e:	b002      	add	sp, #8
    fa20:	bd80      	pop	{r7, pc}
    fa22:	46c0      	nop			; (mov r8, r8)
    fa24:	ffffefff 	.word	0xffffefff

0000fa28 <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency 
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
    fa28:	b580      	push	{r7, lr}
    fa2a:	af00      	add	r7, sp, #0
  return SystemCoreClock;
    fa2c:	4b02      	ldr	r3, [pc, #8]	; (fa38 <HAL_RCC_GetHCLKFreq+0x10>)
    fa2e:	681b      	ldr	r3, [r3, #0]
}
    fa30:	0018      	movs	r0, r3
    fa32:	46bd      	mov	sp, r7
    fa34:	bd80      	pop	{r7, pc}
    fa36:	46c0      	nop			; (mov r8, r8)
    fa38:	0002fec4 	.word	0x0002fec4

0000fa3c <LL_RCC_HSI_IsReady>:
{
    fa3c:	b580      	push	{r7, lr}
    fa3e:	af00      	add	r7, sp, #0
  return (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY));
    fa40:	4b05      	ldr	r3, [pc, #20]	; (fa58 <LL_RCC_HSI_IsReady+0x1c>)
    fa42:	681b      	ldr	r3, [r3, #0]
    fa44:	2202      	movs	r2, #2
    fa46:	4013      	ands	r3, r2
    fa48:	3b02      	subs	r3, #2
    fa4a:	425a      	negs	r2, r3
    fa4c:	4153      	adcs	r3, r2
    fa4e:	b2db      	uxtb	r3, r3
}
    fa50:	0018      	movs	r0, r3
    fa52:	46bd      	mov	sp, r7
    fa54:	bd80      	pop	{r7, pc}
    fa56:	46c0      	nop			; (mov r8, r8)
    fa58:	40021000 	.word	0x40021000

0000fa5c <LL_RCC_LSE_IsReady>:
{
    fa5c:	b580      	push	{r7, lr}
    fa5e:	af00      	add	r7, sp, #0
  return (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == (RCC_BDCR_LSERDY));
    fa60:	4b05      	ldr	r3, [pc, #20]	; (fa78 <LL_RCC_LSE_IsReady+0x1c>)
    fa62:	6a1b      	ldr	r3, [r3, #32]
    fa64:	2202      	movs	r2, #2
    fa66:	4013      	ands	r3, r2
    fa68:	3b02      	subs	r3, #2
    fa6a:	425a      	negs	r2, r3
    fa6c:	4153      	adcs	r3, r2
    fa6e:	b2db      	uxtb	r3, r3
}
    fa70:	0018      	movs	r0, r3
    fa72:	46bd      	mov	sp, r7
    fa74:	bd80      	pop	{r7, pc}
    fa76:	46c0      	nop			; (mov r8, r8)
    fa78:	40021000 	.word	0x40021000

0000fa7c <LL_RCC_GetSysClkSource>:
{
    fa7c:	b580      	push	{r7, lr}
    fa7e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
    fa80:	4b03      	ldr	r3, [pc, #12]	; (fa90 <LL_RCC_GetSysClkSource+0x14>)
    fa82:	685b      	ldr	r3, [r3, #4]
    fa84:	220c      	movs	r2, #12
    fa86:	4013      	ands	r3, r2
}
    fa88:	0018      	movs	r0, r3
    fa8a:	46bd      	mov	sp, r7
    fa8c:	bd80      	pop	{r7, pc}
    fa8e:	46c0      	nop			; (mov r8, r8)
    fa90:	40021000 	.word	0x40021000

0000fa94 <LL_RCC_GetAHBPrescaler>:
{
    fa94:	b580      	push	{r7, lr}
    fa96:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE));
    fa98:	4b03      	ldr	r3, [pc, #12]	; (faa8 <LL_RCC_GetAHBPrescaler+0x14>)
    fa9a:	685b      	ldr	r3, [r3, #4]
    fa9c:	22f0      	movs	r2, #240	; 0xf0
    fa9e:	4013      	ands	r3, r2
}
    faa0:	0018      	movs	r0, r3
    faa2:	46bd      	mov	sp, r7
    faa4:	bd80      	pop	{r7, pc}
    faa6:	46c0      	nop			; (mov r8, r8)
    faa8:	40021000 	.word	0x40021000

0000faac <LL_RCC_GetAPB1Prescaler>:
{
    faac:	b580      	push	{r7, lr}
    faae:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PPRE));
    fab0:	4b03      	ldr	r3, [pc, #12]	; (fac0 <LL_RCC_GetAPB1Prescaler+0x14>)
    fab2:	685a      	ldr	r2, [r3, #4]
    fab4:	23e0      	movs	r3, #224	; 0xe0
    fab6:	00db      	lsls	r3, r3, #3
    fab8:	4013      	ands	r3, r2
}
    faba:	0018      	movs	r0, r3
    fabc:	46bd      	mov	sp, r7
    fabe:	bd80      	pop	{r7, pc}
    fac0:	40021000 	.word	0x40021000

0000fac4 <LL_RCC_GetUSARTClockSource>:
{
    fac4:	b580      	push	{r7, lr}
    fac6:	b082      	sub	sp, #8
    fac8:	af00      	add	r7, sp, #0
    faca:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CFGR3, (RCC_CFGR3_USART1SW << USARTx)) | (USARTx << 24U));
    facc:	4b06      	ldr	r3, [pc, #24]	; (fae8 <LL_RCC_GetUSARTClockSource+0x24>)
    face:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    fad0:	2103      	movs	r1, #3
    fad2:	687a      	ldr	r2, [r7, #4]
    fad4:	4091      	lsls	r1, r2
    fad6:	000a      	movs	r2, r1
    fad8:	401a      	ands	r2, r3
    fada:	687b      	ldr	r3, [r7, #4]
    fadc:	061b      	lsls	r3, r3, #24
    fade:	4313      	orrs	r3, r2
}
    fae0:	0018      	movs	r0, r3
    fae2:	46bd      	mov	sp, r7
    fae4:	b002      	add	sp, #8
    fae6:	bd80      	pop	{r7, pc}
    fae8:	40021000 	.word	0x40021000

0000faec <LL_RCC_PLL_GetMainSource>:
  *         @arg @ref LL_RCC_PLLSOURCE_HSI48 (*)
  *
  *         (*) value not defined in all devices
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_GetMainSource(void)
{
    faec:	b580      	push	{r7, lr}
    faee:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PLLSRC));
    faf0:	4b03      	ldr	r3, [pc, #12]	; (fb00 <LL_RCC_PLL_GetMainSource+0x14>)
    faf2:	685a      	ldr	r2, [r3, #4]
    faf4:	23c0      	movs	r3, #192	; 0xc0
    faf6:	025b      	lsls	r3, r3, #9
    faf8:	4013      	ands	r3, r2
}
    fafa:	0018      	movs	r0, r3
    fafc:	46bd      	mov	sp, r7
    fafe:	bd80      	pop	{r7, pc}
    fb00:	40021000 	.word	0x40021000

0000fb04 <LL_RCC_PLL_GetMultiplicator>:
  *         @arg @ref LL_RCC_PLL_MUL_14
  *         @arg @ref LL_RCC_PLL_MUL_15
  *         @arg @ref LL_RCC_PLL_MUL_16
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_GetMultiplicator(void)
{
    fb04:	b580      	push	{r7, lr}
    fb06:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PLLMUL));
    fb08:	4b03      	ldr	r3, [pc, #12]	; (fb18 <LL_RCC_PLL_GetMultiplicator+0x14>)
    fb0a:	685a      	ldr	r2, [r3, #4]
    fb0c:	23f0      	movs	r3, #240	; 0xf0
    fb0e:	039b      	lsls	r3, r3, #14
    fb10:	4013      	ands	r3, r2
}
    fb12:	0018      	movs	r0, r3
    fb14:	46bd      	mov	sp, r7
    fb16:	bd80      	pop	{r7, pc}
    fb18:	40021000 	.word	0x40021000

0000fb1c <LL_RCC_PLL_GetPrediv>:
  *         @arg @ref LL_RCC_PREDIV_DIV_14
  *         @arg @ref LL_RCC_PREDIV_DIV_15
  *         @arg @ref LL_RCC_PREDIV_DIV_16
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_GetPrediv(void)
{
    fb1c:	b580      	push	{r7, lr}
    fb1e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PREDIV));
    fb20:	4b03      	ldr	r3, [pc, #12]	; (fb30 <LL_RCC_PLL_GetPrediv+0x14>)
    fb22:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    fb24:	220f      	movs	r2, #15
    fb26:	4013      	ands	r3, r2
}
    fb28:	0018      	movs	r0, r3
    fb2a:	46bd      	mov	sp, r7
    fb2c:	bd80      	pop	{r7, pc}
    fb2e:	46c0      	nop			; (mov r8, r8)
    fb30:	40021000 	.word	0x40021000

0000fb34 <LL_RCC_GetSystemClocksFreq>:
  *         configuration based on this function will be incorrect.
  * @param  RCC_Clocks pointer to a @ref LL_RCC_ClocksTypeDef structure which will hold the clocks frequencies
  * @retval None
  */
void LL_RCC_GetSystemClocksFreq(LL_RCC_ClocksTypeDef *RCC_Clocks)
{
    fb34:	b580      	push	{r7, lr}
    fb36:	b082      	sub	sp, #8
    fb38:	af00      	add	r7, sp, #0
    fb3a:	6078      	str	r0, [r7, #4]
  /* Get SYSCLK frequency */
  RCC_Clocks->SYSCLK_Frequency = RCC_GetSystemClockFreq();
    fb3c:	f000 f896 	bl	fc6c <RCC_GetSystemClockFreq>
    fb40:	0002      	movs	r2, r0
    fb42:	687b      	ldr	r3, [r7, #4]
    fb44:	601a      	str	r2, [r3, #0]

  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency   = RCC_GetHCLKClockFreq(RCC_Clocks->SYSCLK_Frequency);
    fb46:	687b      	ldr	r3, [r7, #4]
    fb48:	681b      	ldr	r3, [r3, #0]
    fb4a:	0018      	movs	r0, r3
    fb4c:	f000 f8b2 	bl	fcb4 <RCC_GetHCLKClockFreq>
    fb50:	0002      	movs	r2, r0
    fb52:	687b      	ldr	r3, [r7, #4]
    fb54:	605a      	str	r2, [r3, #4]

  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency  = RCC_GetPCLK1ClockFreq(RCC_Clocks->HCLK_Frequency);
    fb56:	687b      	ldr	r3, [r7, #4]
    fb58:	685b      	ldr	r3, [r3, #4]
    fb5a:	0018      	movs	r0, r3
    fb5c:	f000 f8c0 	bl	fce0 <RCC_GetPCLK1ClockFreq>
    fb60:	0002      	movs	r2, r0
    fb62:	687b      	ldr	r3, [r7, #4]
    fb64:	609a      	str	r2, [r3, #8]
}
    fb66:	46c0      	nop			; (mov r8, r8)
    fb68:	46bd      	mov	sp, r7
    fb6a:	b002      	add	sp, #8
    fb6c:	bd80      	pop	{r7, pc}
	...

0000fb70 <LL_RCC_GetUSARTClockFreq>:
  *         (*) value not defined in all devices.
  * @retval USART clock frequency (in Hz)
  *         @arg @ref LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator (HSI or LSE) is not ready
  */
uint32_t LL_RCC_GetUSARTClockFreq(uint32_t USARTxSource)
{
    fb70:	b580      	push	{r7, lr}
    fb72:	b084      	sub	sp, #16
    fb74:	af00      	add	r7, sp, #0
    fb76:	6078      	str	r0, [r7, #4]
  uint32_t usart_frequency = LL_RCC_PERIPH_FREQUENCY_NO;
    fb78:	2300      	movs	r3, #0
    fb7a:	60fb      	str	r3, [r7, #12]

  /* Check parameter */
  assert_param(IS_LL_RCC_USART_CLKSOURCE(USARTxSource));
#if defined(RCC_CFGR3_USART1SW)
  if (USARTxSource == LL_RCC_USART1_CLKSOURCE)
    fb7c:	687b      	ldr	r3, [r7, #4]
    fb7e:	2b00      	cmp	r3, #0
    fb80:	d12b      	bne.n	fbda <LL_RCC_GetUSARTClockFreq+0x6a>
  {
    /* USART1CLK clock frequency */
    switch (LL_RCC_GetUSARTClockSource(USARTxSource))
    fb82:	687b      	ldr	r3, [r7, #4]
    fb84:	0018      	movs	r0, r3
    fb86:	f7ff ff9d 	bl	fac4 <LL_RCC_GetUSARTClockSource>
    fb8a:	0003      	movs	r3, r0
    fb8c:	2b02      	cmp	r3, #2
    fb8e:	d00f      	beq.n	fbb0 <LL_RCC_GetUSARTClockFreq+0x40>
    fb90:	2b03      	cmp	r3, #3
    fb92:	d006      	beq.n	fba2 <LL_RCC_GetUSARTClockFreq+0x32>
    fb94:	2b01      	cmp	r3, #1
    fb96:	d113      	bne.n	fbc0 <LL_RCC_GetUSARTClockFreq+0x50>
    {
      case LL_RCC_USART1_CLKSOURCE_SYSCLK: /* USART1 Clock is System Clock */
        usart_frequency = RCC_GetSystemClockFreq();
    fb98:	f000 f868 	bl	fc6c <RCC_GetSystemClockFreq>
    fb9c:	0003      	movs	r3, r0
    fb9e:	60fb      	str	r3, [r7, #12]
        break;
    fba0:	e020      	b.n	fbe4 <LL_RCC_GetUSARTClockFreq+0x74>

      case LL_RCC_USART1_CLKSOURCE_HSI:    /* USART1 Clock is HSI Osc. */
        if (LL_RCC_HSI_IsReady())
    fba2:	f7ff ff4b 	bl	fa3c <LL_RCC_HSI_IsReady>
    fba6:	1e03      	subs	r3, r0, #0
    fba8:	d019      	beq.n	fbde <LL_RCC_GetUSARTClockFreq+0x6e>
        {
          usart_frequency = HSI_VALUE;
    fbaa:	4b2c      	ldr	r3, [pc, #176]	; (fc5c <LL_RCC_GetUSARTClockFreq+0xec>)
    fbac:	60fb      	str	r3, [r7, #12]
        }
        break;
    fbae:	e016      	b.n	fbde <LL_RCC_GetUSARTClockFreq+0x6e>

      case LL_RCC_USART1_CLKSOURCE_LSE:    /* USART1 Clock is LSE Osc. */
        if (LL_RCC_LSE_IsReady())
    fbb0:	f7ff ff54 	bl	fa5c <LL_RCC_LSE_IsReady>
    fbb4:	1e03      	subs	r3, r0, #0
    fbb6:	d014      	beq.n	fbe2 <LL_RCC_GetUSARTClockFreq+0x72>
        {
          usart_frequency = LSE_VALUE;
    fbb8:	2380      	movs	r3, #128	; 0x80
    fbba:	021b      	lsls	r3, r3, #8
    fbbc:	60fb      	str	r3, [r7, #12]
        }
        break;
    fbbe:	e010      	b.n	fbe2 <LL_RCC_GetUSARTClockFreq+0x72>

      case LL_RCC_USART1_CLKSOURCE_PCLK1:  /* USART1 Clock is PCLK1 */
      default:
        usart_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));
    fbc0:	f000 f854 	bl	fc6c <RCC_GetSystemClockFreq>
    fbc4:	0003      	movs	r3, r0
    fbc6:	0018      	movs	r0, r3
    fbc8:	f000 f874 	bl	fcb4 <RCC_GetHCLKClockFreq>
    fbcc:	0003      	movs	r3, r0
    fbce:	0018      	movs	r0, r3
    fbd0:	f000 f886 	bl	fce0 <RCC_GetPCLK1ClockFreq>
    fbd4:	0003      	movs	r3, r0
    fbd6:	60fb      	str	r3, [r7, #12]
        break;
    fbd8:	e004      	b.n	fbe4 <LL_RCC_GetUSARTClockFreq+0x74>
    }
  }
    fbda:	46c0      	nop			; (mov r8, r8)
    fbdc:	e002      	b.n	fbe4 <LL_RCC_GetUSARTClockFreq+0x74>
        break;
    fbde:	46c0      	nop			; (mov r8, r8)
    fbe0:	e000      	b.n	fbe4 <LL_RCC_GetUSARTClockFreq+0x74>
        break;
    fbe2:	46c0      	nop			; (mov r8, r8)
#endif /* RCC_CFGR3_USART1SW  */

#if defined(RCC_CFGR3_USART2SW)
  if (USARTxSource == LL_RCC_USART2_CLKSOURCE)
    fbe4:	687b      	ldr	r3, [r7, #4]
    fbe6:	2b10      	cmp	r3, #16
    fbe8:	d12e      	bne.n	fc48 <LL_RCC_GetUSARTClockFreq+0xd8>
  {
    /* USART2CLK clock frequency */
    switch (LL_RCC_GetUSARTClockSource(USARTxSource))
    fbea:	687b      	ldr	r3, [r7, #4]
    fbec:	0018      	movs	r0, r3
    fbee:	f7ff ff69 	bl	fac4 <LL_RCC_GetUSARTClockSource>
    fbf2:	0003      	movs	r3, r0
    fbf4:	4a1a      	ldr	r2, [pc, #104]	; (fc60 <LL_RCC_GetUSARTClockFreq+0xf0>)
    fbf6:	4293      	cmp	r3, r2
    fbf8:	d011      	beq.n	fc1e <LL_RCC_GetUSARTClockFreq+0xae>
    fbfa:	4a1a      	ldr	r2, [pc, #104]	; (fc64 <LL_RCC_GetUSARTClockFreq+0xf4>)
    fbfc:	4293      	cmp	r3, r2
    fbfe:	d007      	beq.n	fc10 <LL_RCC_GetUSARTClockFreq+0xa0>
    fc00:	4a19      	ldr	r2, [pc, #100]	; (fc68 <LL_RCC_GetUSARTClockFreq+0xf8>)
    fc02:	4293      	cmp	r3, r2
    fc04:	d113      	bne.n	fc2e <LL_RCC_GetUSARTClockFreq+0xbe>
    {
      case LL_RCC_USART2_CLKSOURCE_SYSCLK: /* USART2 Clock is System Clock */
        usart_frequency = RCC_GetSystemClockFreq();
    fc06:	f000 f831 	bl	fc6c <RCC_GetSystemClockFreq>
    fc0a:	0003      	movs	r3, r0
    fc0c:	60fb      	str	r3, [r7, #12]
        break;
    fc0e:	e020      	b.n	fc52 <LL_RCC_GetUSARTClockFreq+0xe2>

      case LL_RCC_USART2_CLKSOURCE_HSI:    /* USART2 Clock is HSI Osc. */
        if (LL_RCC_HSI_IsReady())
    fc10:	f7ff ff14 	bl	fa3c <LL_RCC_HSI_IsReady>
    fc14:	1e03      	subs	r3, r0, #0
    fc16:	d019      	beq.n	fc4c <LL_RCC_GetUSARTClockFreq+0xdc>
        {
          usart_frequency = HSI_VALUE;
    fc18:	4b10      	ldr	r3, [pc, #64]	; (fc5c <LL_RCC_GetUSARTClockFreq+0xec>)
    fc1a:	60fb      	str	r3, [r7, #12]
        }
        break;
    fc1c:	e016      	b.n	fc4c <LL_RCC_GetUSARTClockFreq+0xdc>

      case LL_RCC_USART2_CLKSOURCE_LSE:    /* USART2 Clock is LSE Osc. */
        if (LL_RCC_LSE_IsReady())
    fc1e:	f7ff ff1d 	bl	fa5c <LL_RCC_LSE_IsReady>
    fc22:	1e03      	subs	r3, r0, #0
    fc24:	d014      	beq.n	fc50 <LL_RCC_GetUSARTClockFreq+0xe0>
        {
          usart_frequency = LSE_VALUE;
    fc26:	2380      	movs	r3, #128	; 0x80
    fc28:	021b      	lsls	r3, r3, #8
    fc2a:	60fb      	str	r3, [r7, #12]
        }
        break;
    fc2c:	e010      	b.n	fc50 <LL_RCC_GetUSARTClockFreq+0xe0>

      case LL_RCC_USART2_CLKSOURCE_PCLK1:  /* USART2 Clock is PCLK1 */
      default:
        usart_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));
    fc2e:	f000 f81d 	bl	fc6c <RCC_GetSystemClockFreq>
    fc32:	0003      	movs	r3, r0
    fc34:	0018      	movs	r0, r3
    fc36:	f000 f83d 	bl	fcb4 <RCC_GetHCLKClockFreq>
    fc3a:	0003      	movs	r3, r0
    fc3c:	0018      	movs	r0, r3
    fc3e:	f000 f84f 	bl	fce0 <RCC_GetPCLK1ClockFreq>
    fc42:	0003      	movs	r3, r0
    fc44:	60fb      	str	r3, [r7, #12]
        break;
    fc46:	e004      	b.n	fc52 <LL_RCC_GetUSARTClockFreq+0xe2>
    }
  }
    fc48:	46c0      	nop			; (mov r8, r8)
    fc4a:	e002      	b.n	fc52 <LL_RCC_GetUSARTClockFreq+0xe2>
        break;
    fc4c:	46c0      	nop			; (mov r8, r8)
    fc4e:	e000      	b.n	fc52 <LL_RCC_GetUSARTClockFreq+0xe2>
        break;
    fc50:	46c0      	nop			; (mov r8, r8)
        break;
    }
  }

#endif /* RCC_CFGR3_USART3SW */
  return usart_frequency;
    fc52:	68fb      	ldr	r3, [r7, #12]
}
    fc54:	0018      	movs	r0, r3
    fc56:	46bd      	mov	sp, r7
    fc58:	b004      	add	sp, #16
    fc5a:	bd80      	pop	{r7, pc}
    fc5c:	007a1200 	.word	0x007a1200
    fc60:	10020000 	.word	0x10020000
    fc64:	10030000 	.word	0x10030000
    fc68:	10010000 	.word	0x10010000

0000fc6c <RCC_GetSystemClockFreq>:
/**
  * @brief  Return SYSTEM clock frequency
  * @retval SYSTEM clock frequency (in Hz)
  */
uint32_t RCC_GetSystemClockFreq(void)
{
    fc6c:	b580      	push	{r7, lr}
    fc6e:	b082      	sub	sp, #8
    fc70:	af00      	add	r7, sp, #0
  uint32_t frequency = 0U;
    fc72:	2300      	movs	r3, #0
    fc74:	607b      	str	r3, [r7, #4]

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (LL_RCC_GetSysClkSource())
    fc76:	f7ff ff01 	bl	fa7c <LL_RCC_GetSysClkSource>
    fc7a:	0003      	movs	r3, r0
    fc7c:	2b04      	cmp	r3, #4
    fc7e:	d006      	beq.n	fc8e <RCC_GetSystemClockFreq+0x22>
    fc80:	2b08      	cmp	r3, #8
    fc82:	d007      	beq.n	fc94 <RCC_GetSystemClockFreq+0x28>
    fc84:	2b00      	cmp	r3, #0
    fc86:	d10a      	bne.n	fc9e <RCC_GetSystemClockFreq+0x32>
  {
    case LL_RCC_SYS_CLKSOURCE_STATUS_HSI:  /* HSI used as system clock  source */
      frequency = HSI_VALUE;
    fc88:	4b09      	ldr	r3, [pc, #36]	; (fcb0 <RCC_GetSystemClockFreq+0x44>)
    fc8a:	607b      	str	r3, [r7, #4]
      break;
    fc8c:	e00a      	b.n	fca4 <RCC_GetSystemClockFreq+0x38>

    case LL_RCC_SYS_CLKSOURCE_STATUS_HSE:  /* HSE used as system clock  source */
      frequency = HSE_VALUE;
    fc8e:	4b08      	ldr	r3, [pc, #32]	; (fcb0 <RCC_GetSystemClockFreq+0x44>)
    fc90:	607b      	str	r3, [r7, #4]
      break;
    fc92:	e007      	b.n	fca4 <RCC_GetSystemClockFreq+0x38>

    case LL_RCC_SYS_CLKSOURCE_STATUS_PLL:  /* PLL used as system clock  source */
      frequency = RCC_PLL_GetFreqDomain_SYS();
    fc94:	f000 f838 	bl	fd08 <RCC_PLL_GetFreqDomain_SYS>
    fc98:	0003      	movs	r3, r0
    fc9a:	607b      	str	r3, [r7, #4]
      break;
    fc9c:	e002      	b.n	fca4 <RCC_GetSystemClockFreq+0x38>

    default:
      frequency = HSI_VALUE;
    fc9e:	4b04      	ldr	r3, [pc, #16]	; (fcb0 <RCC_GetSystemClockFreq+0x44>)
    fca0:	607b      	str	r3, [r7, #4]
      break;
    fca2:	46c0      	nop			; (mov r8, r8)
  }

  return frequency;
    fca4:	687b      	ldr	r3, [r7, #4]
}
    fca6:	0018      	movs	r0, r3
    fca8:	46bd      	mov	sp, r7
    fcaa:	b002      	add	sp, #8
    fcac:	bd80      	pop	{r7, pc}
    fcae:	46c0      	nop			; (mov r8, r8)
    fcb0:	007a1200 	.word	0x007a1200

0000fcb4 <RCC_GetHCLKClockFreq>:
  * @brief  Return HCLK clock frequency
  * @param  SYSCLK_Frequency SYSCLK clock frequency
  * @retval HCLK clock frequency (in Hz)
  */
uint32_t RCC_GetHCLKClockFreq(uint32_t SYSCLK_Frequency)
{
    fcb4:	b580      	push	{r7, lr}
    fcb6:	b082      	sub	sp, #8
    fcb8:	af00      	add	r7, sp, #0
    fcba:	6078      	str	r0, [r7, #4]
  /* HCLK clock frequency */
  return __LL_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, LL_RCC_GetAHBPrescaler());
    fcbc:	f7ff feea 	bl	fa94 <LL_RCC_GetAHBPrescaler>
    fcc0:	0003      	movs	r3, r0
    fcc2:	091b      	lsrs	r3, r3, #4
    fcc4:	220f      	movs	r2, #15
    fcc6:	4013      	ands	r3, r2
    fcc8:	4a04      	ldr	r2, [pc, #16]	; (fcdc <RCC_GetHCLKClockFreq+0x28>)
    fcca:	5cd3      	ldrb	r3, [r2, r3]
    fccc:	001a      	movs	r2, r3
    fcce:	687b      	ldr	r3, [r7, #4]
    fcd0:	40d3      	lsrs	r3, r2
}
    fcd2:	0018      	movs	r0, r3
    fcd4:	46bd      	mov	sp, r7
    fcd6:	b002      	add	sp, #8
    fcd8:	bd80      	pop	{r7, pc}
    fcda:	46c0      	nop			; (mov r8, r8)
    fcdc:	0001f54c 	.word	0x0001f54c

0000fce0 <RCC_GetPCLK1ClockFreq>:
  * @brief  Return PCLK1 clock frequency
  * @param  HCLK_Frequency HCLK clock frequency
  * @retval PCLK1 clock frequency (in Hz)
  */
uint32_t RCC_GetPCLK1ClockFreq(uint32_t HCLK_Frequency)
{
    fce0:	b580      	push	{r7, lr}
    fce2:	b082      	sub	sp, #8
    fce4:	af00      	add	r7, sp, #0
    fce6:	6078      	str	r0, [r7, #4]
  /* PCLK1 clock frequency */
  return __LL_RCC_CALC_PCLK1_FREQ(HCLK_Frequency, LL_RCC_GetAPB1Prescaler());
    fce8:	f7ff fee0 	bl	faac <LL_RCC_GetAPB1Prescaler>
    fcec:	0003      	movs	r3, r0
    fcee:	0a1b      	lsrs	r3, r3, #8
    fcf0:	4a04      	ldr	r2, [pc, #16]	; (fd04 <RCC_GetPCLK1ClockFreq+0x24>)
    fcf2:	5cd3      	ldrb	r3, [r2, r3]
    fcf4:	001a      	movs	r2, r3
    fcf6:	687b      	ldr	r3, [r7, #4]
    fcf8:	40d3      	lsrs	r3, r2
}
    fcfa:	0018      	movs	r0, r3
    fcfc:	46bd      	mov	sp, r7
    fcfe:	b002      	add	sp, #8
    fd00:	bd80      	pop	{r7, pc}
    fd02:	46c0      	nop			; (mov r8, r8)
    fd04:	0001f55c 	.word	0x0001f55c

0000fd08 <RCC_PLL_GetFreqDomain_SYS>:
/**
  * @brief  Return PLL clock frequency used for system domain
  * @retval PLL clock frequency (in Hz)
  */
uint32_t RCC_PLL_GetFreqDomain_SYS(void)
{
    fd08:	b590      	push	{r4, r7, lr}
    fd0a:	b083      	sub	sp, #12
    fd0c:	af00      	add	r7, sp, #0
  uint32_t pllinputfreq = 0U, pllsource = 0U;
    fd0e:	2300      	movs	r3, #0
    fd10:	607b      	str	r3, [r7, #4]
    fd12:	2300      	movs	r3, #0
    fd14:	603b      	str	r3, [r7, #0]

  /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLL divider) * PLL Multiplicator */

  /* Get PLL source */
  pllsource = LL_RCC_PLL_GetMainSource();
    fd16:	f7ff fee9 	bl	faec <LL_RCC_PLL_GetMainSource>
    fd1a:	0003      	movs	r3, r0
    fd1c:	603b      	str	r3, [r7, #0]

  switch (pllsource)
    fd1e:	683b      	ldr	r3, [r7, #0]
    fd20:	2280      	movs	r2, #128	; 0x80
    fd22:	0252      	lsls	r2, r2, #9
    fd24:	4293      	cmp	r3, r2
    fd26:	d00d      	beq.n	fd44 <RCC_PLL_GetFreqDomain_SYS+0x3c>
    fd28:	22c0      	movs	r2, #192	; 0xc0
    fd2a:	0252      	lsls	r2, r2, #9
    fd2c:	4293      	cmp	r3, r2
    fd2e:	d006      	beq.n	fd3e <RCC_PLL_GetFreqDomain_SYS+0x36>
    fd30:	2280      	movs	r2, #128	; 0x80
    fd32:	0212      	lsls	r2, r2, #8
    fd34:	4293      	cmp	r3, r2
    fd36:	d108      	bne.n	fd4a <RCC_PLL_GetFreqDomain_SYS+0x42>
  {
#if defined(RCC_PLLSRC_PREDIV1_SUPPORT)
    case LL_RCC_PLLSOURCE_HSI:       /* HSI used as PLL clock source */
      pllinputfreq = HSI_VALUE;
    fd38:	4b11      	ldr	r3, [pc, #68]	; (fd80 <RCC_PLL_GetFreqDomain_SYS+0x78>)
    fd3a:	607b      	str	r3, [r7, #4]
#else
    case LL_RCC_PLLSOURCE_HSI_DIV_2: /* HSI used as PLL clock source */
      pllinputfreq = HSI_VALUE / 2U;
#endif /* RCC_PLLSRC_PREDIV1_SUPPORT */
      break;
    fd3c:	e008      	b.n	fd50 <RCC_PLL_GetFreqDomain_SYS+0x48>

#if defined(RCC_CFGR_SW_HSI48)
    case LL_RCC_PLLSOURCE_HSI48:     /* HSI48 used as PLL clock source */
      pllinputfreq = HSI48_VALUE;
    fd3e:	4b11      	ldr	r3, [pc, #68]	; (fd84 <RCC_PLL_GetFreqDomain_SYS+0x7c>)
    fd40:	607b      	str	r3, [r7, #4]
      break;
    fd42:	e005      	b.n	fd50 <RCC_PLL_GetFreqDomain_SYS+0x48>
#endif /* RCC_CFGR_SW_HSI48 */

    case LL_RCC_PLLSOURCE_HSE:       /* HSE used as PLL clock source */
      pllinputfreq = HSE_VALUE;
    fd44:	4b0e      	ldr	r3, [pc, #56]	; (fd80 <RCC_PLL_GetFreqDomain_SYS+0x78>)
    fd46:	607b      	str	r3, [r7, #4]
      break;
    fd48:	e002      	b.n	fd50 <RCC_PLL_GetFreqDomain_SYS+0x48>

    default:
#if defined(RCC_PLLSRC_PREDIV1_SUPPORT)
      pllinputfreq = HSI_VALUE;
    fd4a:	4b0d      	ldr	r3, [pc, #52]	; (fd80 <RCC_PLL_GetFreqDomain_SYS+0x78>)
    fd4c:	607b      	str	r3, [r7, #4]
#else
      pllinputfreq = HSI_VALUE / 2U;
#endif /* RCC_PLLSRC_PREDIV1_SUPPORT */
      break;
    fd4e:	46c0      	nop			; (mov r8, r8)
  }
#if defined(RCC_PLLSRC_PREDIV1_SUPPORT)
  return __LL_RCC_CALC_PLLCLK_FREQ(pllinputfreq, LL_RCC_PLL_GetMultiplicator(), LL_RCC_PLL_GetPrediv());
    fd50:	f7ff fee4 	bl	fb1c <LL_RCC_PLL_GetPrediv>
    fd54:	0002      	movs	r2, r0
    fd56:	230f      	movs	r3, #15
    fd58:	4013      	ands	r3, r2
    fd5a:	3301      	adds	r3, #1
    fd5c:	0019      	movs	r1, r3
    fd5e:	6878      	ldr	r0, [r7, #4]
    fd60:	f00f f8b0 	bl	1eec4 <__udivsi3>
    fd64:	0003      	movs	r3, r0
    fd66:	001c      	movs	r4, r3
    fd68:	f7ff fecc 	bl	fb04 <LL_RCC_PLL_GetMultiplicator>
    fd6c:	0003      	movs	r3, r0
    fd6e:	0c9b      	lsrs	r3, r3, #18
    fd70:	220f      	movs	r2, #15
    fd72:	4013      	ands	r3, r2
    fd74:	3302      	adds	r3, #2
    fd76:	4363      	muls	r3, r4
#else
  return __LL_RCC_CALC_PLLCLK_FREQ((pllinputfreq / (LL_RCC_PLL_GetPrediv() + 1U)), LL_RCC_PLL_GetMultiplicator());
#endif /* RCC_PLLSRC_PREDIV1_SUPPORT */
}
    fd78:	0018      	movs	r0, r3
    fd7a:	46bd      	mov	sp, r7
    fd7c:	b003      	add	sp, #12
    fd7e:	bd90      	pop	{r4, r7, pc}
    fd80:	007a1200 	.word	0x007a1200
    fd84:	02dc6c00 	.word	0x02dc6c00

0000fd88 <LL_USART_IsEnabled>:
  * @rmtoll CR1          UE            LL_USART_IsEnabled
  * @param  USARTx USART Instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_USART_IsEnabled(USART_TypeDef *USARTx)
{
    fd88:	b580      	push	{r7, lr}
    fd8a:	b082      	sub	sp, #8
    fd8c:	af00      	add	r7, sp, #0
    fd8e:	6078      	str	r0, [r7, #4]
  return (READ_BIT(USARTx->CR1, USART_CR1_UE) == (USART_CR1_UE));
    fd90:	687b      	ldr	r3, [r7, #4]
    fd92:	681b      	ldr	r3, [r3, #0]
    fd94:	2201      	movs	r2, #1
    fd96:	4013      	ands	r3, r2
    fd98:	3b01      	subs	r3, #1
    fd9a:	425a      	negs	r2, r3
    fd9c:	4153      	adcs	r3, r2
    fd9e:	b2db      	uxtb	r3, r3
}
    fda0:	0018      	movs	r0, r3
    fda2:	46bd      	mov	sp, r7
    fda4:	b002      	add	sp, #8
    fda6:	bd80      	pop	{r7, pc}

0000fda8 <LL_USART_SetStopBitsLength>:
  *
  *         (*) Values not available on all devices
  * @retval None
  */
__STATIC_INLINE void LL_USART_SetStopBitsLength(USART_TypeDef *USARTx, uint32_t StopBits)
{
    fda8:	b580      	push	{r7, lr}
    fdaa:	b082      	sub	sp, #8
    fdac:	af00      	add	r7, sp, #0
    fdae:	6078      	str	r0, [r7, #4]
    fdb0:	6039      	str	r1, [r7, #0]
  MODIFY_REG(USARTx->CR2, USART_CR2_STOP, StopBits);
    fdb2:	687b      	ldr	r3, [r7, #4]
    fdb4:	685b      	ldr	r3, [r3, #4]
    fdb6:	4a05      	ldr	r2, [pc, #20]	; (fdcc <LL_USART_SetStopBitsLength+0x24>)
    fdb8:	401a      	ands	r2, r3
    fdba:	683b      	ldr	r3, [r7, #0]
    fdbc:	431a      	orrs	r2, r3
    fdbe:	687b      	ldr	r3, [r7, #4]
    fdc0:	605a      	str	r2, [r3, #4]
}
    fdc2:	46c0      	nop			; (mov r8, r8)
    fdc4:	46bd      	mov	sp, r7
    fdc6:	b002      	add	sp, #8
    fdc8:	bd80      	pop	{r7, pc}
    fdca:	46c0      	nop			; (mov r8, r8)
    fdcc:	ffffcfff 	.word	0xffffcfff

0000fdd0 <LL_USART_SetHWFlowCtrl>:
  *         @arg @ref LL_USART_HWCONTROL_CTS
  *         @arg @ref LL_USART_HWCONTROL_RTS_CTS
  * @retval None
  */
__STATIC_INLINE void LL_USART_SetHWFlowCtrl(USART_TypeDef *USARTx, uint32_t HardwareFlowControl)
{
    fdd0:	b580      	push	{r7, lr}
    fdd2:	b082      	sub	sp, #8
    fdd4:	af00      	add	r7, sp, #0
    fdd6:	6078      	str	r0, [r7, #4]
    fdd8:	6039      	str	r1, [r7, #0]
  MODIFY_REG(USARTx->CR3, USART_CR3_RTSE | USART_CR3_CTSE, HardwareFlowControl);
    fdda:	687b      	ldr	r3, [r7, #4]
    fddc:	689b      	ldr	r3, [r3, #8]
    fdde:	4a05      	ldr	r2, [pc, #20]	; (fdf4 <LL_USART_SetHWFlowCtrl+0x24>)
    fde0:	401a      	ands	r2, r3
    fde2:	683b      	ldr	r3, [r7, #0]
    fde4:	431a      	orrs	r2, r3
    fde6:	687b      	ldr	r3, [r7, #4]
    fde8:	609a      	str	r2, [r3, #8]
}
    fdea:	46c0      	nop			; (mov r8, r8)
    fdec:	46bd      	mov	sp, r7
    fdee:	b002      	add	sp, #8
    fdf0:	bd80      	pop	{r7, pc}
    fdf2:	46c0      	nop			; (mov r8, r8)
    fdf4:	fffffcff 	.word	0xfffffcff

0000fdf8 <LL_USART_SetBaudRate>:
  * @param  BaudRate Baud Rate
  * @retval None
  */
__STATIC_INLINE void LL_USART_SetBaudRate(USART_TypeDef *USARTx, uint32_t PeriphClk, uint32_t OverSampling,
                                          uint32_t BaudRate)
{
    fdf8:	b5b0      	push	{r4, r5, r7, lr}
    fdfa:	b084      	sub	sp, #16
    fdfc:	af00      	add	r7, sp, #0
    fdfe:	60f8      	str	r0, [r7, #12]
    fe00:	60b9      	str	r1, [r7, #8]
    fe02:	607a      	str	r2, [r7, #4]
    fe04:	603b      	str	r3, [r7, #0]
  register uint32_t usartdiv = 0x0U;
    fe06:	2500      	movs	r5, #0
  register uint32_t brrtemp = 0x0U;
    fe08:	2400      	movs	r4, #0

  if (OverSampling == LL_USART_OVERSAMPLING_8)
    fe0a:	687a      	ldr	r2, [r7, #4]
    fe0c:	2380      	movs	r3, #128	; 0x80
    fe0e:	021b      	lsls	r3, r3, #8
    fe10:	429a      	cmp	r2, r3
    fe12:	d117      	bne.n	fe44 <LL_USART_SetBaudRate+0x4c>
  {
    usartdiv = (uint16_t)(__LL_USART_DIV_SAMPLING8(PeriphClk, BaudRate));
    fe14:	68bb      	ldr	r3, [r7, #8]
    fe16:	005a      	lsls	r2, r3, #1
    fe18:	683b      	ldr	r3, [r7, #0]
    fe1a:	085b      	lsrs	r3, r3, #1
    fe1c:	18d3      	adds	r3, r2, r3
    fe1e:	6839      	ldr	r1, [r7, #0]
    fe20:	0018      	movs	r0, r3
    fe22:	f00f f84f 	bl	1eec4 <__udivsi3>
    fe26:	0003      	movs	r3, r0
    fe28:	b29b      	uxth	r3, r3
    fe2a:	001d      	movs	r5, r3
    brrtemp = usartdiv & 0xFFF0U;
    fe2c:	4b0e      	ldr	r3, [pc, #56]	; (fe68 <LL_USART_SetBaudRate+0x70>)
    fe2e:	402b      	ands	r3, r5
    fe30:	001c      	movs	r4, r3
    brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
    fe32:	086b      	lsrs	r3, r5, #1
    fe34:	b29b      	uxth	r3, r3
    fe36:	001a      	movs	r2, r3
    fe38:	2307      	movs	r3, #7
    fe3a:	4013      	ands	r3, r2
    fe3c:	431c      	orrs	r4, r3
    USARTx->BRR = brrtemp;
    fe3e:	68fb      	ldr	r3, [r7, #12]
    fe40:	60dc      	str	r4, [r3, #12]
  }
  else
  {
    USARTx->BRR = (uint16_t)(__LL_USART_DIV_SAMPLING16(PeriphClk, BaudRate));
  }
}
    fe42:	e00c      	b.n	fe5e <LL_USART_SetBaudRate+0x66>
    USARTx->BRR = (uint16_t)(__LL_USART_DIV_SAMPLING16(PeriphClk, BaudRate));
    fe44:	683b      	ldr	r3, [r7, #0]
    fe46:	085a      	lsrs	r2, r3, #1
    fe48:	68bb      	ldr	r3, [r7, #8]
    fe4a:	18d3      	adds	r3, r2, r3
    fe4c:	6839      	ldr	r1, [r7, #0]
    fe4e:	0018      	movs	r0, r3
    fe50:	f00f f838 	bl	1eec4 <__udivsi3>
    fe54:	0003      	movs	r3, r0
    fe56:	b29b      	uxth	r3, r3
    fe58:	001a      	movs	r2, r3
    fe5a:	68fb      	ldr	r3, [r7, #12]
    fe5c:	60da      	str	r2, [r3, #12]
}
    fe5e:	46c0      	nop			; (mov r8, r8)
    fe60:	46bd      	mov	sp, r7
    fe62:	b004      	add	sp, #16
    fe64:	bdb0      	pop	{r4, r5, r7, pc}
    fe66:	46c0      	nop			; (mov r8, r8)
    fe68:	0000fff0 	.word	0x0000fff0

0000fe6c <LL_USART_Init>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: USART registers are initialized according to USART_InitStruct content
  *          - ERROR: Problem occurred during USART Registers initialization
  */
ErrorStatus LL_USART_Init(USART_TypeDef *USARTx, LL_USART_InitTypeDef *USART_InitStruct)
{
    fe6c:	b590      	push	{r4, r7, lr}
    fe6e:	b089      	sub	sp, #36	; 0x24
    fe70:	af00      	add	r7, sp, #0
    fe72:	6078      	str	r0, [r7, #4]
    fe74:	6039      	str	r1, [r7, #0]
  ErrorStatus status = ERROR;
    fe76:	231f      	movs	r3, #31
    fe78:	18fb      	adds	r3, r7, r3
    fe7a:	2200      	movs	r2, #0
    fe7c:	701a      	strb	r2, [r3, #0]
  uint32_t periphclk = LL_RCC_PERIPH_FREQUENCY_NO;
    fe7e:	2300      	movs	r3, #0
    fe80:	61bb      	str	r3, [r7, #24]
  uint32_t temp = 0;
    fe82:	2300      	movs	r3, #0
    fe84:	617b      	str	r3, [r7, #20]
  assert_param(IS_LL_USART_HWCONTROL(USART_InitStruct->HardwareFlowControl));
  assert_param(IS_LL_USART_OVERSAMPLING(USART_InitStruct->OverSampling));

  /* USART needs to be in disabled state, in order to be able to configure some bits in
     CRx registers */
  if (LL_USART_IsEnabled(USARTx) == 0U)
    fe86:	687b      	ldr	r3, [r7, #4]
    fe88:	0018      	movs	r0, r3
    fe8a:	f7ff ff7d 	bl	fd88 <LL_USART_IsEnabled>
    fe8e:	1e03      	subs	r3, r0, #0
    fe90:	d162      	bne.n	ff58 <LL_USART_Init+0xec>
     * - DataWidth:          USART_CR1_M bits according to USART_InitStruct->DataWidth value
     * - Parity:             USART_CR1_PCE, USART_CR1_PS bits according to USART_InitStruct->Parity value
     * - TransferDirection:  USART_CR1_TE, USART_CR1_RE bits according to USART_InitStruct->TransferDirection value
     * - Oversampling:       USART_CR1_OVER8 bit according to USART_InitStruct->OverSampling value.
     */
    MODIFY_REG(USARTx->CR1,
    fe92:	687b      	ldr	r3, [r7, #4]
    fe94:	681b      	ldr	r3, [r3, #0]
    fe96:	4a34      	ldr	r2, [pc, #208]	; (ff68 <LL_USART_Init+0xfc>)
    fe98:	401a      	ands	r2, r3
    fe9a:	683b      	ldr	r3, [r7, #0]
    fe9c:	6859      	ldr	r1, [r3, #4]
    fe9e:	683b      	ldr	r3, [r7, #0]
    fea0:	68db      	ldr	r3, [r3, #12]
    fea2:	4319      	orrs	r1, r3
    fea4:	683b      	ldr	r3, [r7, #0]
    fea6:	691b      	ldr	r3, [r3, #16]
    fea8:	4319      	orrs	r1, r3
    feaa:	683b      	ldr	r3, [r7, #0]
    feac:	699b      	ldr	r3, [r3, #24]
    feae:	430b      	orrs	r3, r1
    feb0:	431a      	orrs	r2, r3
    feb2:	687b      	ldr	r3, [r7, #4]
    feb4:	601a      	str	r2, [r3, #0]
    /*---------------------------- USART CR2 Configuration ---------------------
     * Configure USARTx CR2 (Stop bits) with parameters:
     * - Stop Bits:          USART_CR2_STOP bits according to USART_InitStruct->StopBits value.
     * - CLKEN, CPOL, CPHA and LBCL bits are to be configured using LL_USART_ClockInit().
     */
    LL_USART_SetStopBitsLength(USARTx, USART_InitStruct->StopBits);
    feb6:	683b      	ldr	r3, [r7, #0]
    feb8:	689a      	ldr	r2, [r3, #8]
    feba:	687b      	ldr	r3, [r7, #4]
    febc:	0011      	movs	r1, r2
    febe:	0018      	movs	r0, r3
    fec0:	f7ff ff72 	bl	fda8 <LL_USART_SetStopBitsLength>

    /*---------------------------- USART CR3 Configuration ---------------------
     * Configure USARTx CR3 (Hardware Flow Control) with parameters:
     * - HardwareFlowControl: USART_CR3_RTSE, USART_CR3_CTSE bits according to USART_InitStruct->HardwareFlowControl value.
     */
    LL_USART_SetHWFlowCtrl(USARTx, USART_InitStruct->HardwareFlowControl);
    fec4:	683b      	ldr	r3, [r7, #0]
    fec6:	695a      	ldr	r2, [r3, #20]
    fec8:	687b      	ldr	r3, [r7, #4]
    feca:	0011      	movs	r1, r2
    fecc:	0018      	movs	r0, r3
    fece:	f7ff ff7f 	bl	fdd0 <LL_USART_SetHWFlowCtrl>

    /*---------------------------- USART BRR Configuration ---------------------
     * Retrieve Clock frequency used for USART Peripheral
     */
    if (USARTx == USART1)
    fed2:	687b      	ldr	r3, [r7, #4]
    fed4:	4a25      	ldr	r2, [pc, #148]	; (ff6c <LL_USART_Init+0x100>)
    fed6:	4293      	cmp	r3, r2
    fed8:	d105      	bne.n	fee6 <LL_USART_Init+0x7a>
    {
      periphclk = LL_RCC_GetUSARTClockFreq(LL_RCC_USART1_CLKSOURCE);
    feda:	2000      	movs	r0, #0
    fedc:	f7ff fe48 	bl	fb70 <LL_RCC_GetUSARTClockFreq>
    fee0:	0003      	movs	r3, r0
    fee2:	61bb      	str	r3, [r7, #24]
    fee4:	e022      	b.n	ff2c <LL_USART_Init+0xc0>
    }
#if defined(USART2)
    else if (USARTx == USART2)
    fee6:	687b      	ldr	r3, [r7, #4]
    fee8:	4a21      	ldr	r2, [pc, #132]	; (ff70 <LL_USART_Init+0x104>)
    feea:	4293      	cmp	r3, r2
    feec:	d105      	bne.n	fefa <LL_USART_Init+0x8e>
    {
#if defined (RCC_CFGR3_USART2SW)
      periphclk = LL_RCC_GetUSARTClockFreq(LL_RCC_USART2_CLKSOURCE);
    feee:	2010      	movs	r0, #16
    fef0:	f7ff fe3e 	bl	fb70 <LL_RCC_GetUSARTClockFreq>
    fef4:	0003      	movs	r3, r0
    fef6:	61bb      	str	r3, [r7, #24]
    fef8:	e018      	b.n	ff2c <LL_USART_Init+0xc0>
      periphclk = RCC_Clocks.PCLK1_Frequency;
#endif
    }
#endif /* USART2 */
#if defined(USART3)
    else if (USARTx == USART3)
    fefa:	687b      	ldr	r3, [r7, #4]
    fefc:	4a1d      	ldr	r2, [pc, #116]	; (ff74 <LL_USART_Init+0x108>)
    fefe:	4293      	cmp	r3, r2
    ff00:	d108      	bne.n	ff14 <LL_USART_Init+0xa8>
    {
#if defined (RCC_CFGR3_USART3SW)
      periphclk = LL_RCC_GetUSARTClockFreq(LL_RCC_USART3_CLKSOURCE);
#else
      /* USART3 clock is PCLK */
      LL_RCC_GetSystemClocksFreq(&RCC_Clocks);
    ff02:	2408      	movs	r4, #8
    ff04:	193b      	adds	r3, r7, r4
    ff06:	0018      	movs	r0, r3
    ff08:	f7ff fe14 	bl	fb34 <LL_RCC_GetSystemClocksFreq>
      periphclk = RCC_Clocks.PCLK1_Frequency;
    ff0c:	193b      	adds	r3, r7, r4
    ff0e:	689b      	ldr	r3, [r3, #8]
    ff10:	61bb      	str	r3, [r7, #24]
    ff12:	e00b      	b.n	ff2c <LL_USART_Init+0xc0>
#endif
    }
#endif /* USART3 */
#if defined(USART4)
    else if (USARTx == USART4)
    ff14:	687b      	ldr	r3, [r7, #4]
    ff16:	4a18      	ldr	r2, [pc, #96]	; (ff78 <LL_USART_Init+0x10c>)
    ff18:	4293      	cmp	r3, r2
    ff1a:	d107      	bne.n	ff2c <LL_USART_Init+0xc0>
    {
      /* USART4 clock is PCLK */
      LL_RCC_GetSystemClocksFreq(&RCC_Clocks);
    ff1c:	2408      	movs	r4, #8
    ff1e:	193b      	adds	r3, r7, r4
    ff20:	0018      	movs	r0, r3
    ff22:	f7ff fe07 	bl	fb34 <LL_RCC_GetSystemClocksFreq>
      periphclk = RCC_Clocks.PCLK1_Frequency;
    ff26:	193b      	adds	r3, r7, r4
    ff28:	689b      	ldr	r3, [r3, #8]
    ff2a:	61bb      	str	r3, [r7, #24]

    /* Configure the USART Baud Rate :
       - valid baud rate value (different from 0) is required
       - Peripheral clock as returned by RCC service, should be valid (different from 0).
    */
    if ((periphclk != LL_RCC_PERIPH_FREQUENCY_NO)
    ff2c:	69bb      	ldr	r3, [r7, #24]
    ff2e:	2b00      	cmp	r3, #0
    ff30:	d012      	beq.n	ff58 <LL_USART_Init+0xec>
        && (USART_InitStruct->BaudRate != 0U))
    ff32:	683b      	ldr	r3, [r7, #0]
    ff34:	681b      	ldr	r3, [r3, #0]
    ff36:	2b00      	cmp	r3, #0
    ff38:	d00e      	beq.n	ff58 <LL_USART_Init+0xec>
    {
      status = SUCCESS;
    ff3a:	231f      	movs	r3, #31
    ff3c:	18fb      	adds	r3, r7, r3
    ff3e:	2201      	movs	r2, #1
    ff40:	701a      	strb	r2, [r3, #0]
      LL_USART_SetBaudRate(USARTx,
    ff42:	683b      	ldr	r3, [r7, #0]
    ff44:	699a      	ldr	r2, [r3, #24]
    ff46:	683b      	ldr	r3, [r7, #0]
    ff48:	681b      	ldr	r3, [r3, #0]
    ff4a:	69b9      	ldr	r1, [r7, #24]
    ff4c:	6878      	ldr	r0, [r7, #4]
    ff4e:	f7ff ff53 	bl	fdf8 <LL_USART_SetBaudRate>
                           USART_InitStruct->BaudRate);

      /* Check BRR is greater than or equal to 16d */
      /* Use local value to avoid MISRA 2004 issue
         rule 12.4 the right hand operand of an && or || operator shall not contain side effects */
      temp = USARTx->BRR;
    ff52:	687b      	ldr	r3, [r7, #4]
    ff54:	68db      	ldr	r3, [r3, #12]
    ff56:	617b      	str	r3, [r7, #20]

    }
  }
  /* Endif (=> USART not in Disabled state => return ERROR) */

  return (status);
    ff58:	231f      	movs	r3, #31
    ff5a:	18fb      	adds	r3, r7, r3
    ff5c:	781b      	ldrb	r3, [r3, #0]
}
    ff5e:	0018      	movs	r0, r3
    ff60:	46bd      	mov	sp, r7
    ff62:	b009      	add	sp, #36	; 0x24
    ff64:	bd90      	pop	{r4, r7, pc}
    ff66:	46c0      	nop			; (mov r8, r8)
    ff68:	efff69f3 	.word	0xefff69f3
    ff6c:	40013800 	.word	0x40013800
    ff70:	40004400 	.word	0x40004400
    ff74:	40004800 	.word	0x40004800
    ff78:	40004c00 	.word	0x40004c00

0000ff7c <LL_InitTick>:
  *         configuration by calling this function, for a delay use rather osDelay RTOS service.
  * @param  Ticks Number of ticks
  * @retval None
  */
__STATIC_INLINE void LL_InitTick(uint32_t HCLKFrequency, uint32_t Ticks)
{
    ff7c:	b580      	push	{r7, lr}
    ff7e:	b082      	sub	sp, #8
    ff80:	af00      	add	r7, sp, #0
    ff82:	6078      	str	r0, [r7, #4]
    ff84:	6039      	str	r1, [r7, #0]
  /* Configure the SysTick to have interrupt in 1ms time base */
  SysTick->LOAD  = (uint32_t)((HCLKFrequency / Ticks) - 1UL);  /* set reload register */
    ff86:	6839      	ldr	r1, [r7, #0]
    ff88:	6878      	ldr	r0, [r7, #4]
    ff8a:	f00e ff9b 	bl	1eec4 <__udivsi3>
    ff8e:	0003      	movs	r3, r0
    ff90:	001a      	movs	r2, r3
    ff92:	4b06      	ldr	r3, [pc, #24]	; (ffac <LL_InitTick+0x30>)
    ff94:	3a01      	subs	r2, #1
    ff96:	605a      	str	r2, [r3, #4]
  SysTick->VAL   = 0UL;                                       /* Load the SysTick Counter Value */
    ff98:	4b04      	ldr	r3, [pc, #16]	; (ffac <LL_InitTick+0x30>)
    ff9a:	2200      	movs	r2, #0
    ff9c:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
    ff9e:	4b03      	ldr	r3, [pc, #12]	; (ffac <LL_InitTick+0x30>)
    ffa0:	2205      	movs	r2, #5
    ffa2:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_ENABLE_Msk;                   /* Enable the Systick Timer */
}
    ffa4:	46c0      	nop			; (mov r8, r8)
    ffa6:	46bd      	mov	sp, r7
    ffa8:	b002      	add	sp, #8
    ffaa:	bd80      	pop	{r7, pc}
    ffac:	e000e010 	.word	0xe000e010

0000ffb0 <LL_Init1msTick>:
  * @param  HCLKFrequency HCLK frequency in Hz
  * @note   HCLK frequency can be calculated thanks to RCC helper macro or function @ref LL_RCC_GetSystemClocksFreq
  * @retval None
  */
void LL_Init1msTick(uint32_t HCLKFrequency)
{
    ffb0:	b580      	push	{r7, lr}
    ffb2:	b082      	sub	sp, #8
    ffb4:	af00      	add	r7, sp, #0
    ffb6:	6078      	str	r0, [r7, #4]
  /* Use frequency provided in argument */
  LL_InitTick(HCLKFrequency, 1000U);
    ffb8:	23fa      	movs	r3, #250	; 0xfa
    ffba:	009a      	lsls	r2, r3, #2
    ffbc:	687b      	ldr	r3, [r7, #4]
    ffbe:	0011      	movs	r1, r2
    ffc0:	0018      	movs	r0, r3
    ffc2:	f7ff ffdb 	bl	ff7c <LL_InitTick>
}
    ffc6:	46c0      	nop			; (mov r8, r8)
    ffc8:	46bd      	mov	sp, r7
    ffca:	b002      	add	sp, #8
    ffcc:	bd80      	pop	{r7, pc}
	...

0000ffd0 <LL_SetSystemCoreClock>:
  * @note   Variable can be calculated also through SystemCoreClockUpdate function.
  * @param  HCLKFrequency HCLK frequency in Hz (can be calculated thanks to RCC helper macro)
  * @retval None
  */
void LL_SetSystemCoreClock(uint32_t HCLKFrequency)
{
    ffd0:	b580      	push	{r7, lr}
    ffd2:	b082      	sub	sp, #8
    ffd4:	af00      	add	r7, sp, #0
    ffd6:	6078      	str	r0, [r7, #4]
  /* HCLK clock frequency */
  SystemCoreClock = HCLKFrequency;
    ffd8:	4b03      	ldr	r3, [pc, #12]	; (ffe8 <LL_SetSystemCoreClock+0x18>)
    ffda:	687a      	ldr	r2, [r7, #4]
    ffdc:	601a      	str	r2, [r3, #0]
}
    ffde:	46c0      	nop			; (mov r8, r8)
    ffe0:	46bd      	mov	sp, r7
    ffe2:	b002      	add	sp, #8
    ffe4:	bd80      	pop	{r7, pc}
    ffe6:	46c0      	nop			; (mov r8, r8)
    ffe8:	0002fec4 	.word	0x0002fec4

0000ffec <USBPD_DPM_InitCore>:
/**
  * @brief  Initialize the core stack (port power role, PWR_IF, CAD and PE Init procedures)
  * @retval USBPD status
  */
USBPD_StatusTypeDef USBPD_DPM_InitCore(void)
{
    ffec:	b5b0      	push	{r4, r5, r7, lr}
    ffee:	b086      	sub	sp, #24
    fff0:	af02      	add	r7, sp, #8
  /* variable to get dynamique memory allocated by usbpd stack */
  uint32_t stack_dynamemsize;
  USBPD_StatusTypeDef _retr = USBPD_OK;
    fff2:	230f      	movs	r3, #15
    fff4:	18fb      	adds	r3, r7, r3
    fff6:	2200      	movs	r2, #0
    fff8:	701a      	strb	r2, [r3, #0]
  static const USBPD_CAD_Callbacks CAD_cbs = { USBPD_DPM_CADCallback, USBPD_DPM_CADTaskWakeUp };
#endif /* USBPD_TCPM_MODULE_ENABLED */

#if !defined(_SIMULATOR)
  /* Check the lib selected */
  if (USBPD_TRUE != USBPD_PE_CheckLIB(_LIB_ID))
    fffa:	4b3e      	ldr	r3, [pc, #248]	; (100f4 <USBPD_DPM_InitCore+0x108>)
    fffc:	0018      	movs	r0, r3
    fffe:	f007 fc89 	bl	17914 <USBPD_PE_CheckLIB>
   10002:	0003      	movs	r3, r0
   10004:	2b01      	cmp	r3, #1
   10006:	d001      	beq.n	1000c <USBPD_DPM_InitCore+0x20>
  {
    return USBPD_ERROR;
   10008:	2302      	movs	r3, #2
   1000a:	e06e      	b.n	100ea <USBPD_DPM_InitCore+0xfe>
#endif

  /* to get how much memory are dynamically allocated by the stack
     the memory return is corresponding to 2 ports so if the application
     managed only one port divide the value return by 2                   */
  stack_dynamemsize = USBPD_PE_GetMemoryConsumption();
   1000c:	f007 fc89 	bl	17922 <USBPD_PE_GetMemoryConsumption>
   10010:	0003      	movs	r3, r0
   10012:	60bb      	str	r3, [r7, #8]

  /* done to avoid warning */
  (void)stack_dynamemsize;

  /* Variable to be sure that DPM is correctly initialized */
  DPM_Params[USBPD_PORT_0].DPM_Initialized = USBPD_FALSE;
   10014:	4b38      	ldr	r3, [pc, #224]	; (100f8 <USBPD_DPM_InitCore+0x10c>)
   10016:	785a      	ldrb	r2, [r3, #1]
   10018:	2108      	movs	r1, #8
   1001a:	438a      	bics	r2, r1
   1001c:	705a      	strb	r2, [r3, #1]
#if USBPD_PORT_COUNT == 2
  DPM_Params[USBPD_PORT_1].DPM_Initialized = USBPD_FALSE;
#endif /* USBPD_PORT_COUNT == 2 */

  /* check the stack settings */
  DPM_Params[USBPD_PORT_0].PE_SpecRevision  = DPM_Settings[USBPD_PORT_0].PE_SpecRevision;
   1001e:	4b37      	ldr	r3, [pc, #220]	; (100fc <USBPD_DPM_InitCore+0x110>)
   10020:	791b      	ldrb	r3, [r3, #4]
   10022:	079b      	lsls	r3, r3, #30
   10024:	0f9b      	lsrs	r3, r3, #30
   10026:	b2da      	uxtb	r2, r3
   10028:	4b33      	ldr	r3, [pc, #204]	; (100f8 <USBPD_DPM_InitCore+0x10c>)
   1002a:	2103      	movs	r1, #3
   1002c:	400a      	ands	r2, r1
   1002e:	0010      	movs	r0, r2
   10030:	781a      	ldrb	r2, [r3, #0]
   10032:	2103      	movs	r1, #3
   10034:	438a      	bics	r2, r1
   10036:	1c11      	adds	r1, r2, #0
   10038:	1c02      	adds	r2, r0, #0
   1003a:	430a      	orrs	r2, r1
   1003c:	701a      	strb	r2, [r3, #0]
  DPM_Params[USBPD_PORT_0].PE_PowerRole     = DPM_Settings[USBPD_PORT_0].PE_DefaultRole;
   1003e:	4b2f      	ldr	r3, [pc, #188]	; (100fc <USBPD_DPM_InitCore+0x110>)
   10040:	791b      	ldrb	r3, [r3, #4]
   10042:	075b      	lsls	r3, r3, #29
   10044:	0fdb      	lsrs	r3, r3, #31
   10046:	b2da      	uxtb	r2, r3
   10048:	4b2b      	ldr	r3, [pc, #172]	; (100f8 <USBPD_DPM_InitCore+0x10c>)
   1004a:	2101      	movs	r1, #1
   1004c:	400a      	ands	r2, r1
   1004e:	0090      	lsls	r0, r2, #2
   10050:	781a      	ldrb	r2, [r3, #0]
   10052:	2104      	movs	r1, #4
   10054:	438a      	bics	r2, r1
   10056:	1c11      	adds	r1, r2, #0
   10058:	1c02      	adds	r2, r0, #0
   1005a:	430a      	orrs	r2, r1
   1005c:	701a      	strb	r2, [r3, #0]
  DPM_Params[USBPD_PORT_0].PE_SwapOngoing   = USBPD_FALSE;
   1005e:	4b26      	ldr	r3, [pc, #152]	; (100f8 <USBPD_DPM_InitCore+0x10c>)
   10060:	781a      	ldrb	r2, [r3, #0]
   10062:	2110      	movs	r1, #16
   10064:	438a      	bics	r2, r1
   10066:	701a      	strb	r2, [r3, #0]
  DPM_Params[USBPD_PORT_0].ActiveCCIs       = CCNONE;
   10068:	4b23      	ldr	r3, [pc, #140]	; (100f8 <USBPD_DPM_InitCore+0x10c>)
   1006a:	781a      	ldrb	r2, [r3, #0]
   1006c:	213f      	movs	r1, #63	; 0x3f
   1006e:	400a      	ands	r2, r1
   10070:	701a      	strb	r2, [r3, #0]
  DPM_Params[USBPD_PORT_0].VconnCCIs        = CCNONE;
   10072:	4b21      	ldr	r3, [pc, #132]	; (100f8 <USBPD_DPM_InitCore+0x10c>)
   10074:	785a      	ldrb	r2, [r3, #1]
   10076:	2160      	movs	r1, #96	; 0x60
   10078:	438a      	bics	r2, r1
   1007a:	705a      	strb	r2, [r3, #1]
  DPM_Params[USBPD_PORT_0].VconnStatus      = USBPD_FALSE;
   1007c:	4b1e      	ldr	r3, [pc, #120]	; (100f8 <USBPD_DPM_InitCore+0x10c>)
   1007e:	785a      	ldrb	r2, [r3, #1]
   10080:	217f      	movs	r1, #127	; 0x7f
   10082:	400a      	ands	r2, r1
   10084:	705a      	strb	r2, [r3, #1]
  DPM_Params[USBPD_PORT_1].VconnStatus      = USBPD_FALSE;
#endif /* USBPD_PORT_COUNT == 2 */

#if defined(_TRACE) || defined(_GUI_INTERFACE)
  /* Initialise the TRACE */
  USBPD_TRACE_Init();
   10086:	f000 fa5f 	bl	10548 <USBPD_TRACE_Init>
#ifndef _RTOS
  USBPD_TIM_Init();
#endif /* !_RTOS*/

#if !defined(USBPD_STUSB1605)
  USBPD_TCPCI_Init();
   1008a:	f7fd ff1f 	bl	decc <USBPD_TCPCI_Init>
#endif /* !USBPD_STUSB1605 */
  TCPC_DrvTypeDef *tcpc_driver;
  USBPD_TCPCI_GetDevicesDrivers(USBPD_PORT_0, &tcpc_driver);
   1008e:	1d3b      	adds	r3, r7, #4
   10090:	0019      	movs	r1, r3
   10092:	2000      	movs	r0, #0
   10094:	f7fd ff72 	bl	df7c <USBPD_TCPCI_GetDevicesDrivers>
  USBPD_TCPM_HWInit(USBPD_PORT_0, DPM_Settings[USBPD_PORT_0].CAD_RoleToggle, &DPM_Params[USBPD_PORT_0], (USBPD_CAD_Callbacks *)&CAD_cbs, tcpc_driver);
   10098:	4b18      	ldr	r3, [pc, #96]	; (100fc <USBPD_DPM_InitCore+0x110>)
   1009a:	795b      	ldrb	r3, [r3, #5]
   1009c:	069b      	lsls	r3, r3, #26
   1009e:	0fdb      	lsrs	r3, r3, #31
   100a0:	b2db      	uxtb	r3, r3
   100a2:	0018      	movs	r0, r3
   100a4:	687b      	ldr	r3, [r7, #4]
   100a6:	4916      	ldr	r1, [pc, #88]	; (10100 <USBPD_DPM_InitCore+0x114>)
   100a8:	4a13      	ldr	r2, [pc, #76]	; (100f8 <USBPD_DPM_InitCore+0x10c>)
   100aa:	9300      	str	r3, [sp, #0]
   100ac:	000b      	movs	r3, r1
   100ae:	0001      	movs	r1, r0
   100b0:	2000      	movs	r0, #0
   100b2:	f00d fe83 	bl	1ddbc <USBPD_TCPM_HWInit>
  CHECK_CAD_FUNCTION_CALL(USBPD_CAD_Init(USBPD_PORT_1, (USBPD_CAD_Callbacks *)&CAD_cbs, (USBPD_SettingsTypeDef *)&DPM_Settings[USBPD_PORT_1], &DPM_Params[USBPD_PORT_1]));
#endif /* USBPD_PORT_COUNT == 2 */
#endif /* USBPD_TCPM_MODULE_ENABLED */

  /* PE SET UP : Port 0 */
  CHECK_PE_FUNCTION_CALL(USBPD_PE_Init(USBPD_PORT_0, (USBPD_SettingsTypeDef *)&DPM_Settings[USBPD_PORT_0], &DPM_Params[USBPD_PORT_0], &dpmCallbacks));
   100b6:	250f      	movs	r5, #15
   100b8:	197c      	adds	r4, r7, r5
   100ba:	4b12      	ldr	r3, [pc, #72]	; (10104 <USBPD_DPM_InitCore+0x118>)
   100bc:	4a0e      	ldr	r2, [pc, #56]	; (100f8 <USBPD_DPM_InitCore+0x10c>)
   100be:	490f      	ldr	r1, [pc, #60]	; (100fc <USBPD_DPM_InitCore+0x110>)
   100c0:	2000      	movs	r0, #0
   100c2:	f007 fbb3 	bl	1782c <USBPD_PE_Init>
   100c6:	0003      	movs	r3, r0
   100c8:	7023      	strb	r3, [r4, #0]
   100ca:	197b      	adds	r3, r7, r5
   100cc:	781b      	ldrb	r3, [r3, #0]
   100ce:	2b00      	cmp	r3, #0
   100d0:	d003      	beq.n	100da <USBPD_DPM_InitCore+0xee>
   100d2:	230f      	movs	r3, #15
   100d4:	18fb      	adds	r3, r7, r3
   100d6:	781b      	ldrb	r3, [r3, #0]
   100d8:	e007      	b.n	100ea <USBPD_DPM_InitCore+0xfe>
#if USBPD_PORT_COUNT == 2
  CHECK_PE_FUNCTION_CALL(USBPD_PE_Init(USBPD_PORT_1, (USBPD_SettingsTypeDef *)&DPM_Settings[USBPD_PORT_1], &DPM_Params[USBPD_PORT_1], &dpmCallbacks));
#endif /* USBPD_PORT_COUNT == 2 */

  /* DPM is correctly initialized */
  DPM_Params[USBPD_PORT_0].DPM_Initialized = USBPD_TRUE;
   100da:	4b07      	ldr	r3, [pc, #28]	; (100f8 <USBPD_DPM_InitCore+0x10c>)
   100dc:	785a      	ldrb	r2, [r3, #1]
   100de:	2108      	movs	r1, #8
   100e0:	430a      	orrs	r2, r1
   100e2:	705a      	strb	r2, [r3, #1]

#ifdef _LOW_POWER
  USBPD_LOWPOWER_Init();
#endif /* _LOW_POWER */

  return _retr;
   100e4:	230f      	movs	r3, #15
   100e6:	18fb      	adds	r3, r7, r3
   100e8:	781b      	ldrb	r3, [r3, #0]
}
   100ea:	0018      	movs	r0, r3
   100ec:	46bd      	mov	sp, r7
   100ee:	b004      	add	sp, #16
   100f0:	bdb0      	pop	{r4, r5, r7, pc}
   100f2:	46c0      	nop			; (mov r8, r8)
   100f4:	312a0001 	.word	0x312a0001
   100f8:	000321d4 	.word	0x000321d4
   100fc:	0002fec8 	.word	0x0002fec8
   10100:	0001f5fc 	.word	0x0001f5fc
   10104:	0001f604 	.word	0x0001f604

00010108 <USBPD_DPM_InitOS>:
/**
  * @brief  Initialize the OS parts (task, queue,... )
  * @retval USBPD status
  */
USBPD_StatusTypeDef USBPD_DPM_InitOS(void)
{
   10108:	b580      	push	{r7, lr}
   1010a:	b082      	sub	sp, #8
   1010c:	af00      	add	r7, sp, #0
#ifdef _RTOS
#if defined(USBPD_TCPM_MODULE_ENABLED)
#if (osCMSIS < 0x20000U)
  osMessageQDef(MsgBox, TCPM_ALARMBOX_MESSAGES_MAX, uint16_t);
   1010e:	003b      	movs	r3, r7
   10110:	4a1e      	ldr	r2, [pc, #120]	; (1018c <USBPD_DPM_InitOS+0x84>)
   10112:	ca03      	ldmia	r2!, {r0, r1}
   10114:	c303      	stmia	r3!, {r0, r1}
  AlarmMsgBox = osMessageCreate(osMessageQ(MsgBox), NULL);
   10116:	003b      	movs	r3, r7
   10118:	2100      	movs	r1, #0
   1011a:	0018      	movs	r0, r3
   1011c:	f000 fc7a 	bl	10a14 <osMessageCreate>
   10120:	0002      	movs	r2, r0
   10122:	4b1b      	ldr	r3, [pc, #108]	; (10190 <USBPD_DPM_InitOS+0x88>)
   10124:	601a      	str	r2, [r3, #0]
  if (NULL == (ThreadAlert = osThreadCreate(osThread(ALERTTask), &AlarmMsgBox)))
   10126:	4a1a      	ldr	r2, [pc, #104]	; (10190 <USBPD_DPM_InitOS+0x88>)
   10128:	4b1a      	ldr	r3, [pc, #104]	; (10194 <USBPD_DPM_InitOS+0x8c>)
   1012a:	0011      	movs	r1, r2
   1012c:	0018      	movs	r0, r3
   1012e:	f000 fb8d 	bl	1084c <osThreadCreate>
   10132:	0002      	movs	r2, r0
   10134:	4b18      	ldr	r3, [pc, #96]	; (10198 <USBPD_DPM_InitOS+0x90>)
   10136:	601a      	str	r2, [r3, #0]
   10138:	4b17      	ldr	r3, [pc, #92]	; (10198 <USBPD_DPM_InitOS+0x90>)
   1013a:	681b      	ldr	r3, [r3, #0]
   1013c:	2b00      	cmp	r3, #0
   1013e:	d101      	bne.n	10144 <USBPD_DPM_InitOS+0x3c>
#else
  AlarmMsgBox = osMessageQueueNew (TCPM_ALARMBOX_MESSAGES_MAX, sizeof(uint16_t), NULL);
  if (NULL == osThreadNew(USBPD_ALERT_Task, &AlarmMsgBox, &Alert_Thread_Atrr))
#endif /* osCMSIS < 0x20000U */
  {
    return USBPD_ERROR;
   10140:	2302      	movs	r3, #2
   10142:	e01e      	b.n	10182 <USBPD_DPM_InitOS+0x7a>
#endif /* !USBPDCORE_LIB_NO_PD */
#endif /* USBPD_TCPM_MODULE_ENABLED */

#if defined(_TRACE) || defined(_GUI_INTERFACE)
#if (osCMSIS < 0x20000U)
  TraceQueueId = osMessageCreate(osMessageQ(queueTRACE), NULL);
   10144:	4b15      	ldr	r3, [pc, #84]	; (1019c <USBPD_DPM_InitOS+0x94>)
   10146:	2100      	movs	r1, #0
   10148:	0018      	movs	r0, r3
   1014a:	f000 fc63 	bl	10a14 <osMessageCreate>
   1014e:	0002      	movs	r2, r0
   10150:	4b13      	ldr	r3, [pc, #76]	; (101a0 <USBPD_DPM_InitOS+0x98>)
   10152:	601a      	str	r2, [r3, #0]
  if (NULL == osThreadCreate(osThread(TRA_TX), NULL))
   10154:	4b13      	ldr	r3, [pc, #76]	; (101a4 <USBPD_DPM_InitOS+0x9c>)
   10156:	2100      	movs	r1, #0
   10158:	0018      	movs	r0, r3
   1015a:	f000 fb77 	bl	1084c <osThreadCreate>
   1015e:	1e03      	subs	r3, r0, #0
   10160:	d101      	bne.n	10166 <USBPD_DPM_InitOS+0x5e>
#else
  TraceQueueId = osMessageQueueNew (1, sizeof(uint16_t), NULL);
  if (NULL == osThreadNew(USBPD_TRACE_TX_Task, &TraceQueueId, &TRA_Thread_Atrr))
#endif /* osCMSIS < 0x20000U */
  {
    return USBPD_ERROR;
   10162:	2302      	movs	r3, #2
   10164:	e00d      	b.n	10182 <USBPD_DPM_InitOS+0x7a>
#endif /* _TRACE || _GUI_INTERFACE */

#if !defined(USBPDCORE_LIB_NO_PD)
  /* Create the queue corresponding to PE task */
#if (osCMSIS < 0x20000U)
  PEQueueId[0] = osMessageCreate(osMessageQ(queuePE), NULL);
   10166:	4b10      	ldr	r3, [pc, #64]	; (101a8 <USBPD_DPM_InitOS+0xa0>)
   10168:	2100      	movs	r1, #0
   1016a:	0018      	movs	r0, r3
   1016c:	f000 fc52 	bl	10a14 <osMessageCreate>
   10170:	0002      	movs	r2, r0
   10172:	4b0e      	ldr	r3, [pc, #56]	; (101ac <USBPD_DPM_InitOS+0xa4>)
   10174:	601a      	str	r2, [r3, #0]
  PEQueueId[1] = osMessageQueueNew (1, sizeof(uint16_t), NULL);
#endif /* USBPD_PORT_COUNT == 2 */
#endif /* osCMSIS < 0x20000U */

  /* PE task to be created on attachment */
  DPM_PEThreadId_Table[USBPD_PORT_0] = NULL;
   10176:	4b0e      	ldr	r3, [pc, #56]	; (101b0 <USBPD_DPM_InitOS+0xa8>)
   10178:	2200      	movs	r2, #0
   1017a:	601a      	str	r2, [r3, #0]
  DPM_PEThreadId_Table[USBPD_PORT_1] = NULL;
#endif /* USBPD_PORT_COUNT == 2 */
#endif /* !USBPDCORE_LIB_NO_PD */
#endif /* _RTOS */
#if defined(USBPD_TCPM_MODULE_ENABLED)
  USBPD_TCPI_AlertInit();
   1017c:	f7fd fe74 	bl	de68 <USBPD_TCPI_AlertInit>
#endif /* USBPD_TCPM_MODULE_ENABLED */

  return USBPD_OK;
   10180:	2300      	movs	r3, #0
}
   10182:	0018      	movs	r0, r3
   10184:	46bd      	mov	sp, r7
   10186:	b002      	add	sp, #8
   10188:	bd80      	pop	{r7, pc}
   1018a:	46c0      	nop			; (mov r8, r8)
   1018c:	0001f588 	.word	0x0001f588
   10190:	000321d0 	.word	0x000321d0
   10194:	0001f5cc 	.word	0x0001f5cc
   10198:	000321c8 	.word	0x000321c8
   1019c:	0001f5f4 	.word	0x0001f5f4
   101a0:	000321cc 	.word	0x000321cc
   101a4:	0001f5e0 	.word	0x0001f5e0
   101a8:	0001f5c4 	.word	0x0001f5c4
   101ac:	00030148 	.word	0x00030148
   101b0:	00030144 	.word	0x00030144

000101b4 <USBPD_DPM_Run>:
  * @brief  Initialize the OS parts (port power role, PWR_IF, CAD and PE Init procedures)
  * @retval None
  */
#ifdef _RTOS
void USBPD_DPM_Run(void)
{
   101b4:	b580      	push	{r7, lr}
   101b6:	af00      	add	r7, sp, #0
#if (osCMSIS >= 0x20000U)
  osKernelInitialize();
#endif /* osCMSIS >= 0x20000U */
  osKernelStart();
   101b8:	f000 fb40 	bl	1083c <osKernelStart>
}
   101bc:	46c0      	nop			; (mov r8, r8)
   101be:	46bd      	mov	sp, r7
   101c0:	bd80      	pop	{r7, pc}
	...

000101c4 <USBPD_PE_TaskWakeUp>:
  * @brief  WakeUp PE task
  * @param  PortNum port number
  * @retval None
  */
static void USBPD_PE_TaskWakeUp(uint8_t PortNum)
{
   101c4:	b580      	push	{r7, lr}
   101c6:	b082      	sub	sp, #8
   101c8:	af00      	add	r7, sp, #0
   101ca:	0002      	movs	r2, r0
   101cc:	1dfb      	adds	r3, r7, #7
   101ce:	701a      	strb	r2, [r3, #0]
#ifdef _RTOS
#if (osCMSIS < 0x20000U)
  (void)osMessagePut(PEQueueId[PortNum], 0xFFFF, 0);
   101d0:	1dfb      	adds	r3, r7, #7
   101d2:	781a      	ldrb	r2, [r3, #0]
   101d4:	4b05      	ldr	r3, [pc, #20]	; (101ec <USBPD_PE_TaskWakeUp+0x28>)
   101d6:	0092      	lsls	r2, r2, #2
   101d8:	58d3      	ldr	r3, [r2, r3]
   101da:	4905      	ldr	r1, [pc, #20]	; (101f0 <USBPD_PE_TaskWakeUp+0x2c>)
   101dc:	2200      	movs	r2, #0
   101de:	0018      	movs	r0, r3
   101e0:	f000 fc2a 	bl	10a38 <osMessagePut>
  UTIL_SEQ_SetTask(PortNum == 0? TASK_PE_0: TASK_PE_1, 0);
#else
  DPM_Sleep_time[PortNum] = 0;
#endif /* USE_STM32_UTILITY_OS */
#endif /* _RTOS */
}
   101e4:	46c0      	nop			; (mov r8, r8)
   101e6:	46bd      	mov	sp, r7
   101e8:	b002      	add	sp, #8
   101ea:	bd80      	pop	{r7, pc}
   101ec:	00030148 	.word	0x00030148
   101f0:	0000ffff 	.word	0x0000ffff

000101f4 <USBPD_PE_Task>:
  * @brief  Main task for PE layer
  * @param  argument Not used
  * @retval None
  */
void USBPD_PE_Task(void const *argument)
{
   101f4:	b590      	push	{r4, r7, lr}
   101f6:	b089      	sub	sp, #36	; 0x24
   101f8:	af00      	add	r7, sp, #0
   101fa:	6178      	str	r0, [r7, #20]
  uint8_t _port = (uint32_t)argument;
   101fc:	697a      	ldr	r2, [r7, #20]
   101fe:	231f      	movs	r3, #31
   10200:	18fb      	adds	r3, r7, r3
   10202:	701a      	strb	r2, [r3, #0]
      _timing = USBPD_PE_StateMachine_SNKwVPD(_port);
    }
    else
#endif
    {
      _timing = USBPD_PE_StateMachine_DRP(_port);
   10204:	241f      	movs	r4, #31
   10206:	193b      	adds	r3, r7, r4
   10208:	781b      	ldrb	r3, [r3, #0]
   1020a:	0018      	movs	r0, r3
   1020c:	f009 ffa7 	bl	1a15e <USBPD_PE_StateMachine_DRP>
   10210:	0003      	movs	r3, r0
   10212:	61bb      	str	r3, [r7, #24]
#endif
    {
      _timing = USBPD_PE_StateMachine_SNK(_port);
    }
#endif
    osMessageGet(PEQueueId[_port],_timing);
   10214:	193b      	adds	r3, r7, r4
   10216:	781a      	ldrb	r2, [r3, #0]
   10218:	4b14      	ldr	r3, [pc, #80]	; (1026c <USBPD_PE_Task+0x78>)
   1021a:	0092      	lsls	r2, r2, #2
   1021c:	58d1      	ldr	r1, [r2, r3]
   1021e:	003b      	movs	r3, r7
   10220:	69ba      	ldr	r2, [r7, #24]
   10222:	0018      	movs	r0, r3
   10224:	f000 fc44 	bl	10ab0 <osMessageGet>
#if defined(USBPD_TCPM_MODULE_ENABLED)
    /* During SRC tests, VBUS is disabled by the FUSB but the detection is not
       well done */
    if ((DPM_Params[_port].PE_SwapOngoing == 0) && (USBPD_ERROR == USBPD_TCPM_VBUS_IsVsafe5V(_port)))
   10228:	193b      	adds	r3, r7, r4
   1022a:	781a      	ldrb	r2, [r3, #0]
   1022c:	4b10      	ldr	r3, [pc, #64]	; (10270 <USBPD_PE_Task+0x7c>)
   1022e:	0092      	lsls	r2, r2, #2
   10230:	5cd3      	ldrb	r3, [r2, r3]
   10232:	06db      	lsls	r3, r3, #27
   10234:	0fdb      	lsrs	r3, r3, #31
   10236:	b2db      	uxtb	r3, r3
   10238:	2b00      	cmp	r3, #0
   1023a:	d1e3      	bne.n	10204 <USBPD_PE_Task+0x10>
   1023c:	231f      	movs	r3, #31
   1023e:	18fb      	adds	r3, r7, r3
   10240:	781b      	ldrb	r3, [r3, #0]
   10242:	0018      	movs	r0, r3
   10244:	f00d fe48 	bl	1ded8 <USBPD_TCPM_VBUS_IsVsafe5V>
   10248:	0003      	movs	r3, r0
   1024a:	2b02      	cmp	r3, #2
   1024c:	d1da      	bne.n	10204 <USBPD_PE_Task+0x10>
    {
      (void)osMessagePut(AlarmMsgBox, (_port << 8 | 2), osWaitForever);
   1024e:	4b09      	ldr	r3, [pc, #36]	; (10274 <USBPD_PE_Task+0x80>)
   10250:	6818      	ldr	r0, [r3, #0]
   10252:	231f      	movs	r3, #31
   10254:	18fb      	adds	r3, r7, r3
   10256:	781b      	ldrb	r3, [r3, #0]
   10258:	021b      	lsls	r3, r3, #8
   1025a:	2202      	movs	r2, #2
   1025c:	4313      	orrs	r3, r2
   1025e:	0019      	movs	r1, r3
   10260:	2301      	movs	r3, #1
   10262:	425b      	negs	r3, r3
   10264:	001a      	movs	r2, r3
   10266:	f000 fbe7 	bl	10a38 <osMessagePut>
      _timing = USBPD_PE_StateMachine_DRP(_port);
   1026a:	e7cb      	b.n	10204 <USBPD_PE_Task+0x10>
   1026c:	00030148 	.word	0x00030148
   10270:	000321d4 	.word	0x000321d4
   10274:	000321d0 	.word	0x000321d0

00010278 <USBPD_ALERT_Task>:
#if (osCMSIS < 0x20000U)
void USBPD_ALERT_Task(void const *queue_id)
#else
void USBPD_ALERT_Task(void *queue_id)
#endif /* osCMSIS < 0x20000U */
{
   10278:	b5b0      	push	{r4, r5, r7, lr}
   1027a:	b08a      	sub	sp, #40	; 0x28
   1027c:	af02      	add	r7, sp, #8
   1027e:	6078      	str	r0, [r7, #4]
  osMessageQId  queue = *(osMessageQId *)queue_id;
   10280:	687b      	ldr	r3, [r7, #4]
   10282:	681b      	ldr	r3, [r3, #0]
   10284:	61fb      	str	r3, [r7, #28]
  uint8_t port;
  for (;;)
  {
#if (osCMSIS < 0x20000U)
    osEvent event = osMessageGet(queue, osWaitForever);
   10286:	240c      	movs	r4, #12
   10288:	1938      	adds	r0, r7, r4
   1028a:	2301      	movs	r3, #1
   1028c:	425a      	negs	r2, r3
   1028e:	69fb      	ldr	r3, [r7, #28]
   10290:	0019      	movs	r1, r3
   10292:	f000 fc0d 	bl	10ab0 <osMessageGet>
    port = (event.value.v >> 8);
   10296:	193b      	adds	r3, r7, r4
   10298:	685b      	ldr	r3, [r3, #4]
   1029a:	0a1a      	lsrs	r2, r3, #8
   1029c:	211b      	movs	r1, #27
   1029e:	187b      	adds	r3, r7, r1
   102a0:	701a      	strb	r2, [r3, #0]
#else
    (void)osMessageQueueGet(queue, &event, NULL, osWaitForever);
    port = (event >> 8);
#endif /* osCMSIS < 0x20000U */
#if defined(_TRACE)
    USBPD_TRACE_Add(USBPD_TRACE_DEBUG, port, ((event.value.v) & 0x00FF), (uint8_t*)"ALERT_TASK", sizeof("ALERT_TASK") - 1);
   102a2:	193b      	adds	r3, r7, r4
   102a4:	685b      	ldr	r3, [r3, #4]
   102a6:	b2da      	uxtb	r2, r3
   102a8:	480d      	ldr	r0, [pc, #52]	; (102e0 <USBPD_ALERT_Task+0x68>)
   102aa:	000d      	movs	r5, r1
   102ac:	187b      	adds	r3, r7, r1
   102ae:	7819      	ldrb	r1, [r3, #0]
   102b0:	230a      	movs	r3, #10
   102b2:	9300      	str	r3, [sp, #0]
   102b4:	0003      	movs	r3, r0
   102b6:	2006      	movs	r0, #6
   102b8:	f000 f954 	bl	10564 <USBPD_TRACE_Add>
#endif /* _TRACE */
#if (osCMSIS < 0x20000U)
    USBPD_TCPM_alert(event.value.v);
   102bc:	193b      	adds	r3, r7, r4
   102be:	685b      	ldr	r3, [r3, #4]
   102c0:	0018      	movs	r0, r3
   102c2:	f00d fe45 	bl	1df50 <USBPD_TCPM_alert>
#else
    USBPD_TCPM_alert(event);
#endif /* osCMSIS < 0x20000U */
    HAL_NVIC_EnableIRQ(ALERT_GPIO_IRQHANDLER(port));
   102c6:	0029      	movs	r1, r5
   102c8:	187b      	adds	r3, r7, r1
   102ca:	781b      	ldrb	r3, [r3, #0]
   102cc:	2b00      	cmp	r3, #0
   102ce:	d101      	bne.n	102d4 <USBPD_ALERT_Task+0x5c>
   102d0:	2307      	movs	r3, #7
   102d2:	e000      	b.n	102d6 <USBPD_ALERT_Task+0x5e>
   102d4:	2306      	movs	r3, #6
   102d6:	0018      	movs	r0, r3
   102d8:	f7fe fa6d 	bl	e7b6 <HAL_NVIC_EnableIRQ>
  {
   102dc:	e7d3      	b.n	10286 <USBPD_ALERT_Task+0xe>
   102de:	46c0      	nop			; (mov r8, r8)
   102e0:	0001f590 	.word	0x0001f590

000102e4 <USBPD_TRACE_TX_Task>:
#if (osCMSIS < 0x20000U)
void USBPD_TRACE_TX_Task(void const *argument)
#else
void USBPD_TRACE_TX_Task(void *argument)
#endif /* osCMSIS < 0x20000U */
{
   102e4:	b590      	push	{r4, r7, lr}
   102e6:	b087      	sub	sp, #28
   102e8:	af00      	add	r7, sp, #0
   102ea:	6178      	str	r0, [r7, #20]
  for (;;)
  {
#if (osCMSIS < 0x20000U)
    osMessageGet(TraceQueueId,USBPD_TRACE_TX_Process());
   102ec:	4b05      	ldr	r3, [pc, #20]	; (10304 <USBPD_TRACE_TX_Task+0x20>)
   102ee:	681c      	ldr	r4, [r3, #0]
   102f0:	f000 fa75 	bl	107de <USBPD_TRACE_TX_Process>
   102f4:	0002      	movs	r2, r0
   102f6:	003b      	movs	r3, r7
   102f8:	0021      	movs	r1, r4
   102fa:	0018      	movs	r0, r3
   102fc:	f000 fbd8 	bl	10ab0 <osMessageGet>
   10300:	e7f4      	b.n	102ec <USBPD_TRACE_TX_Task+0x8>
   10302:	46c0      	nop			; (mov r8, r8)
   10304:	000321cc 	.word	0x000321cc

00010308 <USBPD_DPM_TraceWakeUp>:
/**
  * @brief  WakeUp TRACE task
  * @retval None
  */
void USBPD_DPM_TraceWakeUp(void)
{
   10308:	b580      	push	{r7, lr}
   1030a:	af00      	add	r7, sp, #0
#ifdef _RTOS
  if (NULL != TraceQueueId)
   1030c:	4b06      	ldr	r3, [pc, #24]	; (10328 <USBPD_DPM_TraceWakeUp+0x20>)
   1030e:	681b      	ldr	r3, [r3, #0]
   10310:	2b00      	cmp	r3, #0
   10312:	d006      	beq.n	10322 <USBPD_DPM_TraceWakeUp+0x1a>
  {
#if (osCMSIS < 0x20000U)
    (void)osMessagePut(TraceQueueId, 0xFFFF, 0);
   10314:	4b04      	ldr	r3, [pc, #16]	; (10328 <USBPD_DPM_TraceWakeUp+0x20>)
   10316:	681b      	ldr	r3, [r3, #0]
   10318:	4904      	ldr	r1, [pc, #16]	; (1032c <USBPD_DPM_TraceWakeUp+0x24>)
   1031a:	2200      	movs	r2, #0
   1031c:	0018      	movs	r0, r3
   1031e:	f000 fb8b 	bl	10a38 <osMessagePut>
  UTIL_SEQ_SetTask(TASK_TRACE, 0);
#else
  DPM_Sleep_time[USBPD_PORT_COUNT + OFFSET_CAD] = 0;
#endif /* USE_STM32_UTILITY_OS */
#endif /* _RTOS */
}
   10322:	46c0      	nop			; (mov r8, r8)
   10324:	46bd      	mov	sp, r7
   10326:	bd80      	pop	{r7, pc}
   10328:	000321cc 	.word	0x000321cc
   1032c:	0000ffff 	.word	0x0000ffff

00010330 <USBPD_DPM_CADCallback>:
  }
}
#endif /* USBPD_TYPE_STATE_MACHINE */
#else
void USBPD_DPM_CADCallback(uint8_t PortNum, USBPD_CAD_EVENT State, CCxPin_TypeDef Cc)
{
   10330:	b580      	push	{r7, lr}
   10332:	b084      	sub	sp, #16
   10334:	af02      	add	r7, sp, #8
   10336:	603a      	str	r2, [r7, #0]
   10338:	1dfb      	adds	r3, r7, #7
   1033a:	1c02      	adds	r2, r0, #0
   1033c:	701a      	strb	r2, [r3, #0]
   1033e:	1dbb      	adds	r3, r7, #6
   10340:	1c0a      	adds	r2, r1, #0
   10342:	701a      	strb	r2, [r3, #0]
#ifdef _TRACE
  USBPD_TRACE_Add(USBPD_TRACE_CADEVENT, PortNum, (uint8_t)State, NULL, 0);
   10344:	1dbb      	adds	r3, r7, #6
   10346:	781a      	ldrb	r2, [r3, #0]
   10348:	1dfb      	adds	r3, r7, #7
   1034a:	7819      	ldrb	r1, [r3, #0]
   1034c:	2300      	movs	r3, #0
   1034e:	9300      	str	r3, [sp, #0]
   10350:	2300      	movs	r3, #0
   10352:	2003      	movs	r0, #3
   10354:	f000 f906 	bl	10564 <USBPD_TRACE_Add>
#endif /* _TRACE */

  switch (State)
   10358:	1dbb      	adds	r3, r7, #6
   1035a:	781b      	ldrb	r3, [r3, #0]
   1035c:	2b02      	cmp	r3, #2
   1035e:	d01b      	beq.n	10398 <USBPD_DPM_CADCallback+0x68>
   10360:	dc02      	bgt.n	10368 <USBPD_DPM_CADCallback+0x38>
   10362:	2b01      	cmp	r3, #1
   10364:	d021      	beq.n	103aa <USBPD_DPM_CADCallback+0x7a>
#endif /* _VCONN_SUPPORT */
      break;
    }
    default :
      /* nothing to do */
      break;
   10366:	e06f      	b.n	10448 <USBPD_DPM_CADCallback+0x118>
  switch (State)
   10368:	2b03      	cmp	r3, #3
   1036a:	d01e      	beq.n	103aa <USBPD_DPM_CADCallback+0x7a>
   1036c:	2b04      	cmp	r3, #4
   1036e:	d000      	beq.n	10372 <USBPD_DPM_CADCallback+0x42>
      break;
   10370:	e06a      	b.n	10448 <USBPD_DPM_CADCallback+0x118>
      DPM_Params[PortNum].VconnStatus = USBPD_TRUE;
   10372:	1dfb      	adds	r3, r7, #7
   10374:	781b      	ldrb	r3, [r3, #0]
   10376:	4a36      	ldr	r2, [pc, #216]	; (10450 <USBPD_DPM_CADCallback+0x120>)
   10378:	009b      	lsls	r3, r3, #2
   1037a:	18d3      	adds	r3, r2, r3
   1037c:	785a      	ldrb	r2, [r3, #1]
   1037e:	2180      	movs	r1, #128	; 0x80
   10380:	4249      	negs	r1, r1
   10382:	430a      	orrs	r2, r1
   10384:	705a      	strb	r2, [r3, #1]
      DPM_ManageAttachedState(PortNum, State, Cc);
   10386:	683a      	ldr	r2, [r7, #0]
   10388:	1dbb      	adds	r3, r7, #6
   1038a:	7819      	ldrb	r1, [r3, #0]
   1038c:	1dfb      	adds	r3, r7, #7
   1038e:	781b      	ldrb	r3, [r3, #0]
   10390:	0018      	movs	r0, r3
   10392:	f000 f861 	bl	10458 <DPM_ManageAttachedState>
      break;
   10396:	e057      	b.n	10448 <USBPD_DPM_CADCallback+0x118>
      DPM_ManageAttachedState(PortNum, State, Cc);
   10398:	683a      	ldr	r2, [r7, #0]
   1039a:	1dbb      	adds	r3, r7, #6
   1039c:	7819      	ldrb	r1, [r3, #0]
   1039e:	1dfb      	adds	r3, r7, #7
   103a0:	781b      	ldrb	r3, [r3, #0]
   103a2:	0018      	movs	r0, r3
   103a4:	f000 f858 	bl	10458 <DPM_ManageAttachedState>
      break;
   103a8:	e04e      	b.n	10448 <USBPD_DPM_CADCallback+0x118>
      (void)USBPD_PE_IsCableConnected(PortNum, 0);
   103aa:	1dfb      	adds	r3, r7, #7
   103ac:	781b      	ldrb	r3, [r3, #0]
   103ae:	2100      	movs	r1, #0
   103b0:	0018      	movs	r0, r3
   103b2:	f007 fb55 	bl	17a60 <USBPD_PE_IsCableConnected>
      if (DPM_PEThreadId_Table[PortNum] != NULL)
   103b6:	1dfb      	adds	r3, r7, #7
   103b8:	781a      	ldrb	r2, [r3, #0]
   103ba:	4b26      	ldr	r3, [pc, #152]	; (10454 <USBPD_DPM_CADCallback+0x124>)
   103bc:	0092      	lsls	r2, r2, #2
   103be:	58d3      	ldr	r3, [r2, r3]
   103c0:	2b00      	cmp	r3, #0
   103c2:	d00d      	beq.n	103e0 <USBPD_DPM_CADCallback+0xb0>
        osThreadTerminate(DPM_PEThreadId_Table[PortNum]);
   103c4:	1dfb      	adds	r3, r7, #7
   103c6:	781a      	ldrb	r2, [r3, #0]
   103c8:	4b22      	ldr	r3, [pc, #136]	; (10454 <USBPD_DPM_CADCallback+0x124>)
   103ca:	0092      	lsls	r2, r2, #2
   103cc:	58d3      	ldr	r3, [r2, r3]
   103ce:	0018      	movs	r0, r3
   103d0:	f000 fa64 	bl	1089c <osThreadTerminate>
        DPM_PEThreadId_Table[PortNum] = NULL;
   103d4:	1dfb      	adds	r3, r7, #7
   103d6:	781a      	ldrb	r2, [r3, #0]
   103d8:	4b1e      	ldr	r3, [pc, #120]	; (10454 <USBPD_DPM_CADCallback+0x124>)
   103da:	0092      	lsls	r2, r2, #2
   103dc:	2100      	movs	r1, #0
   103de:	50d1      	str	r1, [r2, r3]
      USBPD_DPM_UserCableDetection(PortNum, State);
   103e0:	1dbb      	adds	r3, r7, #6
   103e2:	781a      	ldrb	r2, [r3, #0]
   103e4:	1dfb      	adds	r3, r7, #7
   103e6:	781b      	ldrb	r3, [r3, #0]
   103e8:	0011      	movs	r1, r2
   103ea:	0018      	movs	r0, r3
   103ec:	f7f8 f8a4 	bl	8538 <USBPD_DPM_UserCableDetection>
      DPM_Params[PortNum].PE_SwapOngoing = USBPD_FALSE;
   103f0:	1dfb      	adds	r3, r7, #7
   103f2:	781a      	ldrb	r2, [r3, #0]
   103f4:	4b16      	ldr	r3, [pc, #88]	; (10450 <USBPD_DPM_CADCallback+0x120>)
   103f6:	0092      	lsls	r2, r2, #2
   103f8:	5cd1      	ldrb	r1, [r2, r3]
   103fa:	2010      	movs	r0, #16
   103fc:	4381      	bics	r1, r0
   103fe:	54d1      	strb	r1, [r2, r3]
      DPM_Params[PortNum].ActiveCCIs = CCNONE;
   10400:	1dfb      	adds	r3, r7, #7
   10402:	781a      	ldrb	r2, [r3, #0]
   10404:	4b12      	ldr	r3, [pc, #72]	; (10450 <USBPD_DPM_CADCallback+0x120>)
   10406:	0092      	lsls	r2, r2, #2
   10408:	5cd1      	ldrb	r1, [r2, r3]
   1040a:	203f      	movs	r0, #63	; 0x3f
   1040c:	4001      	ands	r1, r0
   1040e:	54d1      	strb	r1, [r2, r3]
      DPM_Params[PortNum].PE_Power   = USBPD_POWER_NO;
   10410:	1dfb      	adds	r3, r7, #7
   10412:	781b      	ldrb	r3, [r3, #0]
   10414:	4a0e      	ldr	r2, [pc, #56]	; (10450 <USBPD_DPM_CADCallback+0x120>)
   10416:	009b      	lsls	r3, r3, #2
   10418:	18d3      	adds	r3, r2, r3
   1041a:	785a      	ldrb	r2, [r3, #1]
   1041c:	2107      	movs	r1, #7
   1041e:	438a      	bics	r2, r1
   10420:	705a      	strb	r2, [r3, #1]
      DPM_Params[PortNum].VconnCCIs = CCNONE;
   10422:	1dfb      	adds	r3, r7, #7
   10424:	781b      	ldrb	r3, [r3, #0]
   10426:	4a0a      	ldr	r2, [pc, #40]	; (10450 <USBPD_DPM_CADCallback+0x120>)
   10428:	009b      	lsls	r3, r3, #2
   1042a:	18d3      	adds	r3, r2, r3
   1042c:	785a      	ldrb	r2, [r3, #1]
   1042e:	2160      	movs	r1, #96	; 0x60
   10430:	438a      	bics	r2, r1
   10432:	705a      	strb	r2, [r3, #1]
      DPM_Params[PortNum].VconnStatus = USBPD_FALSE;
   10434:	1dfb      	adds	r3, r7, #7
   10436:	781b      	ldrb	r3, [r3, #0]
   10438:	4a05      	ldr	r2, [pc, #20]	; (10450 <USBPD_DPM_CADCallback+0x120>)
   1043a:	009b      	lsls	r3, r3, #2
   1043c:	18d3      	adds	r3, r2, r3
   1043e:	785a      	ldrb	r2, [r3, #1]
   10440:	217f      	movs	r1, #127	; 0x7f
   10442:	400a      	ands	r2, r1
   10444:	705a      	strb	r2, [r3, #1]
      break;
   10446:	46c0      	nop			; (mov r8, r8)
  }
}
   10448:	46c0      	nop			; (mov r8, r8)
   1044a:	46bd      	mov	sp, r7
   1044c:	b002      	add	sp, #8
   1044e:	bd80      	pop	{r7, pc}
   10450:	000321d4 	.word	0x000321d4
   10454:	00030144 	.word	0x00030144

00010458 <DPM_ManageAttachedState>:

static void DPM_ManageAttachedState(uint8_t PortNum, USBPD_CAD_EVENT State, CCxPin_TypeDef Cc)
{
   10458:	b590      	push	{r4, r7, lr}
   1045a:	b083      	sub	sp, #12
   1045c:	af00      	add	r7, sp, #0
   1045e:	603a      	str	r2, [r7, #0]
   10460:	1dfb      	adds	r3, r7, #7
   10462:	1c02      	adds	r2, r0, #0
   10464:	701a      	strb	r2, [r3, #0]
   10466:	1dbb      	adds	r3, r7, #6
   10468:	1c0a      	adds	r2, r1, #0
   1046a:	701a      	strb	r2, [r3, #0]
#ifdef _VCONN_SUPPORT
  if (CC1 == Cc)
   1046c:	683b      	ldr	r3, [r7, #0]
   1046e:	2b01      	cmp	r3, #1
   10470:	d10b      	bne.n	1048a <DPM_ManageAttachedState+0x32>
  {
    DPM_Params[PortNum].VconnCCIs = CC2;
   10472:	1dfb      	adds	r3, r7, #7
   10474:	781b      	ldrb	r3, [r3, #0]
   10476:	4a30      	ldr	r2, [pc, #192]	; (10538 <DPM_ManageAttachedState+0xe0>)
   10478:	009b      	lsls	r3, r3, #2
   1047a:	18d3      	adds	r3, r2, r3
   1047c:	785a      	ldrb	r2, [r3, #1]
   1047e:	2160      	movs	r1, #96	; 0x60
   10480:	438a      	bics	r2, r1
   10482:	1c11      	adds	r1, r2, #0
   10484:	2240      	movs	r2, #64	; 0x40
   10486:	430a      	orrs	r2, r1
   10488:	705a      	strb	r2, [r3, #1]
  }
  if (CC2 == Cc)
   1048a:	683b      	ldr	r3, [r7, #0]
   1048c:	2b02      	cmp	r3, #2
   1048e:	d10b      	bne.n	104a8 <DPM_ManageAttachedState+0x50>
  {
    DPM_Params[PortNum].VconnCCIs = CC1;
   10490:	1dfb      	adds	r3, r7, #7
   10492:	781b      	ldrb	r3, [r3, #0]
   10494:	4a28      	ldr	r2, [pc, #160]	; (10538 <DPM_ManageAttachedState+0xe0>)
   10496:	009b      	lsls	r3, r3, #2
   10498:	18d3      	adds	r3, r2, r3
   1049a:	785a      	ldrb	r2, [r3, #1]
   1049c:	2160      	movs	r1, #96	; 0x60
   1049e:	438a      	bics	r2, r1
   104a0:	1c11      	adds	r1, r2, #0
   104a2:	2220      	movs	r2, #32
   104a4:	430a      	orrs	r2, r1
   104a6:	705a      	strb	r2, [r3, #1]
  }
#endif /* _VCONN_SUPPORT */
  DPM_Params[PortNum].ActiveCCIs = Cc;
   104a8:	1dfb      	adds	r3, r7, #7
   104aa:	781a      	ldrb	r2, [r3, #0]
   104ac:	683b      	ldr	r3, [r7, #0]
   104ae:	1c19      	adds	r1, r3, #0
   104b0:	2303      	movs	r3, #3
   104b2:	400b      	ands	r3, r1
   104b4:	b2d9      	uxtb	r1, r3
   104b6:	4b20      	ldr	r3, [pc, #128]	; (10538 <DPM_ManageAttachedState+0xe0>)
   104b8:	0092      	lsls	r2, r2, #2
   104ba:	018c      	lsls	r4, r1, #6
   104bc:	5cd1      	ldrb	r1, [r2, r3]
   104be:	203f      	movs	r0, #63	; 0x3f
   104c0:	4001      	ands	r1, r0
   104c2:	1c08      	adds	r0, r1, #0
   104c4:	1c21      	adds	r1, r4, #0
   104c6:	4301      	orrs	r1, r0
   104c8:	54d1      	strb	r1, [r2, r3]
  (void)USBPD_PE_IsCableConnected(PortNum, 1);
   104ca:	1dfb      	adds	r3, r7, #7
   104cc:	781b      	ldrb	r3, [r3, #0]
   104ce:	2101      	movs	r1, #1
   104d0:	0018      	movs	r0, r3
   104d2:	f007 fac5 	bl	17a60 <USBPD_PE_IsCableConnected>

  USBPD_DPM_UserCableDetection(PortNum, State);
   104d6:	1dbb      	adds	r3, r7, #6
   104d8:	781a      	ldrb	r2, [r3, #0]
   104da:	1dfb      	adds	r3, r7, #7
   104dc:	781b      	ldrb	r3, [r3, #0]
   104de:	0011      	movs	r1, r2
   104e0:	0018      	movs	r0, r3
   104e2:	f7f8 f829 	bl	8538 <USBPD_DPM_UserCableDetection>
#if defined(USBPD_TCPM_MODULE_ENABLED)
  /* Add a delay to postpone the 1st send of SRC capa
  FUS305 seems not react correctly if it sent too quickly */
  USBPD_DPM_WaitForTime(6);
   104e6:	2006      	movs	r0, #6
   104e8:	f7f7 fff8 	bl	84dc <USBPD_DPM_WaitForTime>
#endif /* USBPD_TCPM_MODULE_ENABLED */

#ifdef _RTOS
  /* Create PE task */
  if (DPM_PEThreadId_Table[PortNum] == NULL)
   104ec:	1dfb      	adds	r3, r7, #7
   104ee:	781a      	ldrb	r2, [r3, #0]
   104f0:	4b12      	ldr	r3, [pc, #72]	; (1053c <DPM_ManageAttachedState+0xe4>)
   104f2:	0092      	lsls	r2, r2, #2
   104f4:	58d3      	ldr	r3, [r2, r3]
   104f6:	2b00      	cmp	r3, #0
   104f8:	d11a      	bne.n	10530 <DPM_ManageAttachedState+0xd8>
  {
#if (osCMSIS < 0x20000U)
    DPM_PEThreadId_Table[PortNum] = osThreadCreate(OSTHREAD_PE(PortNum), (void *)((uint32_t)PortNum));
   104fa:	1dfb      	adds	r3, r7, #7
   104fc:	781b      	ldrb	r3, [r3, #0]
   104fe:	2b00      	cmp	r3, #0
   10500:	d101      	bne.n	10506 <DPM_ManageAttachedState+0xae>
   10502:	4b0f      	ldr	r3, [pc, #60]	; (10540 <DPM_ManageAttachedState+0xe8>)
   10504:	e000      	b.n	10508 <DPM_ManageAttachedState+0xb0>
   10506:	4b0f      	ldr	r3, [pc, #60]	; (10544 <DPM_ManageAttachedState+0xec>)
   10508:	1dfa      	adds	r2, r7, #7
   1050a:	7812      	ldrb	r2, [r2, #0]
   1050c:	0011      	movs	r1, r2
   1050e:	1dfa      	adds	r2, r7, #7
   10510:	7814      	ldrb	r4, [r2, #0]
   10512:	0018      	movs	r0, r3
   10514:	f000 f99a 	bl	1084c <osThreadCreate>
   10518:	0001      	movs	r1, r0
   1051a:	4b08      	ldr	r3, [pc, #32]	; (1053c <DPM_ManageAttachedState+0xe4>)
   1051c:	00a2      	lsls	r2, r4, #2
   1051e:	50d1      	str	r1, [r2, r3]
#else
    DPM_PEThreadId_Table[PortNum] = osThreadNew(OSTHREAD_PE(PortNum), NULL, OSTHREAD_PE_ATTR(PortNum));
#endif /* osCMSIS < 0x20000U */
    if (DPM_PEThreadId_Table[PortNum] == NULL)
   10520:	1dfb      	adds	r3, r7, #7
   10522:	781a      	ldrb	r2, [r3, #0]
   10524:	4b05      	ldr	r3, [pc, #20]	; (1053c <DPM_ManageAttachedState+0xe4>)
   10526:	0092      	lsls	r2, r2, #2
   10528:	58d3      	ldr	r3, [r2, r3]
   1052a:	2b00      	cmp	r3, #0
   1052c:	d100      	bne.n	10530 <DPM_ManageAttachedState+0xd8>
    {
      /* should not occurr. May be an issue with FreeRTOS heap size too small */
      while (1);
   1052e:	e7fe      	b.n	1052e <DPM_ManageAttachedState+0xd6>
   UTIL_SEQ_SetTask(PortNum == 0? TASK_PE_0: TASK_PE_1, 0);
#else
   DPM_Sleep_time[PortNum] = 0U;
#endif /* USE_STM32_UTILITY_OS */
#endif /* _RTOS */
}
   10530:	46c0      	nop			; (mov r8, r8)
   10532:	46bd      	mov	sp, r7
   10534:	b003      	add	sp, #12
   10536:	bd90      	pop	{r4, r7, pc}
   10538:	000321d4 	.word	0x000321d4
   1053c:	00030144 	.word	0x00030144
   10540:	0001f59c 	.word	0x0001f59c
   10544:	0001f5b0 	.word	0x0001f5b0

00010548 <USBPD_TRACE_Init>:

/** @addtogroup USBPD_CORE_TRACE_Exported_Functions
  * @{
  */
void USBPD_TRACE_Init(void)
{
   10548:	b580      	push	{r7, lr}
   1054a:	af00      	add	r7, sp, #0
#if defined(_TRACE)
  /* initialize tracer module */
  TRACER_EMB_Init();
   1054c:	f006 fc40 	bl	16dd0 <TRACER_EMB_Init>

  /* Initialize PE trace */
  USBPD_PE_SetTrace(USBPD_TRACE_Add, 3u);
   10550:	4b03      	ldr	r3, [pc, #12]	; (10560 <USBPD_TRACE_Init+0x18>)
   10552:	2103      	movs	r1, #3
   10554:	0018      	movs	r0, r3
   10556:	f007 f9d7 	bl	17908 <USBPD_PE_SetTrace>
#else
  return;
#endif  
}
   1055a:	46c0      	nop			; (mov r8, r8)
   1055c:	46bd      	mov	sp, r7
   1055e:	bd80      	pop	{r7, pc}
   10560:	00010565 	.word	0x00010565

00010564 <USBPD_TRACE_Add>:
  /* Nothing to do */
  return;
}

void USBPD_TRACE_Add(TRACE_EVENT Type, uint8_t PortNum, uint8_t Sop, uint8_t *Ptr, uint32_t Size)
{
   10564:	b590      	push	{r4, r7, lr}
   10566:	b08b      	sub	sp, #44	; 0x2c
   10568:	af00      	add	r7, sp, #0
   1056a:	0004      	movs	r4, r0
   1056c:	0008      	movs	r0, r1
   1056e:	0011      	movs	r1, r2
   10570:	603b      	str	r3, [r7, #0]
   10572:	1dfb      	adds	r3, r7, #7
   10574:	1c22      	adds	r2, r4, #0
   10576:	701a      	strb	r2, [r3, #0]
   10578:	1dbb      	adds	r3, r7, #6
   1057a:	1c02      	adds	r2, r0, #0
   1057c:	701a      	strb	r2, [r3, #0]
   1057e:	1d7b      	adds	r3, r7, #5
   10580:	1c0a      	adds	r2, r1, #0
   10582:	701a      	strb	r2, [r3, #0]
  uint16_t _writepos2;
  uint8_t *data_to_write;
  uint32_t index;
  uint32_t total_size;

  TRACER_EMB_Lock();
   10584:	f006 fcd0 	bl	16f28 <TRACER_EMB_Lock>

  /* Data are encapsulate inside a TLV string*/
  /* Allocate buffer Size */
  total_size = Size + TRACE_SIZE_HEADER_TRACE + TLV_HEADER_SIZE + TLV_SOF_SIZE + TLV_EOF_SIZE;
   10588:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1058a:	3314      	adds	r3, #20
   1058c:	61fb      	str	r3, [r7, #28]
  _writepos = TRACER_EMB_AllocateBufer(total_size);
   1058e:	69fb      	ldr	r3, [r7, #28]
   10590:	0018      	movs	r0, r3
   10592:	f006 fd2f 	bl	16ff4 <TRACER_EMB_AllocateBufer>
   10596:	0003      	movs	r3, r0
   10598:	61bb      	str	r3, [r7, #24]

  /* Check allocation */
  if (_writepos  != -1)
   1059a:	69bb      	ldr	r3, [r7, #24]
   1059c:	3301      	adds	r3, #1
   1059e:	d100      	bne.n	105a2 <USBPD_TRACE_Add+0x3e>
   105a0:	e10f      	b.n	107c2 <USBPD_TRACE_Add+0x25e>
  {
    _writepos2 = (uint16_t)_writepos;
   105a2:	2326      	movs	r3, #38	; 0x26
   105a4:	18fb      	adds	r3, r7, r3
   105a6:	69ba      	ldr	r2, [r7, #24]
   105a8:	801a      	strh	r2, [r3, #0]
    data_to_write = Ptr;
   105aa:	683b      	ldr	r3, [r7, #0]
   105ac:	617b      	str	r3, [r7, #20]

    /* Copy SOF bytes */
    for (index = 0u; index < TLV_SOF_SIZE; index++)
   105ae:	2300      	movs	r3, #0
   105b0:	623b      	str	r3, [r7, #32]
   105b2:	e00e      	b.n	105d2 <USBPD_TRACE_Add+0x6e>
    {
      TRACER_EMB_WRITE_DATA(_writepos2, TLV_SOF);
   105b4:	2426      	movs	r4, #38	; 0x26
   105b6:	193b      	adds	r3, r7, r4
   105b8:	881b      	ldrh	r3, [r3, #0]
   105ba:	21fd      	movs	r1, #253	; 0xfd
   105bc:	0018      	movs	r0, r3
   105be:	f006 fc8d 	bl	16edc <TRACER_EMB_WriteData>
   105c2:	193b      	adds	r3, r7, r4
   105c4:	193a      	adds	r2, r7, r4
   105c6:	8812      	ldrh	r2, [r2, #0]
   105c8:	3201      	adds	r2, #1
   105ca:	801a      	strh	r2, [r3, #0]
    for (index = 0u; index < TLV_SOF_SIZE; index++)
   105cc:	6a3b      	ldr	r3, [r7, #32]
   105ce:	3301      	adds	r3, #1
   105d0:	623b      	str	r3, [r7, #32]
   105d2:	6a3b      	ldr	r3, [r7, #32]
   105d4:	2b03      	cmp	r3, #3
   105d6:	d9ed      	bls.n	105b4 <USBPD_TRACE_Add+0x50>
    }
    /* Copy the TAG */
    TRACER_EMB_WRITE_DATA(_writepos2, __TRACE_SET_TAG_ID((PortNum + 1u), DEBUG_STACK_MESSAGE));
   105d8:	1dbb      	adds	r3, r7, #6
   105da:	781b      	ldrb	r3, [r3, #0]
   105dc:	3301      	adds	r3, #1
   105de:	b2db      	uxtb	r3, r3
   105e0:	015b      	lsls	r3, r3, #5
   105e2:	b2db      	uxtb	r3, r3
   105e4:	2212      	movs	r2, #18
   105e6:	4313      	orrs	r3, r2
   105e8:	b2da      	uxtb	r2, r3
   105ea:	2126      	movs	r1, #38	; 0x26
   105ec:	000c      	movs	r4, r1
   105ee:	187b      	adds	r3, r7, r1
   105f0:	881b      	ldrh	r3, [r3, #0]
   105f2:	0011      	movs	r1, r2
   105f4:	0018      	movs	r0, r3
   105f6:	f006 fc71 	bl	16edc <TRACER_EMB_WriteData>
   105fa:	0021      	movs	r1, r4
   105fc:	187b      	adds	r3, r7, r1
   105fe:	187a      	adds	r2, r7, r1
   10600:	8812      	ldrh	r2, [r2, #0]
   10602:	3201      	adds	r2, #1
   10604:	801a      	strh	r2, [r3, #0]
    /* Copy the LENGTH */
    TRACER_EMB_WRITE_DATA(_writepos2, (uint8_t)((total_size - TLV_HEADER_SIZE - TLV_SOF_SIZE - TLV_EOF_SIZE) >> 8u));
   10606:	69fb      	ldr	r3, [r7, #28]
   10608:	3b0b      	subs	r3, #11
   1060a:	0a1b      	lsrs	r3, r3, #8
   1060c:	b2da      	uxtb	r2, r3
   1060e:	000c      	movs	r4, r1
   10610:	187b      	adds	r3, r7, r1
   10612:	881b      	ldrh	r3, [r3, #0]
   10614:	0011      	movs	r1, r2
   10616:	0018      	movs	r0, r3
   10618:	f006 fc60 	bl	16edc <TRACER_EMB_WriteData>
   1061c:	0021      	movs	r1, r4
   1061e:	187b      	adds	r3, r7, r1
   10620:	187a      	adds	r2, r7, r1
   10622:	8812      	ldrh	r2, [r2, #0]
   10624:	3201      	adds	r2, #1
   10626:	801a      	strh	r2, [r3, #0]
    TRACER_EMB_WRITE_DATA(_writepos2, (uint8_t)(total_size - TLV_HEADER_SIZE - TLV_SOF_SIZE - TLV_EOF_SIZE));
   10628:	69fb      	ldr	r3, [r7, #28]
   1062a:	b2db      	uxtb	r3, r3
   1062c:	3b0b      	subs	r3, #11
   1062e:	b2da      	uxtb	r2, r3
   10630:	000c      	movs	r4, r1
   10632:	187b      	adds	r3, r7, r1
   10634:	881b      	ldrh	r3, [r3, #0]
   10636:	0011      	movs	r1, r2
   10638:	0018      	movs	r0, r3
   1063a:	f006 fc4f 	bl	16edc <TRACER_EMB_WriteData>
   1063e:	0021      	movs	r1, r4
   10640:	187b      	adds	r3, r7, r1
   10642:	187a      	adds	r2, r7, r1
   10644:	8812      	ldrh	r2, [r2, #0]
   10646:	3201      	adds	r2, #1
   10648:	801a      	strh	r2, [r3, #0]
    TRACER_EMB_WRITE_DATA(_writepos2, (uint8_t)Type);
   1064a:	1dfb      	adds	r3, r7, #7
   1064c:	781a      	ldrb	r2, [r3, #0]
   1064e:	000c      	movs	r4, r1
   10650:	193b      	adds	r3, r7, r4
   10652:	881b      	ldrh	r3, [r3, #0]
   10654:	0011      	movs	r1, r2
   10656:	0018      	movs	r0, r3
   10658:	f006 fc40 	bl	16edc <TRACER_EMB_WriteData>
   1065c:	193b      	adds	r3, r7, r4
   1065e:	193a      	adds	r2, r7, r4
   10660:	8812      	ldrh	r2, [r2, #0]
   10662:	3201      	adds	r2, #1
   10664:	801a      	strh	r2, [r3, #0]

    _time = HAL_GetTick();
   10666:	f7fd ffad 	bl	e5c4 <HAL_GetTick>
   1066a:	0003      	movs	r3, r0
   1066c:	613b      	str	r3, [r7, #16]

    TRACER_EMB_WRITE_DATA(_writepos2, (uint8_t)_time);
   1066e:	693b      	ldr	r3, [r7, #16]
   10670:	b2da      	uxtb	r2, r3
   10672:	193b      	adds	r3, r7, r4
   10674:	881b      	ldrh	r3, [r3, #0]
   10676:	0011      	movs	r1, r2
   10678:	0018      	movs	r0, r3
   1067a:	f006 fc2f 	bl	16edc <TRACER_EMB_WriteData>
   1067e:	193b      	adds	r3, r7, r4
   10680:	0021      	movs	r1, r4
   10682:	193a      	adds	r2, r7, r4
   10684:	8812      	ldrh	r2, [r2, #0]
   10686:	3201      	adds	r2, #1
   10688:	801a      	strh	r2, [r3, #0]
    TRACER_EMB_WRITE_DATA(_writepos2, (uint8_t)(_time >> 8u));
   1068a:	693b      	ldr	r3, [r7, #16]
   1068c:	0a1b      	lsrs	r3, r3, #8
   1068e:	b2da      	uxtb	r2, r3
   10690:	000c      	movs	r4, r1
   10692:	187b      	adds	r3, r7, r1
   10694:	881b      	ldrh	r3, [r3, #0]
   10696:	0011      	movs	r1, r2
   10698:	0018      	movs	r0, r3
   1069a:	f006 fc1f 	bl	16edc <TRACER_EMB_WriteData>
   1069e:	0021      	movs	r1, r4
   106a0:	187b      	adds	r3, r7, r1
   106a2:	187a      	adds	r2, r7, r1
   106a4:	8812      	ldrh	r2, [r2, #0]
   106a6:	3201      	adds	r2, #1
   106a8:	801a      	strh	r2, [r3, #0]
    TRACER_EMB_WRITE_DATA(_writepos2, (uint8_t)(_time >> 16u));
   106aa:	693b      	ldr	r3, [r7, #16]
   106ac:	0c1b      	lsrs	r3, r3, #16
   106ae:	b2da      	uxtb	r2, r3
   106b0:	000c      	movs	r4, r1
   106b2:	187b      	adds	r3, r7, r1
   106b4:	881b      	ldrh	r3, [r3, #0]
   106b6:	0011      	movs	r1, r2
   106b8:	0018      	movs	r0, r3
   106ba:	f006 fc0f 	bl	16edc <TRACER_EMB_WriteData>
   106be:	0021      	movs	r1, r4
   106c0:	187b      	adds	r3, r7, r1
   106c2:	187a      	adds	r2, r7, r1
   106c4:	8812      	ldrh	r2, [r2, #0]
   106c6:	3201      	adds	r2, #1
   106c8:	801a      	strh	r2, [r3, #0]
    TRACER_EMB_WRITE_DATA(_writepos2, (uint8_t)(_time >> 24u));
   106ca:	693b      	ldr	r3, [r7, #16]
   106cc:	0e1b      	lsrs	r3, r3, #24
   106ce:	b2da      	uxtb	r2, r3
   106d0:	000c      	movs	r4, r1
   106d2:	187b      	adds	r3, r7, r1
   106d4:	881b      	ldrh	r3, [r3, #0]
   106d6:	0011      	movs	r1, r2
   106d8:	0018      	movs	r0, r3
   106da:	f006 fbff 	bl	16edc <TRACER_EMB_WriteData>
   106de:	0021      	movs	r1, r4
   106e0:	187b      	adds	r3, r7, r1
   106e2:	187a      	adds	r2, r7, r1
   106e4:	8812      	ldrh	r2, [r2, #0]
   106e6:	3201      	adds	r2, #1
   106e8:	801a      	strh	r2, [r3, #0]

    TRACER_EMB_WRITE_DATA(_writepos2, PortNum);
   106ea:	1dbb      	adds	r3, r7, #6
   106ec:	781a      	ldrb	r2, [r3, #0]
   106ee:	000c      	movs	r4, r1
   106f0:	187b      	adds	r3, r7, r1
   106f2:	881b      	ldrh	r3, [r3, #0]
   106f4:	0011      	movs	r1, r2
   106f6:	0018      	movs	r0, r3
   106f8:	f006 fbf0 	bl	16edc <TRACER_EMB_WriteData>
   106fc:	0021      	movs	r1, r4
   106fe:	187b      	adds	r3, r7, r1
   10700:	187a      	adds	r2, r7, r1
   10702:	8812      	ldrh	r2, [r2, #0]
   10704:	3201      	adds	r2, #1
   10706:	801a      	strh	r2, [r3, #0]
    TRACER_EMB_WRITE_DATA(_writepos2, Sop);
   10708:	1d7b      	adds	r3, r7, #5
   1070a:	781a      	ldrb	r2, [r3, #0]
   1070c:	000c      	movs	r4, r1
   1070e:	187b      	adds	r3, r7, r1
   10710:	881b      	ldrh	r3, [r3, #0]
   10712:	0011      	movs	r1, r2
   10714:	0018      	movs	r0, r3
   10716:	f006 fbe1 	bl	16edc <TRACER_EMB_WriteData>
   1071a:	0021      	movs	r1, r4
   1071c:	187b      	adds	r3, r7, r1
   1071e:	187a      	adds	r2, r7, r1
   10720:	8812      	ldrh	r2, [r2, #0]
   10722:	3201      	adds	r2, #1
   10724:	801a      	strh	r2, [r3, #0]

    TRACER_EMB_WRITE_DATA(_writepos2, (uint8_t)(Size >> 8u));
   10726:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   10728:	0a1b      	lsrs	r3, r3, #8
   1072a:	b2da      	uxtb	r2, r3
   1072c:	000c      	movs	r4, r1
   1072e:	187b      	adds	r3, r7, r1
   10730:	881b      	ldrh	r3, [r3, #0]
   10732:	0011      	movs	r1, r2
   10734:	0018      	movs	r0, r3
   10736:	f006 fbd1 	bl	16edc <TRACER_EMB_WriteData>
   1073a:	0021      	movs	r1, r4
   1073c:	187b      	adds	r3, r7, r1
   1073e:	187a      	adds	r2, r7, r1
   10740:	8812      	ldrh	r2, [r2, #0]
   10742:	3201      	adds	r2, #1
   10744:	801a      	strh	r2, [r3, #0]
    TRACER_EMB_WRITE_DATA(_writepos2, (uint8_t)Size);
   10746:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   10748:	b2da      	uxtb	r2, r3
   1074a:	000c      	movs	r4, r1
   1074c:	187b      	adds	r3, r7, r1
   1074e:	881b      	ldrh	r3, [r3, #0]
   10750:	0011      	movs	r1, r2
   10752:	0018      	movs	r0, r3
   10754:	f006 fbc2 	bl	16edc <TRACER_EMB_WriteData>
   10758:	0021      	movs	r1, r4
   1075a:	187b      	adds	r3, r7, r1
   1075c:	187a      	adds	r2, r7, r1
   1075e:	8812      	ldrh	r2, [r2, #0]
   10760:	3201      	adds	r2, #1
   10762:	801a      	strh	r2, [r3, #0]

    /* initialize the Ptr for Read/Write */
    for (index = 0u; index < Size; index++)
   10764:	2300      	movs	r3, #0
   10766:	623b      	str	r3, [r7, #32]
   10768:	e012      	b.n	10790 <USBPD_TRACE_Add+0x22c>
    {
      TRACER_EMB_WRITE_DATA(_writepos2, data_to_write[index]);
   1076a:	697a      	ldr	r2, [r7, #20]
   1076c:	6a3b      	ldr	r3, [r7, #32]
   1076e:	18d3      	adds	r3, r2, r3
   10770:	781a      	ldrb	r2, [r3, #0]
   10772:	2426      	movs	r4, #38	; 0x26
   10774:	193b      	adds	r3, r7, r4
   10776:	881b      	ldrh	r3, [r3, #0]
   10778:	0011      	movs	r1, r2
   1077a:	0018      	movs	r0, r3
   1077c:	f006 fbae 	bl	16edc <TRACER_EMB_WriteData>
   10780:	193b      	adds	r3, r7, r4
   10782:	193a      	adds	r2, r7, r4
   10784:	8812      	ldrh	r2, [r2, #0]
   10786:	3201      	adds	r2, #1
   10788:	801a      	strh	r2, [r3, #0]
    for (index = 0u; index < Size; index++)
   1078a:	6a3b      	ldr	r3, [r7, #32]
   1078c:	3301      	adds	r3, #1
   1078e:	623b      	str	r3, [r7, #32]
   10790:	6a3a      	ldr	r2, [r7, #32]
   10792:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   10794:	429a      	cmp	r2, r3
   10796:	d3e8      	bcc.n	1076a <USBPD_TRACE_Add+0x206>
    }

    /* Copy EOF bytes */
    for (index = 0u; index < TLV_EOF_SIZE; index++)
   10798:	2300      	movs	r3, #0
   1079a:	623b      	str	r3, [r7, #32]
   1079c:	e00e      	b.n	107bc <USBPD_TRACE_Add+0x258>
    {
      TRACER_EMB_WRITE_DATA(_writepos2, TLV_EOF);
   1079e:	2426      	movs	r4, #38	; 0x26
   107a0:	193b      	adds	r3, r7, r4
   107a2:	881b      	ldrh	r3, [r3, #0]
   107a4:	21a5      	movs	r1, #165	; 0xa5
   107a6:	0018      	movs	r0, r3
   107a8:	f006 fb98 	bl	16edc <TRACER_EMB_WriteData>
   107ac:	193b      	adds	r3, r7, r4
   107ae:	193a      	adds	r2, r7, r4
   107b0:	8812      	ldrh	r2, [r2, #0]
   107b2:	3201      	adds	r2, #1
   107b4:	801a      	strh	r2, [r3, #0]
    for (index = 0u; index < TLV_EOF_SIZE; index++)
   107b6:	6a3b      	ldr	r3, [r7, #32]
   107b8:	3301      	adds	r3, #1
   107ba:	623b      	str	r3, [r7, #32]
   107bc:	6a3b      	ldr	r3, [r7, #32]
   107be:	2b03      	cmp	r3, #3
   107c0:	d9ed      	bls.n	1079e <USBPD_TRACE_Add+0x23a>
    }
  }

  TRACER_EMB_UnLock();
   107c2:	f006 fbcb 	bl	16f5c <TRACER_EMB_UnLock>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   107c6:	f3ef 8305 	mrs	r3, IPSR
   107ca:	60fb      	str	r3, [r7, #12]
  return(result);
   107cc:	68fb      	ldr	r3, [r7, #12]
  
  if (__get_IPSR() == 0 )
   107ce:	2b00      	cmp	r3, #0
   107d0:	d101      	bne.n	107d6 <USBPD_TRACE_Add+0x272>
  {
    /* Wakeup the trace system, only for trace outside interrupt context */
    USBPD_DPM_TraceWakeUp();
   107d2:	f7ff fd99 	bl	10308 <USBPD_DPM_TraceWakeUp>
  }
#else
  return;
#endif  
}
   107d6:	46c0      	nop			; (mov r8, r8)
   107d8:	46bd      	mov	sp, r7
   107da:	b00b      	add	sp, #44	; 0x2c
   107dc:	bd90      	pop	{r4, r7, pc}

000107de <USBPD_TRACE_TX_Process>:

uint32_t USBPD_TRACE_TX_Process(void)
{
   107de:	b580      	push	{r7, lr}
   107e0:	af00      	add	r7, sp, #0
#ifdef _TRACE  
  return TRACER_EMB_TX_Process();
   107e2:	f006 fb3f 	bl	16e64 <TRACER_EMB_TX_Process>
   107e6:	0003      	movs	r3, r0
#else
  return 0xFFFFFFFF;
#endif  
}
   107e8:	0018      	movs	r0, r3
   107ea:	46bd      	mov	sp, r7
   107ec:	bd80      	pop	{r7, pc}

000107ee <makeFreeRtosPriority>:

extern void xPortSysTickHandler(void);

/* Convert from CMSIS type osPriority to FreeRTOS priority number */
static unsigned portBASE_TYPE makeFreeRtosPriority (osPriority priority)
{
   107ee:	b580      	push	{r7, lr}
   107f0:	b084      	sub	sp, #16
   107f2:	af00      	add	r7, sp, #0
   107f4:	0002      	movs	r2, r0
   107f6:	1dbb      	adds	r3, r7, #6
   107f8:	801a      	strh	r2, [r3, #0]
  unsigned portBASE_TYPE fpriority = tskIDLE_PRIORITY;
   107fa:	2300      	movs	r3, #0
   107fc:	60fb      	str	r3, [r7, #12]
  
  if (priority != osPriorityError) {
   107fe:	1dbb      	adds	r3, r7, #6
   10800:	2200      	movs	r2, #0
   10802:	5e9b      	ldrsh	r3, [r3, r2]
   10804:	2b84      	cmp	r3, #132	; 0x84
   10806:	d006      	beq.n	10816 <makeFreeRtosPriority+0x28>
    fpriority += (priority - osPriorityIdle);
   10808:	1dbb      	adds	r3, r7, #6
   1080a:	2200      	movs	r2, #0
   1080c:	5e9a      	ldrsh	r2, [r3, r2]
   1080e:	68fb      	ldr	r3, [r7, #12]
   10810:	18d3      	adds	r3, r2, r3
   10812:	3303      	adds	r3, #3
   10814:	60fb      	str	r3, [r7, #12]
  }
  
  return fpriority;
   10816:	68fb      	ldr	r3, [r7, #12]
}
   10818:	0018      	movs	r0, r3
   1081a:	46bd      	mov	sp, r7
   1081c:	b004      	add	sp, #16
   1081e:	bd80      	pop	{r7, pc}

00010820 <inHandlerMode>:
#endif


/* Determine whether we are in thread mode or handler mode. */
static int inHandlerMode (void)
{
   10820:	b580      	push	{r7, lr}
   10822:	b082      	sub	sp, #8
   10824:	af00      	add	r7, sp, #0
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   10826:	f3ef 8305 	mrs	r3, IPSR
   1082a:	607b      	str	r3, [r7, #4]
  return(result);
   1082c:	687b      	ldr	r3, [r7, #4]
  return __get_IPSR() != 0;
   1082e:	1e5a      	subs	r2, r3, #1
   10830:	4193      	sbcs	r3, r2
   10832:	b2db      	uxtb	r3, r3
}
   10834:	0018      	movs	r0, r3
   10836:	46bd      	mov	sp, r7
   10838:	b002      	add	sp, #8
   1083a:	bd80      	pop	{r7, pc}

0001083c <osKernelStart>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval status code that indicates the execution status of the function
* @note   MUST REMAIN UNCHANGED: \b osKernelStart shall be consistent in every CMSIS-RTOS.
*/
osStatus osKernelStart (void)
{
   1083c:	b580      	push	{r7, lr}
   1083e:	af00      	add	r7, sp, #0
  vTaskStartScheduler();
   10840:	f001 f8e2 	bl	11a08 <vTaskStartScheduler>
  
  return osOK;
   10844:	2300      	movs	r3, #0
}
   10846:	0018      	movs	r0, r3
   10848:	46bd      	mov	sp, r7
   1084a:	bd80      	pop	{r7, pc}

0001084c <osThreadCreate>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval thread ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osThreadCreate shall be consistent in every CMSIS-RTOS.
*/
osThreadId osThreadCreate (const osThreadDef_t *thread_def, void *argument)
{
   1084c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1084e:	b087      	sub	sp, #28
   10850:	af02      	add	r7, sp, #8
   10852:	6078      	str	r0, [r7, #4]
   10854:	6039      	str	r1, [r7, #0]

    handle = xTaskCreateStatic((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
              thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
              thread_def->buffer, thread_def->controlblock);
#else
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
   10856:	687b      	ldr	r3, [r7, #4]
   10858:	685c      	ldr	r4, [r3, #4]
   1085a:	687b      	ldr	r3, [r7, #4]
   1085c:	681d      	ldr	r5, [r3, #0]
                   thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
   1085e:	687b      	ldr	r3, [r7, #4]
   10860:	691b      	ldr	r3, [r3, #16]
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
   10862:	b29e      	uxth	r6, r3
   10864:	687b      	ldr	r3, [r7, #4]
   10866:	2208      	movs	r2, #8
   10868:	5e9b      	ldrsh	r3, [r3, r2]
   1086a:	0018      	movs	r0, r3
   1086c:	f7ff ffbf 	bl	107ee <makeFreeRtosPriority>
   10870:	0001      	movs	r1, r0
   10872:	683a      	ldr	r2, [r7, #0]
   10874:	230c      	movs	r3, #12
   10876:	18fb      	adds	r3, r7, r3
   10878:	9301      	str	r3, [sp, #4]
   1087a:	9100      	str	r1, [sp, #0]
   1087c:	0013      	movs	r3, r2
   1087e:	0032      	movs	r2, r6
   10880:	0029      	movs	r1, r5
   10882:	0020      	movs	r0, r4
   10884:	f000 ff15 	bl	116b2 <xTaskCreate>
   10888:	0003      	movs	r3, r0
   1088a:	2b01      	cmp	r3, #1
   1088c:	d001      	beq.n	10892 <osThreadCreate+0x46>
                   &handle) != pdPASS)  {
    return NULL;
   1088e:	2300      	movs	r3, #0
   10890:	e000      	b.n	10894 <osThreadCreate+0x48>
  }     
#endif
  
  return handle;
   10892:	68fb      	ldr	r3, [r7, #12]
}
   10894:	0018      	movs	r0, r3
   10896:	46bd      	mov	sp, r7
   10898:	b005      	add	sp, #20
   1089a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0001089c <osThreadTerminate>:
* @param   thread_id   thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
* @retval  status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osThreadTerminate shall be consistent in every CMSIS-RTOS.
*/
osStatus osThreadTerminate (osThreadId thread_id)
{
   1089c:	b580      	push	{r7, lr}
   1089e:	b082      	sub	sp, #8
   108a0:	af00      	add	r7, sp, #0
   108a2:	6078      	str	r0, [r7, #4]
#if (INCLUDE_vTaskDelete == 1)
  vTaskDelete(thread_id);
   108a4:	687b      	ldr	r3, [r7, #4]
   108a6:	0018      	movs	r0, r3
   108a8:	f001 f824 	bl	118f4 <vTaskDelete>
  return osOK;
   108ac:	2300      	movs	r3, #0
#else
  return osErrorOS;
#endif
}
   108ae:	0018      	movs	r0, r3
   108b0:	46bd      	mov	sp, r7
   108b2:	b002      	add	sp, #8
   108b4:	bd80      	pop	{r7, pc}

000108b6 <osDelay>:
* @brief   Wait for Timeout (Time Delay)
* @param   millisec      time delay value
* @retval  status code that indicates the execution status of the function.
*/
osStatus osDelay (uint32_t millisec)
{
   108b6:	b580      	push	{r7, lr}
   108b8:	b084      	sub	sp, #16
   108ba:	af00      	add	r7, sp, #0
   108bc:	6078      	str	r0, [r7, #4]
#if INCLUDE_vTaskDelay
  TickType_t ticks = millisec / portTICK_PERIOD_MS;
   108be:	687b      	ldr	r3, [r7, #4]
   108c0:	60fb      	str	r3, [r7, #12]
  
  vTaskDelay(ticks ? ticks : 1);          /* Minimum delay = 1 tick */
   108c2:	68fb      	ldr	r3, [r7, #12]
   108c4:	2b00      	cmp	r3, #0
   108c6:	d001      	beq.n	108cc <osDelay+0x16>
   108c8:	68fb      	ldr	r3, [r7, #12]
   108ca:	e000      	b.n	108ce <osDelay+0x18>
   108cc:	2301      	movs	r3, #1
   108ce:	0018      	movs	r0, r3
   108d0:	f001 f874 	bl	119bc <vTaskDelay>
  
  return osOK;
   108d4:	2300      	movs	r3, #0
#else
  (void) millisec;
  
  return osErrorResource;
#endif
}
   108d6:	0018      	movs	r0, r3
   108d8:	46bd      	mov	sp, r7
   108da:	b004      	add	sp, #16
   108dc:	bd80      	pop	{r7, pc}

000108de <osSemaphoreCreate>:
* @param count         number of available resources.
* @retval  semaphore ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osSemaphoreCreate shall be consistent in every CMSIS-RTOS.
*/
osSemaphoreId osSemaphoreCreate (const osSemaphoreDef_t *semaphore_def, int32_t count)
{ 
   108de:	b580      	push	{r7, lr}
   108e0:	b084      	sub	sp, #16
   108e2:	af00      	add	r7, sp, #0
   108e4:	6078      	str	r0, [r7, #4]
   108e6:	6039      	str	r1, [r7, #0]
#endif    
  }
#else  // configSUPPORT_STATIC_ALLOCATION == 0  && configSUPPORT_DYNAMIC_ALLOCATION == 1
  osSemaphoreId sema;
 
  if (count == 1) {
   108e8:	683b      	ldr	r3, [r7, #0]
   108ea:	2b01      	cmp	r3, #1
   108ec:	d111      	bne.n	10912 <osSemaphoreCreate+0x34>
    vSemaphoreCreateBinary(sema);
   108ee:	2203      	movs	r2, #3
   108f0:	2100      	movs	r1, #0
   108f2:	2001      	movs	r0, #1
   108f4:	f000 fa4d 	bl	10d92 <xQueueGenericCreate>
   108f8:	0003      	movs	r3, r0
   108fa:	60fb      	str	r3, [r7, #12]
   108fc:	68fb      	ldr	r3, [r7, #12]
   108fe:	2b00      	cmp	r3, #0
   10900:	d005      	beq.n	1090e <osSemaphoreCreate+0x30>
   10902:	68f8      	ldr	r0, [r7, #12]
   10904:	2300      	movs	r3, #0
   10906:	2200      	movs	r2, #0
   10908:	2100      	movs	r1, #0
   1090a:	f000 fa96 	bl	10e3a <xQueueGenericSend>
    return sema;
   1090e:	68fb      	ldr	r3, [r7, #12]
   10910:	e000      	b.n	10914 <osSemaphoreCreate+0x36>
  }
  else {
#if (configUSE_COUNTING_SEMAPHORES == 1 )	
    return xSemaphoreCreateCounting(count, count);
#else
    return NULL;
   10912:	2300      	movs	r3, #0
#endif
  }
#endif
}
   10914:	0018      	movs	r0, r3
   10916:	46bd      	mov	sp, r7
   10918:	b004      	add	sp, #16
   1091a:	bd80      	pop	{r7, pc}

0001091c <osSemaphoreWait>:
* @param  millisec      timeout value or 0 in case of no time-out.
* @retval  number of available tokens, or -1 in case of incorrect parameters.
* @note   MUST REMAIN UNCHANGED: \b osSemaphoreWait shall be consistent in every CMSIS-RTOS.
*/
int32_t osSemaphoreWait (osSemaphoreId semaphore_id, uint32_t millisec)
{
   1091c:	b580      	push	{r7, lr}
   1091e:	b084      	sub	sp, #16
   10920:	af00      	add	r7, sp, #0
   10922:	6078      	str	r0, [r7, #4]
   10924:	6039      	str	r1, [r7, #0]
  TickType_t ticks;
  portBASE_TYPE taskWoken = pdFALSE;  
   10926:	2300      	movs	r3, #0
   10928:	60bb      	str	r3, [r7, #8]
  
  
  if (semaphore_id == NULL) {
   1092a:	687b      	ldr	r3, [r7, #4]
   1092c:	2b00      	cmp	r3, #0
   1092e:	d101      	bne.n	10934 <osSemaphoreWait+0x18>
    return osErrorParameter;
   10930:	2380      	movs	r3, #128	; 0x80
   10932:	e036      	b.n	109a2 <osSemaphoreWait+0x86>
  }
  
  ticks = 0;
   10934:	2300      	movs	r3, #0
   10936:	60fb      	str	r3, [r7, #12]
  if (millisec == osWaitForever) {
   10938:	683b      	ldr	r3, [r7, #0]
   1093a:	3301      	adds	r3, #1
   1093c:	d103      	bne.n	10946 <osSemaphoreWait+0x2a>
    ticks = portMAX_DELAY;
   1093e:	2301      	movs	r3, #1
   10940:	425b      	negs	r3, r3
   10942:	60fb      	str	r3, [r7, #12]
   10944:	e009      	b.n	1095a <osSemaphoreWait+0x3e>
  }
  else if (millisec != 0) {
   10946:	683b      	ldr	r3, [r7, #0]
   10948:	2b00      	cmp	r3, #0
   1094a:	d006      	beq.n	1095a <osSemaphoreWait+0x3e>
    ticks = millisec / portTICK_PERIOD_MS;
   1094c:	683b      	ldr	r3, [r7, #0]
   1094e:	60fb      	str	r3, [r7, #12]
    if (ticks == 0) {
   10950:	68fb      	ldr	r3, [r7, #12]
   10952:	2b00      	cmp	r3, #0
   10954:	d101      	bne.n	1095a <osSemaphoreWait+0x3e>
      ticks = 1;
   10956:	2301      	movs	r3, #1
   10958:	60fb      	str	r3, [r7, #12]
    }
  }
  
  if (inHandlerMode()) {
   1095a:	f7ff ff61 	bl	10820 <inHandlerMode>
   1095e:	1e03      	subs	r3, r0, #0
   10960:	d013      	beq.n	1098a <osSemaphoreWait+0x6e>
    if (xSemaphoreTakeFromISR(semaphore_id, &taskWoken) != pdTRUE) {
   10962:	2308      	movs	r3, #8
   10964:	18fa      	adds	r2, r7, r3
   10966:	687b      	ldr	r3, [r7, #4]
   10968:	2100      	movs	r1, #0
   1096a:	0018      	movs	r0, r3
   1096c:	f000 fd30 	bl	113d0 <xQueueReceiveFromISR>
   10970:	0003      	movs	r3, r0
   10972:	2b01      	cmp	r3, #1
   10974:	d001      	beq.n	1097a <osSemaphoreWait+0x5e>
      return osErrorOS;
   10976:	23ff      	movs	r3, #255	; 0xff
   10978:	e013      	b.n	109a2 <osSemaphoreWait+0x86>
    }
	portEND_SWITCHING_ISR(taskWoken);
   1097a:	68bb      	ldr	r3, [r7, #8]
   1097c:	2b00      	cmp	r3, #0
   1097e:	d00f      	beq.n	109a0 <osSemaphoreWait+0x84>
   10980:	4b0a      	ldr	r3, [pc, #40]	; (109ac <osSemaphoreWait+0x90>)
   10982:	2280      	movs	r2, #128	; 0x80
   10984:	0552      	lsls	r2, r2, #21
   10986:	601a      	str	r2, [r3, #0]
   10988:	e00a      	b.n	109a0 <osSemaphoreWait+0x84>
  }  
  else if (xSemaphoreTake(semaphore_id, ticks) != pdTRUE) {
   1098a:	68fa      	ldr	r2, [r7, #12]
   1098c:	687b      	ldr	r3, [r7, #4]
   1098e:	0011      	movs	r1, r2
   10990:	0018      	movs	r0, r3
   10992:	f000 fc85 	bl	112a0 <xQueueSemaphoreTake>
   10996:	0003      	movs	r3, r0
   10998:	2b01      	cmp	r3, #1
   1099a:	d001      	beq.n	109a0 <osSemaphoreWait+0x84>
    return osErrorOS;
   1099c:	23ff      	movs	r3, #255	; 0xff
   1099e:	e000      	b.n	109a2 <osSemaphoreWait+0x86>
  }
  
  return osOK;
   109a0:	2300      	movs	r3, #0
}
   109a2:	0018      	movs	r0, r3
   109a4:	46bd      	mov	sp, r7
   109a6:	b004      	add	sp, #16
   109a8:	bd80      	pop	{r7, pc}
   109aa:	46c0      	nop			; (mov r8, r8)
   109ac:	e000ed04 	.word	0xe000ed04

000109b0 <osSemaphoreRelease>:
* @param  semaphore_id  semaphore object referenced with \ref osSemaphore.
* @retval  status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osSemaphoreRelease shall be consistent in every CMSIS-RTOS.
*/
osStatus osSemaphoreRelease (osSemaphoreId semaphore_id)
{
   109b0:	b580      	push	{r7, lr}
   109b2:	b084      	sub	sp, #16
   109b4:	af00      	add	r7, sp, #0
   109b6:	6078      	str	r0, [r7, #4]
  osStatus result = osOK;
   109b8:	2300      	movs	r3, #0
   109ba:	60fb      	str	r3, [r7, #12]
  portBASE_TYPE taskWoken = pdFALSE;
   109bc:	2300      	movs	r3, #0
   109be:	60bb      	str	r3, [r7, #8]
  
  
  if (inHandlerMode()) {
   109c0:	f7ff ff2e 	bl	10820 <inHandlerMode>
   109c4:	1e03      	subs	r3, r0, #0
   109c6:	d013      	beq.n	109f0 <osSemaphoreRelease+0x40>
    if (xSemaphoreGiveFromISR(semaphore_id, &taskWoken) != pdTRUE) {
   109c8:	2308      	movs	r3, #8
   109ca:	18fa      	adds	r2, r7, r3
   109cc:	687b      	ldr	r3, [r7, #4]
   109ce:	0011      	movs	r1, r2
   109d0:	0018      	movs	r0, r3
   109d2:	f000 fb59 	bl	11088 <xQueueGiveFromISR>
   109d6:	0003      	movs	r3, r0
   109d8:	2b01      	cmp	r3, #1
   109da:	d001      	beq.n	109e0 <osSemaphoreRelease+0x30>
      return osErrorOS;
   109dc:	23ff      	movs	r3, #255	; 0xff
   109de:	e013      	b.n	10a08 <osSemaphoreRelease+0x58>
    }
    portEND_SWITCHING_ISR(taskWoken);
   109e0:	68bb      	ldr	r3, [r7, #8]
   109e2:	2b00      	cmp	r3, #0
   109e4:	d00f      	beq.n	10a06 <osSemaphoreRelease+0x56>
   109e6:	4b0a      	ldr	r3, [pc, #40]	; (10a10 <osSemaphoreRelease+0x60>)
   109e8:	2280      	movs	r2, #128	; 0x80
   109ea:	0552      	lsls	r2, r2, #21
   109ec:	601a      	str	r2, [r3, #0]
   109ee:	e00a      	b.n	10a06 <osSemaphoreRelease+0x56>
  }
  else {
    if (xSemaphoreGive(semaphore_id) != pdTRUE) {
   109f0:	6878      	ldr	r0, [r7, #4]
   109f2:	2300      	movs	r3, #0
   109f4:	2200      	movs	r2, #0
   109f6:	2100      	movs	r1, #0
   109f8:	f000 fa1f 	bl	10e3a <xQueueGenericSend>
   109fc:	0003      	movs	r3, r0
   109fe:	2b01      	cmp	r3, #1
   10a00:	d001      	beq.n	10a06 <osSemaphoreRelease+0x56>
      result = osErrorOS;
   10a02:	23ff      	movs	r3, #255	; 0xff
   10a04:	60fb      	str	r3, [r7, #12]
    }
  }
  
  return result;
   10a06:	68fb      	ldr	r3, [r7, #12]
}
   10a08:	0018      	movs	r0, r3
   10a0a:	46bd      	mov	sp, r7
   10a0c:	b004      	add	sp, #16
   10a0e:	bd80      	pop	{r7, pc}
   10a10:	e000ed04 	.word	0xe000ed04

00010a14 <osMessageCreate>:
* @param  thread_id     thread ID (obtained by \ref osThreadCreate or \ref osThreadGetId) or NULL.
* @retval  message queue ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osMessageCreate shall be consistent in every CMSIS-RTOS.
*/
osMessageQId osMessageCreate (const osMessageQDef_t *queue_def, osThreadId thread_id)
{
   10a14:	b580      	push	{r7, lr}
   10a16:	b082      	sub	sp, #8
   10a18:	af00      	add	r7, sp, #0
   10a1a:	6078      	str	r0, [r7, #4]
   10a1c:	6039      	str	r1, [r7, #0]
    return xQueueCreate(queue_def->queue_sz, queue_def->item_sz);
  }
#elif ( configSUPPORT_STATIC_ALLOCATION == 1 )
  return xQueueCreateStatic(queue_def->queue_sz, queue_def->item_sz, queue_def->buffer, queue_def->controlblock);
#else  
  return xQueueCreate(queue_def->queue_sz, queue_def->item_sz);
   10a1e:	687b      	ldr	r3, [r7, #4]
   10a20:	6818      	ldr	r0, [r3, #0]
   10a22:	687b      	ldr	r3, [r7, #4]
   10a24:	685b      	ldr	r3, [r3, #4]
   10a26:	2200      	movs	r2, #0
   10a28:	0019      	movs	r1, r3
   10a2a:	f000 f9b2 	bl	10d92 <xQueueGenericCreate>
   10a2e:	0003      	movs	r3, r0
#endif
}
   10a30:	0018      	movs	r0, r3
   10a32:	46bd      	mov	sp, r7
   10a34:	b002      	add	sp, #8
   10a36:	bd80      	pop	{r7, pc}

00010a38 <osMessagePut>:
* @param  millisec  timeout value or 0 in case of no time-out.
* @retval status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osMessagePut shall be consistent in every CMSIS-RTOS.
*/
osStatus osMessagePut (osMessageQId queue_id, uint32_t info, uint32_t millisec)
{
   10a38:	b580      	push	{r7, lr}
   10a3a:	b086      	sub	sp, #24
   10a3c:	af00      	add	r7, sp, #0
   10a3e:	60f8      	str	r0, [r7, #12]
   10a40:	60b9      	str	r1, [r7, #8]
   10a42:	607a      	str	r2, [r7, #4]
  portBASE_TYPE taskWoken = pdFALSE;
   10a44:	2300      	movs	r3, #0
   10a46:	613b      	str	r3, [r7, #16]
  TickType_t ticks;
  
  ticks = millisec / portTICK_PERIOD_MS;
   10a48:	687b      	ldr	r3, [r7, #4]
   10a4a:	617b      	str	r3, [r7, #20]
  if (ticks == 0) {
   10a4c:	697b      	ldr	r3, [r7, #20]
   10a4e:	2b00      	cmp	r3, #0
   10a50:	d101      	bne.n	10a56 <osMessagePut+0x1e>
    ticks = 1;
   10a52:	2301      	movs	r3, #1
   10a54:	617b      	str	r3, [r7, #20]
  }
  
  if (inHandlerMode()) {
   10a56:	f7ff fee3 	bl	10820 <inHandlerMode>
   10a5a:	1e03      	subs	r3, r0, #0
   10a5c:	d014      	beq.n	10a88 <osMessagePut+0x50>
    if (xQueueSendFromISR(queue_id, &info, &taskWoken) != pdTRUE) {
   10a5e:	2310      	movs	r3, #16
   10a60:	18fa      	adds	r2, r7, r3
   10a62:	2308      	movs	r3, #8
   10a64:	18f9      	adds	r1, r7, r3
   10a66:	68f8      	ldr	r0, [r7, #12]
   10a68:	2300      	movs	r3, #0
   10a6a:	f000 fa9c 	bl	10fa6 <xQueueGenericSendFromISR>
   10a6e:	0003      	movs	r3, r0
   10a70:	2b01      	cmp	r3, #1
   10a72:	d001      	beq.n	10a78 <osMessagePut+0x40>
      return osErrorOS;
   10a74:	23ff      	movs	r3, #255	; 0xff
   10a76:	e014      	b.n	10aa2 <osMessagePut+0x6a>
    }
    portEND_SWITCHING_ISR(taskWoken);
   10a78:	693b      	ldr	r3, [r7, #16]
   10a7a:	2b00      	cmp	r3, #0
   10a7c:	d010      	beq.n	10aa0 <osMessagePut+0x68>
   10a7e:	4b0b      	ldr	r3, [pc, #44]	; (10aac <osMessagePut+0x74>)
   10a80:	2280      	movs	r2, #128	; 0x80
   10a82:	0552      	lsls	r2, r2, #21
   10a84:	601a      	str	r2, [r3, #0]
   10a86:	e00b      	b.n	10aa0 <osMessagePut+0x68>
  }
  else {
    if (xQueueSend(queue_id, &info, ticks) != pdTRUE) {
   10a88:	697a      	ldr	r2, [r7, #20]
   10a8a:	2308      	movs	r3, #8
   10a8c:	18f9      	adds	r1, r7, r3
   10a8e:	68f8      	ldr	r0, [r7, #12]
   10a90:	2300      	movs	r3, #0
   10a92:	f000 f9d2 	bl	10e3a <xQueueGenericSend>
   10a96:	0003      	movs	r3, r0
   10a98:	2b01      	cmp	r3, #1
   10a9a:	d001      	beq.n	10aa0 <osMessagePut+0x68>
      return osErrorOS;
   10a9c:	23ff      	movs	r3, #255	; 0xff
   10a9e:	e000      	b.n	10aa2 <osMessagePut+0x6a>
    }
  }
  
  return osOK;
   10aa0:	2300      	movs	r3, #0
}
   10aa2:	0018      	movs	r0, r3
   10aa4:	46bd      	mov	sp, r7
   10aa6:	b006      	add	sp, #24
   10aa8:	bd80      	pop	{r7, pc}
   10aaa:	46c0      	nop			; (mov r8, r8)
   10aac:	e000ed04 	.word	0xe000ed04

00010ab0 <osMessageGet>:
* @param  millisec  timeout value or 0 in case of no time-out.
* @retval event information that includes status code.
* @note   MUST REMAIN UNCHANGED: \b osMessageGet shall be consistent in every CMSIS-RTOS.
*/
osEvent osMessageGet (osMessageQId queue_id, uint32_t millisec)
{
   10ab0:	b590      	push	{r4, r7, lr}
   10ab2:	b08b      	sub	sp, #44	; 0x2c
   10ab4:	af00      	add	r7, sp, #0
   10ab6:	60f8      	str	r0, [r7, #12]
   10ab8:	60b9      	str	r1, [r7, #8]
   10aba:	607a      	str	r2, [r7, #4]
  portBASE_TYPE taskWoken;
  TickType_t ticks;
  osEvent event;
  
  event.def.message_id = queue_id;
   10abc:	2114      	movs	r1, #20
   10abe:	187b      	adds	r3, r7, r1
   10ac0:	68ba      	ldr	r2, [r7, #8]
   10ac2:	609a      	str	r2, [r3, #8]
  event.value.v = 0;
   10ac4:	187b      	adds	r3, r7, r1
   10ac6:	2200      	movs	r2, #0
   10ac8:	605a      	str	r2, [r3, #4]
  
  if (queue_id == NULL) {
   10aca:	68bb      	ldr	r3, [r7, #8]
   10acc:	2b00      	cmp	r3, #0
   10ace:	d108      	bne.n	10ae2 <osMessageGet+0x32>
    event.status = osErrorParameter;
   10ad0:	2114      	movs	r1, #20
   10ad2:	187b      	adds	r3, r7, r1
   10ad4:	2280      	movs	r2, #128	; 0x80
   10ad6:	601a      	str	r2, [r3, #0]
    return event;
   10ad8:	68fb      	ldr	r3, [r7, #12]
   10ada:	187a      	adds	r2, r7, r1
   10adc:	ca13      	ldmia	r2!, {r0, r1, r4}
   10ade:	c313      	stmia	r3!, {r0, r1, r4}
   10ae0:	e053      	b.n	10b8a <osMessageGet+0xda>
  }
  
  taskWoken = pdFALSE;
   10ae2:	2300      	movs	r3, #0
   10ae4:	623b      	str	r3, [r7, #32]
  
  ticks = 0;
   10ae6:	2300      	movs	r3, #0
   10ae8:	627b      	str	r3, [r7, #36]	; 0x24
  if (millisec == osWaitForever) {
   10aea:	687b      	ldr	r3, [r7, #4]
   10aec:	3301      	adds	r3, #1
   10aee:	d103      	bne.n	10af8 <osMessageGet+0x48>
    ticks = portMAX_DELAY;
   10af0:	2301      	movs	r3, #1
   10af2:	425b      	negs	r3, r3
   10af4:	627b      	str	r3, [r7, #36]	; 0x24
   10af6:	e009      	b.n	10b0c <osMessageGet+0x5c>
  }
  else if (millisec != 0) {
   10af8:	687b      	ldr	r3, [r7, #4]
   10afa:	2b00      	cmp	r3, #0
   10afc:	d006      	beq.n	10b0c <osMessageGet+0x5c>
    ticks = millisec / portTICK_PERIOD_MS;
   10afe:	687b      	ldr	r3, [r7, #4]
   10b00:	627b      	str	r3, [r7, #36]	; 0x24
    if (ticks == 0) {
   10b02:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   10b04:	2b00      	cmp	r3, #0
   10b06:	d101      	bne.n	10b0c <osMessageGet+0x5c>
      ticks = 1;
   10b08:	2301      	movs	r3, #1
   10b0a:	627b      	str	r3, [r7, #36]	; 0x24
    }
  }
  
  if (inHandlerMode()) {
   10b0c:	f7ff fe88 	bl	10820 <inHandlerMode>
   10b10:	1e03      	subs	r3, r0, #0
   10b12:	d01c      	beq.n	10b4e <osMessageGet+0x9e>
    if (xQueueReceiveFromISR(queue_id, &event.value.v, &taskWoken) == pdTRUE) {
   10b14:	2320      	movs	r3, #32
   10b16:	18fa      	adds	r2, r7, r3
   10b18:	2314      	movs	r3, #20
   10b1a:	18fb      	adds	r3, r7, r3
   10b1c:	1d19      	adds	r1, r3, #4
   10b1e:	68bb      	ldr	r3, [r7, #8]
   10b20:	0018      	movs	r0, r3
   10b22:	f000 fc55 	bl	113d0 <xQueueReceiveFromISR>
   10b26:	0003      	movs	r3, r0
   10b28:	2b01      	cmp	r3, #1
   10b2a:	d104      	bne.n	10b36 <osMessageGet+0x86>
      /* We have mail */
      event.status = osEventMessage;
   10b2c:	2314      	movs	r3, #20
   10b2e:	18fb      	adds	r3, r7, r3
   10b30:	2210      	movs	r2, #16
   10b32:	601a      	str	r2, [r3, #0]
   10b34:	e003      	b.n	10b3e <osMessageGet+0x8e>
    }
    else {
      event.status = osOK;
   10b36:	2314      	movs	r3, #20
   10b38:	18fb      	adds	r3, r7, r3
   10b3a:	2200      	movs	r2, #0
   10b3c:	601a      	str	r2, [r3, #0]
    }
    portEND_SWITCHING_ISR(taskWoken);
   10b3e:	6a3b      	ldr	r3, [r7, #32]
   10b40:	2b00      	cmp	r3, #0
   10b42:	d01d      	beq.n	10b80 <osMessageGet+0xd0>
   10b44:	4b13      	ldr	r3, [pc, #76]	; (10b94 <osMessageGet+0xe4>)
   10b46:	2280      	movs	r2, #128	; 0x80
   10b48:	0552      	lsls	r2, r2, #21
   10b4a:	601a      	str	r2, [r3, #0]
   10b4c:	e018      	b.n	10b80 <osMessageGet+0xd0>
  }
  else {
    if (xQueueReceive(queue_id, &event.value.v, ticks) == pdTRUE) {
   10b4e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   10b50:	2314      	movs	r3, #20
   10b52:	18fb      	adds	r3, r7, r3
   10b54:	1d19      	adds	r1, r3, #4
   10b56:	68bb      	ldr	r3, [r7, #8]
   10b58:	0018      	movs	r0, r3
   10b5a:	f000 fafa 	bl	11152 <xQueueReceive>
   10b5e:	0003      	movs	r3, r0
   10b60:	2b01      	cmp	r3, #1
   10b62:	d104      	bne.n	10b6e <osMessageGet+0xbe>
      /* We have mail */
      event.status = osEventMessage;
   10b64:	2314      	movs	r3, #20
   10b66:	18fb      	adds	r3, r7, r3
   10b68:	2210      	movs	r2, #16
   10b6a:	601a      	str	r2, [r3, #0]
   10b6c:	e008      	b.n	10b80 <osMessageGet+0xd0>
    }
    else {
      event.status = (ticks == 0) ? osOK : osEventTimeout;
   10b6e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   10b70:	2b00      	cmp	r3, #0
   10b72:	d101      	bne.n	10b78 <osMessageGet+0xc8>
   10b74:	2200      	movs	r2, #0
   10b76:	e000      	b.n	10b7a <osMessageGet+0xca>
   10b78:	2240      	movs	r2, #64	; 0x40
   10b7a:	2314      	movs	r3, #20
   10b7c:	18fb      	adds	r3, r7, r3
   10b7e:	601a      	str	r2, [r3, #0]
    }
  }
  
  return event;
   10b80:	68fb      	ldr	r3, [r7, #12]
   10b82:	2214      	movs	r2, #20
   10b84:	18ba      	adds	r2, r7, r2
   10b86:	ca13      	ldmia	r2!, {r0, r1, r4}
   10b88:	c313      	stmia	r3!, {r0, r1, r4}
}
   10b8a:	68f8      	ldr	r0, [r7, #12]
   10b8c:	46bd      	mov	sp, r7
   10b8e:	b00b      	add	sp, #44	; 0x2c
   10b90:	bd90      	pop	{r4, r7, pc}
   10b92:	46c0      	nop			; (mov r8, r8)
   10b94:	e000ed04 	.word	0xe000ed04

00010b98 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
   10b98:	b580      	push	{r7, lr}
   10b9a:	b082      	sub	sp, #8
   10b9c:	af00      	add	r7, sp, #0
   10b9e:	6078      	str	r0, [r7, #4]
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   10ba0:	687b      	ldr	r3, [r7, #4]
   10ba2:	3308      	adds	r3, #8
   10ba4:	001a      	movs	r2, r3
   10ba6:	687b      	ldr	r3, [r7, #4]
   10ba8:	605a      	str	r2, [r3, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
   10baa:	687b      	ldr	r3, [r7, #4]
   10bac:	2201      	movs	r2, #1
   10bae:	4252      	negs	r2, r2
   10bb0:	609a      	str	r2, [r3, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   10bb2:	687b      	ldr	r3, [r7, #4]
   10bb4:	3308      	adds	r3, #8
   10bb6:	001a      	movs	r2, r3
   10bb8:	687b      	ldr	r3, [r7, #4]
   10bba:	60da      	str	r2, [r3, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   10bbc:	687b      	ldr	r3, [r7, #4]
   10bbe:	3308      	adds	r3, #8
   10bc0:	001a      	movs	r2, r3
   10bc2:	687b      	ldr	r3, [r7, #4]
   10bc4:	611a      	str	r2, [r3, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
   10bc6:	687b      	ldr	r3, [r7, #4]
   10bc8:	2200      	movs	r2, #0
   10bca:	601a      	str	r2, [r3, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
   10bcc:	46c0      	nop			; (mov r8, r8)
   10bce:	46bd      	mov	sp, r7
   10bd0:	b002      	add	sp, #8
   10bd2:	bd80      	pop	{r7, pc}

00010bd4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
   10bd4:	b580      	push	{r7, lr}
   10bd6:	b082      	sub	sp, #8
   10bd8:	af00      	add	r7, sp, #0
   10bda:	6078      	str	r0, [r7, #4]
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
   10bdc:	687b      	ldr	r3, [r7, #4]
   10bde:	2200      	movs	r2, #0
   10be0:	611a      	str	r2, [r3, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
   10be2:	46c0      	nop			; (mov r8, r8)
   10be4:	46bd      	mov	sp, r7
   10be6:	b002      	add	sp, #8
   10be8:	bd80      	pop	{r7, pc}

00010bea <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
   10bea:	b580      	push	{r7, lr}
   10bec:	b084      	sub	sp, #16
   10bee:	af00      	add	r7, sp, #0
   10bf0:	6078      	str	r0, [r7, #4]
   10bf2:	6039      	str	r1, [r7, #0]
ListItem_t * const pxIndex = pxList->pxIndex;
   10bf4:	687b      	ldr	r3, [r7, #4]
   10bf6:	685b      	ldr	r3, [r3, #4]
   10bf8:	60fb      	str	r3, [r7, #12]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
   10bfa:	683b      	ldr	r3, [r7, #0]
   10bfc:	68fa      	ldr	r2, [r7, #12]
   10bfe:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
   10c00:	68fb      	ldr	r3, [r7, #12]
   10c02:	689a      	ldr	r2, [r3, #8]
   10c04:	683b      	ldr	r3, [r7, #0]
   10c06:	609a      	str	r2, [r3, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
   10c08:	68fb      	ldr	r3, [r7, #12]
   10c0a:	689b      	ldr	r3, [r3, #8]
   10c0c:	683a      	ldr	r2, [r7, #0]
   10c0e:	605a      	str	r2, [r3, #4]
	pxIndex->pxPrevious = pxNewListItem;
   10c10:	68fb      	ldr	r3, [r7, #12]
   10c12:	683a      	ldr	r2, [r7, #0]
   10c14:	609a      	str	r2, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
   10c16:	683b      	ldr	r3, [r7, #0]
   10c18:	687a      	ldr	r2, [r7, #4]
   10c1a:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
   10c1c:	687b      	ldr	r3, [r7, #4]
   10c1e:	681b      	ldr	r3, [r3, #0]
   10c20:	1c5a      	adds	r2, r3, #1
   10c22:	687b      	ldr	r3, [r7, #4]
   10c24:	601a      	str	r2, [r3, #0]
}
   10c26:	46c0      	nop			; (mov r8, r8)
   10c28:	46bd      	mov	sp, r7
   10c2a:	b004      	add	sp, #16
   10c2c:	bd80      	pop	{r7, pc}

00010c2e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
   10c2e:	b580      	push	{r7, lr}
   10c30:	b084      	sub	sp, #16
   10c32:	af00      	add	r7, sp, #0
   10c34:	6078      	str	r0, [r7, #4]
   10c36:	6039      	str	r1, [r7, #0]
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
   10c38:	683b      	ldr	r3, [r7, #0]
   10c3a:	681b      	ldr	r3, [r3, #0]
   10c3c:	60bb      	str	r3, [r7, #8]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
   10c3e:	68bb      	ldr	r3, [r7, #8]
   10c40:	3301      	adds	r3, #1
   10c42:	d103      	bne.n	10c4c <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
   10c44:	687b      	ldr	r3, [r7, #4]
   10c46:	691b      	ldr	r3, [r3, #16]
   10c48:	60fb      	str	r3, [r7, #12]
   10c4a:	e00c      	b.n	10c66 <vListInsert+0x38>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   10c4c:	687b      	ldr	r3, [r7, #4]
   10c4e:	3308      	adds	r3, #8
   10c50:	60fb      	str	r3, [r7, #12]
   10c52:	e002      	b.n	10c5a <vListInsert+0x2c>
   10c54:	68fb      	ldr	r3, [r7, #12]
   10c56:	685b      	ldr	r3, [r3, #4]
   10c58:	60fb      	str	r3, [r7, #12]
   10c5a:	68fb      	ldr	r3, [r7, #12]
   10c5c:	685b      	ldr	r3, [r3, #4]
   10c5e:	681b      	ldr	r3, [r3, #0]
   10c60:	68ba      	ldr	r2, [r7, #8]
   10c62:	429a      	cmp	r2, r3
   10c64:	d2f6      	bcs.n	10c54 <vListInsert+0x26>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
   10c66:	68fb      	ldr	r3, [r7, #12]
   10c68:	685a      	ldr	r2, [r3, #4]
   10c6a:	683b      	ldr	r3, [r7, #0]
   10c6c:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
   10c6e:	683b      	ldr	r3, [r7, #0]
   10c70:	685b      	ldr	r3, [r3, #4]
   10c72:	683a      	ldr	r2, [r7, #0]
   10c74:	609a      	str	r2, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
   10c76:	683b      	ldr	r3, [r7, #0]
   10c78:	68fa      	ldr	r2, [r7, #12]
   10c7a:	609a      	str	r2, [r3, #8]
	pxIterator->pxNext = pxNewListItem;
   10c7c:	68fb      	ldr	r3, [r7, #12]
   10c7e:	683a      	ldr	r2, [r7, #0]
   10c80:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
   10c82:	683b      	ldr	r3, [r7, #0]
   10c84:	687a      	ldr	r2, [r7, #4]
   10c86:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
   10c88:	687b      	ldr	r3, [r7, #4]
   10c8a:	681b      	ldr	r3, [r3, #0]
   10c8c:	1c5a      	adds	r2, r3, #1
   10c8e:	687b      	ldr	r3, [r7, #4]
   10c90:	601a      	str	r2, [r3, #0]
}
   10c92:	46c0      	nop			; (mov r8, r8)
   10c94:	46bd      	mov	sp, r7
   10c96:	b004      	add	sp, #16
   10c98:	bd80      	pop	{r7, pc}

00010c9a <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
   10c9a:	b580      	push	{r7, lr}
   10c9c:	b084      	sub	sp, #16
   10c9e:	af00      	add	r7, sp, #0
   10ca0:	6078      	str	r0, [r7, #4]
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
   10ca2:	687b      	ldr	r3, [r7, #4]
   10ca4:	691b      	ldr	r3, [r3, #16]
   10ca6:	60fb      	str	r3, [r7, #12]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
   10ca8:	687b      	ldr	r3, [r7, #4]
   10caa:	685b      	ldr	r3, [r3, #4]
   10cac:	687a      	ldr	r2, [r7, #4]
   10cae:	6892      	ldr	r2, [r2, #8]
   10cb0:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
   10cb2:	687b      	ldr	r3, [r7, #4]
   10cb4:	689b      	ldr	r3, [r3, #8]
   10cb6:	687a      	ldr	r2, [r7, #4]
   10cb8:	6852      	ldr	r2, [r2, #4]
   10cba:	605a      	str	r2, [r3, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
   10cbc:	68fb      	ldr	r3, [r7, #12]
   10cbe:	685b      	ldr	r3, [r3, #4]
   10cc0:	687a      	ldr	r2, [r7, #4]
   10cc2:	429a      	cmp	r2, r3
   10cc4:	d103      	bne.n	10cce <uxListRemove+0x34>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
   10cc6:	687b      	ldr	r3, [r7, #4]
   10cc8:	689a      	ldr	r2, [r3, #8]
   10cca:	68fb      	ldr	r3, [r7, #12]
   10ccc:	605a      	str	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
   10cce:	687b      	ldr	r3, [r7, #4]
   10cd0:	2200      	movs	r2, #0
   10cd2:	611a      	str	r2, [r3, #16]
	( pxList->uxNumberOfItems )--;
   10cd4:	68fb      	ldr	r3, [r7, #12]
   10cd6:	681b      	ldr	r3, [r3, #0]
   10cd8:	1e5a      	subs	r2, r3, #1
   10cda:	68fb      	ldr	r3, [r7, #12]
   10cdc:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
   10cde:	68fb      	ldr	r3, [r7, #12]
   10ce0:	681b      	ldr	r3, [r3, #0]
}
   10ce2:	0018      	movs	r0, r3
   10ce4:	46bd      	mov	sp, r7
   10ce6:	b004      	add	sp, #16
   10ce8:	bd80      	pop	{r7, pc}

00010cea <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
   10cea:	b580      	push	{r7, lr}
   10cec:	b084      	sub	sp, #16
   10cee:	af00      	add	r7, sp, #0
   10cf0:	6078      	str	r0, [r7, #4]
   10cf2:	6039      	str	r1, [r7, #0]
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   10cf4:	687b      	ldr	r3, [r7, #4]
   10cf6:	60fb      	str	r3, [r7, #12]

	configASSERT( pxQueue );
   10cf8:	68fb      	ldr	r3, [r7, #12]
   10cfa:	2b00      	cmp	r3, #0
   10cfc:	d101      	bne.n	10d02 <xQueueGenericReset+0x18>
   10cfe:	b672      	cpsid	i
   10d00:	e7fe      	b.n	10d00 <xQueueGenericReset+0x16>

	taskENTER_CRITICAL();
   10d02:	f001 fc85 	bl	12610 <vPortEnterCritical>
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
   10d06:	68fb      	ldr	r3, [r7, #12]
   10d08:	681a      	ldr	r2, [r3, #0]
   10d0a:	68fb      	ldr	r3, [r7, #12]
   10d0c:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
   10d0e:	68fb      	ldr	r3, [r7, #12]
   10d10:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   10d12:	434b      	muls	r3, r1
   10d14:	18d2      	adds	r2, r2, r3
   10d16:	68fb      	ldr	r3, [r7, #12]
   10d18:	605a      	str	r2, [r3, #4]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
   10d1a:	68fb      	ldr	r3, [r7, #12]
   10d1c:	2200      	movs	r2, #0
   10d1e:	639a      	str	r2, [r3, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
   10d20:	68fb      	ldr	r3, [r7, #12]
   10d22:	681a      	ldr	r2, [r3, #0]
   10d24:	68fb      	ldr	r3, [r7, #12]
   10d26:	609a      	str	r2, [r3, #8]
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
   10d28:	68fb      	ldr	r3, [r7, #12]
   10d2a:	681a      	ldr	r2, [r3, #0]
   10d2c:	68fb      	ldr	r3, [r7, #12]
   10d2e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   10d30:	1e59      	subs	r1, r3, #1
   10d32:	68fb      	ldr	r3, [r7, #12]
   10d34:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   10d36:	434b      	muls	r3, r1
   10d38:	18d2      	adds	r2, r2, r3
   10d3a:	68fb      	ldr	r3, [r7, #12]
   10d3c:	60da      	str	r2, [r3, #12]
		pxQueue->cRxLock = queueUNLOCKED;
   10d3e:	68fb      	ldr	r3, [r7, #12]
   10d40:	2244      	movs	r2, #68	; 0x44
   10d42:	21ff      	movs	r1, #255	; 0xff
   10d44:	5499      	strb	r1, [r3, r2]
		pxQueue->cTxLock = queueUNLOCKED;
   10d46:	68fb      	ldr	r3, [r7, #12]
   10d48:	2245      	movs	r2, #69	; 0x45
   10d4a:	21ff      	movs	r1, #255	; 0xff
   10d4c:	5499      	strb	r1, [r3, r2]

		if( xNewQueue == pdFALSE )
   10d4e:	683b      	ldr	r3, [r7, #0]
   10d50:	2b00      	cmp	r3, #0
   10d52:	d10d      	bne.n	10d70 <xQueueGenericReset+0x86>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   10d54:	68fb      	ldr	r3, [r7, #12]
   10d56:	691b      	ldr	r3, [r3, #16]
   10d58:	2b00      	cmp	r3, #0
   10d5a:	d013      	beq.n	10d84 <xQueueGenericReset+0x9a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   10d5c:	68fb      	ldr	r3, [r7, #12]
   10d5e:	3310      	adds	r3, #16
   10d60:	0018      	movs	r0, r3
   10d62:	f001 f843 	bl	11dec <xTaskRemoveFromEventList>
   10d66:	1e03      	subs	r3, r0, #0
   10d68:	d00c      	beq.n	10d84 <xQueueGenericReset+0x9a>
				{
					queueYIELD_IF_USING_PREEMPTION();
   10d6a:	f001 fc41 	bl	125f0 <vPortYield>
   10d6e:	e009      	b.n	10d84 <xQueueGenericReset+0x9a>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
   10d70:	68fb      	ldr	r3, [r7, #12]
   10d72:	3310      	adds	r3, #16
   10d74:	0018      	movs	r0, r3
   10d76:	f7ff ff0f 	bl	10b98 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
   10d7a:	68fb      	ldr	r3, [r7, #12]
   10d7c:	3324      	adds	r3, #36	; 0x24
   10d7e:	0018      	movs	r0, r3
   10d80:	f7ff ff0a 	bl	10b98 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
   10d84:	f001 fc56 	bl	12634 <vPortExitCritical>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
   10d88:	2301      	movs	r3, #1
}
   10d8a:	0018      	movs	r0, r3
   10d8c:	46bd      	mov	sp, r7
   10d8e:	b004      	add	sp, #16
   10d90:	bd80      	pop	{r7, pc}

00010d92 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
   10d92:	b590      	push	{r4, r7, lr}
   10d94:	b08b      	sub	sp, #44	; 0x2c
   10d96:	af02      	add	r7, sp, #8
   10d98:	60f8      	str	r0, [r7, #12]
   10d9a:	60b9      	str	r1, [r7, #8]
   10d9c:	1dfb      	adds	r3, r7, #7
   10d9e:	701a      	strb	r2, [r3, #0]
	Queue_t *pxNewQueue;
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
   10da0:	68fb      	ldr	r3, [r7, #12]
   10da2:	2b00      	cmp	r3, #0
   10da4:	d101      	bne.n	10daa <xQueueGenericCreate+0x18>
   10da6:	b672      	cpsid	i
   10da8:	e7fe      	b.n	10da8 <xQueueGenericCreate+0x16>

		if( uxItemSize == ( UBaseType_t ) 0 )
   10daa:	68bb      	ldr	r3, [r7, #8]
   10dac:	2b00      	cmp	r3, #0
   10dae:	d102      	bne.n	10db6 <xQueueGenericCreate+0x24>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
   10db0:	2300      	movs	r3, #0
   10db2:	61fb      	str	r3, [r7, #28]
   10db4:	e003      	b.n	10dbe <xQueueGenericCreate+0x2c>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   10db6:	68fb      	ldr	r3, [r7, #12]
   10db8:	68ba      	ldr	r2, [r7, #8]
   10dba:	4353      	muls	r3, r2
   10dbc:	61fb      	str	r3, [r7, #28]
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
   10dbe:	69fb      	ldr	r3, [r7, #28]
   10dc0:	3348      	adds	r3, #72	; 0x48
   10dc2:	0018      	movs	r0, r3
   10dc4:	f001 f9e8 	bl	12198 <pvPortMalloc>
   10dc8:	0003      	movs	r3, r0
   10dca:	61bb      	str	r3, [r7, #24]

		if( pxNewQueue != NULL )
   10dcc:	69bb      	ldr	r3, [r7, #24]
   10dce:	2b00      	cmp	r3, #0
   10dd0:	d00c      	beq.n	10dec <xQueueGenericCreate+0x5a>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
   10dd2:	69bb      	ldr	r3, [r7, #24]
   10dd4:	3348      	adds	r3, #72	; 0x48
   10dd6:	617b      	str	r3, [r7, #20]
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
   10dd8:	1dfb      	adds	r3, r7, #7
   10dda:	781c      	ldrb	r4, [r3, #0]
   10ddc:	697a      	ldr	r2, [r7, #20]
   10dde:	68b9      	ldr	r1, [r7, #8]
   10de0:	68f8      	ldr	r0, [r7, #12]
   10de2:	69bb      	ldr	r3, [r7, #24]
   10de4:	9300      	str	r3, [sp, #0]
   10de6:	0023      	movs	r3, r4
   10de8:	f000 f805 	bl	10df6 <prvInitialiseNewQueue>
		else
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
		}

		return pxNewQueue;
   10dec:	69bb      	ldr	r3, [r7, #24]
	}
   10dee:	0018      	movs	r0, r3
   10df0:	46bd      	mov	sp, r7
   10df2:	b009      	add	sp, #36	; 0x24
   10df4:	bd90      	pop	{r4, r7, pc}

00010df6 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
   10df6:	b580      	push	{r7, lr}
   10df8:	b084      	sub	sp, #16
   10dfa:	af00      	add	r7, sp, #0
   10dfc:	60f8      	str	r0, [r7, #12]
   10dfe:	60b9      	str	r1, [r7, #8]
   10e00:	607a      	str	r2, [r7, #4]
   10e02:	001a      	movs	r2, r3
   10e04:	1cfb      	adds	r3, r7, #3
   10e06:	701a      	strb	r2, [r3, #0]
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
   10e08:	68bb      	ldr	r3, [r7, #8]
   10e0a:	2b00      	cmp	r3, #0
   10e0c:	d103      	bne.n	10e16 <prvInitialiseNewQueue+0x20>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
   10e0e:	69bb      	ldr	r3, [r7, #24]
   10e10:	69ba      	ldr	r2, [r7, #24]
   10e12:	601a      	str	r2, [r3, #0]
   10e14:	e002      	b.n	10e1c <prvInitialiseNewQueue+0x26>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
   10e16:	69bb      	ldr	r3, [r7, #24]
   10e18:	687a      	ldr	r2, [r7, #4]
   10e1a:	601a      	str	r2, [r3, #0]
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
   10e1c:	69bb      	ldr	r3, [r7, #24]
   10e1e:	68fa      	ldr	r2, [r7, #12]
   10e20:	63da      	str	r2, [r3, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
   10e22:	69bb      	ldr	r3, [r7, #24]
   10e24:	68ba      	ldr	r2, [r7, #8]
   10e26:	641a      	str	r2, [r3, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
   10e28:	69bb      	ldr	r3, [r7, #24]
   10e2a:	2101      	movs	r1, #1
   10e2c:	0018      	movs	r0, r3
   10e2e:	f7ff ff5c 	bl	10cea <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
   10e32:	46c0      	nop			; (mov r8, r8)
   10e34:	46bd      	mov	sp, r7
   10e36:	b004      	add	sp, #16
   10e38:	bd80      	pop	{r7, pc}

00010e3a <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
   10e3a:	b580      	push	{r7, lr}
   10e3c:	b08a      	sub	sp, #40	; 0x28
   10e3e:	af00      	add	r7, sp, #0
   10e40:	60f8      	str	r0, [r7, #12]
   10e42:	60b9      	str	r1, [r7, #8]
   10e44:	607a      	str	r2, [r7, #4]
   10e46:	603b      	str	r3, [r7, #0]
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
   10e48:	2300      	movs	r3, #0
   10e4a:	627b      	str	r3, [r7, #36]	; 0x24
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   10e4c:	68fb      	ldr	r3, [r7, #12]
   10e4e:	623b      	str	r3, [r7, #32]

	configASSERT( pxQueue );
   10e50:	6a3b      	ldr	r3, [r7, #32]
   10e52:	2b00      	cmp	r3, #0
   10e54:	d101      	bne.n	10e5a <xQueueGenericSend+0x20>
   10e56:	b672      	cpsid	i
   10e58:	e7fe      	b.n	10e58 <xQueueGenericSend+0x1e>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
   10e5a:	68bb      	ldr	r3, [r7, #8]
   10e5c:	2b00      	cmp	r3, #0
   10e5e:	d103      	bne.n	10e68 <xQueueGenericSend+0x2e>
   10e60:	6a3b      	ldr	r3, [r7, #32]
   10e62:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   10e64:	2b00      	cmp	r3, #0
   10e66:	d101      	bne.n	10e6c <xQueueGenericSend+0x32>
   10e68:	2301      	movs	r3, #1
   10e6a:	e000      	b.n	10e6e <xQueueGenericSend+0x34>
   10e6c:	2300      	movs	r3, #0
   10e6e:	2b00      	cmp	r3, #0
   10e70:	d101      	bne.n	10e76 <xQueueGenericSend+0x3c>
   10e72:	b672      	cpsid	i
   10e74:	e7fe      	b.n	10e74 <xQueueGenericSend+0x3a>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
   10e76:	683b      	ldr	r3, [r7, #0]
   10e78:	2b02      	cmp	r3, #2
   10e7a:	d103      	bne.n	10e84 <xQueueGenericSend+0x4a>
   10e7c:	6a3b      	ldr	r3, [r7, #32]
   10e7e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   10e80:	2b01      	cmp	r3, #1
   10e82:	d101      	bne.n	10e88 <xQueueGenericSend+0x4e>
   10e84:	2301      	movs	r3, #1
   10e86:	e000      	b.n	10e8a <xQueueGenericSend+0x50>
   10e88:	2300      	movs	r3, #0
   10e8a:	2b00      	cmp	r3, #0
   10e8c:	d101      	bne.n	10e92 <xQueueGenericSend+0x58>
   10e8e:	b672      	cpsid	i
   10e90:	e7fe      	b.n	10e90 <xQueueGenericSend+0x56>
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
   10e92:	f001 fbbd 	bl	12610 <vPortEnterCritical>
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
   10e96:	6a3b      	ldr	r3, [r7, #32]
   10e98:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   10e9a:	6a3b      	ldr	r3, [r7, #32]
   10e9c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   10e9e:	429a      	cmp	r2, r3
   10ea0:	d302      	bcc.n	10ea8 <xQueueGenericSend+0x6e>
   10ea2:	683b      	ldr	r3, [r7, #0]
   10ea4:	2b02      	cmp	r3, #2
   10ea6:	d11e      	bne.n	10ee6 <xQueueGenericSend+0xac>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
   10ea8:	683a      	ldr	r2, [r7, #0]
   10eaa:	68b9      	ldr	r1, [r7, #8]
   10eac:	6a3b      	ldr	r3, [r7, #32]
   10eae:	0018      	movs	r0, r3
   10eb0:	f000 faf1 	bl	11496 <prvCopyDataToQueue>
   10eb4:	0003      	movs	r3, r0
   10eb6:	61fb      	str	r3, [r7, #28]
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   10eb8:	6a3b      	ldr	r3, [r7, #32]
   10eba:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   10ebc:	2b00      	cmp	r3, #0
   10ebe:	d009      	beq.n	10ed4 <xQueueGenericSend+0x9a>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   10ec0:	6a3b      	ldr	r3, [r7, #32]
   10ec2:	3324      	adds	r3, #36	; 0x24
   10ec4:	0018      	movs	r0, r3
   10ec6:	f000 ff91 	bl	11dec <xTaskRemoveFromEventList>
   10eca:	1e03      	subs	r3, r0, #0
   10ecc:	d007      	beq.n	10ede <xQueueGenericSend+0xa4>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
   10ece:	f001 fb8f 	bl	125f0 <vPortYield>
   10ed2:	e004      	b.n	10ede <xQueueGenericSend+0xa4>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
   10ed4:	69fb      	ldr	r3, [r7, #28]
   10ed6:	2b00      	cmp	r3, #0
   10ed8:	d001      	beq.n	10ede <xQueueGenericSend+0xa4>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
   10eda:	f001 fb89 	bl	125f0 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
   10ede:	f001 fba9 	bl	12634 <vPortExitCritical>
				return pdPASS;
   10ee2:	2301      	movs	r3, #1
   10ee4:	e05b      	b.n	10f9e <xQueueGenericSend+0x164>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
   10ee6:	687b      	ldr	r3, [r7, #4]
   10ee8:	2b00      	cmp	r3, #0
   10eea:	d103      	bne.n	10ef4 <xQueueGenericSend+0xba>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
   10eec:	f001 fba2 	bl	12634 <vPortExitCritical>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
   10ef0:	2300      	movs	r3, #0
   10ef2:	e054      	b.n	10f9e <xQueueGenericSend+0x164>
				}
				else if( xEntryTimeSet == pdFALSE )
   10ef4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   10ef6:	2b00      	cmp	r3, #0
   10ef8:	d106      	bne.n	10f08 <xQueueGenericSend+0xce>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
   10efa:	2314      	movs	r3, #20
   10efc:	18fb      	adds	r3, r7, r3
   10efe:	0018      	movs	r0, r3
   10f00:	f000 ffd0 	bl	11ea4 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
   10f04:	2301      	movs	r3, #1
   10f06:	627b      	str	r3, [r7, #36]	; 0x24
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
   10f08:	f001 fb94 	bl	12634 <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
   10f0c:	f000 fdb2 	bl	11a74 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
   10f10:	f001 fb7e 	bl	12610 <vPortEnterCritical>
   10f14:	6a3b      	ldr	r3, [r7, #32]
   10f16:	2244      	movs	r2, #68	; 0x44
   10f18:	5c9b      	ldrb	r3, [r3, r2]
   10f1a:	b25b      	sxtb	r3, r3
   10f1c:	3301      	adds	r3, #1
   10f1e:	d103      	bne.n	10f28 <xQueueGenericSend+0xee>
   10f20:	6a3b      	ldr	r3, [r7, #32]
   10f22:	2244      	movs	r2, #68	; 0x44
   10f24:	2100      	movs	r1, #0
   10f26:	5499      	strb	r1, [r3, r2]
   10f28:	6a3b      	ldr	r3, [r7, #32]
   10f2a:	2245      	movs	r2, #69	; 0x45
   10f2c:	5c9b      	ldrb	r3, [r3, r2]
   10f2e:	b25b      	sxtb	r3, r3
   10f30:	3301      	adds	r3, #1
   10f32:	d103      	bne.n	10f3c <xQueueGenericSend+0x102>
   10f34:	6a3b      	ldr	r3, [r7, #32]
   10f36:	2245      	movs	r2, #69	; 0x45
   10f38:	2100      	movs	r1, #0
   10f3a:	5499      	strb	r1, [r3, r2]
   10f3c:	f001 fb7a 	bl	12634 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   10f40:	1d3a      	adds	r2, r7, #4
   10f42:	2314      	movs	r3, #20
   10f44:	18fb      	adds	r3, r7, r3
   10f46:	0011      	movs	r1, r2
   10f48:	0018      	movs	r0, r3
   10f4a:	f000 ffbf 	bl	11ecc <xTaskCheckForTimeOut>
   10f4e:	1e03      	subs	r3, r0, #0
   10f50:	d11e      	bne.n	10f90 <xQueueGenericSend+0x156>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
   10f52:	6a3b      	ldr	r3, [r7, #32]
   10f54:	0018      	movs	r0, r3
   10f56:	f000 fb94 	bl	11682 <prvIsQueueFull>
   10f5a:	1e03      	subs	r3, r0, #0
   10f5c:	d011      	beq.n	10f82 <xQueueGenericSend+0x148>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
   10f5e:	6a3b      	ldr	r3, [r7, #32]
   10f60:	3310      	adds	r3, #16
   10f62:	687a      	ldr	r2, [r7, #4]
   10f64:	0011      	movs	r1, r2
   10f66:	0018      	movs	r0, r3
   10f68:	f000 ff22 	bl	11db0 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
   10f6c:	6a3b      	ldr	r3, [r7, #32]
   10f6e:	0018      	movs	r0, r3
   10f70:	f000 fb13 	bl	1159a <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
   10f74:	f000 fd8a 	bl	11a8c <xTaskResumeAll>
   10f78:	1e03      	subs	r3, r0, #0
   10f7a:	d18a      	bne.n	10e92 <xQueueGenericSend+0x58>
				{
					portYIELD_WITHIN_API();
   10f7c:	f001 fb38 	bl	125f0 <vPortYield>
   10f80:	e787      	b.n	10e92 <xQueueGenericSend+0x58>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
   10f82:	6a3b      	ldr	r3, [r7, #32]
   10f84:	0018      	movs	r0, r3
   10f86:	f000 fb08 	bl	1159a <prvUnlockQueue>
				( void ) xTaskResumeAll();
   10f8a:	f000 fd7f 	bl	11a8c <xTaskResumeAll>
   10f8e:	e780      	b.n	10e92 <xQueueGenericSend+0x58>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
   10f90:	6a3b      	ldr	r3, [r7, #32]
   10f92:	0018      	movs	r0, r3
   10f94:	f000 fb01 	bl	1159a <prvUnlockQueue>
			( void ) xTaskResumeAll();
   10f98:	f000 fd78 	bl	11a8c <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
   10f9c:	2300      	movs	r3, #0
		}
	}
}
   10f9e:	0018      	movs	r0, r3
   10fa0:	46bd      	mov	sp, r7
   10fa2:	b00a      	add	sp, #40	; 0x28
   10fa4:	bd80      	pop	{r7, pc}

00010fa6 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
   10fa6:	b590      	push	{r4, r7, lr}
   10fa8:	b089      	sub	sp, #36	; 0x24
   10faa:	af00      	add	r7, sp, #0
   10fac:	60f8      	str	r0, [r7, #12]
   10fae:	60b9      	str	r1, [r7, #8]
   10fb0:	607a      	str	r2, [r7, #4]
   10fb2:	603b      	str	r3, [r7, #0]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   10fb4:	68fb      	ldr	r3, [r7, #12]
   10fb6:	61bb      	str	r3, [r7, #24]

	configASSERT( pxQueue );
   10fb8:	69bb      	ldr	r3, [r7, #24]
   10fba:	2b00      	cmp	r3, #0
   10fbc:	d101      	bne.n	10fc2 <xQueueGenericSendFromISR+0x1c>
   10fbe:	b672      	cpsid	i
   10fc0:	e7fe      	b.n	10fc0 <xQueueGenericSendFromISR+0x1a>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
   10fc2:	68bb      	ldr	r3, [r7, #8]
   10fc4:	2b00      	cmp	r3, #0
   10fc6:	d103      	bne.n	10fd0 <xQueueGenericSendFromISR+0x2a>
   10fc8:	69bb      	ldr	r3, [r7, #24]
   10fca:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   10fcc:	2b00      	cmp	r3, #0
   10fce:	d101      	bne.n	10fd4 <xQueueGenericSendFromISR+0x2e>
   10fd0:	2301      	movs	r3, #1
   10fd2:	e000      	b.n	10fd6 <xQueueGenericSendFromISR+0x30>
   10fd4:	2300      	movs	r3, #0
   10fd6:	2b00      	cmp	r3, #0
   10fd8:	d101      	bne.n	10fde <xQueueGenericSendFromISR+0x38>
   10fda:	b672      	cpsid	i
   10fdc:	e7fe      	b.n	10fdc <xQueueGenericSendFromISR+0x36>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
   10fde:	683b      	ldr	r3, [r7, #0]
   10fe0:	2b02      	cmp	r3, #2
   10fe2:	d103      	bne.n	10fec <xQueueGenericSendFromISR+0x46>
   10fe4:	69bb      	ldr	r3, [r7, #24]
   10fe6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   10fe8:	2b01      	cmp	r3, #1
   10fea:	d101      	bne.n	10ff0 <xQueueGenericSendFromISR+0x4a>
   10fec:	2301      	movs	r3, #1
   10fee:	e000      	b.n	10ff2 <xQueueGenericSendFromISR+0x4c>
   10ff0:	2300      	movs	r3, #0
   10ff2:	2b00      	cmp	r3, #0
   10ff4:	d101      	bne.n	10ffa <xQueueGenericSendFromISR+0x54>
   10ff6:	b672      	cpsid	i
   10ff8:	e7fe      	b.n	10ff8 <xQueueGenericSendFromISR+0x52>
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   10ffa:	f001 fb33 	bl	12664 <ulSetInterruptMaskFromISR>
   10ffe:	0003      	movs	r3, r0
   11000:	617b      	str	r3, [r7, #20]
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
   11002:	69bb      	ldr	r3, [r7, #24]
   11004:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   11006:	69bb      	ldr	r3, [r7, #24]
   11008:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   1100a:	429a      	cmp	r2, r3
   1100c:	d302      	bcc.n	11014 <xQueueGenericSendFromISR+0x6e>
   1100e:	683b      	ldr	r3, [r7, #0]
   11010:	2b02      	cmp	r3, #2
   11012:	d12e      	bne.n	11072 <xQueueGenericSendFromISR+0xcc>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
   11014:	2413      	movs	r4, #19
   11016:	193b      	adds	r3, r7, r4
   11018:	69ba      	ldr	r2, [r7, #24]
   1101a:	2145      	movs	r1, #69	; 0x45
   1101c:	5c52      	ldrb	r2, [r2, r1]
   1101e:	701a      	strb	r2, [r3, #0]
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
   11020:	683a      	ldr	r2, [r7, #0]
   11022:	68b9      	ldr	r1, [r7, #8]
   11024:	69bb      	ldr	r3, [r7, #24]
   11026:	0018      	movs	r0, r3
   11028:	f000 fa35 	bl	11496 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
   1102c:	193b      	adds	r3, r7, r4
   1102e:	781b      	ldrb	r3, [r3, #0]
   11030:	b25b      	sxtb	r3, r3
   11032:	3301      	adds	r3, #1
   11034:	d111      	bne.n	1105a <xQueueGenericSendFromISR+0xb4>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   11036:	69bb      	ldr	r3, [r7, #24]
   11038:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   1103a:	2b00      	cmp	r3, #0
   1103c:	d016      	beq.n	1106c <xQueueGenericSendFromISR+0xc6>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   1103e:	69bb      	ldr	r3, [r7, #24]
   11040:	3324      	adds	r3, #36	; 0x24
   11042:	0018      	movs	r0, r3
   11044:	f000 fed2 	bl	11dec <xTaskRemoveFromEventList>
   11048:	1e03      	subs	r3, r0, #0
   1104a:	d00f      	beq.n	1106c <xQueueGenericSendFromISR+0xc6>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
   1104c:	687b      	ldr	r3, [r7, #4]
   1104e:	2b00      	cmp	r3, #0
   11050:	d00c      	beq.n	1106c <xQueueGenericSendFromISR+0xc6>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
   11052:	687b      	ldr	r3, [r7, #4]
   11054:	2201      	movs	r2, #1
   11056:	601a      	str	r2, [r3, #0]
   11058:	e008      	b.n	1106c <xQueueGenericSendFromISR+0xc6>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
   1105a:	2313      	movs	r3, #19
   1105c:	18fb      	adds	r3, r7, r3
   1105e:	781b      	ldrb	r3, [r3, #0]
   11060:	3301      	adds	r3, #1
   11062:	b2db      	uxtb	r3, r3
   11064:	b259      	sxtb	r1, r3
   11066:	69bb      	ldr	r3, [r7, #24]
   11068:	2245      	movs	r2, #69	; 0x45
   1106a:	5499      	strb	r1, [r3, r2]
			}

			xReturn = pdPASS;
   1106c:	2301      	movs	r3, #1
   1106e:	61fb      	str	r3, [r7, #28]
		{
   11070:	e001      	b.n	11076 <xQueueGenericSendFromISR+0xd0>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
   11072:	2300      	movs	r3, #0
   11074:	61fb      	str	r3, [r7, #28]
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   11076:	697b      	ldr	r3, [r7, #20]
   11078:	0018      	movs	r0, r3
   1107a:	f001 faf9 	bl	12670 <vClearInterruptMaskFromISR>

	return xReturn;
   1107e:	69fb      	ldr	r3, [r7, #28]
}
   11080:	0018      	movs	r0, r3
   11082:	46bd      	mov	sp, r7
   11084:	b009      	add	sp, #36	; 0x24
   11086:	bd90      	pop	{r4, r7, pc}

00011088 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
   11088:	b580      	push	{r7, lr}
   1108a:	b088      	sub	sp, #32
   1108c:	af00      	add	r7, sp, #0
   1108e:	6078      	str	r0, [r7, #4]
   11090:	6039      	str	r1, [r7, #0]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   11092:	687b      	ldr	r3, [r7, #4]
   11094:	61bb      	str	r3, [r7, #24]
	item size is 0.  Don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */

	configASSERT( pxQueue );
   11096:	69bb      	ldr	r3, [r7, #24]
   11098:	2b00      	cmp	r3, #0
   1109a:	d101      	bne.n	110a0 <xQueueGiveFromISR+0x18>
   1109c:	b672      	cpsid	i
   1109e:	e7fe      	b.n	1109e <xQueueGiveFromISR+0x16>

	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
	if the item size is not 0. */
	configASSERT( pxQueue->uxItemSize == 0 );
   110a0:	69bb      	ldr	r3, [r7, #24]
   110a2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   110a4:	2b00      	cmp	r3, #0
   110a6:	d001      	beq.n	110ac <xQueueGiveFromISR+0x24>
   110a8:	b672      	cpsid	i
   110aa:	e7fe      	b.n	110aa <xQueueGiveFromISR+0x22>

	/* Normally a mutex would not be given from an interrupt, especially if
	there is a mutex holder, as priority inheritance makes no sense for an
	interrupts, only tasks. */
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NULL ) ) );
   110ac:	69bb      	ldr	r3, [r7, #24]
   110ae:	681b      	ldr	r3, [r3, #0]
   110b0:	2b00      	cmp	r3, #0
   110b2:	d103      	bne.n	110bc <xQueueGiveFromISR+0x34>
   110b4:	69bb      	ldr	r3, [r7, #24]
   110b6:	685b      	ldr	r3, [r3, #4]
   110b8:	2b00      	cmp	r3, #0
   110ba:	d101      	bne.n	110c0 <xQueueGiveFromISR+0x38>
   110bc:	2301      	movs	r3, #1
   110be:	e000      	b.n	110c2 <xQueueGiveFromISR+0x3a>
   110c0:	2300      	movs	r3, #0
   110c2:	2b00      	cmp	r3, #0
   110c4:	d101      	bne.n	110ca <xQueueGiveFromISR+0x42>
   110c6:	b672      	cpsid	i
   110c8:	e7fe      	b.n	110c8 <xQueueGiveFromISR+0x40>
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   110ca:	f001 facb 	bl	12664 <ulSetInterruptMaskFromISR>
   110ce:	0003      	movs	r3, r0
   110d0:	617b      	str	r3, [r7, #20]
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
   110d2:	69bb      	ldr	r3, [r7, #24]
   110d4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   110d6:	613b      	str	r3, [r7, #16]

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
   110d8:	69bb      	ldr	r3, [r7, #24]
   110da:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   110dc:	693a      	ldr	r2, [r7, #16]
   110de:	429a      	cmp	r2, r3
   110e0:	d22c      	bcs.n	1113c <xQueueGiveFromISR+0xb4>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
   110e2:	200f      	movs	r0, #15
   110e4:	183b      	adds	r3, r7, r0
   110e6:	69ba      	ldr	r2, [r7, #24]
   110e8:	2145      	movs	r1, #69	; 0x45
   110ea:	5c52      	ldrb	r2, [r2, r1]
   110ec:	701a      	strb	r2, [r3, #0]
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
   110ee:	693b      	ldr	r3, [r7, #16]
   110f0:	1c5a      	adds	r2, r3, #1
   110f2:	69bb      	ldr	r3, [r7, #24]
   110f4:	639a      	str	r2, [r3, #56]	; 0x38

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
   110f6:	183b      	adds	r3, r7, r0
   110f8:	781b      	ldrb	r3, [r3, #0]
   110fa:	b25b      	sxtb	r3, r3
   110fc:	3301      	adds	r3, #1
   110fe:	d111      	bne.n	11124 <xQueueGiveFromISR+0x9c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   11100:	69bb      	ldr	r3, [r7, #24]
   11102:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   11104:	2b00      	cmp	r3, #0
   11106:	d016      	beq.n	11136 <xQueueGiveFromISR+0xae>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   11108:	69bb      	ldr	r3, [r7, #24]
   1110a:	3324      	adds	r3, #36	; 0x24
   1110c:	0018      	movs	r0, r3
   1110e:	f000 fe6d 	bl	11dec <xTaskRemoveFromEventList>
   11112:	1e03      	subs	r3, r0, #0
   11114:	d00f      	beq.n	11136 <xQueueGiveFromISR+0xae>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
   11116:	683b      	ldr	r3, [r7, #0]
   11118:	2b00      	cmp	r3, #0
   1111a:	d00c      	beq.n	11136 <xQueueGiveFromISR+0xae>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
   1111c:	683b      	ldr	r3, [r7, #0]
   1111e:	2201      	movs	r2, #1
   11120:	601a      	str	r2, [r3, #0]
   11122:	e008      	b.n	11136 <xQueueGiveFromISR+0xae>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
   11124:	230f      	movs	r3, #15
   11126:	18fb      	adds	r3, r7, r3
   11128:	781b      	ldrb	r3, [r3, #0]
   1112a:	3301      	adds	r3, #1
   1112c:	b2db      	uxtb	r3, r3
   1112e:	b259      	sxtb	r1, r3
   11130:	69bb      	ldr	r3, [r7, #24]
   11132:	2245      	movs	r2, #69	; 0x45
   11134:	5499      	strb	r1, [r3, r2]
			}

			xReturn = pdPASS;
   11136:	2301      	movs	r3, #1
   11138:	61fb      	str	r3, [r7, #28]
   1113a:	e001      	b.n	11140 <xQueueGiveFromISR+0xb8>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
   1113c:	2300      	movs	r3, #0
   1113e:	61fb      	str	r3, [r7, #28]
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   11140:	697b      	ldr	r3, [r7, #20]
   11142:	0018      	movs	r0, r3
   11144:	f001 fa94 	bl	12670 <vClearInterruptMaskFromISR>

	return xReturn;
   11148:	69fb      	ldr	r3, [r7, #28]
}
   1114a:	0018      	movs	r0, r3
   1114c:	46bd      	mov	sp, r7
   1114e:	b008      	add	sp, #32
   11150:	bd80      	pop	{r7, pc}

00011152 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
   11152:	b580      	push	{r7, lr}
   11154:	b08a      	sub	sp, #40	; 0x28
   11156:	af00      	add	r7, sp, #0
   11158:	60f8      	str	r0, [r7, #12]
   1115a:	60b9      	str	r1, [r7, #8]
   1115c:	607a      	str	r2, [r7, #4]
BaseType_t xEntryTimeSet = pdFALSE;
   1115e:	2300      	movs	r3, #0
   11160:	627b      	str	r3, [r7, #36]	; 0x24
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   11162:	68fb      	ldr	r3, [r7, #12]
   11164:	623b      	str	r3, [r7, #32]

	/* Check the pointer is not NULL. */
	configASSERT( ( pxQueue ) );
   11166:	6a3b      	ldr	r3, [r7, #32]
   11168:	2b00      	cmp	r3, #0
   1116a:	d101      	bne.n	11170 <xQueueReceive+0x1e>
   1116c:	b672      	cpsid	i
   1116e:	e7fe      	b.n	1116e <xQueueReceive+0x1c>

	/* The buffer into which data is received can only be NULL if the data size
	is zero (so no data is copied into the buffer. */
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
   11170:	68bb      	ldr	r3, [r7, #8]
   11172:	2b00      	cmp	r3, #0
   11174:	d103      	bne.n	1117e <xQueueReceive+0x2c>
   11176:	6a3b      	ldr	r3, [r7, #32]
   11178:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   1117a:	2b00      	cmp	r3, #0
   1117c:	d101      	bne.n	11182 <xQueueReceive+0x30>
   1117e:	2301      	movs	r3, #1
   11180:	e000      	b.n	11184 <xQueueReceive+0x32>
   11182:	2300      	movs	r3, #0
   11184:	2b00      	cmp	r3, #0
   11186:	d101      	bne.n	1118c <xQueueReceive+0x3a>
   11188:	b672      	cpsid	i
   1118a:	e7fe      	b.n	1118a <xQueueReceive+0x38>
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
   1118c:	f001 fa40 	bl	12610 <vPortEnterCritical>
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
   11190:	6a3b      	ldr	r3, [r7, #32]
   11192:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   11194:	61fb      	str	r3, [r7, #28]

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
   11196:	69fb      	ldr	r3, [r7, #28]
   11198:	2b00      	cmp	r3, #0
   1119a:	d01a      	beq.n	111d2 <xQueueReceive+0x80>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
   1119c:	68ba      	ldr	r2, [r7, #8]
   1119e:	6a3b      	ldr	r3, [r7, #32]
   111a0:	0011      	movs	r1, r2
   111a2:	0018      	movs	r0, r3
   111a4:	f000 f9d3 	bl	1154e <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
   111a8:	69fb      	ldr	r3, [r7, #28]
   111aa:	1e5a      	subs	r2, r3, #1
   111ac:	6a3b      	ldr	r3, [r7, #32]
   111ae:	639a      	str	r2, [r3, #56]	; 0x38

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   111b0:	6a3b      	ldr	r3, [r7, #32]
   111b2:	691b      	ldr	r3, [r3, #16]
   111b4:	2b00      	cmp	r3, #0
   111b6:	d008      	beq.n	111ca <xQueueReceive+0x78>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   111b8:	6a3b      	ldr	r3, [r7, #32]
   111ba:	3310      	adds	r3, #16
   111bc:	0018      	movs	r0, r3
   111be:	f000 fe15 	bl	11dec <xTaskRemoveFromEventList>
   111c2:	1e03      	subs	r3, r0, #0
   111c4:	d001      	beq.n	111ca <xQueueReceive+0x78>
					{
						queueYIELD_IF_USING_PREEMPTION();
   111c6:	f001 fa13 	bl	125f0 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
   111ca:	f001 fa33 	bl	12634 <vPortExitCritical>
				return pdPASS;
   111ce:	2301      	movs	r3, #1
   111d0:	e062      	b.n	11298 <xQueueReceive+0x146>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
   111d2:	687b      	ldr	r3, [r7, #4]
   111d4:	2b00      	cmp	r3, #0
   111d6:	d103      	bne.n	111e0 <xQueueReceive+0x8e>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
   111d8:	f001 fa2c 	bl	12634 <vPortExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
   111dc:	2300      	movs	r3, #0
   111de:	e05b      	b.n	11298 <xQueueReceive+0x146>
				}
				else if( xEntryTimeSet == pdFALSE )
   111e0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   111e2:	2b00      	cmp	r3, #0
   111e4:	d106      	bne.n	111f4 <xQueueReceive+0xa2>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
   111e6:	2314      	movs	r3, #20
   111e8:	18fb      	adds	r3, r7, r3
   111ea:	0018      	movs	r0, r3
   111ec:	f000 fe5a 	bl	11ea4 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
   111f0:	2301      	movs	r3, #1
   111f2:	627b      	str	r3, [r7, #36]	; 0x24
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
   111f4:	f001 fa1e 	bl	12634 <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
   111f8:	f000 fc3c 	bl	11a74 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
   111fc:	f001 fa08 	bl	12610 <vPortEnterCritical>
   11200:	6a3b      	ldr	r3, [r7, #32]
   11202:	2244      	movs	r2, #68	; 0x44
   11204:	5c9b      	ldrb	r3, [r3, r2]
   11206:	b25b      	sxtb	r3, r3
   11208:	3301      	adds	r3, #1
   1120a:	d103      	bne.n	11214 <xQueueReceive+0xc2>
   1120c:	6a3b      	ldr	r3, [r7, #32]
   1120e:	2244      	movs	r2, #68	; 0x44
   11210:	2100      	movs	r1, #0
   11212:	5499      	strb	r1, [r3, r2]
   11214:	6a3b      	ldr	r3, [r7, #32]
   11216:	2245      	movs	r2, #69	; 0x45
   11218:	5c9b      	ldrb	r3, [r3, r2]
   1121a:	b25b      	sxtb	r3, r3
   1121c:	3301      	adds	r3, #1
   1121e:	d103      	bne.n	11228 <xQueueReceive+0xd6>
   11220:	6a3b      	ldr	r3, [r7, #32]
   11222:	2245      	movs	r2, #69	; 0x45
   11224:	2100      	movs	r1, #0
   11226:	5499      	strb	r1, [r3, r2]
   11228:	f001 fa04 	bl	12634 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   1122c:	1d3a      	adds	r2, r7, #4
   1122e:	2314      	movs	r3, #20
   11230:	18fb      	adds	r3, r7, r3
   11232:	0011      	movs	r1, r2
   11234:	0018      	movs	r0, r3
   11236:	f000 fe49 	bl	11ecc <xTaskCheckForTimeOut>
   1123a:	1e03      	subs	r3, r0, #0
   1123c:	d11e      	bne.n	1127c <xQueueReceive+0x12a>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   1123e:	6a3b      	ldr	r3, [r7, #32]
   11240:	0018      	movs	r0, r3
   11242:	f000 fa08 	bl	11656 <prvIsQueueEmpty>
   11246:	1e03      	subs	r3, r0, #0
   11248:	d011      	beq.n	1126e <xQueueReceive+0x11c>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
   1124a:	6a3b      	ldr	r3, [r7, #32]
   1124c:	3324      	adds	r3, #36	; 0x24
   1124e:	687a      	ldr	r2, [r7, #4]
   11250:	0011      	movs	r1, r2
   11252:	0018      	movs	r0, r3
   11254:	f000 fdac 	bl	11db0 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
   11258:	6a3b      	ldr	r3, [r7, #32]
   1125a:	0018      	movs	r0, r3
   1125c:	f000 f99d 	bl	1159a <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
   11260:	f000 fc14 	bl	11a8c <xTaskResumeAll>
   11264:	1e03      	subs	r3, r0, #0
   11266:	d191      	bne.n	1118c <xQueueReceive+0x3a>
				{
					portYIELD_WITHIN_API();
   11268:	f001 f9c2 	bl	125f0 <vPortYield>
   1126c:	e78e      	b.n	1118c <xQueueReceive+0x3a>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
   1126e:	6a3b      	ldr	r3, [r7, #32]
   11270:	0018      	movs	r0, r3
   11272:	f000 f992 	bl	1159a <prvUnlockQueue>
				( void ) xTaskResumeAll();
   11276:	f000 fc09 	bl	11a8c <xTaskResumeAll>
   1127a:	e787      	b.n	1118c <xQueueReceive+0x3a>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
   1127c:	6a3b      	ldr	r3, [r7, #32]
   1127e:	0018      	movs	r0, r3
   11280:	f000 f98b 	bl	1159a <prvUnlockQueue>
			( void ) xTaskResumeAll();
   11284:	f000 fc02 	bl	11a8c <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   11288:	6a3b      	ldr	r3, [r7, #32]
   1128a:	0018      	movs	r0, r3
   1128c:	f000 f9e3 	bl	11656 <prvIsQueueEmpty>
   11290:	1e03      	subs	r3, r0, #0
   11292:	d100      	bne.n	11296 <xQueueReceive+0x144>
   11294:	e77a      	b.n	1118c <xQueueReceive+0x3a>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
   11296:	2300      	movs	r3, #0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
   11298:	0018      	movs	r0, r3
   1129a:	46bd      	mov	sp, r7
   1129c:	b00a      	add	sp, #40	; 0x28
   1129e:	bd80      	pop	{r7, pc}

000112a0 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
   112a0:	b580      	push	{r7, lr}
   112a2:	b088      	sub	sp, #32
   112a4:	af00      	add	r7, sp, #0
   112a6:	6078      	str	r0, [r7, #4]
   112a8:	6039      	str	r1, [r7, #0]
BaseType_t xEntryTimeSet = pdFALSE;
   112aa:	2300      	movs	r3, #0
   112ac:	61fb      	str	r3, [r7, #28]
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   112ae:	687b      	ldr	r3, [r7, #4]
   112b0:	61bb      	str	r3, [r7, #24]
#if( configUSE_MUTEXES == 1 )
	BaseType_t xInheritanceOccurred = pdFALSE;
#endif

	/* Check the queue pointer is not NULL. */
	configASSERT( ( pxQueue ) );
   112b2:	69bb      	ldr	r3, [r7, #24]
   112b4:	2b00      	cmp	r3, #0
   112b6:	d101      	bne.n	112bc <xQueueSemaphoreTake+0x1c>
   112b8:	b672      	cpsid	i
   112ba:	e7fe      	b.n	112ba <xQueueSemaphoreTake+0x1a>

	/* Check this really is a semaphore, in which case the item size will be
	0. */
	configASSERT( pxQueue->uxItemSize == 0 );
   112bc:	69bb      	ldr	r3, [r7, #24]
   112be:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   112c0:	2b00      	cmp	r3, #0
   112c2:	d001      	beq.n	112c8 <xQueueSemaphoreTake+0x28>
   112c4:	b672      	cpsid	i
   112c6:	e7fe      	b.n	112c6 <xQueueSemaphoreTake+0x26>
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
   112c8:	f001 f9a2 	bl	12610 <vPortEnterCritical>
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
   112cc:	69bb      	ldr	r3, [r7, #24]
   112ce:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   112d0:	617b      	str	r3, [r7, #20]

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
   112d2:	697b      	ldr	r3, [r7, #20]
   112d4:	2b00      	cmp	r3, #0
   112d6:	d014      	beq.n	11302 <xQueueSemaphoreTake+0x62>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
   112d8:	697b      	ldr	r3, [r7, #20]
   112da:	1e5a      	subs	r2, r3, #1
   112dc:	69bb      	ldr	r3, [r7, #24]
   112de:	639a      	str	r2, [r3, #56]	; 0x38
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   112e0:	69bb      	ldr	r3, [r7, #24]
   112e2:	691b      	ldr	r3, [r3, #16]
   112e4:	2b00      	cmp	r3, #0
   112e6:	d008      	beq.n	112fa <xQueueSemaphoreTake+0x5a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   112e8:	69bb      	ldr	r3, [r7, #24]
   112ea:	3310      	adds	r3, #16
   112ec:	0018      	movs	r0, r3
   112ee:	f000 fd7d 	bl	11dec <xTaskRemoveFromEventList>
   112f2:	1e03      	subs	r3, r0, #0
   112f4:	d001      	beq.n	112fa <xQueueSemaphoreTake+0x5a>
					{
						queueYIELD_IF_USING_PREEMPTION();
   112f6:	f001 f97b 	bl	125f0 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
   112fa:	f001 f99b 	bl	12634 <vPortExitCritical>
				return pdPASS;
   112fe:	2301      	movs	r3, #1
   11300:	e062      	b.n	113c8 <xQueueSemaphoreTake+0x128>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
   11302:	683b      	ldr	r3, [r7, #0]
   11304:	2b00      	cmp	r3, #0
   11306:	d103      	bne.n	11310 <xQueueSemaphoreTake+0x70>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
   11308:	f001 f994 	bl	12634 <vPortExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
   1130c:	2300      	movs	r3, #0
   1130e:	e05b      	b.n	113c8 <xQueueSemaphoreTake+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
   11310:	69fb      	ldr	r3, [r7, #28]
   11312:	2b00      	cmp	r3, #0
   11314:	d106      	bne.n	11324 <xQueueSemaphoreTake+0x84>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
   11316:	230c      	movs	r3, #12
   11318:	18fb      	adds	r3, r7, r3
   1131a:	0018      	movs	r0, r3
   1131c:	f000 fdc2 	bl	11ea4 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
   11320:	2301      	movs	r3, #1
   11322:	61fb      	str	r3, [r7, #28]
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
   11324:	f001 f986 	bl	12634 <vPortExitCritical>

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
   11328:	f000 fba4 	bl	11a74 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
   1132c:	f001 f970 	bl	12610 <vPortEnterCritical>
   11330:	69bb      	ldr	r3, [r7, #24]
   11332:	2244      	movs	r2, #68	; 0x44
   11334:	5c9b      	ldrb	r3, [r3, r2]
   11336:	b25b      	sxtb	r3, r3
   11338:	3301      	adds	r3, #1
   1133a:	d103      	bne.n	11344 <xQueueSemaphoreTake+0xa4>
   1133c:	69bb      	ldr	r3, [r7, #24]
   1133e:	2244      	movs	r2, #68	; 0x44
   11340:	2100      	movs	r1, #0
   11342:	5499      	strb	r1, [r3, r2]
   11344:	69bb      	ldr	r3, [r7, #24]
   11346:	2245      	movs	r2, #69	; 0x45
   11348:	5c9b      	ldrb	r3, [r3, r2]
   1134a:	b25b      	sxtb	r3, r3
   1134c:	3301      	adds	r3, #1
   1134e:	d103      	bne.n	11358 <xQueueSemaphoreTake+0xb8>
   11350:	69bb      	ldr	r3, [r7, #24]
   11352:	2245      	movs	r2, #69	; 0x45
   11354:	2100      	movs	r1, #0
   11356:	5499      	strb	r1, [r3, r2]
   11358:	f001 f96c 	bl	12634 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   1135c:	003a      	movs	r2, r7
   1135e:	230c      	movs	r3, #12
   11360:	18fb      	adds	r3, r7, r3
   11362:	0011      	movs	r1, r2
   11364:	0018      	movs	r0, r3
   11366:	f000 fdb1 	bl	11ecc <xTaskCheckForTimeOut>
   1136a:	1e03      	subs	r3, r0, #0
   1136c:	d11e      	bne.n	113ac <xQueueSemaphoreTake+0x10c>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   1136e:	69bb      	ldr	r3, [r7, #24]
   11370:	0018      	movs	r0, r3
   11372:	f000 f970 	bl	11656 <prvIsQueueEmpty>
   11376:	1e03      	subs	r3, r0, #0
   11378:	d011      	beq.n	1139e <xQueueSemaphoreTake+0xfe>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
   1137a:	69bb      	ldr	r3, [r7, #24]
   1137c:	3324      	adds	r3, #36	; 0x24
   1137e:	683a      	ldr	r2, [r7, #0]
   11380:	0011      	movs	r1, r2
   11382:	0018      	movs	r0, r3
   11384:	f000 fd14 	bl	11db0 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
   11388:	69bb      	ldr	r3, [r7, #24]
   1138a:	0018      	movs	r0, r3
   1138c:	f000 f905 	bl	1159a <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
   11390:	f000 fb7c 	bl	11a8c <xTaskResumeAll>
   11394:	1e03      	subs	r3, r0, #0
   11396:	d197      	bne.n	112c8 <xQueueSemaphoreTake+0x28>
				{
					portYIELD_WITHIN_API();
   11398:	f001 f92a 	bl	125f0 <vPortYield>
   1139c:	e794      	b.n	112c8 <xQueueSemaphoreTake+0x28>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
   1139e:	69bb      	ldr	r3, [r7, #24]
   113a0:	0018      	movs	r0, r3
   113a2:	f000 f8fa 	bl	1159a <prvUnlockQueue>
				( void ) xTaskResumeAll();
   113a6:	f000 fb71 	bl	11a8c <xTaskResumeAll>
   113aa:	e78d      	b.n	112c8 <xQueueSemaphoreTake+0x28>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
   113ac:	69bb      	ldr	r3, [r7, #24]
   113ae:	0018      	movs	r0, r3
   113b0:	f000 f8f3 	bl	1159a <prvUnlockQueue>
			( void ) xTaskResumeAll();
   113b4:	f000 fb6a 	bl	11a8c <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   113b8:	69bb      	ldr	r3, [r7, #24]
   113ba:	0018      	movs	r0, r3
   113bc:	f000 f94b 	bl	11656 <prvIsQueueEmpty>
   113c0:	1e03      	subs	r3, r0, #0
   113c2:	d100      	bne.n	113c6 <xQueueSemaphoreTake+0x126>
   113c4:	e780      	b.n	112c8 <xQueueSemaphoreTake+0x28>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
   113c6:	2300      	movs	r3, #0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
   113c8:	0018      	movs	r0, r3
   113ca:	46bd      	mov	sp, r7
   113cc:	b008      	add	sp, #32
   113ce:	bd80      	pop	{r7, pc}

000113d0 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
   113d0:	b590      	push	{r4, r7, lr}
   113d2:	b08b      	sub	sp, #44	; 0x2c
   113d4:	af00      	add	r7, sp, #0
   113d6:	60f8      	str	r0, [r7, #12]
   113d8:	60b9      	str	r1, [r7, #8]
   113da:	607a      	str	r2, [r7, #4]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   113dc:	68fb      	ldr	r3, [r7, #12]
   113de:	623b      	str	r3, [r7, #32]

	configASSERT( pxQueue );
   113e0:	6a3b      	ldr	r3, [r7, #32]
   113e2:	2b00      	cmp	r3, #0
   113e4:	d101      	bne.n	113ea <xQueueReceiveFromISR+0x1a>
   113e6:	b672      	cpsid	i
   113e8:	e7fe      	b.n	113e8 <xQueueReceiveFromISR+0x18>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
   113ea:	68bb      	ldr	r3, [r7, #8]
   113ec:	2b00      	cmp	r3, #0
   113ee:	d103      	bne.n	113f8 <xQueueReceiveFromISR+0x28>
   113f0:	6a3b      	ldr	r3, [r7, #32]
   113f2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   113f4:	2b00      	cmp	r3, #0
   113f6:	d101      	bne.n	113fc <xQueueReceiveFromISR+0x2c>
   113f8:	2301      	movs	r3, #1
   113fa:	e000      	b.n	113fe <xQueueReceiveFromISR+0x2e>
   113fc:	2300      	movs	r3, #0
   113fe:	2b00      	cmp	r3, #0
   11400:	d101      	bne.n	11406 <xQueueReceiveFromISR+0x36>
   11402:	b672      	cpsid	i
   11404:	e7fe      	b.n	11404 <xQueueReceiveFromISR+0x34>
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   11406:	f001 f92d 	bl	12664 <ulSetInterruptMaskFromISR>
   1140a:	0003      	movs	r3, r0
   1140c:	61fb      	str	r3, [r7, #28]
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
   1140e:	6a3b      	ldr	r3, [r7, #32]
   11410:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   11412:	61bb      	str	r3, [r7, #24]

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
   11414:	69bb      	ldr	r3, [r7, #24]
   11416:	2b00      	cmp	r3, #0
   11418:	d032      	beq.n	11480 <xQueueReceiveFromISR+0xb0>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
   1141a:	2417      	movs	r4, #23
   1141c:	193b      	adds	r3, r7, r4
   1141e:	6a3a      	ldr	r2, [r7, #32]
   11420:	2144      	movs	r1, #68	; 0x44
   11422:	5c52      	ldrb	r2, [r2, r1]
   11424:	701a      	strb	r2, [r3, #0]

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
   11426:	68ba      	ldr	r2, [r7, #8]
   11428:	6a3b      	ldr	r3, [r7, #32]
   1142a:	0011      	movs	r1, r2
   1142c:	0018      	movs	r0, r3
   1142e:	f000 f88e 	bl	1154e <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
   11432:	69bb      	ldr	r3, [r7, #24]
   11434:	1e5a      	subs	r2, r3, #1
   11436:	6a3b      	ldr	r3, [r7, #32]
   11438:	639a      	str	r2, [r3, #56]	; 0x38

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
   1143a:	193b      	adds	r3, r7, r4
   1143c:	781b      	ldrb	r3, [r3, #0]
   1143e:	b25b      	sxtb	r3, r3
   11440:	3301      	adds	r3, #1
   11442:	d111      	bne.n	11468 <xQueueReceiveFromISR+0x98>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   11444:	6a3b      	ldr	r3, [r7, #32]
   11446:	691b      	ldr	r3, [r3, #16]
   11448:	2b00      	cmp	r3, #0
   1144a:	d016      	beq.n	1147a <xQueueReceiveFromISR+0xaa>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   1144c:	6a3b      	ldr	r3, [r7, #32]
   1144e:	3310      	adds	r3, #16
   11450:	0018      	movs	r0, r3
   11452:	f000 fccb 	bl	11dec <xTaskRemoveFromEventList>
   11456:	1e03      	subs	r3, r0, #0
   11458:	d00f      	beq.n	1147a <xQueueReceiveFromISR+0xaa>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
   1145a:	687b      	ldr	r3, [r7, #4]
   1145c:	2b00      	cmp	r3, #0
   1145e:	d00c      	beq.n	1147a <xQueueReceiveFromISR+0xaa>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
   11460:	687b      	ldr	r3, [r7, #4]
   11462:	2201      	movs	r2, #1
   11464:	601a      	str	r2, [r3, #0]
   11466:	e008      	b.n	1147a <xQueueReceiveFromISR+0xaa>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
   11468:	2317      	movs	r3, #23
   1146a:	18fb      	adds	r3, r7, r3
   1146c:	781b      	ldrb	r3, [r3, #0]
   1146e:	3301      	adds	r3, #1
   11470:	b2db      	uxtb	r3, r3
   11472:	b259      	sxtb	r1, r3
   11474:	6a3b      	ldr	r3, [r7, #32]
   11476:	2244      	movs	r2, #68	; 0x44
   11478:	5499      	strb	r1, [r3, r2]
			}

			xReturn = pdPASS;
   1147a:	2301      	movs	r3, #1
   1147c:	627b      	str	r3, [r7, #36]	; 0x24
   1147e:	e001      	b.n	11484 <xQueueReceiveFromISR+0xb4>
		}
		else
		{
			xReturn = pdFAIL;
   11480:	2300      	movs	r3, #0
   11482:	627b      	str	r3, [r7, #36]	; 0x24
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   11484:	69fb      	ldr	r3, [r7, #28]
   11486:	0018      	movs	r0, r3
   11488:	f001 f8f2 	bl	12670 <vClearInterruptMaskFromISR>

	return xReturn;
   1148c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
   1148e:	0018      	movs	r0, r3
   11490:	46bd      	mov	sp, r7
   11492:	b00b      	add	sp, #44	; 0x2c
   11494:	bd90      	pop	{r4, r7, pc}

00011496 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
   11496:	b580      	push	{r7, lr}
   11498:	b086      	sub	sp, #24
   1149a:	af00      	add	r7, sp, #0
   1149c:	60f8      	str	r0, [r7, #12]
   1149e:	60b9      	str	r1, [r7, #8]
   114a0:	607a      	str	r2, [r7, #4]
BaseType_t xReturn = pdFALSE;
   114a2:	2300      	movs	r3, #0
   114a4:	613b      	str	r3, [r7, #16]
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
   114a6:	68fb      	ldr	r3, [r7, #12]
   114a8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   114aa:	617b      	str	r3, [r7, #20]

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
   114ac:	68fb      	ldr	r3, [r7, #12]
   114ae:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   114b0:	2b00      	cmp	r3, #0
   114b2:	d043      	beq.n	1153c <prvCopyDataToQueue+0xa6>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
   114b4:	687b      	ldr	r3, [r7, #4]
   114b6:	2b00      	cmp	r3, #0
   114b8:	d119      	bne.n	114ee <prvCopyDataToQueue+0x58>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
   114ba:	68fb      	ldr	r3, [r7, #12]
   114bc:	6898      	ldr	r0, [r3, #8]
   114be:	68fb      	ldr	r3, [r7, #12]
   114c0:	6c1a      	ldr	r2, [r3, #64]	; 0x40
   114c2:	68bb      	ldr	r3, [r7, #8]
   114c4:	0019      	movs	r1, r3
   114c6:	f00d f8e5 	bl	1e694 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
   114ca:	68fb      	ldr	r3, [r7, #12]
   114cc:	689a      	ldr	r2, [r3, #8]
   114ce:	68fb      	ldr	r3, [r7, #12]
   114d0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   114d2:	18d2      	adds	r2, r2, r3
   114d4:	68fb      	ldr	r3, [r7, #12]
   114d6:	609a      	str	r2, [r3, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
   114d8:	68fb      	ldr	r3, [r7, #12]
   114da:	689a      	ldr	r2, [r3, #8]
   114dc:	68fb      	ldr	r3, [r7, #12]
   114de:	685b      	ldr	r3, [r3, #4]
   114e0:	429a      	cmp	r2, r3
   114e2:	d32b      	bcc.n	1153c <prvCopyDataToQueue+0xa6>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
   114e4:	68fb      	ldr	r3, [r7, #12]
   114e6:	681a      	ldr	r2, [r3, #0]
   114e8:	68fb      	ldr	r3, [r7, #12]
   114ea:	609a      	str	r2, [r3, #8]
   114ec:	e026      	b.n	1153c <prvCopyDataToQueue+0xa6>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   114ee:	68fb      	ldr	r3, [r7, #12]
   114f0:	68d8      	ldr	r0, [r3, #12]
   114f2:	68fb      	ldr	r3, [r7, #12]
   114f4:	6c1a      	ldr	r2, [r3, #64]	; 0x40
   114f6:	68bb      	ldr	r3, [r7, #8]
   114f8:	0019      	movs	r1, r3
   114fa:	f00d f8cb 	bl	1e694 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
   114fe:	68fb      	ldr	r3, [r7, #12]
   11500:	68da      	ldr	r2, [r3, #12]
   11502:	68fb      	ldr	r3, [r7, #12]
   11504:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   11506:	425b      	negs	r3, r3
   11508:	18d2      	adds	r2, r2, r3
   1150a:	68fb      	ldr	r3, [r7, #12]
   1150c:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
   1150e:	68fb      	ldr	r3, [r7, #12]
   11510:	68da      	ldr	r2, [r3, #12]
   11512:	68fb      	ldr	r3, [r7, #12]
   11514:	681b      	ldr	r3, [r3, #0]
   11516:	429a      	cmp	r2, r3
   11518:	d207      	bcs.n	1152a <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
   1151a:	68fb      	ldr	r3, [r7, #12]
   1151c:	685a      	ldr	r2, [r3, #4]
   1151e:	68fb      	ldr	r3, [r7, #12]
   11520:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   11522:	425b      	negs	r3, r3
   11524:	18d2      	adds	r2, r2, r3
   11526:	68fb      	ldr	r3, [r7, #12]
   11528:	60da      	str	r2, [r3, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
   1152a:	687b      	ldr	r3, [r7, #4]
   1152c:	2b02      	cmp	r3, #2
   1152e:	d105      	bne.n	1153c <prvCopyDataToQueue+0xa6>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
   11530:	697b      	ldr	r3, [r7, #20]
   11532:	2b00      	cmp	r3, #0
   11534:	d002      	beq.n	1153c <prvCopyDataToQueue+0xa6>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
   11536:	697b      	ldr	r3, [r7, #20]
   11538:	3b01      	subs	r3, #1
   1153a:	617b      	str	r3, [r7, #20]
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
   1153c:	697b      	ldr	r3, [r7, #20]
   1153e:	1c5a      	adds	r2, r3, #1
   11540:	68fb      	ldr	r3, [r7, #12]
   11542:	639a      	str	r2, [r3, #56]	; 0x38

	return xReturn;
   11544:	693b      	ldr	r3, [r7, #16]
}
   11546:	0018      	movs	r0, r3
   11548:	46bd      	mov	sp, r7
   1154a:	b006      	add	sp, #24
   1154c:	bd80      	pop	{r7, pc}

0001154e <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
   1154e:	b580      	push	{r7, lr}
   11550:	b082      	sub	sp, #8
   11552:	af00      	add	r7, sp, #0
   11554:	6078      	str	r0, [r7, #4]
   11556:	6039      	str	r1, [r7, #0]
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
   11558:	687b      	ldr	r3, [r7, #4]
   1155a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   1155c:	2b00      	cmp	r3, #0
   1155e:	d018      	beq.n	11592 <prvCopyDataFromQueue+0x44>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
   11560:	687b      	ldr	r3, [r7, #4]
   11562:	68da      	ldr	r2, [r3, #12]
   11564:	687b      	ldr	r3, [r7, #4]
   11566:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   11568:	18d2      	adds	r2, r2, r3
   1156a:	687b      	ldr	r3, [r7, #4]
   1156c:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
   1156e:	687b      	ldr	r3, [r7, #4]
   11570:	68da      	ldr	r2, [r3, #12]
   11572:	687b      	ldr	r3, [r7, #4]
   11574:	685b      	ldr	r3, [r3, #4]
   11576:	429a      	cmp	r2, r3
   11578:	d303      	bcc.n	11582 <prvCopyDataFromQueue+0x34>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
   1157a:	687b      	ldr	r3, [r7, #4]
   1157c:	681a      	ldr	r2, [r3, #0]
   1157e:	687b      	ldr	r3, [r7, #4]
   11580:	60da      	str	r2, [r3, #12]
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
   11582:	687b      	ldr	r3, [r7, #4]
   11584:	68d9      	ldr	r1, [r3, #12]
   11586:	687b      	ldr	r3, [r7, #4]
   11588:	6c1a      	ldr	r2, [r3, #64]	; 0x40
   1158a:	683b      	ldr	r3, [r7, #0]
   1158c:	0018      	movs	r0, r3
   1158e:	f00d f881 	bl	1e694 <memcpy>
	}
}
   11592:	46c0      	nop			; (mov r8, r8)
   11594:	46bd      	mov	sp, r7
   11596:	b002      	add	sp, #8
   11598:	bd80      	pop	{r7, pc}

0001159a <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
   1159a:	b580      	push	{r7, lr}
   1159c:	b084      	sub	sp, #16
   1159e:	af00      	add	r7, sp, #0
   115a0:	6078      	str	r0, [r7, #4]

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
   115a2:	f001 f835 	bl	12610 <vPortEnterCritical>
	{
		int8_t cTxLock = pxQueue->cTxLock;
   115a6:	230f      	movs	r3, #15
   115a8:	18fb      	adds	r3, r7, r3
   115aa:	687a      	ldr	r2, [r7, #4]
   115ac:	2145      	movs	r1, #69	; 0x45
   115ae:	5c52      	ldrb	r2, [r2, r1]
   115b0:	701a      	strb	r2, [r3, #0]

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
   115b2:	e013      	b.n	115dc <prvUnlockQueue+0x42>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   115b4:	687b      	ldr	r3, [r7, #4]
   115b6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   115b8:	2b00      	cmp	r3, #0
   115ba:	d016      	beq.n	115ea <prvUnlockQueue+0x50>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   115bc:	687b      	ldr	r3, [r7, #4]
   115be:	3324      	adds	r3, #36	; 0x24
   115c0:	0018      	movs	r0, r3
   115c2:	f000 fc13 	bl	11dec <xTaskRemoveFromEventList>
   115c6:	1e03      	subs	r3, r0, #0
   115c8:	d001      	beq.n	115ce <prvUnlockQueue+0x34>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
   115ca:	f000 fccf 	bl	11f6c <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
   115ce:	210f      	movs	r1, #15
   115d0:	187b      	adds	r3, r7, r1
   115d2:	781b      	ldrb	r3, [r3, #0]
   115d4:	3b01      	subs	r3, #1
   115d6:	b2da      	uxtb	r2, r3
   115d8:	187b      	adds	r3, r7, r1
   115da:	701a      	strb	r2, [r3, #0]
		while( cTxLock > queueLOCKED_UNMODIFIED )
   115dc:	230f      	movs	r3, #15
   115de:	18fb      	adds	r3, r7, r3
   115e0:	781b      	ldrb	r3, [r3, #0]
   115e2:	b25b      	sxtb	r3, r3
   115e4:	2b00      	cmp	r3, #0
   115e6:	dce5      	bgt.n	115b4 <prvUnlockQueue+0x1a>
   115e8:	e000      	b.n	115ec <prvUnlockQueue+0x52>
					break;
   115ea:	46c0      	nop			; (mov r8, r8)
		}

		pxQueue->cTxLock = queueUNLOCKED;
   115ec:	687b      	ldr	r3, [r7, #4]
   115ee:	2245      	movs	r2, #69	; 0x45
   115f0:	21ff      	movs	r1, #255	; 0xff
   115f2:	5499      	strb	r1, [r3, r2]
	}
	taskEXIT_CRITICAL();
   115f4:	f001 f81e 	bl	12634 <vPortExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
   115f8:	f001 f80a 	bl	12610 <vPortEnterCritical>
	{
		int8_t cRxLock = pxQueue->cRxLock;
   115fc:	230e      	movs	r3, #14
   115fe:	18fb      	adds	r3, r7, r3
   11600:	687a      	ldr	r2, [r7, #4]
   11602:	2144      	movs	r1, #68	; 0x44
   11604:	5c52      	ldrb	r2, [r2, r1]
   11606:	701a      	strb	r2, [r3, #0]

		while( cRxLock > queueLOCKED_UNMODIFIED )
   11608:	e013      	b.n	11632 <prvUnlockQueue+0x98>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   1160a:	687b      	ldr	r3, [r7, #4]
   1160c:	691b      	ldr	r3, [r3, #16]
   1160e:	2b00      	cmp	r3, #0
   11610:	d016      	beq.n	11640 <prvUnlockQueue+0xa6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   11612:	687b      	ldr	r3, [r7, #4]
   11614:	3310      	adds	r3, #16
   11616:	0018      	movs	r0, r3
   11618:	f000 fbe8 	bl	11dec <xTaskRemoveFromEventList>
   1161c:	1e03      	subs	r3, r0, #0
   1161e:	d001      	beq.n	11624 <prvUnlockQueue+0x8a>
				{
					vTaskMissedYield();
   11620:	f000 fca4 	bl	11f6c <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
   11624:	210e      	movs	r1, #14
   11626:	187b      	adds	r3, r7, r1
   11628:	781b      	ldrb	r3, [r3, #0]
   1162a:	3b01      	subs	r3, #1
   1162c:	b2da      	uxtb	r2, r3
   1162e:	187b      	adds	r3, r7, r1
   11630:	701a      	strb	r2, [r3, #0]
		while( cRxLock > queueLOCKED_UNMODIFIED )
   11632:	230e      	movs	r3, #14
   11634:	18fb      	adds	r3, r7, r3
   11636:	781b      	ldrb	r3, [r3, #0]
   11638:	b25b      	sxtb	r3, r3
   1163a:	2b00      	cmp	r3, #0
   1163c:	dce5      	bgt.n	1160a <prvUnlockQueue+0x70>
   1163e:	e000      	b.n	11642 <prvUnlockQueue+0xa8>
			}
			else
			{
				break;
   11640:	46c0      	nop			; (mov r8, r8)
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
   11642:	687b      	ldr	r3, [r7, #4]
   11644:	2244      	movs	r2, #68	; 0x44
   11646:	21ff      	movs	r1, #255	; 0xff
   11648:	5499      	strb	r1, [r3, r2]
	}
	taskEXIT_CRITICAL();
   1164a:	f000 fff3 	bl	12634 <vPortExitCritical>
}
   1164e:	46c0      	nop			; (mov r8, r8)
   11650:	46bd      	mov	sp, r7
   11652:	b004      	add	sp, #16
   11654:	bd80      	pop	{r7, pc}

00011656 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
   11656:	b580      	push	{r7, lr}
   11658:	b084      	sub	sp, #16
   1165a:	af00      	add	r7, sp, #0
   1165c:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
   1165e:	f000 ffd7 	bl	12610 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
   11662:	687b      	ldr	r3, [r7, #4]
   11664:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   11666:	2b00      	cmp	r3, #0
   11668:	d102      	bne.n	11670 <prvIsQueueEmpty+0x1a>
		{
			xReturn = pdTRUE;
   1166a:	2301      	movs	r3, #1
   1166c:	60fb      	str	r3, [r7, #12]
   1166e:	e001      	b.n	11674 <prvIsQueueEmpty+0x1e>
		}
		else
		{
			xReturn = pdFALSE;
   11670:	2300      	movs	r3, #0
   11672:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
   11674:	f000 ffde 	bl	12634 <vPortExitCritical>

	return xReturn;
   11678:	68fb      	ldr	r3, [r7, #12]
}
   1167a:	0018      	movs	r0, r3
   1167c:	46bd      	mov	sp, r7
   1167e:	b004      	add	sp, #16
   11680:	bd80      	pop	{r7, pc}

00011682 <prvIsQueueFull>:
	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
   11682:	b580      	push	{r7, lr}
   11684:	b084      	sub	sp, #16
   11686:	af00      	add	r7, sp, #0
   11688:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
   1168a:	f000 ffc1 	bl	12610 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
   1168e:	687b      	ldr	r3, [r7, #4]
   11690:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   11692:	687b      	ldr	r3, [r7, #4]
   11694:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   11696:	429a      	cmp	r2, r3
   11698:	d102      	bne.n	116a0 <prvIsQueueFull+0x1e>
		{
			xReturn = pdTRUE;
   1169a:	2301      	movs	r3, #1
   1169c:	60fb      	str	r3, [r7, #12]
   1169e:	e001      	b.n	116a4 <prvIsQueueFull+0x22>
		}
		else
		{
			xReturn = pdFALSE;
   116a0:	2300      	movs	r3, #0
   116a2:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
   116a4:	f000 ffc6 	bl	12634 <vPortExitCritical>

	return xReturn;
   116a8:	68fb      	ldr	r3, [r7, #12]
}
   116aa:	0018      	movs	r0, r3
   116ac:	46bd      	mov	sp, r7
   116ae:	b004      	add	sp, #16
   116b0:	bd80      	pop	{r7, pc}

000116b2 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
   116b2:	b590      	push	{r4, r7, lr}
   116b4:	b08d      	sub	sp, #52	; 0x34
   116b6:	af04      	add	r7, sp, #16
   116b8:	60f8      	str	r0, [r7, #12]
   116ba:	60b9      	str	r1, [r7, #8]
   116bc:	603b      	str	r3, [r7, #0]
   116be:	1dbb      	adds	r3, r7, #6
   116c0:	801a      	strh	r2, [r3, #0]
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   116c2:	1dbb      	adds	r3, r7, #6
   116c4:	881b      	ldrh	r3, [r3, #0]
   116c6:	009b      	lsls	r3, r3, #2
   116c8:	0018      	movs	r0, r3
   116ca:	f000 fd65 	bl	12198 <pvPortMalloc>
   116ce:	0003      	movs	r3, r0
   116d0:	617b      	str	r3, [r7, #20]

			if( pxStack != NULL )
   116d2:	697b      	ldr	r3, [r7, #20]
   116d4:	2b00      	cmp	r3, #0
   116d6:	d010      	beq.n	116fa <xTaskCreate+0x48>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
   116d8:	2044      	movs	r0, #68	; 0x44
   116da:	f000 fd5d 	bl	12198 <pvPortMalloc>
   116de:	0003      	movs	r3, r0
   116e0:	61fb      	str	r3, [r7, #28]

				if( pxNewTCB != NULL )
   116e2:	69fb      	ldr	r3, [r7, #28]
   116e4:	2b00      	cmp	r3, #0
   116e6:	d003      	beq.n	116f0 <xTaskCreate+0x3e>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
   116e8:	69fb      	ldr	r3, [r7, #28]
   116ea:	697a      	ldr	r2, [r7, #20]
   116ec:	631a      	str	r2, [r3, #48]	; 0x30
   116ee:	e006      	b.n	116fe <xTaskCreate+0x4c>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
   116f0:	697b      	ldr	r3, [r7, #20]
   116f2:	0018      	movs	r0, r3
   116f4:	f000 fdf6 	bl	122e4 <vPortFree>
   116f8:	e001      	b.n	116fe <xTaskCreate+0x4c>
				}
			}
			else
			{
				pxNewTCB = NULL;
   116fa:	2300      	movs	r3, #0
   116fc:	61fb      	str	r3, [r7, #28]
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
   116fe:	69fb      	ldr	r3, [r7, #28]
   11700:	2b00      	cmp	r3, #0
   11702:	d016      	beq.n	11732 <xTaskCreate+0x80>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
   11704:	1dbb      	adds	r3, r7, #6
   11706:	881a      	ldrh	r2, [r3, #0]
   11708:	683c      	ldr	r4, [r7, #0]
   1170a:	68b9      	ldr	r1, [r7, #8]
   1170c:	68f8      	ldr	r0, [r7, #12]
   1170e:	2300      	movs	r3, #0
   11710:	9303      	str	r3, [sp, #12]
   11712:	69fb      	ldr	r3, [r7, #28]
   11714:	9302      	str	r3, [sp, #8]
   11716:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   11718:	9301      	str	r3, [sp, #4]
   1171a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   1171c:	9300      	str	r3, [sp, #0]
   1171e:	0023      	movs	r3, r4
   11720:	f000 f810 	bl	11744 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
   11724:	69fb      	ldr	r3, [r7, #28]
   11726:	0018      	movs	r0, r3
   11728:	f000 f880 	bl	1182c <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
   1172c:	2301      	movs	r3, #1
   1172e:	61bb      	str	r3, [r7, #24]
   11730:	e002      	b.n	11738 <xTaskCreate+0x86>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
   11732:	2301      	movs	r3, #1
   11734:	425b      	negs	r3, r3
   11736:	61bb      	str	r3, [r7, #24]
		}

		return xReturn;
   11738:	69bb      	ldr	r3, [r7, #24]
	}
   1173a:	0018      	movs	r0, r3
   1173c:	46bd      	mov	sp, r7
   1173e:	b009      	add	sp, #36	; 0x24
   11740:	bd90      	pop	{r4, r7, pc}
	...

00011744 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
   11744:	b580      	push	{r7, lr}
   11746:	b086      	sub	sp, #24
   11748:	af00      	add	r7, sp, #0
   1174a:	60f8      	str	r0, [r7, #12]
   1174c:	60b9      	str	r1, [r7, #8]
   1174e:	607a      	str	r2, [r7, #4]
   11750:	603b      	str	r3, [r7, #0]
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
   11752:	6abb      	ldr	r3, [r7, #40]	; 0x28
   11754:	6b1a      	ldr	r2, [r3, #48]	; 0x30
   11756:	687b      	ldr	r3, [r7, #4]
   11758:	4933      	ldr	r1, [pc, #204]	; (11828 <prvInitialiseNewTask+0xe4>)
   1175a:	468c      	mov	ip, r1
   1175c:	4463      	add	r3, ip
   1175e:	009b      	lsls	r3, r3, #2
   11760:	18d3      	adds	r3, r2, r3
   11762:	613b      	str	r3, [r7, #16]
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
   11764:	693b      	ldr	r3, [r7, #16]
   11766:	2207      	movs	r2, #7
   11768:	4393      	bics	r3, r2
   1176a:	613b      	str	r3, [r7, #16]

		/* Check the alignment of the calculated top of stack is correct. */
		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
   1176c:	693b      	ldr	r3, [r7, #16]
   1176e:	2207      	movs	r2, #7
   11770:	4013      	ands	r3, r2
   11772:	d001      	beq.n	11778 <prvInitialiseNewTask+0x34>
   11774:	b672      	cpsid	i
   11776:	e7fe      	b.n	11776 <prvInitialiseNewTask+0x32>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
   11778:	2300      	movs	r3, #0
   1177a:	617b      	str	r3, [r7, #20]
   1177c:	e013      	b.n	117a6 <prvInitialiseNewTask+0x62>
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
   1177e:	68ba      	ldr	r2, [r7, #8]
   11780:	697b      	ldr	r3, [r7, #20]
   11782:	18d3      	adds	r3, r2, r3
   11784:	7818      	ldrb	r0, [r3, #0]
   11786:	6aba      	ldr	r2, [r7, #40]	; 0x28
   11788:	2134      	movs	r1, #52	; 0x34
   1178a:	697b      	ldr	r3, [r7, #20]
   1178c:	18d3      	adds	r3, r2, r3
   1178e:	185b      	adds	r3, r3, r1
   11790:	1c02      	adds	r2, r0, #0
   11792:	701a      	strb	r2, [r3, #0]

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
   11794:	68ba      	ldr	r2, [r7, #8]
   11796:	697b      	ldr	r3, [r7, #20]
   11798:	18d3      	adds	r3, r2, r3
   1179a:	781b      	ldrb	r3, [r3, #0]
   1179c:	2b00      	cmp	r3, #0
   1179e:	d006      	beq.n	117ae <prvInitialiseNewTask+0x6a>
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
   117a0:	697b      	ldr	r3, [r7, #20]
   117a2:	3301      	adds	r3, #1
   117a4:	617b      	str	r3, [r7, #20]
   117a6:	697b      	ldr	r3, [r7, #20]
   117a8:	2b07      	cmp	r3, #7
   117aa:	d9e8      	bls.n	1177e <prvInitialiseNewTask+0x3a>
   117ac:	e000      	b.n	117b0 <prvInitialiseNewTask+0x6c>
		{
			break;
   117ae:	46c0      	nop			; (mov r8, r8)
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
   117b0:	6abb      	ldr	r3, [r7, #40]	; 0x28
   117b2:	223b      	movs	r2, #59	; 0x3b
   117b4:	2100      	movs	r1, #0
   117b6:	5499      	strb	r1, [r3, r2]

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
   117b8:	6a3b      	ldr	r3, [r7, #32]
   117ba:	2b06      	cmp	r3, #6
   117bc:	d901      	bls.n	117c2 <prvInitialiseNewTask+0x7e>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
   117be:	2306      	movs	r3, #6
   117c0:	623b      	str	r3, [r7, #32]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
   117c2:	6abb      	ldr	r3, [r7, #40]	; 0x28
   117c4:	6a3a      	ldr	r2, [r7, #32]
   117c6:	62da      	str	r2, [r3, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
   117c8:	6abb      	ldr	r3, [r7, #40]	; 0x28
   117ca:	3304      	adds	r3, #4
   117cc:	0018      	movs	r0, r3
   117ce:	f7ff fa01 	bl	10bd4 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
   117d2:	6abb      	ldr	r3, [r7, #40]	; 0x28
   117d4:	3318      	adds	r3, #24
   117d6:	0018      	movs	r0, r3
   117d8:	f7ff f9fc 	bl	10bd4 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
   117dc:	6abb      	ldr	r3, [r7, #40]	; 0x28
   117de:	6aba      	ldr	r2, [r7, #40]	; 0x28
   117e0:	611a      	str	r2, [r3, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   117e2:	6a3b      	ldr	r3, [r7, #32]
   117e4:	2207      	movs	r2, #7
   117e6:	1ad2      	subs	r2, r2, r3
   117e8:	6abb      	ldr	r3, [r7, #40]	; 0x28
   117ea:	619a      	str	r2, [r3, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
   117ec:	6abb      	ldr	r3, [r7, #40]	; 0x28
   117ee:	6aba      	ldr	r2, [r7, #40]	; 0x28
   117f0:	625a      	str	r2, [r3, #36]	; 0x24
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
   117f2:	6abb      	ldr	r3, [r7, #40]	; 0x28
   117f4:	2200      	movs	r2, #0
   117f6:	63da      	str	r2, [r3, #60]	; 0x3c
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
   117f8:	6abb      	ldr	r3, [r7, #40]	; 0x28
   117fa:	2240      	movs	r2, #64	; 0x40
   117fc:	2100      	movs	r1, #0
   117fe:	5499      	strb	r1, [r3, r2]
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
   11800:	683a      	ldr	r2, [r7, #0]
   11802:	68f9      	ldr	r1, [r7, #12]
   11804:	693b      	ldr	r3, [r7, #16]
   11806:	0018      	movs	r0, r3
   11808:	f000 fe6c 	bl	124e4 <pxPortInitialiseStack>
   1180c:	0002      	movs	r2, r0
   1180e:	6abb      	ldr	r3, [r7, #40]	; 0x28
   11810:	601a      	str	r2, [r3, #0]
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
   11812:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   11814:	2b00      	cmp	r3, #0
   11816:	d002      	beq.n	1181e <prvInitialiseNewTask+0xda>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
   11818:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1181a:	6aba      	ldr	r2, [r7, #40]	; 0x28
   1181c:	601a      	str	r2, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
   1181e:	46c0      	nop			; (mov r8, r8)
   11820:	46bd      	mov	sp, r7
   11822:	b006      	add	sp, #24
   11824:	bd80      	pop	{r7, pc}
   11826:	46c0      	nop			; (mov r8, r8)
   11828:	3fffffff 	.word	0x3fffffff

0001182c <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
   1182c:	b580      	push	{r7, lr}
   1182e:	b082      	sub	sp, #8
   11830:	af00      	add	r7, sp, #0
   11832:	6078      	str	r0, [r7, #4]
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
   11834:	f000 feec 	bl	12610 <vPortEnterCritical>
	{
		uxCurrentNumberOfTasks++;
   11838:	4b28      	ldr	r3, [pc, #160]	; (118dc <prvAddNewTaskToReadyList+0xb0>)
   1183a:	681b      	ldr	r3, [r3, #0]
   1183c:	1c5a      	adds	r2, r3, #1
   1183e:	4b27      	ldr	r3, [pc, #156]	; (118dc <prvAddNewTaskToReadyList+0xb0>)
   11840:	601a      	str	r2, [r3, #0]
		if( pxCurrentTCB == NULL )
   11842:	4b27      	ldr	r3, [pc, #156]	; (118e0 <prvAddNewTaskToReadyList+0xb4>)
   11844:	681b      	ldr	r3, [r3, #0]
   11846:	2b00      	cmp	r3, #0
   11848:	d109      	bne.n	1185e <prvAddNewTaskToReadyList+0x32>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
   1184a:	4b25      	ldr	r3, [pc, #148]	; (118e0 <prvAddNewTaskToReadyList+0xb4>)
   1184c:	687a      	ldr	r2, [r7, #4]
   1184e:	601a      	str	r2, [r3, #0]

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
   11850:	4b22      	ldr	r3, [pc, #136]	; (118dc <prvAddNewTaskToReadyList+0xb0>)
   11852:	681b      	ldr	r3, [r3, #0]
   11854:	2b01      	cmp	r3, #1
   11856:	d110      	bne.n	1187a <prvAddNewTaskToReadyList+0x4e>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
   11858:	f000 fba2 	bl	11fa0 <prvInitialiseTaskLists>
   1185c:	e00d      	b.n	1187a <prvAddNewTaskToReadyList+0x4e>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
   1185e:	4b21      	ldr	r3, [pc, #132]	; (118e4 <prvAddNewTaskToReadyList+0xb8>)
   11860:	681b      	ldr	r3, [r3, #0]
   11862:	2b00      	cmp	r3, #0
   11864:	d109      	bne.n	1187a <prvAddNewTaskToReadyList+0x4e>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
   11866:	4b1e      	ldr	r3, [pc, #120]	; (118e0 <prvAddNewTaskToReadyList+0xb4>)
   11868:	681b      	ldr	r3, [r3, #0]
   1186a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1186c:	687b      	ldr	r3, [r7, #4]
   1186e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   11870:	429a      	cmp	r2, r3
   11872:	d802      	bhi.n	1187a <prvAddNewTaskToReadyList+0x4e>
				{
					pxCurrentTCB = pxNewTCB;
   11874:	4b1a      	ldr	r3, [pc, #104]	; (118e0 <prvAddNewTaskToReadyList+0xb4>)
   11876:	687a      	ldr	r2, [r7, #4]
   11878:	601a      	str	r2, [r3, #0]
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
   1187a:	4b1b      	ldr	r3, [pc, #108]	; (118e8 <prvAddNewTaskToReadyList+0xbc>)
   1187c:	681b      	ldr	r3, [r3, #0]
   1187e:	1c5a      	adds	r2, r3, #1
   11880:	4b19      	ldr	r3, [pc, #100]	; (118e8 <prvAddNewTaskToReadyList+0xbc>)
   11882:	601a      	str	r2, [r3, #0]
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
   11884:	687b      	ldr	r3, [r7, #4]
   11886:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   11888:	4b18      	ldr	r3, [pc, #96]	; (118ec <prvAddNewTaskToReadyList+0xc0>)
   1188a:	681b      	ldr	r3, [r3, #0]
   1188c:	429a      	cmp	r2, r3
   1188e:	d903      	bls.n	11898 <prvAddNewTaskToReadyList+0x6c>
   11890:	687b      	ldr	r3, [r7, #4]
   11892:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   11894:	4b15      	ldr	r3, [pc, #84]	; (118ec <prvAddNewTaskToReadyList+0xc0>)
   11896:	601a      	str	r2, [r3, #0]
   11898:	687b      	ldr	r3, [r7, #4]
   1189a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1189c:	0013      	movs	r3, r2
   1189e:	009b      	lsls	r3, r3, #2
   118a0:	189b      	adds	r3, r3, r2
   118a2:	009b      	lsls	r3, r3, #2
   118a4:	4a12      	ldr	r2, [pc, #72]	; (118f0 <prvAddNewTaskToReadyList+0xc4>)
   118a6:	189a      	adds	r2, r3, r2
   118a8:	687b      	ldr	r3, [r7, #4]
   118aa:	3304      	adds	r3, #4
   118ac:	0019      	movs	r1, r3
   118ae:	0010      	movs	r0, r2
   118b0:	f7ff f99b 	bl	10bea <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
   118b4:	f000 febe 	bl	12634 <vPortExitCritical>

	if( xSchedulerRunning != pdFALSE )
   118b8:	4b0a      	ldr	r3, [pc, #40]	; (118e4 <prvAddNewTaskToReadyList+0xb8>)
   118ba:	681b      	ldr	r3, [r3, #0]
   118bc:	2b00      	cmp	r3, #0
   118be:	d008      	beq.n	118d2 <prvAddNewTaskToReadyList+0xa6>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
   118c0:	4b07      	ldr	r3, [pc, #28]	; (118e0 <prvAddNewTaskToReadyList+0xb4>)
   118c2:	681b      	ldr	r3, [r3, #0]
   118c4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   118c6:	687b      	ldr	r3, [r7, #4]
   118c8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   118ca:	429a      	cmp	r2, r3
   118cc:	d201      	bcs.n	118d2 <prvAddNewTaskToReadyList+0xa6>
		{
			taskYIELD_IF_USING_PREEMPTION();
   118ce:	f000 fe8f 	bl	125f0 <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
   118d2:	46c0      	nop			; (mov r8, r8)
   118d4:	46bd      	mov	sp, r7
   118d6:	b002      	add	sp, #8
   118d8:	bd80      	pop	{r7, pc}
   118da:	46c0      	nop			; (mov r8, r8)
   118dc:	0003024c 	.word	0x0003024c
   118e0:	0003014c 	.word	0x0003014c
   118e4:	00030258 	.word	0x00030258
   118e8:	00030268 	.word	0x00030268
   118ec:	00030254 	.word	0x00030254
   118f0:	00030150 	.word	0x00030150

000118f4 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
   118f4:	b580      	push	{r7, lr}
   118f6:	b084      	sub	sp, #16
   118f8:	af00      	add	r7, sp, #0
   118fa:	6078      	str	r0, [r7, #4]
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
   118fc:	f000 fe88 	bl	12610 <vPortEnterCritical>
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
   11900:	687b      	ldr	r3, [r7, #4]
   11902:	2b00      	cmp	r3, #0
   11904:	d102      	bne.n	1190c <vTaskDelete+0x18>
   11906:	4b26      	ldr	r3, [pc, #152]	; (119a0 <vTaskDelete+0xac>)
   11908:	681b      	ldr	r3, [r3, #0]
   1190a:	e000      	b.n	1190e <vTaskDelete+0x1a>
   1190c:	687b      	ldr	r3, [r7, #4]
   1190e:	60fb      	str	r3, [r7, #12]

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   11910:	68fb      	ldr	r3, [r7, #12]
   11912:	3304      	adds	r3, #4
   11914:	0018      	movs	r0, r3
   11916:	f7ff f9c0 	bl	10c9a <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   1191a:	68fb      	ldr	r3, [r7, #12]
   1191c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   1191e:	2b00      	cmp	r3, #0
   11920:	d004      	beq.n	1192c <vTaskDelete+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   11922:	68fb      	ldr	r3, [r7, #12]
   11924:	3318      	adds	r3, #24
   11926:	0018      	movs	r0, r3
   11928:	f7ff f9b7 	bl	10c9a <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
   1192c:	4b1d      	ldr	r3, [pc, #116]	; (119a4 <vTaskDelete+0xb0>)
   1192e:	681b      	ldr	r3, [r3, #0]
   11930:	1c5a      	adds	r2, r3, #1
   11932:	4b1c      	ldr	r3, [pc, #112]	; (119a4 <vTaskDelete+0xb0>)
   11934:	601a      	str	r2, [r3, #0]

			if( pxTCB == pxCurrentTCB )
   11936:	4b1a      	ldr	r3, [pc, #104]	; (119a0 <vTaskDelete+0xac>)
   11938:	681b      	ldr	r3, [r3, #0]
   1193a:	68fa      	ldr	r2, [r7, #12]
   1193c:	429a      	cmp	r2, r3
   1193e:	d10c      	bne.n	1195a <vTaskDelete+0x66>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
   11940:	68fb      	ldr	r3, [r7, #12]
   11942:	1d1a      	adds	r2, r3, #4
   11944:	4b18      	ldr	r3, [pc, #96]	; (119a8 <vTaskDelete+0xb4>)
   11946:	0011      	movs	r1, r2
   11948:	0018      	movs	r0, r3
   1194a:	f7ff f94e 	bl	10bea <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
   1194e:	4b17      	ldr	r3, [pc, #92]	; (119ac <vTaskDelete+0xb8>)
   11950:	681b      	ldr	r3, [r3, #0]
   11952:	1c5a      	adds	r2, r3, #1
   11954:	4b15      	ldr	r3, [pc, #84]	; (119ac <vTaskDelete+0xb8>)
   11956:	601a      	str	r2, [r3, #0]
   11958:	e00a      	b.n	11970 <vTaskDelete+0x7c>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
   1195a:	4b15      	ldr	r3, [pc, #84]	; (119b0 <vTaskDelete+0xbc>)
   1195c:	681b      	ldr	r3, [r3, #0]
   1195e:	1e5a      	subs	r2, r3, #1
   11960:	4b13      	ldr	r3, [pc, #76]	; (119b0 <vTaskDelete+0xbc>)
   11962:	601a      	str	r2, [r3, #0]
				prvDeleteTCB( pxTCB );
   11964:	68fb      	ldr	r3, [r7, #12]
   11966:	0018      	movs	r0, r3
   11968:	f000 fb8c 	bl	12084 <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
   1196c:	f000 fb9c 	bl	120a8 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
   11970:	f000 fe60 	bl	12634 <vPortExitCritical>

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
   11974:	4b0f      	ldr	r3, [pc, #60]	; (119b4 <vTaskDelete+0xc0>)
   11976:	681b      	ldr	r3, [r3, #0]
   11978:	2b00      	cmp	r3, #0
   1197a:	d00c      	beq.n	11996 <vTaskDelete+0xa2>
		{
			if( pxTCB == pxCurrentTCB )
   1197c:	4b08      	ldr	r3, [pc, #32]	; (119a0 <vTaskDelete+0xac>)
   1197e:	681b      	ldr	r3, [r3, #0]
   11980:	68fa      	ldr	r2, [r7, #12]
   11982:	429a      	cmp	r2, r3
   11984:	d107      	bne.n	11996 <vTaskDelete+0xa2>
			{
				configASSERT( uxSchedulerSuspended == 0 );
   11986:	4b0c      	ldr	r3, [pc, #48]	; (119b8 <vTaskDelete+0xc4>)
   11988:	681b      	ldr	r3, [r3, #0]
   1198a:	2b00      	cmp	r3, #0
   1198c:	d001      	beq.n	11992 <vTaskDelete+0x9e>
   1198e:	b672      	cpsid	i
   11990:	e7fe      	b.n	11990 <vTaskDelete+0x9c>
				portYIELD_WITHIN_API();
   11992:	f000 fe2d 	bl	125f0 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
   11996:	46c0      	nop			; (mov r8, r8)
   11998:	46bd      	mov	sp, r7
   1199a:	b004      	add	sp, #16
   1199c:	bd80      	pop	{r7, pc}
   1199e:	46c0      	nop			; (mov r8, r8)
   119a0:	0003014c 	.word	0x0003014c
   119a4:	00030268 	.word	0x00030268
   119a8:	00030220 	.word	0x00030220
   119ac:	00030234 	.word	0x00030234
   119b0:	0003024c 	.word	0x0003024c
   119b4:	00030258 	.word	0x00030258
   119b8:	00030274 	.word	0x00030274

000119bc <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
   119bc:	b580      	push	{r7, lr}
   119be:	b084      	sub	sp, #16
   119c0:	af00      	add	r7, sp, #0
   119c2:	6078      	str	r0, [r7, #4]
	BaseType_t xAlreadyYielded = pdFALSE;
   119c4:	2300      	movs	r3, #0
   119c6:	60fb      	str	r3, [r7, #12]

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
   119c8:	687b      	ldr	r3, [r7, #4]
   119ca:	2b00      	cmp	r3, #0
   119cc:	d010      	beq.n	119f0 <vTaskDelay+0x34>
		{
			configASSERT( uxSchedulerSuspended == 0 );
   119ce:	4b0d      	ldr	r3, [pc, #52]	; (11a04 <vTaskDelay+0x48>)
   119d0:	681b      	ldr	r3, [r3, #0]
   119d2:	2b00      	cmp	r3, #0
   119d4:	d001      	beq.n	119da <vTaskDelay+0x1e>
   119d6:	b672      	cpsid	i
   119d8:	e7fe      	b.n	119d8 <vTaskDelay+0x1c>
			vTaskSuspendAll();
   119da:	f000 f84b 	bl	11a74 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
   119de:	687b      	ldr	r3, [r7, #4]
   119e0:	2100      	movs	r1, #0
   119e2:	0018      	movs	r0, r3
   119e4:	f000 fb84 	bl	120f0 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
   119e8:	f000 f850 	bl	11a8c <xTaskResumeAll>
   119ec:	0003      	movs	r3, r0
   119ee:	60fb      	str	r3, [r7, #12]
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
   119f0:	68fb      	ldr	r3, [r7, #12]
   119f2:	2b00      	cmp	r3, #0
   119f4:	d101      	bne.n	119fa <vTaskDelay+0x3e>
		{
			portYIELD_WITHIN_API();
   119f6:	f000 fdfb 	bl	125f0 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
   119fa:	46c0      	nop			; (mov r8, r8)
   119fc:	46bd      	mov	sp, r7
   119fe:	b004      	add	sp, #16
   11a00:	bd80      	pop	{r7, pc}
   11a02:	46c0      	nop			; (mov r8, r8)
   11a04:	00030274 	.word	0x00030274

00011a08 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
   11a08:	b580      	push	{r7, lr}
   11a0a:	b084      	sub	sp, #16
   11a0c:	af02      	add	r7, sp, #8
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
   11a0e:	4913      	ldr	r1, [pc, #76]	; (11a5c <vTaskStartScheduler+0x54>)
   11a10:	4813      	ldr	r0, [pc, #76]	; (11a60 <vTaskStartScheduler+0x58>)
   11a12:	4b14      	ldr	r3, [pc, #80]	; (11a64 <vTaskStartScheduler+0x5c>)
   11a14:	9301      	str	r3, [sp, #4]
   11a16:	2300      	movs	r3, #0
   11a18:	9300      	str	r3, [sp, #0]
   11a1a:	2300      	movs	r3, #0
   11a1c:	2228      	movs	r2, #40	; 0x28
   11a1e:	f7ff fe48 	bl	116b2 <xTaskCreate>
   11a22:	0003      	movs	r3, r0
   11a24:	607b      	str	r3, [r7, #4]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
   11a26:	687b      	ldr	r3, [r7, #4]
   11a28:	2b01      	cmp	r3, #1
   11a2a:	d10d      	bne.n	11a48 <vTaskStartScheduler+0x40>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
   11a2c:	b672      	cpsid	i
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
   11a2e:	4b0e      	ldr	r3, [pc, #56]	; (11a68 <vTaskStartScheduler+0x60>)
   11a30:	2201      	movs	r2, #1
   11a32:	4252      	negs	r2, r2
   11a34:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
   11a36:	4b0d      	ldr	r3, [pc, #52]	; (11a6c <vTaskStartScheduler+0x64>)
   11a38:	2201      	movs	r2, #1
   11a3a:	601a      	str	r2, [r3, #0]
		xTickCount = ( TickType_t ) 0U;
   11a3c:	4b0c      	ldr	r3, [pc, #48]	; (11a70 <vTaskStartScheduler+0x68>)
   11a3e:	2200      	movs	r2, #0
   11a40:	601a      	str	r2, [r3, #0]
		FreeRTOSConfig.h file. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
   11a42:	f000 fdb1 	bl	125a8 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
   11a46:	e004      	b.n	11a52 <vTaskStartScheduler+0x4a>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
   11a48:	687b      	ldr	r3, [r7, #4]
   11a4a:	3301      	adds	r3, #1
   11a4c:	d101      	bne.n	11a52 <vTaskStartScheduler+0x4a>
   11a4e:	b672      	cpsid	i
   11a50:	e7fe      	b.n	11a50 <vTaskStartScheduler+0x48>
}
   11a52:	46c0      	nop			; (mov r8, r8)
   11a54:	46bd      	mov	sp, r7
   11a56:	b002      	add	sp, #8
   11a58:	bd80      	pop	{r7, pc}
   11a5a:	46c0      	nop			; (mov r8, r8)
   11a5c:	0001f644 	.word	0x0001f644
   11a60:	00011f81 	.word	0x00011f81
   11a64:	00030270 	.word	0x00030270
   11a68:	0003026c 	.word	0x0003026c
   11a6c:	00030258 	.word	0x00030258
   11a70:	00030250 	.word	0x00030250

00011a74 <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
   11a74:	b580      	push	{r7, lr}
   11a76:	af00      	add	r7, sp, #0
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
   11a78:	4b03      	ldr	r3, [pc, #12]	; (11a88 <vTaskSuspendAll+0x14>)
   11a7a:	681b      	ldr	r3, [r3, #0]
   11a7c:	1c5a      	adds	r2, r3, #1
   11a7e:	4b02      	ldr	r3, [pc, #8]	; (11a88 <vTaskSuspendAll+0x14>)
   11a80:	601a      	str	r2, [r3, #0]
}
   11a82:	46c0      	nop			; (mov r8, r8)
   11a84:	46bd      	mov	sp, r7
   11a86:	bd80      	pop	{r7, pc}
   11a88:	00030274 	.word	0x00030274

00011a8c <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
   11a8c:	b580      	push	{r7, lr}
   11a8e:	b084      	sub	sp, #16
   11a90:	af00      	add	r7, sp, #0
TCB_t *pxTCB = NULL;
   11a92:	2300      	movs	r3, #0
   11a94:	60fb      	str	r3, [r7, #12]
BaseType_t xAlreadyYielded = pdFALSE;
   11a96:	2300      	movs	r3, #0
   11a98:	60bb      	str	r3, [r7, #8]

	/* If uxSchedulerSuspended is zero then this function does not match a
	previous call to vTaskSuspendAll(). */
	configASSERT( uxSchedulerSuspended );
   11a9a:	4b3a      	ldr	r3, [pc, #232]	; (11b84 <xTaskResumeAll+0xf8>)
   11a9c:	681b      	ldr	r3, [r3, #0]
   11a9e:	2b00      	cmp	r3, #0
   11aa0:	d101      	bne.n	11aa6 <xTaskResumeAll+0x1a>
   11aa2:	b672      	cpsid	i
   11aa4:	e7fe      	b.n	11aa4 <xTaskResumeAll+0x18>
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
   11aa6:	f000 fdb3 	bl	12610 <vPortEnterCritical>
	{
		--uxSchedulerSuspended;
   11aaa:	4b36      	ldr	r3, [pc, #216]	; (11b84 <xTaskResumeAll+0xf8>)
   11aac:	681b      	ldr	r3, [r3, #0]
   11aae:	1e5a      	subs	r2, r3, #1
   11ab0:	4b34      	ldr	r3, [pc, #208]	; (11b84 <xTaskResumeAll+0xf8>)
   11ab2:	601a      	str	r2, [r3, #0]

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   11ab4:	4b33      	ldr	r3, [pc, #204]	; (11b84 <xTaskResumeAll+0xf8>)
   11ab6:	681b      	ldr	r3, [r3, #0]
   11ab8:	2b00      	cmp	r3, #0
   11aba:	d15b      	bne.n	11b74 <xTaskResumeAll+0xe8>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
   11abc:	4b32      	ldr	r3, [pc, #200]	; (11b88 <xTaskResumeAll+0xfc>)
   11abe:	681b      	ldr	r3, [r3, #0]
   11ac0:	2b00      	cmp	r3, #0
   11ac2:	d057      	beq.n	11b74 <xTaskResumeAll+0xe8>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
   11ac4:	e02f      	b.n	11b26 <xTaskResumeAll+0x9a>
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
   11ac6:	4b31      	ldr	r3, [pc, #196]	; (11b8c <xTaskResumeAll+0x100>)
   11ac8:	68db      	ldr	r3, [r3, #12]
   11aca:	68db      	ldr	r3, [r3, #12]
   11acc:	60fb      	str	r3, [r7, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   11ace:	68fb      	ldr	r3, [r7, #12]
   11ad0:	3318      	adds	r3, #24
   11ad2:	0018      	movs	r0, r3
   11ad4:	f7ff f8e1 	bl	10c9a <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   11ad8:	68fb      	ldr	r3, [r7, #12]
   11ada:	3304      	adds	r3, #4
   11adc:	0018      	movs	r0, r3
   11ade:	f7ff f8dc 	bl	10c9a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
   11ae2:	68fb      	ldr	r3, [r7, #12]
   11ae4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   11ae6:	4b2a      	ldr	r3, [pc, #168]	; (11b90 <xTaskResumeAll+0x104>)
   11ae8:	681b      	ldr	r3, [r3, #0]
   11aea:	429a      	cmp	r2, r3
   11aec:	d903      	bls.n	11af6 <xTaskResumeAll+0x6a>
   11aee:	68fb      	ldr	r3, [r7, #12]
   11af0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   11af2:	4b27      	ldr	r3, [pc, #156]	; (11b90 <xTaskResumeAll+0x104>)
   11af4:	601a      	str	r2, [r3, #0]
   11af6:	68fb      	ldr	r3, [r7, #12]
   11af8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   11afa:	0013      	movs	r3, r2
   11afc:	009b      	lsls	r3, r3, #2
   11afe:	189b      	adds	r3, r3, r2
   11b00:	009b      	lsls	r3, r3, #2
   11b02:	4a24      	ldr	r2, [pc, #144]	; (11b94 <xTaskResumeAll+0x108>)
   11b04:	189a      	adds	r2, r3, r2
   11b06:	68fb      	ldr	r3, [r7, #12]
   11b08:	3304      	adds	r3, #4
   11b0a:	0019      	movs	r1, r3
   11b0c:	0010      	movs	r0, r2
   11b0e:	f7ff f86c 	bl	10bea <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   11b12:	68fb      	ldr	r3, [r7, #12]
   11b14:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   11b16:	4b20      	ldr	r3, [pc, #128]	; (11b98 <xTaskResumeAll+0x10c>)
   11b18:	681b      	ldr	r3, [r3, #0]
   11b1a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   11b1c:	429a      	cmp	r2, r3
   11b1e:	d302      	bcc.n	11b26 <xTaskResumeAll+0x9a>
					{
						xYieldPending = pdTRUE;
   11b20:	4b1e      	ldr	r3, [pc, #120]	; (11b9c <xTaskResumeAll+0x110>)
   11b22:	2201      	movs	r2, #1
   11b24:	601a      	str	r2, [r3, #0]
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
   11b26:	4b19      	ldr	r3, [pc, #100]	; (11b8c <xTaskResumeAll+0x100>)
   11b28:	681b      	ldr	r3, [r3, #0]
   11b2a:	2b00      	cmp	r3, #0
   11b2c:	d1cb      	bne.n	11ac6 <xTaskResumeAll+0x3a>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
   11b2e:	68fb      	ldr	r3, [r7, #12]
   11b30:	2b00      	cmp	r3, #0
   11b32:	d001      	beq.n	11b38 <xTaskResumeAll+0xac>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
   11b34:	f000 fab8 	bl	120a8 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
   11b38:	4b19      	ldr	r3, [pc, #100]	; (11ba0 <xTaskResumeAll+0x114>)
   11b3a:	681b      	ldr	r3, [r3, #0]
   11b3c:	607b      	str	r3, [r7, #4]

					if( uxPendedCounts > ( UBaseType_t ) 0U )
   11b3e:	687b      	ldr	r3, [r7, #4]
   11b40:	2b00      	cmp	r3, #0
   11b42:	d00f      	beq.n	11b64 <xTaskResumeAll+0xd8>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
   11b44:	f000 f82e 	bl	11ba4 <xTaskIncrementTick>
   11b48:	1e03      	subs	r3, r0, #0
   11b4a:	d002      	beq.n	11b52 <xTaskResumeAll+0xc6>
							{
								xYieldPending = pdTRUE;
   11b4c:	4b13      	ldr	r3, [pc, #76]	; (11b9c <xTaskResumeAll+0x110>)
   11b4e:	2201      	movs	r2, #1
   11b50:	601a      	str	r2, [r3, #0]
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
   11b52:	687b      	ldr	r3, [r7, #4]
   11b54:	3b01      	subs	r3, #1
   11b56:	607b      	str	r3, [r7, #4]
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
   11b58:	687b      	ldr	r3, [r7, #4]
   11b5a:	2b00      	cmp	r3, #0
   11b5c:	d1f2      	bne.n	11b44 <xTaskResumeAll+0xb8>

						uxPendedTicks = 0;
   11b5e:	4b10      	ldr	r3, [pc, #64]	; (11ba0 <xTaskResumeAll+0x114>)
   11b60:	2200      	movs	r2, #0
   11b62:	601a      	str	r2, [r3, #0]
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
   11b64:	4b0d      	ldr	r3, [pc, #52]	; (11b9c <xTaskResumeAll+0x110>)
   11b66:	681b      	ldr	r3, [r3, #0]
   11b68:	2b00      	cmp	r3, #0
   11b6a:	d003      	beq.n	11b74 <xTaskResumeAll+0xe8>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
   11b6c:	2301      	movs	r3, #1
   11b6e:	60bb      	str	r3, [r7, #8]
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
   11b70:	f000 fd3e 	bl	125f0 <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
   11b74:	f000 fd5e 	bl	12634 <vPortExitCritical>

	return xAlreadyYielded;
   11b78:	68bb      	ldr	r3, [r7, #8]
}
   11b7a:	0018      	movs	r0, r3
   11b7c:	46bd      	mov	sp, r7
   11b7e:	b004      	add	sp, #16
   11b80:	bd80      	pop	{r7, pc}
   11b82:	46c0      	nop			; (mov r8, r8)
   11b84:	00030274 	.word	0x00030274
   11b88:	0003024c 	.word	0x0003024c
   11b8c:	0003020c 	.word	0x0003020c
   11b90:	00030254 	.word	0x00030254
   11b94:	00030150 	.word	0x00030150
   11b98:	0003014c 	.word	0x0003014c
   11b9c:	00030260 	.word	0x00030260
   11ba0:	0003025c 	.word	0x0003025c

00011ba4 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
   11ba4:	b580      	push	{r7, lr}
   11ba6:	b086      	sub	sp, #24
   11ba8:	af00      	add	r7, sp, #0
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
   11baa:	2300      	movs	r3, #0
   11bac:	617b      	str	r3, [r7, #20]

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   11bae:	4b4c      	ldr	r3, [pc, #304]	; (11ce0 <xTaskIncrementTick+0x13c>)
   11bb0:	681b      	ldr	r3, [r3, #0]
   11bb2:	2b00      	cmp	r3, #0
   11bb4:	d000      	beq.n	11bb8 <xTaskIncrementTick+0x14>
   11bb6:	e083      	b.n	11cc0 <xTaskIncrementTick+0x11c>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
   11bb8:	4b4a      	ldr	r3, [pc, #296]	; (11ce4 <xTaskIncrementTick+0x140>)
   11bba:	681b      	ldr	r3, [r3, #0]
   11bbc:	3301      	adds	r3, #1
   11bbe:	613b      	str	r3, [r7, #16]

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
   11bc0:	4b48      	ldr	r3, [pc, #288]	; (11ce4 <xTaskIncrementTick+0x140>)
   11bc2:	693a      	ldr	r2, [r7, #16]
   11bc4:	601a      	str	r2, [r3, #0]

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
   11bc6:	693b      	ldr	r3, [r7, #16]
   11bc8:	2b00      	cmp	r3, #0
   11bca:	d117      	bne.n	11bfc <xTaskIncrementTick+0x58>
		{
			taskSWITCH_DELAYED_LISTS();
   11bcc:	4b46      	ldr	r3, [pc, #280]	; (11ce8 <xTaskIncrementTick+0x144>)
   11bce:	681b      	ldr	r3, [r3, #0]
   11bd0:	681b      	ldr	r3, [r3, #0]
   11bd2:	2b00      	cmp	r3, #0
   11bd4:	d001      	beq.n	11bda <xTaskIncrementTick+0x36>
   11bd6:	b672      	cpsid	i
   11bd8:	e7fe      	b.n	11bd8 <xTaskIncrementTick+0x34>
   11bda:	4b43      	ldr	r3, [pc, #268]	; (11ce8 <xTaskIncrementTick+0x144>)
   11bdc:	681b      	ldr	r3, [r3, #0]
   11bde:	60fb      	str	r3, [r7, #12]
   11be0:	4b42      	ldr	r3, [pc, #264]	; (11cec <xTaskIncrementTick+0x148>)
   11be2:	681a      	ldr	r2, [r3, #0]
   11be4:	4b40      	ldr	r3, [pc, #256]	; (11ce8 <xTaskIncrementTick+0x144>)
   11be6:	601a      	str	r2, [r3, #0]
   11be8:	4b40      	ldr	r3, [pc, #256]	; (11cec <xTaskIncrementTick+0x148>)
   11bea:	68fa      	ldr	r2, [r7, #12]
   11bec:	601a      	str	r2, [r3, #0]
   11bee:	4b40      	ldr	r3, [pc, #256]	; (11cf0 <xTaskIncrementTick+0x14c>)
   11bf0:	681b      	ldr	r3, [r3, #0]
   11bf2:	1c5a      	adds	r2, r3, #1
   11bf4:	4b3e      	ldr	r3, [pc, #248]	; (11cf0 <xTaskIncrementTick+0x14c>)
   11bf6:	601a      	str	r2, [r3, #0]
   11bf8:	f000 fa56 	bl	120a8 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
   11bfc:	4b3d      	ldr	r3, [pc, #244]	; (11cf4 <xTaskIncrementTick+0x150>)
   11bfe:	681b      	ldr	r3, [r3, #0]
   11c00:	693a      	ldr	r2, [r7, #16]
   11c02:	429a      	cmp	r2, r3
   11c04:	d34e      	bcc.n	11ca4 <xTaskIncrementTick+0x100>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   11c06:	4b38      	ldr	r3, [pc, #224]	; (11ce8 <xTaskIncrementTick+0x144>)
   11c08:	681b      	ldr	r3, [r3, #0]
   11c0a:	681b      	ldr	r3, [r3, #0]
   11c0c:	2b00      	cmp	r3, #0
   11c0e:	d101      	bne.n	11c14 <xTaskIncrementTick+0x70>
   11c10:	2301      	movs	r3, #1
   11c12:	e000      	b.n	11c16 <xTaskIncrementTick+0x72>
   11c14:	2300      	movs	r3, #0
   11c16:	2b00      	cmp	r3, #0
   11c18:	d004      	beq.n	11c24 <xTaskIncrementTick+0x80>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   11c1a:	4b36      	ldr	r3, [pc, #216]	; (11cf4 <xTaskIncrementTick+0x150>)
   11c1c:	2201      	movs	r2, #1
   11c1e:	4252      	negs	r2, r2
   11c20:	601a      	str	r2, [r3, #0]
					break;
   11c22:	e03f      	b.n	11ca4 <xTaskIncrementTick+0x100>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
   11c24:	4b30      	ldr	r3, [pc, #192]	; (11ce8 <xTaskIncrementTick+0x144>)
   11c26:	681b      	ldr	r3, [r3, #0]
   11c28:	68db      	ldr	r3, [r3, #12]
   11c2a:	68db      	ldr	r3, [r3, #12]
   11c2c:	60bb      	str	r3, [r7, #8]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
   11c2e:	68bb      	ldr	r3, [r7, #8]
   11c30:	685b      	ldr	r3, [r3, #4]
   11c32:	607b      	str	r3, [r7, #4]

					if( xConstTickCount < xItemValue )
   11c34:	693a      	ldr	r2, [r7, #16]
   11c36:	687b      	ldr	r3, [r7, #4]
   11c38:	429a      	cmp	r2, r3
   11c3a:	d203      	bcs.n	11c44 <xTaskIncrementTick+0xa0>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
   11c3c:	4b2d      	ldr	r3, [pc, #180]	; (11cf4 <xTaskIncrementTick+0x150>)
   11c3e:	687a      	ldr	r2, [r7, #4]
   11c40:	601a      	str	r2, [r3, #0]
						break;
   11c42:	e02f      	b.n	11ca4 <xTaskIncrementTick+0x100>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   11c44:	68bb      	ldr	r3, [r7, #8]
   11c46:	3304      	adds	r3, #4
   11c48:	0018      	movs	r0, r3
   11c4a:	f7ff f826 	bl	10c9a <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   11c4e:	68bb      	ldr	r3, [r7, #8]
   11c50:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   11c52:	2b00      	cmp	r3, #0
   11c54:	d004      	beq.n	11c60 <xTaskIncrementTick+0xbc>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   11c56:	68bb      	ldr	r3, [r7, #8]
   11c58:	3318      	adds	r3, #24
   11c5a:	0018      	movs	r0, r3
   11c5c:	f7ff f81d 	bl	10c9a <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
   11c60:	68bb      	ldr	r3, [r7, #8]
   11c62:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   11c64:	4b24      	ldr	r3, [pc, #144]	; (11cf8 <xTaskIncrementTick+0x154>)
   11c66:	681b      	ldr	r3, [r3, #0]
   11c68:	429a      	cmp	r2, r3
   11c6a:	d903      	bls.n	11c74 <xTaskIncrementTick+0xd0>
   11c6c:	68bb      	ldr	r3, [r7, #8]
   11c6e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   11c70:	4b21      	ldr	r3, [pc, #132]	; (11cf8 <xTaskIncrementTick+0x154>)
   11c72:	601a      	str	r2, [r3, #0]
   11c74:	68bb      	ldr	r3, [r7, #8]
   11c76:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   11c78:	0013      	movs	r3, r2
   11c7a:	009b      	lsls	r3, r3, #2
   11c7c:	189b      	adds	r3, r3, r2
   11c7e:	009b      	lsls	r3, r3, #2
   11c80:	4a1e      	ldr	r2, [pc, #120]	; (11cfc <xTaskIncrementTick+0x158>)
   11c82:	189a      	adds	r2, r3, r2
   11c84:	68bb      	ldr	r3, [r7, #8]
   11c86:	3304      	adds	r3, #4
   11c88:	0019      	movs	r1, r3
   11c8a:	0010      	movs	r0, r2
   11c8c:	f7fe ffad 	bl	10bea <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   11c90:	68bb      	ldr	r3, [r7, #8]
   11c92:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   11c94:	4b1a      	ldr	r3, [pc, #104]	; (11d00 <xTaskIncrementTick+0x15c>)
   11c96:	681b      	ldr	r3, [r3, #0]
   11c98:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   11c9a:	429a      	cmp	r2, r3
   11c9c:	d3b3      	bcc.n	11c06 <xTaskIncrementTick+0x62>
						{
							xSwitchRequired = pdTRUE;
   11c9e:	2301      	movs	r3, #1
   11ca0:	617b      	str	r3, [r7, #20]
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   11ca2:	e7b0      	b.n	11c06 <xTaskIncrementTick+0x62>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
   11ca4:	4b16      	ldr	r3, [pc, #88]	; (11d00 <xTaskIncrementTick+0x15c>)
   11ca6:	681b      	ldr	r3, [r3, #0]
   11ca8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   11caa:	4914      	ldr	r1, [pc, #80]	; (11cfc <xTaskIncrementTick+0x158>)
   11cac:	0013      	movs	r3, r2
   11cae:	009b      	lsls	r3, r3, #2
   11cb0:	189b      	adds	r3, r3, r2
   11cb2:	009b      	lsls	r3, r3, #2
   11cb4:	585b      	ldr	r3, [r3, r1]
   11cb6:	2b01      	cmp	r3, #1
   11cb8:	d907      	bls.n	11cca <xTaskIncrementTick+0x126>
			{
				xSwitchRequired = pdTRUE;
   11cba:	2301      	movs	r3, #1
   11cbc:	617b      	str	r3, [r7, #20]
   11cbe:	e004      	b.n	11cca <xTaskIncrementTick+0x126>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
   11cc0:	4b10      	ldr	r3, [pc, #64]	; (11d04 <xTaskIncrementTick+0x160>)
   11cc2:	681b      	ldr	r3, [r3, #0]
   11cc4:	1c5a      	adds	r2, r3, #1
   11cc6:	4b0f      	ldr	r3, [pc, #60]	; (11d04 <xTaskIncrementTick+0x160>)
   11cc8:	601a      	str	r2, [r3, #0]
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
   11cca:	4b0f      	ldr	r3, [pc, #60]	; (11d08 <xTaskIncrementTick+0x164>)
   11ccc:	681b      	ldr	r3, [r3, #0]
   11cce:	2b00      	cmp	r3, #0
   11cd0:	d001      	beq.n	11cd6 <xTaskIncrementTick+0x132>
		{
			xSwitchRequired = pdTRUE;
   11cd2:	2301      	movs	r3, #1
   11cd4:	617b      	str	r3, [r7, #20]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
   11cd6:	697b      	ldr	r3, [r7, #20]
}
   11cd8:	0018      	movs	r0, r3
   11cda:	46bd      	mov	sp, r7
   11cdc:	b006      	add	sp, #24
   11cde:	bd80      	pop	{r7, pc}
   11ce0:	00030274 	.word	0x00030274
   11ce4:	00030250 	.word	0x00030250
   11ce8:	00030204 	.word	0x00030204
   11cec:	00030208 	.word	0x00030208
   11cf0:	00030264 	.word	0x00030264
   11cf4:	0003026c 	.word	0x0003026c
   11cf8:	00030254 	.word	0x00030254
   11cfc:	00030150 	.word	0x00030150
   11d00:	0003014c 	.word	0x0003014c
   11d04:	0003025c 	.word	0x0003025c
   11d08:	00030260 	.word	0x00030260

00011d0c <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
   11d0c:	b580      	push	{r7, lr}
   11d0e:	b082      	sub	sp, #8
   11d10:	af00      	add	r7, sp, #0
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
   11d12:	4b22      	ldr	r3, [pc, #136]	; (11d9c <vTaskSwitchContext+0x90>)
   11d14:	681b      	ldr	r3, [r3, #0]
   11d16:	2b00      	cmp	r3, #0
   11d18:	d003      	beq.n	11d22 <vTaskSwitchContext+0x16>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
   11d1a:	4b21      	ldr	r3, [pc, #132]	; (11da0 <vTaskSwitchContext+0x94>)
   11d1c:	2201      	movs	r2, #1
   11d1e:	601a      	str	r2, [r3, #0]
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
   11d20:	e037      	b.n	11d92 <vTaskSwitchContext+0x86>
		xYieldPending = pdFALSE;
   11d22:	4b1f      	ldr	r3, [pc, #124]	; (11da0 <vTaskSwitchContext+0x94>)
   11d24:	2200      	movs	r2, #0
   11d26:	601a      	str	r2, [r3, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK();
   11d28:	4b1e      	ldr	r3, [pc, #120]	; (11da4 <vTaskSwitchContext+0x98>)
   11d2a:	681b      	ldr	r3, [r3, #0]
   11d2c:	607b      	str	r3, [r7, #4]
   11d2e:	e007      	b.n	11d40 <vTaskSwitchContext+0x34>
   11d30:	687b      	ldr	r3, [r7, #4]
   11d32:	2b00      	cmp	r3, #0
   11d34:	d101      	bne.n	11d3a <vTaskSwitchContext+0x2e>
   11d36:	b672      	cpsid	i
   11d38:	e7fe      	b.n	11d38 <vTaskSwitchContext+0x2c>
   11d3a:	687b      	ldr	r3, [r7, #4]
   11d3c:	3b01      	subs	r3, #1
   11d3e:	607b      	str	r3, [r7, #4]
   11d40:	4919      	ldr	r1, [pc, #100]	; (11da8 <vTaskSwitchContext+0x9c>)
   11d42:	687a      	ldr	r2, [r7, #4]
   11d44:	0013      	movs	r3, r2
   11d46:	009b      	lsls	r3, r3, #2
   11d48:	189b      	adds	r3, r3, r2
   11d4a:	009b      	lsls	r3, r3, #2
   11d4c:	585b      	ldr	r3, [r3, r1]
   11d4e:	2b00      	cmp	r3, #0
   11d50:	d0ee      	beq.n	11d30 <vTaskSwitchContext+0x24>
   11d52:	687a      	ldr	r2, [r7, #4]
   11d54:	0013      	movs	r3, r2
   11d56:	009b      	lsls	r3, r3, #2
   11d58:	189b      	adds	r3, r3, r2
   11d5a:	009b      	lsls	r3, r3, #2
   11d5c:	4a12      	ldr	r2, [pc, #72]	; (11da8 <vTaskSwitchContext+0x9c>)
   11d5e:	189b      	adds	r3, r3, r2
   11d60:	603b      	str	r3, [r7, #0]
   11d62:	683b      	ldr	r3, [r7, #0]
   11d64:	685b      	ldr	r3, [r3, #4]
   11d66:	685a      	ldr	r2, [r3, #4]
   11d68:	683b      	ldr	r3, [r7, #0]
   11d6a:	605a      	str	r2, [r3, #4]
   11d6c:	683b      	ldr	r3, [r7, #0]
   11d6e:	685a      	ldr	r2, [r3, #4]
   11d70:	683b      	ldr	r3, [r7, #0]
   11d72:	3308      	adds	r3, #8
   11d74:	429a      	cmp	r2, r3
   11d76:	d104      	bne.n	11d82 <vTaskSwitchContext+0x76>
   11d78:	683b      	ldr	r3, [r7, #0]
   11d7a:	685b      	ldr	r3, [r3, #4]
   11d7c:	685a      	ldr	r2, [r3, #4]
   11d7e:	683b      	ldr	r3, [r7, #0]
   11d80:	605a      	str	r2, [r3, #4]
   11d82:	683b      	ldr	r3, [r7, #0]
   11d84:	685b      	ldr	r3, [r3, #4]
   11d86:	68da      	ldr	r2, [r3, #12]
   11d88:	4b08      	ldr	r3, [pc, #32]	; (11dac <vTaskSwitchContext+0xa0>)
   11d8a:	601a      	str	r2, [r3, #0]
   11d8c:	4b05      	ldr	r3, [pc, #20]	; (11da4 <vTaskSwitchContext+0x98>)
   11d8e:	687a      	ldr	r2, [r7, #4]
   11d90:	601a      	str	r2, [r3, #0]
}
   11d92:	46c0      	nop			; (mov r8, r8)
   11d94:	46bd      	mov	sp, r7
   11d96:	b002      	add	sp, #8
   11d98:	bd80      	pop	{r7, pc}
   11d9a:	46c0      	nop			; (mov r8, r8)
   11d9c:	00030274 	.word	0x00030274
   11da0:	00030260 	.word	0x00030260
   11da4:	00030254 	.word	0x00030254
   11da8:	00030150 	.word	0x00030150
   11dac:	0003014c 	.word	0x0003014c

00011db0 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
   11db0:	b580      	push	{r7, lr}
   11db2:	b082      	sub	sp, #8
   11db4:	af00      	add	r7, sp, #0
   11db6:	6078      	str	r0, [r7, #4]
   11db8:	6039      	str	r1, [r7, #0]
	configASSERT( pxEventList );
   11dba:	687b      	ldr	r3, [r7, #4]
   11dbc:	2b00      	cmp	r3, #0
   11dbe:	d101      	bne.n	11dc4 <vTaskPlaceOnEventList+0x14>
   11dc0:	b672      	cpsid	i
   11dc2:	e7fe      	b.n	11dc2 <vTaskPlaceOnEventList+0x12>

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   11dc4:	4b08      	ldr	r3, [pc, #32]	; (11de8 <vTaskPlaceOnEventList+0x38>)
   11dc6:	681b      	ldr	r3, [r3, #0]
   11dc8:	3318      	adds	r3, #24
   11dca:	001a      	movs	r2, r3
   11dcc:	687b      	ldr	r3, [r7, #4]
   11dce:	0011      	movs	r1, r2
   11dd0:	0018      	movs	r0, r3
   11dd2:	f7fe ff2c 	bl	10c2e <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
   11dd6:	683b      	ldr	r3, [r7, #0]
   11dd8:	2101      	movs	r1, #1
   11dda:	0018      	movs	r0, r3
   11ddc:	f000 f988 	bl	120f0 <prvAddCurrentTaskToDelayedList>
}
   11de0:	46c0      	nop			; (mov r8, r8)
   11de2:	46bd      	mov	sp, r7
   11de4:	b002      	add	sp, #8
   11de6:	bd80      	pop	{r7, pc}
   11de8:	0003014c 	.word	0x0003014c

00011dec <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
   11dec:	b580      	push	{r7, lr}
   11dee:	b084      	sub	sp, #16
   11df0:	af00      	add	r7, sp, #0
   11df2:	6078      	str	r0, [r7, #4]
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
   11df4:	687b      	ldr	r3, [r7, #4]
   11df6:	68db      	ldr	r3, [r3, #12]
   11df8:	68db      	ldr	r3, [r3, #12]
   11dfa:	60bb      	str	r3, [r7, #8]
	configASSERT( pxUnblockedTCB );
   11dfc:	68bb      	ldr	r3, [r7, #8]
   11dfe:	2b00      	cmp	r3, #0
   11e00:	d101      	bne.n	11e06 <xTaskRemoveFromEventList+0x1a>
   11e02:	b672      	cpsid	i
   11e04:	e7fe      	b.n	11e04 <xTaskRemoveFromEventList+0x18>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
   11e06:	68bb      	ldr	r3, [r7, #8]
   11e08:	3318      	adds	r3, #24
   11e0a:	0018      	movs	r0, r3
   11e0c:	f7fe ff45 	bl	10c9a <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   11e10:	4b1e      	ldr	r3, [pc, #120]	; (11e8c <xTaskRemoveFromEventList+0xa0>)
   11e12:	681b      	ldr	r3, [r3, #0]
   11e14:	2b00      	cmp	r3, #0
   11e16:	d11d      	bne.n	11e54 <xTaskRemoveFromEventList+0x68>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
   11e18:	68bb      	ldr	r3, [r7, #8]
   11e1a:	3304      	adds	r3, #4
   11e1c:	0018      	movs	r0, r3
   11e1e:	f7fe ff3c 	bl	10c9a <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
   11e22:	68bb      	ldr	r3, [r7, #8]
   11e24:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   11e26:	4b1a      	ldr	r3, [pc, #104]	; (11e90 <xTaskRemoveFromEventList+0xa4>)
   11e28:	681b      	ldr	r3, [r3, #0]
   11e2a:	429a      	cmp	r2, r3
   11e2c:	d903      	bls.n	11e36 <xTaskRemoveFromEventList+0x4a>
   11e2e:	68bb      	ldr	r3, [r7, #8]
   11e30:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   11e32:	4b17      	ldr	r3, [pc, #92]	; (11e90 <xTaskRemoveFromEventList+0xa4>)
   11e34:	601a      	str	r2, [r3, #0]
   11e36:	68bb      	ldr	r3, [r7, #8]
   11e38:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   11e3a:	0013      	movs	r3, r2
   11e3c:	009b      	lsls	r3, r3, #2
   11e3e:	189b      	adds	r3, r3, r2
   11e40:	009b      	lsls	r3, r3, #2
   11e42:	4a14      	ldr	r2, [pc, #80]	; (11e94 <xTaskRemoveFromEventList+0xa8>)
   11e44:	189a      	adds	r2, r3, r2
   11e46:	68bb      	ldr	r3, [r7, #8]
   11e48:	3304      	adds	r3, #4
   11e4a:	0019      	movs	r1, r3
   11e4c:	0010      	movs	r0, r2
   11e4e:	f7fe fecc 	bl	10bea <vListInsertEnd>
   11e52:	e007      	b.n	11e64 <xTaskRemoveFromEventList+0x78>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
   11e54:	68bb      	ldr	r3, [r7, #8]
   11e56:	3318      	adds	r3, #24
   11e58:	001a      	movs	r2, r3
   11e5a:	4b0f      	ldr	r3, [pc, #60]	; (11e98 <xTaskRemoveFromEventList+0xac>)
   11e5c:	0011      	movs	r1, r2
   11e5e:	0018      	movs	r0, r3
   11e60:	f7fe fec3 	bl	10bea <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
   11e64:	68bb      	ldr	r3, [r7, #8]
   11e66:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   11e68:	4b0c      	ldr	r3, [pc, #48]	; (11e9c <xTaskRemoveFromEventList+0xb0>)
   11e6a:	681b      	ldr	r3, [r3, #0]
   11e6c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   11e6e:	429a      	cmp	r2, r3
   11e70:	d905      	bls.n	11e7e <xTaskRemoveFromEventList+0x92>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
   11e72:	2301      	movs	r3, #1
   11e74:	60fb      	str	r3, [r7, #12]

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
   11e76:	4b0a      	ldr	r3, [pc, #40]	; (11ea0 <xTaskRemoveFromEventList+0xb4>)
   11e78:	2201      	movs	r2, #1
   11e7a:	601a      	str	r2, [r3, #0]
   11e7c:	e001      	b.n	11e82 <xTaskRemoveFromEventList+0x96>
	}
	else
	{
		xReturn = pdFALSE;
   11e7e:	2300      	movs	r3, #0
   11e80:	60fb      	str	r3, [r7, #12]
		ensure it is updated at the earliest possible time. */
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
   11e82:	68fb      	ldr	r3, [r7, #12]
}
   11e84:	0018      	movs	r0, r3
   11e86:	46bd      	mov	sp, r7
   11e88:	b004      	add	sp, #16
   11e8a:	bd80      	pop	{r7, pc}
   11e8c:	00030274 	.word	0x00030274
   11e90:	00030254 	.word	0x00030254
   11e94:	00030150 	.word	0x00030150
   11e98:	0003020c 	.word	0x0003020c
   11e9c:	0003014c 	.word	0x0003014c
   11ea0:	00030260 	.word	0x00030260

00011ea4 <vTaskInternalSetTimeOutState>:
	taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
   11ea4:	b580      	push	{r7, lr}
   11ea6:	b082      	sub	sp, #8
   11ea8:	af00      	add	r7, sp, #0
   11eaa:	6078      	str	r0, [r7, #4]
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
   11eac:	4b05      	ldr	r3, [pc, #20]	; (11ec4 <vTaskInternalSetTimeOutState+0x20>)
   11eae:	681a      	ldr	r2, [r3, #0]
   11eb0:	687b      	ldr	r3, [r7, #4]
   11eb2:	601a      	str	r2, [r3, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
   11eb4:	4b04      	ldr	r3, [pc, #16]	; (11ec8 <vTaskInternalSetTimeOutState+0x24>)
   11eb6:	681a      	ldr	r2, [r3, #0]
   11eb8:	687b      	ldr	r3, [r7, #4]
   11eba:	605a      	str	r2, [r3, #4]
}
   11ebc:	46c0      	nop			; (mov r8, r8)
   11ebe:	46bd      	mov	sp, r7
   11ec0:	b002      	add	sp, #8
   11ec2:	bd80      	pop	{r7, pc}
   11ec4:	00030264 	.word	0x00030264
   11ec8:	00030250 	.word	0x00030250

00011ecc <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
   11ecc:	b580      	push	{r7, lr}
   11ece:	b086      	sub	sp, #24
   11ed0:	af00      	add	r7, sp, #0
   11ed2:	6078      	str	r0, [r7, #4]
   11ed4:	6039      	str	r1, [r7, #0]
BaseType_t xReturn;

	configASSERT( pxTimeOut );
   11ed6:	687b      	ldr	r3, [r7, #4]
   11ed8:	2b00      	cmp	r3, #0
   11eda:	d101      	bne.n	11ee0 <xTaskCheckForTimeOut+0x14>
   11edc:	b672      	cpsid	i
   11ede:	e7fe      	b.n	11ede <xTaskCheckForTimeOut+0x12>
	configASSERT( pxTicksToWait );
   11ee0:	683b      	ldr	r3, [r7, #0]
   11ee2:	2b00      	cmp	r3, #0
   11ee4:	d101      	bne.n	11eea <xTaskCheckForTimeOut+0x1e>
   11ee6:	b672      	cpsid	i
   11ee8:	e7fe      	b.n	11ee8 <xTaskCheckForTimeOut+0x1c>

	taskENTER_CRITICAL();
   11eea:	f000 fb91 	bl	12610 <vPortEnterCritical>
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
   11eee:	4b1d      	ldr	r3, [pc, #116]	; (11f64 <xTaskCheckForTimeOut+0x98>)
   11ef0:	681b      	ldr	r3, [r3, #0]
   11ef2:	613b      	str	r3, [r7, #16]
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
   11ef4:	687b      	ldr	r3, [r7, #4]
   11ef6:	685b      	ldr	r3, [r3, #4]
   11ef8:	693a      	ldr	r2, [r7, #16]
   11efa:	1ad3      	subs	r3, r2, r3
   11efc:	60fb      	str	r3, [r7, #12]
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
   11efe:	683b      	ldr	r3, [r7, #0]
   11f00:	681b      	ldr	r3, [r3, #0]
   11f02:	3301      	adds	r3, #1
   11f04:	d102      	bne.n	11f0c <xTaskCheckForTimeOut+0x40>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
   11f06:	2300      	movs	r3, #0
   11f08:	617b      	str	r3, [r7, #20]
   11f0a:	e024      	b.n	11f56 <xTaskCheckForTimeOut+0x8a>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
   11f0c:	687b      	ldr	r3, [r7, #4]
   11f0e:	681a      	ldr	r2, [r3, #0]
   11f10:	4b15      	ldr	r3, [pc, #84]	; (11f68 <xTaskCheckForTimeOut+0x9c>)
   11f12:	681b      	ldr	r3, [r3, #0]
   11f14:	429a      	cmp	r2, r3
   11f16:	d007      	beq.n	11f28 <xTaskCheckForTimeOut+0x5c>
   11f18:	687b      	ldr	r3, [r7, #4]
   11f1a:	685b      	ldr	r3, [r3, #4]
   11f1c:	693a      	ldr	r2, [r7, #16]
   11f1e:	429a      	cmp	r2, r3
   11f20:	d302      	bcc.n	11f28 <xTaskCheckForTimeOut+0x5c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
   11f22:	2301      	movs	r3, #1
   11f24:	617b      	str	r3, [r7, #20]
   11f26:	e016      	b.n	11f56 <xTaskCheckForTimeOut+0x8a>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
   11f28:	683b      	ldr	r3, [r7, #0]
   11f2a:	681b      	ldr	r3, [r3, #0]
   11f2c:	68fa      	ldr	r2, [r7, #12]
   11f2e:	429a      	cmp	r2, r3
   11f30:	d20c      	bcs.n	11f4c <xTaskCheckForTimeOut+0x80>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
   11f32:	683b      	ldr	r3, [r7, #0]
   11f34:	681a      	ldr	r2, [r3, #0]
   11f36:	68fb      	ldr	r3, [r7, #12]
   11f38:	1ad2      	subs	r2, r2, r3
   11f3a:	683b      	ldr	r3, [r7, #0]
   11f3c:	601a      	str	r2, [r3, #0]
			vTaskInternalSetTimeOutState( pxTimeOut );
   11f3e:	687b      	ldr	r3, [r7, #4]
   11f40:	0018      	movs	r0, r3
   11f42:	f7ff ffaf 	bl	11ea4 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
   11f46:	2300      	movs	r3, #0
   11f48:	617b      	str	r3, [r7, #20]
   11f4a:	e004      	b.n	11f56 <xTaskCheckForTimeOut+0x8a>
		}
		else
		{
			*pxTicksToWait = 0;
   11f4c:	683b      	ldr	r3, [r7, #0]
   11f4e:	2200      	movs	r2, #0
   11f50:	601a      	str	r2, [r3, #0]
			xReturn = pdTRUE;
   11f52:	2301      	movs	r3, #1
   11f54:	617b      	str	r3, [r7, #20]
		}
	}
	taskEXIT_CRITICAL();
   11f56:	f000 fb6d 	bl	12634 <vPortExitCritical>

	return xReturn;
   11f5a:	697b      	ldr	r3, [r7, #20]
}
   11f5c:	0018      	movs	r0, r3
   11f5e:	46bd      	mov	sp, r7
   11f60:	b006      	add	sp, #24
   11f62:	bd80      	pop	{r7, pc}
   11f64:	00030250 	.word	0x00030250
   11f68:	00030264 	.word	0x00030264

00011f6c <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
   11f6c:	b580      	push	{r7, lr}
   11f6e:	af00      	add	r7, sp, #0
	xYieldPending = pdTRUE;
   11f70:	4b02      	ldr	r3, [pc, #8]	; (11f7c <vTaskMissedYield+0x10>)
   11f72:	2201      	movs	r2, #1
   11f74:	601a      	str	r2, [r3, #0]
}
   11f76:	46c0      	nop			; (mov r8, r8)
   11f78:	46bd      	mov	sp, r7
   11f7a:	bd80      	pop	{r7, pc}
   11f7c:	00030260 	.word	0x00030260

00011f80 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
   11f80:	b580      	push	{r7, lr}
   11f82:	b082      	sub	sp, #8
   11f84:	af00      	add	r7, sp, #0
   11f86:	6078      	str	r0, [r7, #4]

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
   11f88:	f000 f84e 	bl	12028 <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
   11f8c:	4b03      	ldr	r3, [pc, #12]	; (11f9c <prvIdleTask+0x1c>)
   11f8e:	681b      	ldr	r3, [r3, #0]
   11f90:	2b01      	cmp	r3, #1
   11f92:	d9f9      	bls.n	11f88 <prvIdleTask+0x8>
			{
				taskYIELD();
   11f94:	f000 fb2c 	bl	125f0 <vPortYield>
		prvCheckTasksWaitingTermination();
   11f98:	e7f6      	b.n	11f88 <prvIdleTask+0x8>
   11f9a:	46c0      	nop			; (mov r8, r8)
   11f9c:	00030150 	.word	0x00030150

00011fa0 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
   11fa0:	b580      	push	{r7, lr}
   11fa2:	b082      	sub	sp, #8
   11fa4:	af00      	add	r7, sp, #0
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
   11fa6:	2300      	movs	r3, #0
   11fa8:	607b      	str	r3, [r7, #4]
   11faa:	e00c      	b.n	11fc6 <prvInitialiseTaskLists+0x26>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
   11fac:	687a      	ldr	r2, [r7, #4]
   11fae:	0013      	movs	r3, r2
   11fb0:	009b      	lsls	r3, r3, #2
   11fb2:	189b      	adds	r3, r3, r2
   11fb4:	009b      	lsls	r3, r3, #2
   11fb6:	4a14      	ldr	r2, [pc, #80]	; (12008 <prvInitialiseTaskLists+0x68>)
   11fb8:	189b      	adds	r3, r3, r2
   11fba:	0018      	movs	r0, r3
   11fbc:	f7fe fdec 	bl	10b98 <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
   11fc0:	687b      	ldr	r3, [r7, #4]
   11fc2:	3301      	adds	r3, #1
   11fc4:	607b      	str	r3, [r7, #4]
   11fc6:	687b      	ldr	r3, [r7, #4]
   11fc8:	2b06      	cmp	r3, #6
   11fca:	d9ef      	bls.n	11fac <prvInitialiseTaskLists+0xc>
	}

	vListInitialise( &xDelayedTaskList1 );
   11fcc:	4b0f      	ldr	r3, [pc, #60]	; (1200c <prvInitialiseTaskLists+0x6c>)
   11fce:	0018      	movs	r0, r3
   11fd0:	f7fe fde2 	bl	10b98 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
   11fd4:	4b0e      	ldr	r3, [pc, #56]	; (12010 <prvInitialiseTaskLists+0x70>)
   11fd6:	0018      	movs	r0, r3
   11fd8:	f7fe fdde 	bl	10b98 <vListInitialise>
	vListInitialise( &xPendingReadyList );
   11fdc:	4b0d      	ldr	r3, [pc, #52]	; (12014 <prvInitialiseTaskLists+0x74>)
   11fde:	0018      	movs	r0, r3
   11fe0:	f7fe fdda 	bl	10b98 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
   11fe4:	4b0c      	ldr	r3, [pc, #48]	; (12018 <prvInitialiseTaskLists+0x78>)
   11fe6:	0018      	movs	r0, r3
   11fe8:	f7fe fdd6 	bl	10b98 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
   11fec:	4b0b      	ldr	r3, [pc, #44]	; (1201c <prvInitialiseTaskLists+0x7c>)
   11fee:	0018      	movs	r0, r3
   11ff0:	f7fe fdd2 	bl	10b98 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
   11ff4:	4b0a      	ldr	r3, [pc, #40]	; (12020 <prvInitialiseTaskLists+0x80>)
   11ff6:	4a05      	ldr	r2, [pc, #20]	; (1200c <prvInitialiseTaskLists+0x6c>)
   11ff8:	601a      	str	r2, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
   11ffa:	4b0a      	ldr	r3, [pc, #40]	; (12024 <prvInitialiseTaskLists+0x84>)
   11ffc:	4a04      	ldr	r2, [pc, #16]	; (12010 <prvInitialiseTaskLists+0x70>)
   11ffe:	601a      	str	r2, [r3, #0]
}
   12000:	46c0      	nop			; (mov r8, r8)
   12002:	46bd      	mov	sp, r7
   12004:	b002      	add	sp, #8
   12006:	bd80      	pop	{r7, pc}
   12008:	00030150 	.word	0x00030150
   1200c:	000301dc 	.word	0x000301dc
   12010:	000301f0 	.word	0x000301f0
   12014:	0003020c 	.word	0x0003020c
   12018:	00030220 	.word	0x00030220
   1201c:	00030238 	.word	0x00030238
   12020:	00030204 	.word	0x00030204
   12024:	00030208 	.word	0x00030208

00012028 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
   12028:	b580      	push	{r7, lr}
   1202a:	b082      	sub	sp, #8
   1202c:	af00      	add	r7, sp, #0
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent vTaskSuspendAll()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
   1202e:	e01a      	b.n	12066 <prvCheckTasksWaitingTermination+0x3e>
		{
			taskENTER_CRITICAL();
   12030:	f000 faee 	bl	12610 <vPortEnterCritical>
			{
				pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
   12034:	4b10      	ldr	r3, [pc, #64]	; (12078 <prvCheckTasksWaitingTermination+0x50>)
   12036:	68db      	ldr	r3, [r3, #12]
   12038:	68db      	ldr	r3, [r3, #12]
   1203a:	607b      	str	r3, [r7, #4]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   1203c:	687b      	ldr	r3, [r7, #4]
   1203e:	3304      	adds	r3, #4
   12040:	0018      	movs	r0, r3
   12042:	f7fe fe2a 	bl	10c9a <uxListRemove>
				--uxCurrentNumberOfTasks;
   12046:	4b0d      	ldr	r3, [pc, #52]	; (1207c <prvCheckTasksWaitingTermination+0x54>)
   12048:	681b      	ldr	r3, [r3, #0]
   1204a:	1e5a      	subs	r2, r3, #1
   1204c:	4b0b      	ldr	r3, [pc, #44]	; (1207c <prvCheckTasksWaitingTermination+0x54>)
   1204e:	601a      	str	r2, [r3, #0]
				--uxDeletedTasksWaitingCleanUp;
   12050:	4b0b      	ldr	r3, [pc, #44]	; (12080 <prvCheckTasksWaitingTermination+0x58>)
   12052:	681b      	ldr	r3, [r3, #0]
   12054:	1e5a      	subs	r2, r3, #1
   12056:	4b0a      	ldr	r3, [pc, #40]	; (12080 <prvCheckTasksWaitingTermination+0x58>)
   12058:	601a      	str	r2, [r3, #0]
			}
			taskEXIT_CRITICAL();
   1205a:	f000 faeb 	bl	12634 <vPortExitCritical>

			prvDeleteTCB( pxTCB );
   1205e:	687b      	ldr	r3, [r7, #4]
   12060:	0018      	movs	r0, r3
   12062:	f000 f80f 	bl	12084 <prvDeleteTCB>
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
   12066:	4b06      	ldr	r3, [pc, #24]	; (12080 <prvCheckTasksWaitingTermination+0x58>)
   12068:	681b      	ldr	r3, [r3, #0]
   1206a:	2b00      	cmp	r3, #0
   1206c:	d1e0      	bne.n	12030 <prvCheckTasksWaitingTermination+0x8>
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
   1206e:	46c0      	nop			; (mov r8, r8)
   12070:	46bd      	mov	sp, r7
   12072:	b002      	add	sp, #8
   12074:	bd80      	pop	{r7, pc}
   12076:	46c0      	nop			; (mov r8, r8)
   12078:	00030220 	.word	0x00030220
   1207c:	0003024c 	.word	0x0003024c
   12080:	00030234 	.word	0x00030234

00012084 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
   12084:	b580      	push	{r7, lr}
   12086:	b082      	sub	sp, #8
   12088:	af00      	add	r7, sp, #0
   1208a:	6078      	str	r0, [r7, #4]

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
   1208c:	687b      	ldr	r3, [r7, #4]
   1208e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   12090:	0018      	movs	r0, r3
   12092:	f000 f927 	bl	122e4 <vPortFree>
			vPortFree( pxTCB );
   12096:	687b      	ldr	r3, [r7, #4]
   12098:	0018      	movs	r0, r3
   1209a:	f000 f923 	bl	122e4 <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
   1209e:	46c0      	nop			; (mov r8, r8)
   120a0:	46bd      	mov	sp, r7
   120a2:	b002      	add	sp, #8
   120a4:	bd80      	pop	{r7, pc}
	...

000120a8 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
   120a8:	b580      	push	{r7, lr}
   120aa:	b082      	sub	sp, #8
   120ac:	af00      	add	r7, sp, #0
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   120ae:	4b0e      	ldr	r3, [pc, #56]	; (120e8 <prvResetNextTaskUnblockTime+0x40>)
   120b0:	681b      	ldr	r3, [r3, #0]
   120b2:	681b      	ldr	r3, [r3, #0]
   120b4:	2b00      	cmp	r3, #0
   120b6:	d101      	bne.n	120bc <prvResetNextTaskUnblockTime+0x14>
   120b8:	2301      	movs	r3, #1
   120ba:	e000      	b.n	120be <prvResetNextTaskUnblockTime+0x16>
   120bc:	2300      	movs	r3, #0
   120be:	2b00      	cmp	r3, #0
   120c0:	d004      	beq.n	120cc <prvResetNextTaskUnblockTime+0x24>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
   120c2:	4b0a      	ldr	r3, [pc, #40]	; (120ec <prvResetNextTaskUnblockTime+0x44>)
   120c4:	2201      	movs	r2, #1
   120c6:	4252      	negs	r2, r2
   120c8:	601a      	str	r2, [r3, #0]
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
	}
}
   120ca:	e008      	b.n	120de <prvResetNextTaskUnblockTime+0x36>
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
   120cc:	4b06      	ldr	r3, [pc, #24]	; (120e8 <prvResetNextTaskUnblockTime+0x40>)
   120ce:	681b      	ldr	r3, [r3, #0]
   120d0:	68db      	ldr	r3, [r3, #12]
   120d2:	68db      	ldr	r3, [r3, #12]
   120d4:	607b      	str	r3, [r7, #4]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
   120d6:	687b      	ldr	r3, [r7, #4]
   120d8:	685a      	ldr	r2, [r3, #4]
   120da:	4b04      	ldr	r3, [pc, #16]	; (120ec <prvResetNextTaskUnblockTime+0x44>)
   120dc:	601a      	str	r2, [r3, #0]
}
   120de:	46c0      	nop			; (mov r8, r8)
   120e0:	46bd      	mov	sp, r7
   120e2:	b002      	add	sp, #8
   120e4:	bd80      	pop	{r7, pc}
   120e6:	46c0      	nop			; (mov r8, r8)
   120e8:	00030204 	.word	0x00030204
   120ec:	0003026c 	.word	0x0003026c

000120f0 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
   120f0:	b580      	push	{r7, lr}
   120f2:	b084      	sub	sp, #16
   120f4:	af00      	add	r7, sp, #0
   120f6:	6078      	str	r0, [r7, #4]
   120f8:	6039      	str	r1, [r7, #0]
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
   120fa:	4b21      	ldr	r3, [pc, #132]	; (12180 <prvAddCurrentTaskToDelayedList+0x90>)
   120fc:	681b      	ldr	r3, [r3, #0]
   120fe:	60fb      	str	r3, [r7, #12]
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   12100:	4b20      	ldr	r3, [pc, #128]	; (12184 <prvAddCurrentTaskToDelayedList+0x94>)
   12102:	681b      	ldr	r3, [r3, #0]
   12104:	3304      	adds	r3, #4
   12106:	0018      	movs	r0, r3
   12108:	f7fe fdc7 	bl	10c9a <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
   1210c:	687b      	ldr	r3, [r7, #4]
   1210e:	3301      	adds	r3, #1
   12110:	d10b      	bne.n	1212a <prvAddCurrentTaskToDelayedList+0x3a>
   12112:	683b      	ldr	r3, [r7, #0]
   12114:	2b00      	cmp	r3, #0
   12116:	d008      	beq.n	1212a <prvAddCurrentTaskToDelayedList+0x3a>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
   12118:	4b1a      	ldr	r3, [pc, #104]	; (12184 <prvAddCurrentTaskToDelayedList+0x94>)
   1211a:	681b      	ldr	r3, [r3, #0]
   1211c:	1d1a      	adds	r2, r3, #4
   1211e:	4b1a      	ldr	r3, [pc, #104]	; (12188 <prvAddCurrentTaskToDelayedList+0x98>)
   12120:	0011      	movs	r1, r2
   12122:	0018      	movs	r0, r3
   12124:	f7fe fd61 	bl	10bea <vListInsertEnd>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
   12128:	e026      	b.n	12178 <prvAddCurrentTaskToDelayedList+0x88>
			xTimeToWake = xConstTickCount + xTicksToWait;
   1212a:	68fa      	ldr	r2, [r7, #12]
   1212c:	687b      	ldr	r3, [r7, #4]
   1212e:	18d3      	adds	r3, r2, r3
   12130:	60bb      	str	r3, [r7, #8]
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
   12132:	4b14      	ldr	r3, [pc, #80]	; (12184 <prvAddCurrentTaskToDelayedList+0x94>)
   12134:	681b      	ldr	r3, [r3, #0]
   12136:	68ba      	ldr	r2, [r7, #8]
   12138:	605a      	str	r2, [r3, #4]
			if( xTimeToWake < xConstTickCount )
   1213a:	68ba      	ldr	r2, [r7, #8]
   1213c:	68fb      	ldr	r3, [r7, #12]
   1213e:	429a      	cmp	r2, r3
   12140:	d209      	bcs.n	12156 <prvAddCurrentTaskToDelayedList+0x66>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
   12142:	4b12      	ldr	r3, [pc, #72]	; (1218c <prvAddCurrentTaskToDelayedList+0x9c>)
   12144:	681a      	ldr	r2, [r3, #0]
   12146:	4b0f      	ldr	r3, [pc, #60]	; (12184 <prvAddCurrentTaskToDelayedList+0x94>)
   12148:	681b      	ldr	r3, [r3, #0]
   1214a:	3304      	adds	r3, #4
   1214c:	0019      	movs	r1, r3
   1214e:	0010      	movs	r0, r2
   12150:	f7fe fd6d 	bl	10c2e <vListInsert>
}
   12154:	e010      	b.n	12178 <prvAddCurrentTaskToDelayedList+0x88>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
   12156:	4b0e      	ldr	r3, [pc, #56]	; (12190 <prvAddCurrentTaskToDelayedList+0xa0>)
   12158:	681a      	ldr	r2, [r3, #0]
   1215a:	4b0a      	ldr	r3, [pc, #40]	; (12184 <prvAddCurrentTaskToDelayedList+0x94>)
   1215c:	681b      	ldr	r3, [r3, #0]
   1215e:	3304      	adds	r3, #4
   12160:	0019      	movs	r1, r3
   12162:	0010      	movs	r0, r2
   12164:	f7fe fd63 	bl	10c2e <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
   12168:	4b0a      	ldr	r3, [pc, #40]	; (12194 <prvAddCurrentTaskToDelayedList+0xa4>)
   1216a:	681b      	ldr	r3, [r3, #0]
   1216c:	68ba      	ldr	r2, [r7, #8]
   1216e:	429a      	cmp	r2, r3
   12170:	d202      	bcs.n	12178 <prvAddCurrentTaskToDelayedList+0x88>
					xNextTaskUnblockTime = xTimeToWake;
   12172:	4b08      	ldr	r3, [pc, #32]	; (12194 <prvAddCurrentTaskToDelayedList+0xa4>)
   12174:	68ba      	ldr	r2, [r7, #8]
   12176:	601a      	str	r2, [r3, #0]
}
   12178:	46c0      	nop			; (mov r8, r8)
   1217a:	46bd      	mov	sp, r7
   1217c:	b004      	add	sp, #16
   1217e:	bd80      	pop	{r7, pc}
   12180:	00030250 	.word	0x00030250
   12184:	0003014c 	.word	0x0003014c
   12188:	00030238 	.word	0x00030238
   1218c:	00030208 	.word	0x00030208
   12190:	00030204 	.word	0x00030204
   12194:	0003026c 	.word	0x0003026c

00012198 <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
   12198:	b580      	push	{r7, lr}
   1219a:	b086      	sub	sp, #24
   1219c:	af00      	add	r7, sp, #0
   1219e:	6078      	str	r0, [r7, #4]
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
   121a0:	2300      	movs	r3, #0
   121a2:	60fb      	str	r3, [r7, #12]

	vTaskSuspendAll();
   121a4:	f7ff fc66 	bl	11a74 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
   121a8:	4b49      	ldr	r3, [pc, #292]	; (122d0 <pvPortMalloc+0x138>)
   121aa:	681b      	ldr	r3, [r3, #0]
   121ac:	2b00      	cmp	r3, #0
   121ae:	d101      	bne.n	121b4 <pvPortMalloc+0x1c>
		{
			prvHeapInit();
   121b0:	f000 f8e0 	bl	12374 <prvHeapInit>

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
   121b4:	4b47      	ldr	r3, [pc, #284]	; (122d4 <pvPortMalloc+0x13c>)
   121b6:	681b      	ldr	r3, [r3, #0]
   121b8:	687a      	ldr	r2, [r7, #4]
   121ba:	4013      	ands	r3, r2
   121bc:	d000      	beq.n	121c0 <pvPortMalloc+0x28>
   121be:	e079      	b.n	122b4 <pvPortMalloc+0x11c>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
   121c0:	687b      	ldr	r3, [r7, #4]
   121c2:	2b00      	cmp	r3, #0
   121c4:	d012      	beq.n	121ec <pvPortMalloc+0x54>
			{
				xWantedSize += xHeapStructSize;
   121c6:	2208      	movs	r2, #8
   121c8:	687b      	ldr	r3, [r7, #4]
   121ca:	189b      	adds	r3, r3, r2
   121cc:	607b      	str	r3, [r7, #4]

				/* Ensure that blocks are always aligned to the required number
				of bytes. */
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
   121ce:	687b      	ldr	r3, [r7, #4]
   121d0:	2207      	movs	r2, #7
   121d2:	4013      	ands	r3, r2
   121d4:	d00a      	beq.n	121ec <pvPortMalloc+0x54>
				{
					/* Byte alignment required. */
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
   121d6:	687b      	ldr	r3, [r7, #4]
   121d8:	2207      	movs	r2, #7
   121da:	4393      	bics	r3, r2
   121dc:	3308      	adds	r3, #8
   121de:	607b      	str	r3, [r7, #4]
					configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );
   121e0:	687b      	ldr	r3, [r7, #4]
   121e2:	2207      	movs	r2, #7
   121e4:	4013      	ands	r3, r2
   121e6:	d001      	beq.n	121ec <pvPortMalloc+0x54>
   121e8:	b672      	cpsid	i
   121ea:	e7fe      	b.n	121ea <pvPortMalloc+0x52>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
   121ec:	687b      	ldr	r3, [r7, #4]
   121ee:	2b00      	cmp	r3, #0
   121f0:	d060      	beq.n	122b4 <pvPortMalloc+0x11c>
   121f2:	4b39      	ldr	r3, [pc, #228]	; (122d8 <pvPortMalloc+0x140>)
   121f4:	681b      	ldr	r3, [r3, #0]
   121f6:	687a      	ldr	r2, [r7, #4]
   121f8:	429a      	cmp	r2, r3
   121fa:	d85b      	bhi.n	122b4 <pvPortMalloc+0x11c>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
   121fc:	4b37      	ldr	r3, [pc, #220]	; (122dc <pvPortMalloc+0x144>)
   121fe:	613b      	str	r3, [r7, #16]
				pxBlock = xStart.pxNextFreeBlock;
   12200:	4b36      	ldr	r3, [pc, #216]	; (122dc <pvPortMalloc+0x144>)
   12202:	681b      	ldr	r3, [r3, #0]
   12204:	617b      	str	r3, [r7, #20]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
   12206:	e004      	b.n	12212 <pvPortMalloc+0x7a>
				{
					pxPreviousBlock = pxBlock;
   12208:	697b      	ldr	r3, [r7, #20]
   1220a:	613b      	str	r3, [r7, #16]
					pxBlock = pxBlock->pxNextFreeBlock;
   1220c:	697b      	ldr	r3, [r7, #20]
   1220e:	681b      	ldr	r3, [r3, #0]
   12210:	617b      	str	r3, [r7, #20]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
   12212:	697b      	ldr	r3, [r7, #20]
   12214:	685b      	ldr	r3, [r3, #4]
   12216:	687a      	ldr	r2, [r7, #4]
   12218:	429a      	cmp	r2, r3
   1221a:	d903      	bls.n	12224 <pvPortMalloc+0x8c>
   1221c:	697b      	ldr	r3, [r7, #20]
   1221e:	681b      	ldr	r3, [r3, #0]
   12220:	2b00      	cmp	r3, #0
   12222:	d1f1      	bne.n	12208 <pvPortMalloc+0x70>
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
   12224:	4b2a      	ldr	r3, [pc, #168]	; (122d0 <pvPortMalloc+0x138>)
   12226:	681b      	ldr	r3, [r3, #0]
   12228:	697a      	ldr	r2, [r7, #20]
   1222a:	429a      	cmp	r2, r3
   1222c:	d042      	beq.n	122b4 <pvPortMalloc+0x11c>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
   1222e:	693b      	ldr	r3, [r7, #16]
   12230:	681b      	ldr	r3, [r3, #0]
   12232:	2208      	movs	r2, #8
   12234:	189b      	adds	r3, r3, r2
   12236:	60fb      	str	r3, [r7, #12]

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
   12238:	697b      	ldr	r3, [r7, #20]
   1223a:	681a      	ldr	r2, [r3, #0]
   1223c:	693b      	ldr	r3, [r7, #16]
   1223e:	601a      	str	r2, [r3, #0]

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
   12240:	697b      	ldr	r3, [r7, #20]
   12242:	685a      	ldr	r2, [r3, #4]
   12244:	687b      	ldr	r3, [r7, #4]
   12246:	1ad2      	subs	r2, r2, r3
   12248:	2308      	movs	r3, #8
   1224a:	005b      	lsls	r3, r3, #1
   1224c:	429a      	cmp	r2, r3
   1224e:	d916      	bls.n	1227e <pvPortMalloc+0xe6>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
   12250:	697a      	ldr	r2, [r7, #20]
   12252:	687b      	ldr	r3, [r7, #4]
   12254:	18d3      	adds	r3, r2, r3
   12256:	60bb      	str	r3, [r7, #8]
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
   12258:	68bb      	ldr	r3, [r7, #8]
   1225a:	2207      	movs	r2, #7
   1225c:	4013      	ands	r3, r2
   1225e:	d001      	beq.n	12264 <pvPortMalloc+0xcc>
   12260:	b672      	cpsid	i
   12262:	e7fe      	b.n	12262 <pvPortMalloc+0xca>

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
   12264:	697b      	ldr	r3, [r7, #20]
   12266:	685a      	ldr	r2, [r3, #4]
   12268:	687b      	ldr	r3, [r7, #4]
   1226a:	1ad2      	subs	r2, r2, r3
   1226c:	68bb      	ldr	r3, [r7, #8]
   1226e:	605a      	str	r2, [r3, #4]
						pxBlock->xBlockSize = xWantedSize;
   12270:	697b      	ldr	r3, [r7, #20]
   12272:	687a      	ldr	r2, [r7, #4]
   12274:	605a      	str	r2, [r3, #4]

						/* Insert the new block into the list of free blocks. */
						prvInsertBlockIntoFreeList( pxNewBlockLink );
   12276:	68bb      	ldr	r3, [r7, #8]
   12278:	0018      	movs	r0, r3
   1227a:	f000 f8db 	bl	12434 <prvInsertBlockIntoFreeList>
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
   1227e:	4b16      	ldr	r3, [pc, #88]	; (122d8 <pvPortMalloc+0x140>)
   12280:	681a      	ldr	r2, [r3, #0]
   12282:	697b      	ldr	r3, [r7, #20]
   12284:	685b      	ldr	r3, [r3, #4]
   12286:	1ad2      	subs	r2, r2, r3
   12288:	4b13      	ldr	r3, [pc, #76]	; (122d8 <pvPortMalloc+0x140>)
   1228a:	601a      	str	r2, [r3, #0]

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
   1228c:	4b12      	ldr	r3, [pc, #72]	; (122d8 <pvPortMalloc+0x140>)
   1228e:	681a      	ldr	r2, [r3, #0]
   12290:	4b13      	ldr	r3, [pc, #76]	; (122e0 <pvPortMalloc+0x148>)
   12292:	681b      	ldr	r3, [r3, #0]
   12294:	429a      	cmp	r2, r3
   12296:	d203      	bcs.n	122a0 <pvPortMalloc+0x108>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
   12298:	4b0f      	ldr	r3, [pc, #60]	; (122d8 <pvPortMalloc+0x140>)
   1229a:	681a      	ldr	r2, [r3, #0]
   1229c:	4b10      	ldr	r3, [pc, #64]	; (122e0 <pvPortMalloc+0x148>)
   1229e:	601a      	str	r2, [r3, #0]
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
   122a0:	697b      	ldr	r3, [r7, #20]
   122a2:	685a      	ldr	r2, [r3, #4]
   122a4:	4b0b      	ldr	r3, [pc, #44]	; (122d4 <pvPortMalloc+0x13c>)
   122a6:	681b      	ldr	r3, [r3, #0]
   122a8:	431a      	orrs	r2, r3
   122aa:	697b      	ldr	r3, [r7, #20]
   122ac:	605a      	str	r2, [r3, #4]
					pxBlock->pxNextFreeBlock = NULL;
   122ae:	697b      	ldr	r3, [r7, #20]
   122b0:	2200      	movs	r2, #0
   122b2:	601a      	str	r2, [r3, #0]
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
   122b4:	f7ff fbea 	bl	11a8c <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif

	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
   122b8:	68fb      	ldr	r3, [r7, #12]
   122ba:	2207      	movs	r2, #7
   122bc:	4013      	ands	r3, r2
   122be:	d001      	beq.n	122c4 <pvPortMalloc+0x12c>
   122c0:	b672      	cpsid	i
   122c2:	e7fe      	b.n	122c2 <pvPortMalloc+0x12a>
	return pvReturn;
   122c4:	68fb      	ldr	r3, [r7, #12]
}
   122c6:	0018      	movs	r0, r3
   122c8:	46bd      	mov	sp, r7
   122ca:	b006      	add	sp, #24
   122cc:	bd80      	pop	{r7, pc}
   122ce:	46c0      	nop			; (mov r8, r8)
   122d0:	00031cac 	.word	0x00031cac
   122d4:	00031cb8 	.word	0x00031cb8
   122d8:	00031cb0 	.word	0x00031cb0
   122dc:	00031ca4 	.word	0x00031ca4
   122e0:	00031cb4 	.word	0x00031cb4

000122e4 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
   122e4:	b580      	push	{r7, lr}
   122e6:	b084      	sub	sp, #16
   122e8:	af00      	add	r7, sp, #0
   122ea:	6078      	str	r0, [r7, #4]
uint8_t *puc = ( uint8_t * ) pv;
   122ec:	687b      	ldr	r3, [r7, #4]
   122ee:	60fb      	str	r3, [r7, #12]
BlockLink_t *pxLink;

	if( pv != NULL )
   122f0:	687b      	ldr	r3, [r7, #4]
   122f2:	2b00      	cmp	r3, #0
   122f4:	d035      	beq.n	12362 <vPortFree+0x7e>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= xHeapStructSize;
   122f6:	2308      	movs	r3, #8
   122f8:	425b      	negs	r3, r3
   122fa:	68fa      	ldr	r2, [r7, #12]
   122fc:	18d3      	adds	r3, r2, r3
   122fe:	60fb      	str	r3, [r7, #12]

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;
   12300:	68fb      	ldr	r3, [r7, #12]
   12302:	60bb      	str	r3, [r7, #8]

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
   12304:	68bb      	ldr	r3, [r7, #8]
   12306:	685a      	ldr	r2, [r3, #4]
   12308:	4b18      	ldr	r3, [pc, #96]	; (1236c <vPortFree+0x88>)
   1230a:	681b      	ldr	r3, [r3, #0]
   1230c:	4013      	ands	r3, r2
   1230e:	d101      	bne.n	12314 <vPortFree+0x30>
   12310:	b672      	cpsid	i
   12312:	e7fe      	b.n	12312 <vPortFree+0x2e>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
   12314:	68bb      	ldr	r3, [r7, #8]
   12316:	681b      	ldr	r3, [r3, #0]
   12318:	2b00      	cmp	r3, #0
   1231a:	d001      	beq.n	12320 <vPortFree+0x3c>
   1231c:	b672      	cpsid	i
   1231e:	e7fe      	b.n	1231e <vPortFree+0x3a>

		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
   12320:	68bb      	ldr	r3, [r7, #8]
   12322:	685a      	ldr	r2, [r3, #4]
   12324:	4b11      	ldr	r3, [pc, #68]	; (1236c <vPortFree+0x88>)
   12326:	681b      	ldr	r3, [r3, #0]
   12328:	4013      	ands	r3, r2
   1232a:	d01a      	beq.n	12362 <vPortFree+0x7e>
		{
			if( pxLink->pxNextFreeBlock == NULL )
   1232c:	68bb      	ldr	r3, [r7, #8]
   1232e:	681b      	ldr	r3, [r3, #0]
   12330:	2b00      	cmp	r3, #0
   12332:	d116      	bne.n	12362 <vPortFree+0x7e>
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
   12334:	68bb      	ldr	r3, [r7, #8]
   12336:	685a      	ldr	r2, [r3, #4]
   12338:	4b0c      	ldr	r3, [pc, #48]	; (1236c <vPortFree+0x88>)
   1233a:	681b      	ldr	r3, [r3, #0]
   1233c:	43db      	mvns	r3, r3
   1233e:	401a      	ands	r2, r3
   12340:	68bb      	ldr	r3, [r7, #8]
   12342:	605a      	str	r2, [r3, #4]

				vTaskSuspendAll();
   12344:	f7ff fb96 	bl	11a74 <vTaskSuspendAll>
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
   12348:	68bb      	ldr	r3, [r7, #8]
   1234a:	685a      	ldr	r2, [r3, #4]
   1234c:	4b08      	ldr	r3, [pc, #32]	; (12370 <vPortFree+0x8c>)
   1234e:	681b      	ldr	r3, [r3, #0]
   12350:	18d2      	adds	r2, r2, r3
   12352:	4b07      	ldr	r3, [pc, #28]	; (12370 <vPortFree+0x8c>)
   12354:	601a      	str	r2, [r3, #0]
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
   12356:	68bb      	ldr	r3, [r7, #8]
   12358:	0018      	movs	r0, r3
   1235a:	f000 f86b 	bl	12434 <prvInsertBlockIntoFreeList>
				}
				( void ) xTaskResumeAll();
   1235e:	f7ff fb95 	bl	11a8c <xTaskResumeAll>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
   12362:	46c0      	nop			; (mov r8, r8)
   12364:	46bd      	mov	sp, r7
   12366:	b004      	add	sp, #16
   12368:	bd80      	pop	{r7, pc}
   1236a:	46c0      	nop			; (mov r8, r8)
   1236c:	00031cb8 	.word	0x00031cb8
   12370:	00031cb0 	.word	0x00031cb0

00012374 <prvHeapInit>:
	/* This just exists to keep the linker quiet. */
}
/*-----------------------------------------------------------*/

static void prvHeapInit( void )
{
   12374:	b580      	push	{r7, lr}
   12376:	b084      	sub	sp, #16
   12378:	af00      	add	r7, sp, #0
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;
size_t uxAddress;
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
   1237a:	4b27      	ldr	r3, [pc, #156]	; (12418 <prvHeapInit+0xa4>)
   1237c:	60bb      	str	r3, [r7, #8]

	/* Ensure the heap starts on a correctly aligned boundary. */
	uxAddress = ( size_t ) ucHeap;
   1237e:	4b27      	ldr	r3, [pc, #156]	; (1241c <prvHeapInit+0xa8>)
   12380:	60fb      	str	r3, [r7, #12]

	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
   12382:	68fb      	ldr	r3, [r7, #12]
   12384:	2207      	movs	r2, #7
   12386:	4013      	ands	r3, r2
   12388:	d00c      	beq.n	123a4 <prvHeapInit+0x30>
	{
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
   1238a:	68fb      	ldr	r3, [r7, #12]
   1238c:	3307      	adds	r3, #7
   1238e:	60fb      	str	r3, [r7, #12]
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
   12390:	68fb      	ldr	r3, [r7, #12]
   12392:	2207      	movs	r2, #7
   12394:	4393      	bics	r3, r2
   12396:	60fb      	str	r3, [r7, #12]
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
   12398:	68ba      	ldr	r2, [r7, #8]
   1239a:	68fb      	ldr	r3, [r7, #12]
   1239c:	1ad2      	subs	r2, r2, r3
   1239e:	4b1f      	ldr	r3, [pc, #124]	; (1241c <prvHeapInit+0xa8>)
   123a0:	18d3      	adds	r3, r2, r3
   123a2:	60bb      	str	r3, [r7, #8]
	}

	pucAlignedHeap = ( uint8_t * ) uxAddress;
   123a4:	68fb      	ldr	r3, [r7, #12]
   123a6:	607b      	str	r3, [r7, #4]

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
   123a8:	4b1d      	ldr	r3, [pc, #116]	; (12420 <prvHeapInit+0xac>)
   123aa:	687a      	ldr	r2, [r7, #4]
   123ac:	601a      	str	r2, [r3, #0]
	xStart.xBlockSize = ( size_t ) 0;
   123ae:	4b1c      	ldr	r3, [pc, #112]	; (12420 <prvHeapInit+0xac>)
   123b0:	2200      	movs	r2, #0
   123b2:	605a      	str	r2, [r3, #4]

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
   123b4:	687b      	ldr	r3, [r7, #4]
   123b6:	68ba      	ldr	r2, [r7, #8]
   123b8:	18d3      	adds	r3, r2, r3
   123ba:	60fb      	str	r3, [r7, #12]
	uxAddress -= xHeapStructSize;
   123bc:	2208      	movs	r2, #8
   123be:	68fb      	ldr	r3, [r7, #12]
   123c0:	1a9b      	subs	r3, r3, r2
   123c2:	60fb      	str	r3, [r7, #12]
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
   123c4:	68fb      	ldr	r3, [r7, #12]
   123c6:	2207      	movs	r2, #7
   123c8:	4393      	bics	r3, r2
   123ca:	60fb      	str	r3, [r7, #12]
	pxEnd = ( void * ) uxAddress;
   123cc:	68fa      	ldr	r2, [r7, #12]
   123ce:	4b15      	ldr	r3, [pc, #84]	; (12424 <prvHeapInit+0xb0>)
   123d0:	601a      	str	r2, [r3, #0]
	pxEnd->xBlockSize = 0;
   123d2:	4b14      	ldr	r3, [pc, #80]	; (12424 <prvHeapInit+0xb0>)
   123d4:	681b      	ldr	r3, [r3, #0]
   123d6:	2200      	movs	r2, #0
   123d8:	605a      	str	r2, [r3, #4]
	pxEnd->pxNextFreeBlock = NULL;
   123da:	4b12      	ldr	r3, [pc, #72]	; (12424 <prvHeapInit+0xb0>)
   123dc:	681b      	ldr	r3, [r3, #0]
   123de:	2200      	movs	r2, #0
   123e0:	601a      	str	r2, [r3, #0]

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
   123e2:	687b      	ldr	r3, [r7, #4]
   123e4:	603b      	str	r3, [r7, #0]
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
   123e6:	683b      	ldr	r3, [r7, #0]
   123e8:	68fa      	ldr	r2, [r7, #12]
   123ea:	1ad2      	subs	r2, r2, r3
   123ec:	683b      	ldr	r3, [r7, #0]
   123ee:	605a      	str	r2, [r3, #4]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
   123f0:	4b0c      	ldr	r3, [pc, #48]	; (12424 <prvHeapInit+0xb0>)
   123f2:	681a      	ldr	r2, [r3, #0]
   123f4:	683b      	ldr	r3, [r7, #0]
   123f6:	601a      	str	r2, [r3, #0]

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
   123f8:	683b      	ldr	r3, [r7, #0]
   123fa:	685a      	ldr	r2, [r3, #4]
   123fc:	4b0a      	ldr	r3, [pc, #40]	; (12428 <prvHeapInit+0xb4>)
   123fe:	601a      	str	r2, [r3, #0]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
   12400:	683b      	ldr	r3, [r7, #0]
   12402:	685a      	ldr	r2, [r3, #4]
   12404:	4b09      	ldr	r3, [pc, #36]	; (1242c <prvHeapInit+0xb8>)
   12406:	601a      	str	r2, [r3, #0]

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
   12408:	4b09      	ldr	r3, [pc, #36]	; (12430 <prvHeapInit+0xbc>)
   1240a:	2280      	movs	r2, #128	; 0x80
   1240c:	0612      	lsls	r2, r2, #24
   1240e:	601a      	str	r2, [r3, #0]
}
   12410:	46c0      	nop			; (mov r8, r8)
   12412:	46bd      	mov	sp, r7
   12414:	b004      	add	sp, #16
   12416:	bd80      	pop	{r7, pc}
   12418:	00001a2c 	.word	0x00001a2c
   1241c:	00030278 	.word	0x00030278
   12420:	00031ca4 	.word	0x00031ca4
   12424:	00031cac 	.word	0x00031cac
   12428:	00031cb4 	.word	0x00031cb4
   1242c:	00031cb0 	.word	0x00031cb0
   12430:	00031cb8 	.word	0x00031cb8

00012434 <prvInsertBlockIntoFreeList>:
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
   12434:	b580      	push	{r7, lr}
   12436:	b084      	sub	sp, #16
   12438:	af00      	add	r7, sp, #0
   1243a:	6078      	str	r0, [r7, #4]
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
   1243c:	4b27      	ldr	r3, [pc, #156]	; (124dc <prvInsertBlockIntoFreeList+0xa8>)
   1243e:	60fb      	str	r3, [r7, #12]
   12440:	e002      	b.n	12448 <prvInsertBlockIntoFreeList+0x14>
   12442:	68fb      	ldr	r3, [r7, #12]
   12444:	681b      	ldr	r3, [r3, #0]
   12446:	60fb      	str	r3, [r7, #12]
   12448:	68fb      	ldr	r3, [r7, #12]
   1244a:	681b      	ldr	r3, [r3, #0]
   1244c:	687a      	ldr	r2, [r7, #4]
   1244e:	429a      	cmp	r2, r3
   12450:	d8f7      	bhi.n	12442 <prvInsertBlockIntoFreeList+0xe>
		/* Nothing to do here, just iterate to the right position. */
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
   12452:	68fb      	ldr	r3, [r7, #12]
   12454:	60bb      	str	r3, [r7, #8]
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
   12456:	68fb      	ldr	r3, [r7, #12]
   12458:	685b      	ldr	r3, [r3, #4]
   1245a:	68ba      	ldr	r2, [r7, #8]
   1245c:	18d3      	adds	r3, r2, r3
   1245e:	687a      	ldr	r2, [r7, #4]
   12460:	429a      	cmp	r2, r3
   12462:	d108      	bne.n	12476 <prvInsertBlockIntoFreeList+0x42>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
   12464:	68fb      	ldr	r3, [r7, #12]
   12466:	685a      	ldr	r2, [r3, #4]
   12468:	687b      	ldr	r3, [r7, #4]
   1246a:	685b      	ldr	r3, [r3, #4]
   1246c:	18d2      	adds	r2, r2, r3
   1246e:	68fb      	ldr	r3, [r7, #12]
   12470:	605a      	str	r2, [r3, #4]
		pxBlockToInsert = pxIterator;
   12472:	68fb      	ldr	r3, [r7, #12]
   12474:	607b      	str	r3, [r7, #4]
		mtCOVERAGE_TEST_MARKER();
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
   12476:	687b      	ldr	r3, [r7, #4]
   12478:	60bb      	str	r3, [r7, #8]
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
   1247a:	687b      	ldr	r3, [r7, #4]
   1247c:	685b      	ldr	r3, [r3, #4]
   1247e:	68ba      	ldr	r2, [r7, #8]
   12480:	18d2      	adds	r2, r2, r3
   12482:	68fb      	ldr	r3, [r7, #12]
   12484:	681b      	ldr	r3, [r3, #0]
   12486:	429a      	cmp	r2, r3
   12488:	d118      	bne.n	124bc <prvInsertBlockIntoFreeList+0x88>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
   1248a:	68fb      	ldr	r3, [r7, #12]
   1248c:	681a      	ldr	r2, [r3, #0]
   1248e:	4b14      	ldr	r3, [pc, #80]	; (124e0 <prvInsertBlockIntoFreeList+0xac>)
   12490:	681b      	ldr	r3, [r3, #0]
   12492:	429a      	cmp	r2, r3
   12494:	d00d      	beq.n	124b2 <prvInsertBlockIntoFreeList+0x7e>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
   12496:	687b      	ldr	r3, [r7, #4]
   12498:	685a      	ldr	r2, [r3, #4]
   1249a:	68fb      	ldr	r3, [r7, #12]
   1249c:	681b      	ldr	r3, [r3, #0]
   1249e:	685b      	ldr	r3, [r3, #4]
   124a0:	18d2      	adds	r2, r2, r3
   124a2:	687b      	ldr	r3, [r7, #4]
   124a4:	605a      	str	r2, [r3, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
   124a6:	68fb      	ldr	r3, [r7, #12]
   124a8:	681b      	ldr	r3, [r3, #0]
   124aa:	681a      	ldr	r2, [r3, #0]
   124ac:	687b      	ldr	r3, [r7, #4]
   124ae:	601a      	str	r2, [r3, #0]
   124b0:	e008      	b.n	124c4 <prvInsertBlockIntoFreeList+0x90>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
   124b2:	4b0b      	ldr	r3, [pc, #44]	; (124e0 <prvInsertBlockIntoFreeList+0xac>)
   124b4:	681a      	ldr	r2, [r3, #0]
   124b6:	687b      	ldr	r3, [r7, #4]
   124b8:	601a      	str	r2, [r3, #0]
   124ba:	e003      	b.n	124c4 <prvInsertBlockIntoFreeList+0x90>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
   124bc:	68fb      	ldr	r3, [r7, #12]
   124be:	681a      	ldr	r2, [r3, #0]
   124c0:	687b      	ldr	r3, [r7, #4]
   124c2:	601a      	str	r2, [r3, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
   124c4:	68fa      	ldr	r2, [r7, #12]
   124c6:	687b      	ldr	r3, [r7, #4]
   124c8:	429a      	cmp	r2, r3
   124ca:	d002      	beq.n	124d2 <prvInsertBlockIntoFreeList+0x9e>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
   124cc:	68fb      	ldr	r3, [r7, #12]
   124ce:	687a      	ldr	r2, [r7, #4]
   124d0:	601a      	str	r2, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
   124d2:	46c0      	nop			; (mov r8, r8)
   124d4:	46bd      	mov	sp, r7
   124d6:	b004      	add	sp, #16
   124d8:	bd80      	pop	{r7, pc}
   124da:	46c0      	nop			; (mov r8, r8)
   124dc:	00031ca4 	.word	0x00031ca4
   124e0:	00031cac 	.word	0x00031cac

000124e4 <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
   124e4:	b580      	push	{r7, lr}
   124e6:	b084      	sub	sp, #16
   124e8:	af00      	add	r7, sp, #0
   124ea:	60f8      	str	r0, [r7, #12]
   124ec:	60b9      	str	r1, [r7, #8]
   124ee:	607a      	str	r2, [r7, #4]
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */
	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
   124f0:	68fb      	ldr	r3, [r7, #12]
   124f2:	3b04      	subs	r3, #4
   124f4:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
   124f6:	68fb      	ldr	r3, [r7, #12]
   124f8:	2280      	movs	r2, #128	; 0x80
   124fa:	0452      	lsls	r2, r2, #17
   124fc:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
   124fe:	68fb      	ldr	r3, [r7, #12]
   12500:	3b04      	subs	r3, #4
   12502:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
   12504:	68ba      	ldr	r2, [r7, #8]
   12506:	68fb      	ldr	r3, [r7, #12]
   12508:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
   1250a:	68fb      	ldr	r3, [r7, #12]
   1250c:	3b04      	subs	r3, #4
   1250e:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
   12510:	4a08      	ldr	r2, [pc, #32]	; (12534 <pxPortInitialiseStack+0x50>)
   12512:	68fb      	ldr	r3, [r7, #12]
   12514:	601a      	str	r2, [r3, #0]
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
   12516:	68fb      	ldr	r3, [r7, #12]
   12518:	3b14      	subs	r3, #20
   1251a:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
   1251c:	687a      	ldr	r2, [r7, #4]
   1251e:	68fb      	ldr	r3, [r7, #12]
   12520:	601a      	str	r2, [r3, #0]
	pxTopOfStack -= 8; /* R11..R4. */
   12522:	68fb      	ldr	r3, [r7, #12]
   12524:	3b20      	subs	r3, #32
   12526:	60fb      	str	r3, [r7, #12]

	return pxTopOfStack;
   12528:	68fb      	ldr	r3, [r7, #12]
}
   1252a:	0018      	movs	r0, r3
   1252c:	46bd      	mov	sp, r7
   1252e:	b004      	add	sp, #16
   12530:	bd80      	pop	{r7, pc}
   12532:	46c0      	nop			; (mov r8, r8)
   12534:	00012539 	.word	0x00012539

00012538 <prvTaskExitError>:
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
   12538:	b580      	push	{r7, lr}
   1253a:	b082      	sub	sp, #8
   1253c:	af00      	add	r7, sp, #0
volatile uint32_t ulDummy = 0UL;
   1253e:	2300      	movs	r3, #0
   12540:	607b      	str	r3, [r7, #4]
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
   12542:	4b07      	ldr	r3, [pc, #28]	; (12560 <prvTaskExitError+0x28>)
   12544:	681b      	ldr	r3, [r3, #0]
   12546:	3301      	adds	r3, #1
   12548:	d001      	beq.n	1254e <prvTaskExitError+0x16>
   1254a:	b672      	cpsid	i
   1254c:	e7fe      	b.n	1254c <prvTaskExitError+0x14>
	portDISABLE_INTERRUPTS();
   1254e:	b672      	cpsid	i
	while( ulDummy == 0 )
   12550:	46c0      	nop			; (mov r8, r8)
   12552:	687b      	ldr	r3, [r7, #4]
   12554:	2b00      	cmp	r3, #0
   12556:	d0fc      	beq.n	12552 <prvTaskExitError+0x1a>
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. */
	}
}
   12558:	46c0      	nop			; (mov r8, r8)
   1255a:	46bd      	mov	sp, r7
   1255c:	b002      	add	sp, #8
   1255e:	bd80      	pop	{r7, pc}
   12560:	0002ff50 	.word	0x0002ff50
	...

00012570 <vPortStartFirstTask>:
void vPortStartFirstTask( void )
{
	/* The MSP stack is not reset as, unlike on M3/4 parts, there is no vector
	table offset register that can be used to locate the initial stack value.
	Not all M0 parts have the application vector table at address 0. */
	__asm volatile(
   12570:	4a0b      	ldr	r2, [pc, #44]	; (125a0 <pxCurrentTCBConst2>)
   12572:	6813      	ldr	r3, [r2, #0]
   12574:	6818      	ldr	r0, [r3, #0]
   12576:	3020      	adds	r0, #32
   12578:	f380 8809 	msr	PSP, r0
   1257c:	2002      	movs	r0, #2
   1257e:	f380 8814 	msr	CONTROL, r0
   12582:	f3bf 8f6f 	isb	sy
   12586:	bc3f      	pop	{r0, r1, r2, r3, r4, r5}
   12588:	46ae      	mov	lr, r5
   1258a:	bc08      	pop	{r3}
   1258c:	bc04      	pop	{r2}
   1258e:	b662      	cpsie	i
   12590:	4718      	bx	r3
   12592:	46c0      	nop			; (mov r8, r8)
   12594:	46c0      	nop			; (mov r8, r8)
   12596:	46c0      	nop			; (mov r8, r8)
   12598:	46c0      	nop			; (mov r8, r8)
   1259a:	46c0      	nop			; (mov r8, r8)
   1259c:	46c0      	nop			; (mov r8, r8)
   1259e:	46c0      	nop			; (mov r8, r8)

000125a0 <pxCurrentTCBConst2>:
   125a0:	0003014c 	.word	0x0003014c
	"	bx   r3						\n" /* Finally, jump to the user defined task code. */
	"								\n"
	"	.align 4					\n"
	"pxCurrentTCBConst2: .word pxCurrentTCB	  "
				  );
}
   125a4:	46c0      	nop			; (mov r8, r8)
   125a6:	46c0      	nop			; (mov r8, r8)

000125a8 <xPortStartScheduler>:

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
   125a8:	b580      	push	{r7, lr}
   125aa:	af00      	add	r7, sp, #0
	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
   125ac:	4b0e      	ldr	r3, [pc, #56]	; (125e8 <xPortStartScheduler+0x40>)
   125ae:	681a      	ldr	r2, [r3, #0]
   125b0:	4b0d      	ldr	r3, [pc, #52]	; (125e8 <xPortStartScheduler+0x40>)
   125b2:	21ff      	movs	r1, #255	; 0xff
   125b4:	0409      	lsls	r1, r1, #16
   125b6:	430a      	orrs	r2, r1
   125b8:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
   125ba:	4b0b      	ldr	r3, [pc, #44]	; (125e8 <xPortStartScheduler+0x40>)
   125bc:	681a      	ldr	r2, [r3, #0]
   125be:	4b0a      	ldr	r3, [pc, #40]	; (125e8 <xPortStartScheduler+0x40>)
   125c0:	21ff      	movs	r1, #255	; 0xff
   125c2:	0609      	lsls	r1, r1, #24
   125c4:	430a      	orrs	r2, r1
   125c6:	601a      	str	r2, [r3, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();
   125c8:	f000 f856 	bl	12678 <prvSetupTimerInterrupt>

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
   125cc:	4b07      	ldr	r3, [pc, #28]	; (125ec <xPortStartScheduler+0x44>)
   125ce:	2200      	movs	r2, #0
   125d0:	601a      	str	r2, [r3, #0]

	/* Start the first task. */
	vPortStartFirstTask();
   125d2:	f7ff ffcd 	bl	12570 <vPortStartFirstTask>
	exit error function to prevent compiler warnings about a static function
	not being called in the case that the application writer overrides this
	functionality by defining configTASK_RETURN_ADDRESS.  Call
	vTaskSwitchContext() so link time optimisation does not remove the
	symbol. */
	vTaskSwitchContext();
   125d6:	f7ff fb99 	bl	11d0c <vTaskSwitchContext>
	prvTaskExitError();
   125da:	f7ff ffad 	bl	12538 <prvTaskExitError>

	/* Should not get here! */
	return 0;
   125de:	2300      	movs	r3, #0
}
   125e0:	0018      	movs	r0, r3
   125e2:	46bd      	mov	sp, r7
   125e4:	bd80      	pop	{r7, pc}
   125e6:	46c0      	nop			; (mov r8, r8)
   125e8:	e000ed20 	.word	0xe000ed20
   125ec:	0002ff50 	.word	0x0002ff50

000125f0 <vPortYield>:
	configASSERT( uxCriticalNesting == 1000UL );
}
/*-----------------------------------------------------------*/

void vPortYield( void )
{
   125f0:	b580      	push	{r7, lr}
   125f2:	af00      	add	r7, sp, #0
	/* Set a PendSV to request a context switch. */
	*( portNVIC_INT_CTRL ) = portNVIC_PENDSVSET;
   125f4:	4b05      	ldr	r3, [pc, #20]	; (1260c <vPortYield+0x1c>)
   125f6:	2280      	movs	r2, #128	; 0x80
   125f8:	0552      	lsls	r2, r2, #21
   125fa:	601a      	str	r2, [r3, #0]

	/* Barriers are normally not required but do ensure the code is completely
	within the specified behaviour for the architecture. */
	__asm volatile( "dsb" ::: "memory" );
   125fc:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
   12600:	f3bf 8f6f 	isb	sy
}
   12604:	46c0      	nop			; (mov r8, r8)
   12606:	46bd      	mov	sp, r7
   12608:	bd80      	pop	{r7, pc}
   1260a:	46c0      	nop			; (mov r8, r8)
   1260c:	e000ed04 	.word	0xe000ed04

00012610 <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
   12610:	b580      	push	{r7, lr}
   12612:	af00      	add	r7, sp, #0
    portDISABLE_INTERRUPTS();
   12614:	b672      	cpsid	i
    uxCriticalNesting++;
   12616:	4b06      	ldr	r3, [pc, #24]	; (12630 <vPortEnterCritical+0x20>)
   12618:	681b      	ldr	r3, [r3, #0]
   1261a:	1c5a      	adds	r2, r3, #1
   1261c:	4b04      	ldr	r3, [pc, #16]	; (12630 <vPortEnterCritical+0x20>)
   1261e:	601a      	str	r2, [r3, #0]
	__asm volatile( "dsb" ::: "memory" );
   12620:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
   12624:	f3bf 8f6f 	isb	sy
}
   12628:	46c0      	nop			; (mov r8, r8)
   1262a:	46bd      	mov	sp, r7
   1262c:	bd80      	pop	{r7, pc}
   1262e:	46c0      	nop			; (mov r8, r8)
   12630:	0002ff50 	.word	0x0002ff50

00012634 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
   12634:	b580      	push	{r7, lr}
   12636:	af00      	add	r7, sp, #0
	configASSERT( uxCriticalNesting );
   12638:	4b09      	ldr	r3, [pc, #36]	; (12660 <vPortExitCritical+0x2c>)
   1263a:	681b      	ldr	r3, [r3, #0]
   1263c:	2b00      	cmp	r3, #0
   1263e:	d101      	bne.n	12644 <vPortExitCritical+0x10>
   12640:	b672      	cpsid	i
   12642:	e7fe      	b.n	12642 <vPortExitCritical+0xe>
    uxCriticalNesting--;
   12644:	4b06      	ldr	r3, [pc, #24]	; (12660 <vPortExitCritical+0x2c>)
   12646:	681b      	ldr	r3, [r3, #0]
   12648:	1e5a      	subs	r2, r3, #1
   1264a:	4b05      	ldr	r3, [pc, #20]	; (12660 <vPortExitCritical+0x2c>)
   1264c:	601a      	str	r2, [r3, #0]
    if( uxCriticalNesting == 0 )
   1264e:	4b04      	ldr	r3, [pc, #16]	; (12660 <vPortExitCritical+0x2c>)
   12650:	681b      	ldr	r3, [r3, #0]
   12652:	2b00      	cmp	r3, #0
   12654:	d100      	bne.n	12658 <vPortExitCritical+0x24>
    {
        portENABLE_INTERRUPTS();
   12656:	b662      	cpsie	i
    }
}
   12658:	46c0      	nop			; (mov r8, r8)
   1265a:	46bd      	mov	sp, r7
   1265c:	bd80      	pop	{r7, pc}
   1265e:	46c0      	nop			; (mov r8, r8)
   12660:	0002ff50 	.word	0x0002ff50

00012664 <ulSetInterruptMaskFromISR>:
/*-----------------------------------------------------------*/

uint32_t ulSetInterruptMaskFromISR( void )
{
	__asm volatile(
   12664:	f3ef 8010 	mrs	r0, PRIMASK
   12668:	b672      	cpsid	i
   1266a:	4770      	bx	lr
	/* To avoid compiler warnings.  The return statement will nevere be reached,
	but some compilers warn if it is not included, while others won't compile if
	it is. */
	return 0;
#endif
}
   1266c:	46c0      	nop			; (mov r8, r8)
   1266e:	0018      	movs	r0, r3

00012670 <vClearInterruptMaskFromISR>:
/*-----------------------------------------------------------*/

void vClearInterruptMaskFromISR( __attribute__( ( unused ) ) uint32_t ulMask )
{
	__asm volatile(
   12670:	f380 8810 	msr	PRIMASK, r0
   12674:	4770      	bx	lr
	/* Just to avoid compiler warning.  ulMask is used from the asm code but
	the compiler can't see that.  Some compilers generate warnings without the
	following line, while others generate warnings if the line is included. */
	( void ) ulMask;
#endif
}
   12676:	46c0      	nop			; (mov r8, r8)

00012678 <prvSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
void prvSetupTimerInterrupt( void )
{
   12678:	b580      	push	{r7, lr}
   1267a:	af00      	add	r7, sp, #0
   ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
 }
 #endif /* configUSE_TICKLESS_IDLE */

/* Stop and reset the SysTick. */
	portNVIC_SYSTICK_CTRL = 0UL;
   1267c:	4b0b      	ldr	r3, [pc, #44]	; (126ac <prvSetupTimerInterrupt+0x34>)
   1267e:	2200      	movs	r2, #0
   12680:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CURRENT_VALUE = 0UL;
   12682:	4b0b      	ldr	r3, [pc, #44]	; (126b0 <prvSetupTimerInterrupt+0x38>)
   12684:	2200      	movs	r2, #0
   12686:	601a      	str	r2, [r3, #0]

 /* Configure SysTick to interrupt at the requested rate. */
 portNVIC_SYSTICK_LOAD = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
   12688:	4b0a      	ldr	r3, [pc, #40]	; (126b4 <prvSetupTimerInterrupt+0x3c>)
   1268a:	681a      	ldr	r2, [r3, #0]
   1268c:	23fa      	movs	r3, #250	; 0xfa
   1268e:	0099      	lsls	r1, r3, #2
   12690:	0010      	movs	r0, r2
   12692:	f00c fc17 	bl	1eec4 <__udivsi3>
   12696:	0003      	movs	r3, r0
   12698:	001a      	movs	r2, r3
   1269a:	4b07      	ldr	r3, [pc, #28]	; (126b8 <prvSetupTimerInterrupt+0x40>)
   1269c:	3a01      	subs	r2, #1
   1269e:	601a      	str	r2, [r3, #0]
 portNVIC_SYSTICK_CTRL = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
   126a0:	4b02      	ldr	r3, [pc, #8]	; (126ac <prvSetupTimerInterrupt+0x34>)
   126a2:	2207      	movs	r2, #7
   126a4:	601a      	str	r2, [r3, #0]
}
   126a6:	46c0      	nop			; (mov r8, r8)
   126a8:	46bd      	mov	sp, r7
   126aa:	bd80      	pop	{r7, pc}
   126ac:	e000e010 	.word	0xe000e010
   126b0:	e000e018 	.word	0xe000e018
   126b4:	0002fec4 	.word	0x0002fec4
   126b8:	e000e014 	.word	0xe000e014

000126bc <BSP_GUI_LoadDataFromFlash>:
static GUI_StatusTypeDef        LoadSettingsFromFlash(uint32_t Address, uint32_t *pSettings, uint32_t Size);
static GUI_StatusTypeDef        SavePDOInFlash(uint32_t Address, uint32_t* pListOfPDO);
static GUI_StatusTypeDef        SaveSettingsInFlash(uint32_t Address, uint32_t *pSettings, uint32_t Size);

GUI_StatusTypeDef BSP_GUI_LoadDataFromFlash(void)
{
   126bc:	b590      	push	{r4, r7, lr}
   126be:	b085      	sub	sp, #20
   126c0:	af00      	add	r7, sp, #0
  GUI_StatusTypeDef _status = GUI_ERROR;
   126c2:	230f      	movs	r3, #15
   126c4:	18fb      	adds	r3, r7, r3
   126c6:	2203      	movs	r2, #3
   126c8:	701a      	strb	r2, [r3, #0]
  uint32_t _addr = GUI_FLASH_ADDR_NB_PDO_SNK_P0;
   126ca:	4b44      	ldr	r3, [pc, #272]	; (127dc <BSP_GUI_LoadDataFromFlash+0x120>)
   126cc:	60bb      	str	r3, [r7, #8]
  {
    goto _exit;
  }

  /* Update USBPD_NbPDO? */
  if (0xFFFFFFFFu != *((uint32_t*)_addr))
   126ce:	68bb      	ldr	r3, [r7, #8]
   126d0:	681b      	ldr	r3, [r3, #0]
   126d2:	3301      	adds	r3, #1
   126d4:	d022      	beq.n	1271c <BSP_GUI_LoadDataFromFlash+0x60>
  {
    uint32_t* _ptr = (uint32_t*)USBPD_NbPDO;
   126d6:	4b42      	ldr	r3, [pc, #264]	; (127e0 <BSP_GUI_LoadDataFromFlash+0x124>)
   126d8:	607b      	str	r3, [r7, #4]
    USPBPD_WRITE32 (_ptr,*((uint32_t*)_addr));
   126da:	230e      	movs	r3, #14
   126dc:	18fb      	adds	r3, r7, r3
   126de:	2200      	movs	r2, #0
   126e0:	701a      	strb	r2, [r3, #0]
   126e2:	e012      	b.n	1270a <BSP_GUI_LoadDataFromFlash+0x4e>
   126e4:	68bb      	ldr	r3, [r7, #8]
   126e6:	681a      	ldr	r2, [r3, #0]
   126e8:	200e      	movs	r0, #14
   126ea:	183b      	adds	r3, r7, r0
   126ec:	781b      	ldrb	r3, [r3, #0]
   126ee:	00db      	lsls	r3, r3, #3
   126f0:	40da      	lsrs	r2, r3
   126f2:	0011      	movs	r1, r2
   126f4:	183b      	adds	r3, r7, r0
   126f6:	781b      	ldrb	r3, [r3, #0]
   126f8:	687a      	ldr	r2, [r7, #4]
   126fa:	18d3      	adds	r3, r2, r3
   126fc:	b2ca      	uxtb	r2, r1
   126fe:	701a      	strb	r2, [r3, #0]
   12700:	183b      	adds	r3, r7, r0
   12702:	781a      	ldrb	r2, [r3, #0]
   12704:	183b      	adds	r3, r7, r0
   12706:	3201      	adds	r2, #1
   12708:	701a      	strb	r2, [r3, #0]
   1270a:	230e      	movs	r3, #14
   1270c:	18fb      	adds	r3, r7, r3
   1270e:	781b      	ldrb	r3, [r3, #0]
   12710:	2b03      	cmp	r3, #3
   12712:	d9e7      	bls.n	126e4 <BSP_GUI_LoadDataFromFlash+0x28>
    _status = GUI_OK;
   12714:	230f      	movs	r3, #15
   12716:	18fb      	adds	r3, r7, r3
   12718:	2200      	movs	r2, #0
   1271a:	701a      	strb	r2, [r3, #0]
  }

#if defined(_SRC) || defined(_DRP)
  /* Save PORT0_PDO_ListSRC */
  _status |= LoadPDOFromFlash(GUI_FLASH_ADDR_PDO_SRC_P0, PORT0_PDO_ListSRC);
   1271c:	4b31      	ldr	r3, [pc, #196]	; (127e4 <BSP_GUI_LoadDataFromFlash+0x128>)
   1271e:	4a32      	ldr	r2, [pc, #200]	; (127e8 <BSP_GUI_LoadDataFromFlash+0x12c>)
   12720:	0019      	movs	r1, r3
   12722:	0010      	movs	r0, r2
   12724:	f000 fa90 	bl	12c48 <LoadPDOFromFlash>
   12728:	0003      	movs	r3, r0
   1272a:	0019      	movs	r1, r3
   1272c:	240f      	movs	r4, #15
   1272e:	193b      	adds	r3, r7, r4
   12730:	193a      	adds	r2, r7, r4
   12732:	7812      	ldrb	r2, [r2, #0]
   12734:	430a      	orrs	r2, r1
   12736:	701a      	strb	r2, [r3, #0]
#endif /* _SRC || _DRP */

#if defined(_SNK) || defined(_DRP)
  /* Save PORT0_PDO_ListSNK */
  _status |= LoadPDOFromFlash(GUI_FLASH_ADDR_PDO_SNK_P0, PORT0_PDO_ListSNK);
   12738:	4b2c      	ldr	r3, [pc, #176]	; (127ec <BSP_GUI_LoadDataFromFlash+0x130>)
   1273a:	4a2d      	ldr	r2, [pc, #180]	; (127f0 <BSP_GUI_LoadDataFromFlash+0x134>)
   1273c:	0019      	movs	r1, r3
   1273e:	0010      	movs	r0, r2
   12740:	f000 fa82 	bl	12c48 <LoadPDOFromFlash>
   12744:	0003      	movs	r3, r0
   12746:	0019      	movs	r1, r3
   12748:	193b      	adds	r3, r7, r4
   1274a:	193a      	adds	r2, r7, r4
   1274c:	7812      	ldrb	r2, [r2, #0]
   1274e:	430a      	orrs	r2, r1
   12750:	701a      	strb	r2, [r3, #0]
  _status |= LoadPDOFromFlash(GUI_FLASH_ADDR_PDO_SNK_P1, PORT1_PDO_ListSNK);
#endif /* _SNK || _DRP */
#endif /* USBPD_PORT_COUNT==2 */

  /* Save DPM_Settings of port 0 */
  _status |= LoadSettingsFromFlash(GUI_FLASH_ADDR_DPM_SETTINGS, (uint32_t*)DPM_Settings, sizeof(USBPD_SettingsTypeDef) * USBPD_PORT_COUNT);
   12752:	4b28      	ldr	r3, [pc, #160]	; (127f4 <BSP_GUI_LoadDataFromFlash+0x138>)
   12754:	4828      	ldr	r0, [pc, #160]	; (127f8 <BSP_GUI_LoadDataFromFlash+0x13c>)
   12756:	220c      	movs	r2, #12
   12758:	0019      	movs	r1, r3
   1275a:	f000 faa2 	bl	12ca2 <LoadSettingsFromFlash>
   1275e:	0003      	movs	r3, r0
   12760:	0019      	movs	r1, r3
   12762:	193b      	adds	r3, r7, r4
   12764:	193a      	adds	r2, r7, r4
   12766:	7812      	ldrb	r2, [r2, #0]
   12768:	430a      	orrs	r2, r1
   1276a:	701a      	strb	r2, [r3, #0]

#if defined(GUI_FLASH_ADDR_DPM_ID_SETTINGS)
  /* Save DPM_ID_Settings */
  _status |= LoadSettingsFromFlash(GUI_FLASH_ADDR_DPM_ID_SETTINGS, (uint32_t*)DPM_ID_Settings, sizeof(USBPD_IdSettingsTypeDef) * USBPD_PORT_COUNT);
   1276c:	4b23      	ldr	r3, [pc, #140]	; (127fc <BSP_GUI_LoadDataFromFlash+0x140>)
   1276e:	4824      	ldr	r0, [pc, #144]	; (12800 <BSP_GUI_LoadDataFromFlash+0x144>)
   12770:	2208      	movs	r2, #8
   12772:	0019      	movs	r1, r3
   12774:	f000 fa95 	bl	12ca2 <LoadSettingsFromFlash>
   12778:	0003      	movs	r3, r0
   1277a:	0019      	movs	r1, r3
   1277c:	193b      	adds	r3, r7, r4
   1277e:	193a      	adds	r2, r7, r4
   12780:	7812      	ldrb	r2, [r2, #0]
   12782:	430a      	orrs	r2, r1
   12784:	701a      	strb	r2, [r3, #0]
#endif /* GUI_FLASH_ADDR_DPM_ID_SETTINGS */

  /* Save DPM_Settings of port 0 */
  _status |= LoadSettingsFromFlash(GUI_FLASH_ADDR_DPM_USER_SETTINGS, (uint32_t*)DPM_USER_Settings, sizeof(USBPD_USER_SettingsTypeDef) * USBPD_PORT_COUNT);
   12786:	4b1f      	ldr	r3, [pc, #124]	; (12804 <BSP_GUI_LoadDataFromFlash+0x148>)
   12788:	481f      	ldr	r0, [pc, #124]	; (12808 <BSP_GUI_LoadDataFromFlash+0x14c>)
   1278a:	2274      	movs	r2, #116	; 0x74
   1278c:	0019      	movs	r1, r3
   1278e:	f000 fa88 	bl	12ca2 <LoadSettingsFromFlash>
   12792:	0003      	movs	r3, r0
   12794:	0019      	movs	r1, r3
   12796:	0020      	movs	r0, r4
   12798:	183b      	adds	r3, r7, r0
   1279a:	183a      	adds	r2, r7, r0
   1279c:	7812      	ldrb	r2, [r2, #0]
   1279e:	430a      	orrs	r2, r1
   127a0:	701a      	strb	r2, [r3, #0]
  DPM_USER_Settings[USBPD_PORT_1].DPM_SRCExtendedCapa.VID = DPM_ID_Settings[USBPD_PORT_1].VID;
  DPM_USER_Settings[USBPD_PORT_1].DPM_SRCExtendedCapa.PID = DPM_ID_Settings[USBPD_PORT_1].PID;
#endif /* USBPD_PORT_COUNT==2 */
#endif /* _SRC_CAPA_EXT && (_SRC || _DRP) */
#if defined(_SNK)||defined(_DRP)
  DPM_USER_Settings[USBPD_PORT_0].DPM_SNKExtendedCapa.XID = DPM_ID_Settings[USBPD_PORT_0].XID;
   127a2:	4b16      	ldr	r3, [pc, #88]	; (127fc <BSP_GUI_LoadDataFromFlash+0x140>)
   127a4:	681a      	ldr	r2, [r3, #0]
   127a6:	4b17      	ldr	r3, [pc, #92]	; (12804 <BSP_GUI_LoadDataFromFlash+0x148>)
   127a8:	655a      	str	r2, [r3, #84]	; 0x54
  DPM_USER_Settings[USBPD_PORT_0].DPM_SNKExtendedCapa.VID = DPM_ID_Settings[USBPD_PORT_0].VID;
   127aa:	4b14      	ldr	r3, [pc, #80]	; (127fc <BSP_GUI_LoadDataFromFlash+0x140>)
   127ac:	8899      	ldrh	r1, [r3, #4]
   127ae:	4b15      	ldr	r3, [pc, #84]	; (12804 <BSP_GUI_LoadDataFromFlash+0x148>)
   127b0:	2250      	movs	r2, #80	; 0x50
   127b2:	5299      	strh	r1, [r3, r2]
  DPM_USER_Settings[USBPD_PORT_0].DPM_SNKExtendedCapa.PID = DPM_ID_Settings[USBPD_PORT_0].PID;
   127b4:	4b11      	ldr	r3, [pc, #68]	; (127fc <BSP_GUI_LoadDataFromFlash+0x140>)
   127b6:	88d9      	ldrh	r1, [r3, #6]
   127b8:	4b12      	ldr	r3, [pc, #72]	; (12804 <BSP_GUI_LoadDataFromFlash+0x148>)
   127ba:	2252      	movs	r2, #82	; 0x52
   127bc:	5299      	strh	r1, [r3, r2]
  DPM_USER_Settings[USBPD_PORT_1].DPM_SNKExtendedCapa.VID = DPM_ID_Settings[USBPD_PORT_1].VID;
  DPM_USER_Settings[USBPD_PORT_1].DPM_SNKExtendedCapa.PID = DPM_ID_Settings[USBPD_PORT_1].PID;
#endif /* USBPD_PORT_COUNT==2 */
#endif /* _SNK || _DRP */
#if _MANU_INFO
  DPM_USER_Settings[USBPD_PORT_0].DPM_ManuInfoPort.VID = DPM_ID_Settings[USBPD_PORT_0].VID;
   127be:	4b0f      	ldr	r3, [pc, #60]	; (127fc <BSP_GUI_LoadDataFromFlash+0x140>)
   127c0:	889a      	ldrh	r2, [r3, #4]
   127c2:	4b10      	ldr	r3, [pc, #64]	; (12804 <BSP_GUI_LoadDataFromFlash+0x148>)
   127c4:	839a      	strh	r2, [r3, #28]
  DPM_USER_Settings[USBPD_PORT_0].DPM_ManuInfoPort.PID = DPM_ID_Settings[USBPD_PORT_0].PID;
   127c6:	4b0d      	ldr	r3, [pc, #52]	; (127fc <BSP_GUI_LoadDataFromFlash+0x140>)
   127c8:	88da      	ldrh	r2, [r3, #6]
   127ca:	4b0e      	ldr	r3, [pc, #56]	; (12804 <BSP_GUI_LoadDataFromFlash+0x148>)
   127cc:	83da      	strh	r2, [r3, #30]
#endif /* USBPD_PORT_COUNT==2 */
#endif /* _VDM */
#endif /* GUI_FLASH_ADDR_DPM_ID_SETTINGS */

_exit:
  return _status;
   127ce:	183b      	adds	r3, r7, r0
   127d0:	781b      	ldrb	r3, [r3, #0]
}
   127d2:	0018      	movs	r0, r3
   127d4:	46bd      	mov	sp, r7
   127d6:	b005      	add	sp, #20
   127d8:	bd90      	pop	{r4, r7, pc}
   127da:	46c0      	nop			; (mov r8, r8)
   127dc:	0801f800 	.word	0x0801f800
   127e0:	0002fe20 	.word	0x0002fe20
   127e4:	0002fe24 	.word	0x0002fe24
   127e8:	0801f808 	.word	0x0801f808
   127ec:	0002fe40 	.word	0x0002fe40
   127f0:	0801f828 	.word	0x0801f828
   127f4:	0002fec8 	.word	0x0002fec8
   127f8:	0801f888 	.word	0x0801f888
   127fc:	0002fed4 	.word	0x0002fed4
   12800:	0801f9a0 	.word	0x0801f9a0
   12804:	0002fedc 	.word	0x0002fedc
   12808:	0801f8a0 	.word	0x0801f8a0

0001280c <BSP_GUI_SaveDataInFlash>:

GUI_StatusTypeDef BSP_GUI_SaveDataInFlash(void)
{
   1280c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1280e:	b08f      	sub	sp, #60	; 0x3c
   12810:	af00      	add	r7, sp, #0
  GUI_StatusTypeDef status = GUI_ERROR;
   12812:	261f      	movs	r6, #31
   12814:	2318      	movs	r3, #24
   12816:	18fa      	adds	r2, r7, r3
   12818:	1993      	adds	r3, r2, r6
   1281a:	2203      	movs	r2, #3
   1281c:	701a      	strb	r2, [r3, #0]
  __ASM volatile ("cpsid i" : : : "memory");
   1281e:	b672      	cpsid	i

  /* Disable interrupts */
  __disable_irq();

  /* Init Flash registers for writing */
  HAL_FLASH_Unlock();
   12820:	f7fc f880 	bl	e924 <HAL_FLASH_Unlock>

  /* Erase the page associated to the GUI parameters */
  erase_init.TypeErase  = FLASH_TYPEERASE_PAGES;
   12824:	211c      	movs	r1, #28
   12826:	187b      	adds	r3, r7, r1
   12828:	2200      	movs	r2, #0
   1282a:	601a      	str	r2, [r3, #0]
#if defined(STM32F072xB)|| defined(STM32F051x8)
  erase_init.PageAddress        = ADDR_FLASH_LAST_PAGE;
   1282c:	187b      	adds	r3, r7, r1
   1282e:	4a6e      	ldr	r2, [pc, #440]	; (129e8 <BSP_GUI_SaveDataInFlash+0x1dc>)
   12830:	605a      	str	r2, [r3, #4]
  erase_init.Page       = INDEX_PAGE;
#endif /* STM32F072xB || STM32F051x8 */
#if defined (FLASH_OPTR_DBANK)
  erase_init.Banks      = FLASH_BANK_2;
#endif /* FLASH_OPTR_DBANK */
  erase_init.NbPages    = 1;
   12832:	187b      	adds	r3, r7, r1
   12834:	2201      	movs	r2, #1
   12836:	609a      	str	r2, [r3, #8]
  if(FLASH->SR != 0x00)
  {
    FLASH->SR = FLASH_SR_OPTVERR;
  }
#endif
  status = HAL_OK == HAL_FLASHEx_Erase(&erase_init, &page_error) ? GUI_OK : GUI_ERASE_ERROR;
   12838:	2318      	movs	r3, #24
   1283a:	18fa      	adds	r2, r7, r3
   1283c:	187b      	adds	r3, r7, r1
   1283e:	0011      	movs	r1, r2
   12840:	0018      	movs	r0, r3
   12842:	f7fc f923 	bl	ea8c <HAL_FLASHEx_Erase>
   12846:	0003      	movs	r3, r0
   12848:	1e5a      	subs	r2, r3, #1
   1284a:	4193      	sbcs	r3, r2
   1284c:	b2da      	uxtb	r2, r3
   1284e:	2318      	movs	r3, #24
   12850:	18fb      	adds	r3, r7, r3
   12852:	199b      	adds	r3, r3, r6
   12854:	701a      	strb	r2, [r3, #0]

  /* If Erase is OK, program the new data */
  if ((0xFFFFFFFF == page_error) && (GUI_OK == status))
   12856:	69bb      	ldr	r3, [r7, #24]
   12858:	3301      	adds	r3, #1
   1285a:	d000      	beq.n	1285e <BSP_GUI_SaveDataInFlash+0x52>
   1285c:	e0b7      	b.n	129ce <BSP_GUI_SaveDataInFlash+0x1c2>
   1285e:	231f      	movs	r3, #31
   12860:	2218      	movs	r2, #24
   12862:	4694      	mov	ip, r2
   12864:	44bc      	add	ip, r7
   12866:	4463      	add	r3, ip
   12868:	781b      	ldrb	r3, [r3, #0]
   1286a:	2b00      	cmp	r3, #0
   1286c:	d000      	beq.n	12870 <BSP_GUI_SaveDataInFlash+0x64>
   1286e:	e0ae      	b.n	129ce <BSP_GUI_SaveDataInFlash+0x1c2>
  {
#ifdef GUI_FLASH_ADDR_NB_PDO_SNK_P0
    /* Save the nb of sink and src PDO */
    uint64_t value = 0;
   12870:	2200      	movs	r2, #0
   12872:	2300      	movs	r3, #0
   12874:	62ba      	str	r2, [r7, #40]	; 0x28
   12876:	62fb      	str	r3, [r7, #44]	; 0x2c
    value |= USBPD_NbPDO[0];
   12878:	4b5c      	ldr	r3, [pc, #368]	; (129ec <BSP_GUI_SaveDataInFlash+0x1e0>)
   1287a:	781b      	ldrb	r3, [r3, #0]
   1287c:	613b      	str	r3, [r7, #16]
   1287e:	2300      	movs	r3, #0
   12880:	617b      	str	r3, [r7, #20]
   12882:	6abb      	ldr	r3, [r7, #40]	; 0x28
   12884:	6939      	ldr	r1, [r7, #16]
   12886:	697a      	ldr	r2, [r7, #20]
   12888:	0008      	movs	r0, r1
   1288a:	4303      	orrs	r3, r0
   1288c:	62bb      	str	r3, [r7, #40]	; 0x28
   1288e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   12890:	4313      	orrs	r3, r2
   12892:	62fb      	str	r3, [r7, #44]	; 0x2c
    value |= (USBPD_NbPDO[1] << 8);
   12894:	4b55      	ldr	r3, [pc, #340]	; (129ec <BSP_GUI_SaveDataInFlash+0x1e0>)
   12896:	785b      	ldrb	r3, [r3, #1]
   12898:	021b      	lsls	r3, r3, #8
   1289a:	60bb      	str	r3, [r7, #8]
   1289c:	17db      	asrs	r3, r3, #31
   1289e:	60fb      	str	r3, [r7, #12]
   128a0:	6abb      	ldr	r3, [r7, #40]	; 0x28
   128a2:	68b9      	ldr	r1, [r7, #8]
   128a4:	68fa      	ldr	r2, [r7, #12]
   128a6:	0008      	movs	r0, r1
   128a8:	4303      	orrs	r3, r0
   128aa:	62bb      	str	r3, [r7, #40]	; 0x28
   128ac:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   128ae:	4313      	orrs	r3, r2
   128b0:	62fb      	str	r3, [r7, #44]	; 0x2c
    value |= (USBPD_NbPDO[2] << 16);
   128b2:	4b4e      	ldr	r3, [pc, #312]	; (129ec <BSP_GUI_SaveDataInFlash+0x1e0>)
   128b4:	789b      	ldrb	r3, [r3, #2]
   128b6:	041b      	lsls	r3, r3, #16
   128b8:	603b      	str	r3, [r7, #0]
   128ba:	17db      	asrs	r3, r3, #31
   128bc:	607b      	str	r3, [r7, #4]
   128be:	6abb      	ldr	r3, [r7, #40]	; 0x28
   128c0:	6839      	ldr	r1, [r7, #0]
   128c2:	687a      	ldr	r2, [r7, #4]
   128c4:	0008      	movs	r0, r1
   128c6:	4303      	orrs	r3, r0
   128c8:	62bb      	str	r3, [r7, #40]	; 0x28
   128ca:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   128cc:	4313      	orrs	r3, r2
   128ce:	62fb      	str	r3, [r7, #44]	; 0x2c
    value |= (USBPD_NbPDO[3] << 24);
   128d0:	4b46      	ldr	r3, [pc, #280]	; (129ec <BSP_GUI_SaveDataInFlash+0x1e0>)
   128d2:	78db      	ldrb	r3, [r3, #3]
   128d4:	061b      	lsls	r3, r3, #24
   128d6:	001c      	movs	r4, r3
   128d8:	17db      	asrs	r3, r3, #31
   128da:	001d      	movs	r5, r3
   128dc:	6abb      	ldr	r3, [r7, #40]	; 0x28
   128de:	4323      	orrs	r3, r4
   128e0:	62bb      	str	r3, [r7, #40]	; 0x28
   128e2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   128e4:	432b      	orrs	r3, r5
   128e6:	62fb      	str	r3, [r7, #44]	; 0x2c
   status = HAL_OK == HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD, GUI_FLASH_ADDR_NB_PDO_SNK_P0, value)? GUI_OK : GUI_WRITE_ERROR;
   128e8:	6abb      	ldr	r3, [r7, #40]	; 0x28
   128ea:	6afc      	ldr	r4, [r7, #44]	; 0x2c
   128ec:	493e      	ldr	r1, [pc, #248]	; (129e8 <BSP_GUI_SaveDataInFlash+0x1dc>)
   128ee:	001a      	movs	r2, r3
   128f0:	0023      	movs	r3, r4
   128f2:	2003      	movs	r0, #3
   128f4:	f7fb ff80 	bl	e7f8 <HAL_FLASH_Program>
   128f8:	1e03      	subs	r3, r0, #0
   128fa:	d101      	bne.n	12900 <BSP_GUI_SaveDataInFlash+0xf4>
   128fc:	2200      	movs	r2, #0
   128fe:	e000      	b.n	12902 <BSP_GUI_SaveDataInFlash+0xf6>
   12900:	2202      	movs	r2, #2
   12902:	211f      	movs	r1, #31
   12904:	2018      	movs	r0, #24
   12906:	183b      	adds	r3, r7, r0
   12908:	185b      	adds	r3, r3, r1
   1290a:	701a      	strb	r2, [r3, #0]
#endif  /* GUI_FLASH_ADDR_NB_PDO_SNK_P0 */

#if defined(_SRC) || defined(_DRP)
    /* Save PORT0_PDO_ListSRC */
    if (GUI_OK == status)
   1290c:	183b      	adds	r3, r7, r0
   1290e:	185b      	adds	r3, r3, r1
   12910:	781b      	ldrb	r3, [r3, #0]
   12912:	2b00      	cmp	r3, #0
   12914:	d10b      	bne.n	1292e <BSP_GUI_SaveDataInFlash+0x122>
    {
      status = SavePDOInFlash(GUI_FLASH_ADDR_PDO_SRC_P0, PORT0_PDO_ListSRC);
   12916:	231f      	movs	r3, #31
   12918:	2218      	movs	r2, #24
   1291a:	18ba      	adds	r2, r7, r2
   1291c:	18d4      	adds	r4, r2, r3
   1291e:	4b34      	ldr	r3, [pc, #208]	; (129f0 <BSP_GUI_SaveDataInFlash+0x1e4>)
   12920:	4a34      	ldr	r2, [pc, #208]	; (129f4 <BSP_GUI_SaveDataInFlash+0x1e8>)
   12922:	0019      	movs	r1, r3
   12924:	0010      	movs	r0, r2
   12926:	f000 f877 	bl	12a18 <SavePDOInFlash>
   1292a:	0003      	movs	r3, r0
   1292c:	7023      	strb	r3, [r4, #0]
    }
#endif /* _SRC || _DRP */

#if defined(_SNK) || defined(_DRP)
    /* Save PORT0_PDO_ListSNK */
    if (GUI_OK == status)
   1292e:	231f      	movs	r3, #31
   12930:	2218      	movs	r2, #24
   12932:	4694      	mov	ip, r2
   12934:	44bc      	add	ip, r7
   12936:	4463      	add	r3, ip
   12938:	781b      	ldrb	r3, [r3, #0]
   1293a:	2b00      	cmp	r3, #0
   1293c:	d10b      	bne.n	12956 <BSP_GUI_SaveDataInFlash+0x14a>
    {
      status = SavePDOInFlash(GUI_FLASH_ADDR_PDO_SNK_P0, PORT0_PDO_ListSNK);
   1293e:	231f      	movs	r3, #31
   12940:	2218      	movs	r2, #24
   12942:	18ba      	adds	r2, r7, r2
   12944:	18d4      	adds	r4, r2, r3
   12946:	4b2c      	ldr	r3, [pc, #176]	; (129f8 <BSP_GUI_SaveDataInFlash+0x1ec>)
   12948:	4a2c      	ldr	r2, [pc, #176]	; (129fc <BSP_GUI_SaveDataInFlash+0x1f0>)
   1294a:	0019      	movs	r1, r3
   1294c:	0010      	movs	r0, r2
   1294e:	f000 f863 	bl	12a18 <SavePDOInFlash>
   12952:	0003      	movs	r3, r0
   12954:	7023      	strb	r3, [r4, #0]
        }
#endif /* _SNK || _DRP */
#endif /* USBPD_PORT_COUNT==2 */

    /* Save DPM_Settings of port 0 */
    if (GUI_OK == status)
   12956:	231f      	movs	r3, #31
   12958:	2218      	movs	r2, #24
   1295a:	4694      	mov	ip, r2
   1295c:	44bc      	add	ip, r7
   1295e:	4463      	add	r3, ip
   12960:	781b      	ldrb	r3, [r3, #0]
   12962:	2b00      	cmp	r3, #0
   12964:	d10b      	bne.n	1297e <BSP_GUI_SaveDataInFlash+0x172>
    {
      status = SaveSettingsInFlash(GUI_FLASH_ADDR_DPM_SETTINGS, (uint32_t*)DPM_Settings, sizeof(USBPD_SettingsTypeDef) * USBPD_PORT_COUNT);
   12966:	231f      	movs	r3, #31
   12968:	2218      	movs	r2, #24
   1296a:	18ba      	adds	r2, r7, r2
   1296c:	18d4      	adds	r4, r2, r3
   1296e:	4b24      	ldr	r3, [pc, #144]	; (12a00 <BSP_GUI_SaveDataInFlash+0x1f4>)
   12970:	4824      	ldr	r0, [pc, #144]	; (12a04 <BSP_GUI_SaveDataInFlash+0x1f8>)
   12972:	220c      	movs	r2, #12
   12974:	0019      	movs	r1, r3
   12976:	f000 f8ce 	bl	12b16 <SaveSettingsInFlash>
   1297a:	0003      	movs	r3, r0
   1297c:	7023      	strb	r3, [r4, #0]
    }

#if defined(GUI_FLASH_ADDR_DPM_ID_SETTINGS)
    /* Save DPM_ID_Settings */
    if (GUI_OK == status)
   1297e:	231f      	movs	r3, #31
   12980:	2218      	movs	r2, #24
   12982:	4694      	mov	ip, r2
   12984:	44bc      	add	ip, r7
   12986:	4463      	add	r3, ip
   12988:	781b      	ldrb	r3, [r3, #0]
   1298a:	2b00      	cmp	r3, #0
   1298c:	d10b      	bne.n	129a6 <BSP_GUI_SaveDataInFlash+0x19a>
    {
      status = SaveSettingsInFlash(GUI_FLASH_ADDR_DPM_ID_SETTINGS, (uint32_t*)DPM_ID_Settings, sizeof(USBPD_IdSettingsTypeDef));
   1298e:	231f      	movs	r3, #31
   12990:	2218      	movs	r2, #24
   12992:	18ba      	adds	r2, r7, r2
   12994:	18d4      	adds	r4, r2, r3
   12996:	4b1c      	ldr	r3, [pc, #112]	; (12a08 <BSP_GUI_SaveDataInFlash+0x1fc>)
   12998:	481c      	ldr	r0, [pc, #112]	; (12a0c <BSP_GUI_SaveDataInFlash+0x200>)
   1299a:	2208      	movs	r2, #8
   1299c:	0019      	movs	r1, r3
   1299e:	f000 f8ba 	bl	12b16 <SaveSettingsInFlash>
   129a2:	0003      	movs	r3, r0
   129a4:	7023      	strb	r3, [r4, #0]
    }
#endif /* GUI_FLASH_ADDR_DPM_ID_SETTINGS */

    /* Save DPM_Settings of port 0 */
    if (GUI_OK == status)
   129a6:	231f      	movs	r3, #31
   129a8:	2218      	movs	r2, #24
   129aa:	4694      	mov	ip, r2
   129ac:	44bc      	add	ip, r7
   129ae:	4463      	add	r3, ip
   129b0:	781b      	ldrb	r3, [r3, #0]
   129b2:	2b00      	cmp	r3, #0
   129b4:	d10b      	bne.n	129ce <BSP_GUI_SaveDataInFlash+0x1c2>
    {
      status = SaveSettingsInFlash(GUI_FLASH_ADDR_DPM_USER_SETTINGS, (uint32_t*)DPM_USER_Settings, sizeof(USBPD_USER_SettingsTypeDef) * USBPD_PORT_COUNT);
   129b6:	231f      	movs	r3, #31
   129b8:	2218      	movs	r2, #24
   129ba:	18ba      	adds	r2, r7, r2
   129bc:	18d4      	adds	r4, r2, r3
   129be:	4b14      	ldr	r3, [pc, #80]	; (12a10 <BSP_GUI_SaveDataInFlash+0x204>)
   129c0:	4814      	ldr	r0, [pc, #80]	; (12a14 <BSP_GUI_SaveDataInFlash+0x208>)
   129c2:	2274      	movs	r2, #116	; 0x74
   129c4:	0019      	movs	r1, r3
   129c6:	f000 f8a6 	bl	12b16 <SaveSettingsInFlash>
   129ca:	0003      	movs	r3, r0
   129cc:	7023      	strb	r3, [r4, #0]
    }
#endif /* _VDM */
  }

  /* Lock the flash afer end of operations */
  HAL_FLASH_Lock();
   129ce:	f7fb ffc3 	bl	e958 <HAL_FLASH_Lock>
  __ASM volatile ("cpsie i" : : : "memory");
   129d2:	b662      	cpsie	i

  /* Enable interrupts */
  __enable_irq();

  return status;
   129d4:	231f      	movs	r3, #31
   129d6:	2218      	movs	r2, #24
   129d8:	4694      	mov	ip, r2
   129da:	44bc      	add	ip, r7
   129dc:	4463      	add	r3, ip
   129de:	781b      	ldrb	r3, [r3, #0]
}
   129e0:	0018      	movs	r0, r3
   129e2:	46bd      	mov	sp, r7
   129e4:	b00f      	add	sp, #60	; 0x3c
   129e6:	bdf0      	pop	{r4, r5, r6, r7, pc}
   129e8:	0801f800 	.word	0x0801f800
   129ec:	0002fe20 	.word	0x0002fe20
   129f0:	0002fe24 	.word	0x0002fe24
   129f4:	0801f808 	.word	0x0801f808
   129f8:	0002fe40 	.word	0x0002fe40
   129fc:	0801f828 	.word	0x0801f828
   12a00:	0002fec8 	.word	0x0002fec8
   12a04:	0801f888 	.word	0x0801f888
   12a08:	0002fed4 	.word	0x0002fed4
   12a0c:	0801f9a0 	.word	0x0801f9a0
   12a10:	0002fedc 	.word	0x0002fedc
   12a14:	0801f8a0 	.word	0x0801f8a0

00012a18 <SavePDOInFlash>:

static GUI_StatusTypeDef SavePDOInFlash(uint32_t Address, uint32_t *pListOfPDO)
{
   12a18:	b5b0      	push	{r4, r5, r7, lr}
   12a1a:	b08e      	sub	sp, #56	; 0x38
   12a1c:	af00      	add	r7, sp, #0
   12a1e:	6178      	str	r0, [r7, #20]
   12a20:	6139      	str	r1, [r7, #16]
  uint64_t data_in_64;
  uint32_t index, index_flash;
  uint32_t value[2];
  GUI_StatusTypeDef status = GUI_OK;
   12a22:	231f      	movs	r3, #31
   12a24:	2210      	movs	r2, #16
   12a26:	4694      	mov	ip, r2
   12a28:	44bc      	add	ip, r7
   12a2a:	4463      	add	r3, ip
   12a2c:	2200      	movs	r2, #0
   12a2e:	701a      	strb	r2, [r3, #0]

  for (index = 0, index_flash = 0; ((index < USBPD_MAX_NB_PDO) && (GUI_OK == status)); index++, index_flash++)
   12a30:	2300      	movs	r3, #0
   12a32:	637b      	str	r3, [r7, #52]	; 0x34
   12a34:	2300      	movs	r3, #0
   12a36:	633b      	str	r3, [r7, #48]	; 0x30
   12a38:	e058      	b.n	12aec <SavePDOInFlash+0xd4>
  {
    value[0] = pListOfPDO[index];
   12a3a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   12a3c:	009b      	lsls	r3, r3, #2
   12a3e:	693a      	ldr	r2, [r7, #16]
   12a40:	18d3      	adds	r3, r2, r3
   12a42:	681a      	ldr	r2, [r3, #0]
   12a44:	2308      	movs	r3, #8
   12a46:	2110      	movs	r1, #16
   12a48:	468c      	mov	ip, r1
   12a4a:	44bc      	add	ip, r7
   12a4c:	4463      	add	r3, ip
   12a4e:	601a      	str	r2, [r3, #0]
    index++;
   12a50:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   12a52:	3301      	adds	r3, #1
   12a54:	637b      	str	r3, [r7, #52]	; 0x34
    if (index < USBPD_MAX_NB_PDO)
   12a56:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   12a58:	2b06      	cmp	r3, #6
   12a5a:	d80b      	bhi.n	12a74 <SavePDOInFlash+0x5c>
    {
      value[1] = pListOfPDO[index];
   12a5c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   12a5e:	009b      	lsls	r3, r3, #2
   12a60:	693a      	ldr	r2, [r7, #16]
   12a62:	18d3      	adds	r3, r2, r3
   12a64:	681a      	ldr	r2, [r3, #0]
   12a66:	2308      	movs	r3, #8
   12a68:	2110      	movs	r1, #16
   12a6a:	468c      	mov	ip, r1
   12a6c:	44bc      	add	ip, r7
   12a6e:	4463      	add	r3, ip
   12a70:	605a      	str	r2, [r3, #4]
   12a72:	e007      	b.n	12a84 <SavePDOInFlash+0x6c>
    }
    else
    {
      value[1] = (0xFFFFFFFF);
   12a74:	2308      	movs	r3, #8
   12a76:	2210      	movs	r2, #16
   12a78:	4694      	mov	ip, r2
   12a7a:	44bc      	add	ip, r7
   12a7c:	4463      	add	r3, ip
   12a7e:	2201      	movs	r2, #1
   12a80:	4252      	negs	r2, r2
   12a82:	605a      	str	r2, [r3, #4]
    }

    data_in_64 = value[0] | (uint64_t)value[1] << 32;
   12a84:	2208      	movs	r2, #8
   12a86:	2110      	movs	r1, #16
   12a88:	187b      	adds	r3, r7, r1
   12a8a:	189b      	adds	r3, r3, r2
   12a8c:	681b      	ldr	r3, [r3, #0]
   12a8e:	60bb      	str	r3, [r7, #8]
   12a90:	2300      	movs	r3, #0
   12a92:	60fb      	str	r3, [r7, #12]
   12a94:	187b      	adds	r3, r7, r1
   12a96:	189b      	adds	r3, r3, r2
   12a98:	685b      	ldr	r3, [r3, #4]
   12a9a:	603b      	str	r3, [r7, #0]
   12a9c:	2300      	movs	r3, #0
   12a9e:	607b      	str	r3, [r7, #4]
   12aa0:	683b      	ldr	r3, [r7, #0]
   12aa2:	001d      	movs	r5, r3
   12aa4:	2300      	movs	r3, #0
   12aa6:	001c      	movs	r4, r3
   12aa8:	68b9      	ldr	r1, [r7, #8]
   12aaa:	68fa      	ldr	r2, [r7, #12]
   12aac:	000b      	movs	r3, r1
   12aae:	4323      	orrs	r3, r4
   12ab0:	623b      	str	r3, [r7, #32]
   12ab2:	0013      	movs	r3, r2
   12ab4:	432b      	orrs	r3, r5
   12ab6:	627b      	str	r3, [r7, #36]	; 0x24

    /* Save in the FLASH */
    status = HAL_OK == HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD, (Address + (8 * index_flash)) , data_in_64) ? GUI_OK : GUI_WRITE_ERROR;
   12ab8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   12aba:	00da      	lsls	r2, r3, #3
   12abc:	697b      	ldr	r3, [r7, #20]
   12abe:	18d1      	adds	r1, r2, r3
   12ac0:	6a3a      	ldr	r2, [r7, #32]
   12ac2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   12ac4:	2003      	movs	r0, #3
   12ac6:	f7fb fe97 	bl	e7f8 <HAL_FLASH_Program>
   12aca:	1e03      	subs	r3, r0, #0
   12acc:	d101      	bne.n	12ad2 <SavePDOInFlash+0xba>
   12ace:	2200      	movs	r2, #0
   12ad0:	e000      	b.n	12ad4 <SavePDOInFlash+0xbc>
   12ad2:	2202      	movs	r2, #2
   12ad4:	231f      	movs	r3, #31
   12ad6:	2110      	movs	r1, #16
   12ad8:	468c      	mov	ip, r1
   12ada:	44bc      	add	ip, r7
   12adc:	4463      	add	r3, ip
   12ade:	701a      	strb	r2, [r3, #0]
  for (index = 0, index_flash = 0; ((index < USBPD_MAX_NB_PDO) && (GUI_OK == status)); index++, index_flash++)
   12ae0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   12ae2:	3301      	adds	r3, #1
   12ae4:	637b      	str	r3, [r7, #52]	; 0x34
   12ae6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   12ae8:	3301      	adds	r3, #1
   12aea:	633b      	str	r3, [r7, #48]	; 0x30
   12aec:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   12aee:	2b06      	cmp	r3, #6
   12af0:	d807      	bhi.n	12b02 <SavePDOInFlash+0xea>
   12af2:	231f      	movs	r3, #31
   12af4:	2210      	movs	r2, #16
   12af6:	4694      	mov	ip, r2
   12af8:	44bc      	add	ip, r7
   12afa:	4463      	add	r3, ip
   12afc:	781b      	ldrb	r3, [r3, #0]
   12afe:	2b00      	cmp	r3, #0
   12b00:	d09b      	beq.n	12a3a <SavePDOInFlash+0x22>
  }
  return status;
   12b02:	231f      	movs	r3, #31
   12b04:	2210      	movs	r2, #16
   12b06:	4694      	mov	ip, r2
   12b08:	44bc      	add	ip, r7
   12b0a:	4463      	add	r3, ip
   12b0c:	781b      	ldrb	r3, [r3, #0]
}
   12b0e:	0018      	movs	r0, r3
   12b10:	46bd      	mov	sp, r7
   12b12:	b00e      	add	sp, #56	; 0x38
   12b14:	bdb0      	pop	{r4, r5, r7, pc}

00012b16 <SaveSettingsInFlash>:

static GUI_StatusTypeDef SaveSettingsInFlash(uint32_t Address, uint32_t *pSettings, uint32_t Size)
{
   12b16:	b5b0      	push	{r4, r5, r7, lr}
   12b18:	b092      	sub	sp, #72	; 0x48
   12b1a:	af00      	add	r7, sp, #0
   12b1c:	61f8      	str	r0, [r7, #28]
   12b1e:	61b9      	str	r1, [r7, #24]
   12b20:	617a      	str	r2, [r7, #20]
  uint64_t data_in_64;
  uint32_t index, index_flash;
  uint32_t value[2];
  GUI_StatusTypeDef status = GUI_OK;
   12b22:	232f      	movs	r3, #47	; 0x2f
   12b24:	2210      	movs	r2, #16
   12b26:	4694      	mov	ip, r2
   12b28:	44bc      	add	ip, r7
   12b2a:	4463      	add	r3, ip
   12b2c:	2200      	movs	r2, #0
   12b2e:	701a      	strb	r2, [r3, #0]

  uint32_t nb_double = ((Size * USBPD_PORT_COUNT) / 4);
   12b30:	697b      	ldr	r3, [r7, #20]
   12b32:	089b      	lsrs	r3, r3, #2
   12b34:	63bb      	str	r3, [r7, #56]	; 0x38
  uint8_t remaining = ((Size * USBPD_PORT_COUNT) % 4);
   12b36:	697b      	ldr	r3, [r7, #20]
   12b38:	b2da      	uxtb	r2, r3
   12b3a:	2327      	movs	r3, #39	; 0x27
   12b3c:	2110      	movs	r1, #16
   12b3e:	468c      	mov	ip, r1
   12b40:	44bc      	add	ip, r7
   12b42:	4463      	add	r3, ip
   12b44:	2103      	movs	r1, #3
   12b46:	400a      	ands	r2, r1
   12b48:	701a      	strb	r2, [r3, #0]

  /* Save Settings in the FLASH */
  for (index = 0, index_flash = 0; ((index < nb_double) && (GUI_OK == status)); index++, index_flash++)
   12b4a:	2300      	movs	r3, #0
   12b4c:	647b      	str	r3, [r7, #68]	; 0x44
   12b4e:	2300      	movs	r3, #0
   12b50:	643b      	str	r3, [r7, #64]	; 0x40
   12b52:	e063      	b.n	12c1c <SaveSettingsInFlash+0x106>
  {
    value[0] = pSettings[index];
   12b54:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   12b56:	009b      	lsls	r3, r3, #2
   12b58:	69ba      	ldr	r2, [r7, #24]
   12b5a:	18d3      	adds	r3, r2, r3
   12b5c:	681a      	ldr	r2, [r3, #0]
   12b5e:	2310      	movs	r3, #16
   12b60:	2110      	movs	r1, #16
   12b62:	468c      	mov	ip, r1
   12b64:	44bc      	add	ip, r7
   12b66:	4463      	add	r3, ip
   12b68:	601a      	str	r2, [r3, #0]
    index++;
   12b6a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   12b6c:	3301      	adds	r3, #1
   12b6e:	647b      	str	r3, [r7, #68]	; 0x44
    if (index < nb_double)
   12b70:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   12b72:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   12b74:	429a      	cmp	r2, r3
   12b76:	d20b      	bcs.n	12b90 <SaveSettingsInFlash+0x7a>
    {
      value[1] = pSettings[index];
   12b78:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   12b7a:	009b      	lsls	r3, r3, #2
   12b7c:	69ba      	ldr	r2, [r7, #24]
   12b7e:	18d3      	adds	r3, r2, r3
   12b80:	681a      	ldr	r2, [r3, #0]
   12b82:	2310      	movs	r3, #16
   12b84:	2110      	movs	r1, #16
   12b86:	468c      	mov	ip, r1
   12b88:	44bc      	add	ip, r7
   12b8a:	4463      	add	r3, ip
   12b8c:	605a      	str	r2, [r3, #4]
   12b8e:	e011      	b.n	12bb4 <SaveSettingsInFlash+0x9e>
    }
    else
    {
      if (0 == remaining)
   12b90:	2327      	movs	r3, #39	; 0x27
   12b92:	2210      	movs	r2, #16
   12b94:	4694      	mov	ip, r2
   12b96:	44bc      	add	ip, r7
   12b98:	4463      	add	r3, ip
   12b9a:	781b      	ldrb	r3, [r3, #0]
   12b9c:	2b00      	cmp	r3, #0
   12b9e:	d108      	bne.n	12bb2 <SaveSettingsInFlash+0x9c>
        value[1] = (0xFFFFFFFF);
   12ba0:	2310      	movs	r3, #16
   12ba2:	2210      	movs	r2, #16
   12ba4:	4694      	mov	ip, r2
   12ba6:	44bc      	add	ip, r7
   12ba8:	4463      	add	r3, ip
   12baa:	2201      	movs	r2, #1
   12bac:	4252      	negs	r2, r2
   12bae:	605a      	str	r2, [r3, #4]
   12bb0:	e000      	b.n	12bb4 <SaveSettingsInFlash+0x9e>
      else
        while(1);
   12bb2:	e7fe      	b.n	12bb2 <SaveSettingsInFlash+0x9c>
    }

    data_in_64 = value[0] | (uint64_t)value[1] << 32;
   12bb4:	2210      	movs	r2, #16
   12bb6:	2110      	movs	r1, #16
   12bb8:	187b      	adds	r3, r7, r1
   12bba:	189b      	adds	r3, r3, r2
   12bbc:	681b      	ldr	r3, [r3, #0]
   12bbe:	60bb      	str	r3, [r7, #8]
   12bc0:	2300      	movs	r3, #0
   12bc2:	60fb      	str	r3, [r7, #12]
   12bc4:	187b      	adds	r3, r7, r1
   12bc6:	189b      	adds	r3, r3, r2
   12bc8:	685b      	ldr	r3, [r3, #4]
   12bca:	603b      	str	r3, [r7, #0]
   12bcc:	2300      	movs	r3, #0
   12bce:	607b      	str	r3, [r7, #4]
   12bd0:	683b      	ldr	r3, [r7, #0]
   12bd2:	001d      	movs	r5, r3
   12bd4:	2300      	movs	r3, #0
   12bd6:	001c      	movs	r4, r3
   12bd8:	68b9      	ldr	r1, [r7, #8]
   12bda:	68fa      	ldr	r2, [r7, #12]
   12bdc:	000b      	movs	r3, r1
   12bde:	4323      	orrs	r3, r4
   12be0:	62bb      	str	r3, [r7, #40]	; 0x28
   12be2:	0013      	movs	r3, r2
   12be4:	432b      	orrs	r3, r5
   12be6:	62fb      	str	r3, [r7, #44]	; 0x2c

    /* Save in the FLASH */
    status = HAL_OK == HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD, (Address + (8 * index_flash)) , data_in_64)? GUI_OK : GUI_WRITE_ERROR;
   12be8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   12bea:	00da      	lsls	r2, r3, #3
   12bec:	69fb      	ldr	r3, [r7, #28]
   12bee:	18d1      	adds	r1, r2, r3
   12bf0:	6aba      	ldr	r2, [r7, #40]	; 0x28
   12bf2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   12bf4:	2003      	movs	r0, #3
   12bf6:	f7fb fdff 	bl	e7f8 <HAL_FLASH_Program>
   12bfa:	1e03      	subs	r3, r0, #0
   12bfc:	d101      	bne.n	12c02 <SaveSettingsInFlash+0xec>
   12bfe:	2200      	movs	r2, #0
   12c00:	e000      	b.n	12c04 <SaveSettingsInFlash+0xee>
   12c02:	2202      	movs	r2, #2
   12c04:	232f      	movs	r3, #47	; 0x2f
   12c06:	2110      	movs	r1, #16
   12c08:	468c      	mov	ip, r1
   12c0a:	44bc      	add	ip, r7
   12c0c:	4463      	add	r3, ip
   12c0e:	701a      	strb	r2, [r3, #0]
  for (index = 0, index_flash = 0; ((index < nb_double) && (GUI_OK == status)); index++, index_flash++)
   12c10:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   12c12:	3301      	adds	r3, #1
   12c14:	647b      	str	r3, [r7, #68]	; 0x44
   12c16:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   12c18:	3301      	adds	r3, #1
   12c1a:	643b      	str	r3, [r7, #64]	; 0x40
   12c1c:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   12c1e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   12c20:	429a      	cmp	r2, r3
   12c22:	d207      	bcs.n	12c34 <SaveSettingsInFlash+0x11e>
   12c24:	232f      	movs	r3, #47	; 0x2f
   12c26:	2210      	movs	r2, #16
   12c28:	4694      	mov	ip, r2
   12c2a:	44bc      	add	ip, r7
   12c2c:	4463      	add	r3, ip
   12c2e:	781b      	ldrb	r3, [r3, #0]
   12c30:	2b00      	cmp	r3, #0
   12c32:	d08f      	beq.n	12b54 <SaveSettingsInFlash+0x3e>
  }
  return status;
   12c34:	232f      	movs	r3, #47	; 0x2f
   12c36:	2210      	movs	r2, #16
   12c38:	4694      	mov	ip, r2
   12c3a:	44bc      	add	ip, r7
   12c3c:	4463      	add	r3, ip
   12c3e:	781b      	ldrb	r3, [r3, #0]
}
   12c40:	0018      	movs	r0, r3
   12c42:	46bd      	mov	sp, r7
   12c44:	b012      	add	sp, #72	; 0x48
   12c46:	bdb0      	pop	{r4, r5, r7, pc}

00012c48 <LoadPDOFromFlash>:

static GUI_StatusTypeDef LoadPDOFromFlash(uint32_t Address, uint32_t *pListOfPDO)
{
   12c48:	b580      	push	{r7, lr}
   12c4a:	b086      	sub	sp, #24
   12c4c:	af00      	add	r7, sp, #0
   12c4e:	6078      	str	r0, [r7, #4]
   12c50:	6039      	str	r1, [r7, #0]
  uint32_t _addr = Address;
   12c52:	687b      	ldr	r3, [r7, #4]
   12c54:	617b      	str	r3, [r7, #20]
  GUI_StatusTypeDef _status = GUI_ERROR;
   12c56:	2313      	movs	r3, #19
   12c58:	18fb      	adds	r3, r7, r3
   12c5a:	2203      	movs	r2, #3
   12c5c:	701a      	strb	r2, [r3, #0]

  /* Check if FLASH is not empty to retrieve the data. Nethertheless keep data in the RAM */
  if (0xFFFFFFFFu != *((uint32_t*)_addr))
   12c5e:	697b      	ldr	r3, [r7, #20]
   12c60:	681b      	ldr	r3, [r3, #0]
   12c62:	3301      	adds	r3, #1
   12c64:	d016      	beq.n	12c94 <LoadPDOFromFlash+0x4c>
  {
    uint32_t _index;
    for (_index = 0; _index < USBPD_MAX_NB_PDO; _index++)
   12c66:	2300      	movs	r3, #0
   12c68:	60fb      	str	r3, [r7, #12]
   12c6a:	e00c      	b.n	12c86 <LoadPDOFromFlash+0x3e>
    {
      pListOfPDO[_index] = *((uint32_t*)_addr);
   12c6c:	697a      	ldr	r2, [r7, #20]
   12c6e:	68fb      	ldr	r3, [r7, #12]
   12c70:	009b      	lsls	r3, r3, #2
   12c72:	6839      	ldr	r1, [r7, #0]
   12c74:	18cb      	adds	r3, r1, r3
   12c76:	6812      	ldr	r2, [r2, #0]
   12c78:	601a      	str	r2, [r3, #0]
      _addr = _addr + 4u;
   12c7a:	697b      	ldr	r3, [r7, #20]
   12c7c:	3304      	adds	r3, #4
   12c7e:	617b      	str	r3, [r7, #20]
    for (_index = 0; _index < USBPD_MAX_NB_PDO; _index++)
   12c80:	68fb      	ldr	r3, [r7, #12]
   12c82:	3301      	adds	r3, #1
   12c84:	60fb      	str	r3, [r7, #12]
   12c86:	68fb      	ldr	r3, [r7, #12]
   12c88:	2b06      	cmp	r3, #6
   12c8a:	d9ef      	bls.n	12c6c <LoadPDOFromFlash+0x24>
    }
    _status = GUI_OK;
   12c8c:	2313      	movs	r3, #19
   12c8e:	18fb      	adds	r3, r7, r3
   12c90:	2200      	movs	r2, #0
   12c92:	701a      	strb	r2, [r3, #0]
  }
  return _status;
   12c94:	2313      	movs	r3, #19
   12c96:	18fb      	adds	r3, r7, r3
   12c98:	781b      	ldrb	r3, [r3, #0]
}
   12c9a:	0018      	movs	r0, r3
   12c9c:	46bd      	mov	sp, r7
   12c9e:	b006      	add	sp, #24
   12ca0:	bd80      	pop	{r7, pc}

00012ca2 <LoadSettingsFromFlash>:

static GUI_StatusTypeDef LoadSettingsFromFlash(uint32_t Address, uint32_t *pSettings, uint32_t Size)
{
   12ca2:	b580      	push	{r7, lr}
   12ca4:	b086      	sub	sp, #24
   12ca6:	af00      	add	r7, sp, #0
   12ca8:	60f8      	str	r0, [r7, #12]
   12caa:	60b9      	str	r1, [r7, #8]
   12cac:	607a      	str	r2, [r7, #4]
  uint32_t _addr = Address;
   12cae:	68fb      	ldr	r3, [r7, #12]
   12cb0:	613b      	str	r3, [r7, #16]
  GUI_StatusTypeDef _status = GUI_ERROR;
   12cb2:	2317      	movs	r3, #23
   12cb4:	18fb      	adds	r3, r7, r3
   12cb6:	2203      	movs	r2, #3
   12cb8:	701a      	strb	r2, [r3, #0]

  /* Check if FLASH is not empty to retrieve the data. Nethertheless keep data in the RAM */
  if (0xFFFFFFFFu != *((uint32_t*)_addr))
   12cba:	693b      	ldr	r3, [r7, #16]
   12cbc:	681b      	ldr	r3, [r3, #0]
   12cbe:	3301      	adds	r3, #1
   12cc0:	d009      	beq.n	12cd6 <LoadSettingsFromFlash+0x34>
  {
    memcpy(pSettings, ((uint32_t*)_addr), Size);
   12cc2:	6939      	ldr	r1, [r7, #16]
   12cc4:	687a      	ldr	r2, [r7, #4]
   12cc6:	68bb      	ldr	r3, [r7, #8]
   12cc8:	0018      	movs	r0, r3
   12cca:	f00b fce3 	bl	1e694 <memcpy>
    _status = GUI_OK;
   12cce:	2317      	movs	r3, #23
   12cd0:	18fb      	adds	r3, r7, r3
   12cd2:	2200      	movs	r2, #0
   12cd4:	701a      	strb	r2, [r3, #0]
  }
  return _status;
   12cd6:	2317      	movs	r3, #23
   12cd8:	18fb      	adds	r3, r7, r3
   12cda:	781b      	ldrb	r3, [r3, #0]
}
   12cdc:	0018      	movs	r0, r3
   12cde:	46bd      	mov	sp, r7
   12ce0:	b006      	add	sp, #24
   12ce2:	bd80      	pop	{r7, pc}

00012ce4 <TLV_init_encode>:
  * @param    SizeMax      The maximal size of the instruction. Will be used to protect writting against overflow.
  * @param    Ptr          A pointer to the value. This function does not allocate memory, it is the user's responsibility to allocate this.
  * @return   0 if everything went fine, 0xFF otherwise.
  */
uint8_t TLV_init_encode(TLV_ToSend_Data *ToSendTLV, uint8_t Tag, uint16_t SizeMax, uint8_t *Ptr)
{
   12ce4:	b580      	push	{r7, lr}
   12ce6:	b084      	sub	sp, #16
   12ce8:	af00      	add	r7, sp, #0
   12cea:	60f8      	str	r0, [r7, #12]
   12cec:	0008      	movs	r0, r1
   12cee:	0011      	movs	r1, r2
   12cf0:	607b      	str	r3, [r7, #4]
   12cf2:	230b      	movs	r3, #11
   12cf4:	18fb      	adds	r3, r7, r3
   12cf6:	1c02      	adds	r2, r0, #0
   12cf8:	701a      	strb	r2, [r3, #0]
   12cfa:	2308      	movs	r3, #8
   12cfc:	18fb      	adds	r3, r7, r3
   12cfe:	1c0a      	adds	r2, r1, #0
   12d00:	801a      	strh	r2, [r3, #0]
  if(Ptr == NULL) return 0xFF;                  /* Buffer is NULL*/
   12d02:	687b      	ldr	r3, [r7, #4]
   12d04:	2b00      	cmp	r3, #0
   12d06:	d101      	bne.n	12d0c <TLV_init_encode+0x28>
   12d08:	23ff      	movs	r3, #255	; 0xff
   12d0a:	e04a      	b.n	12da2 <TLV_init_encode+0xbe>
  if(SizeMax < 11) return 0xFF;                 /* Because of his small max size, the buffer can't even receive one empty TLV*/
   12d0c:	2308      	movs	r3, #8
   12d0e:	18fb      	adds	r3, r7, r3
   12d10:	881b      	ldrh	r3, [r3, #0]
   12d12:	2b0a      	cmp	r3, #10
   12d14:	d801      	bhi.n	12d1a <TLV_init_encode+0x36>
   12d16:	23ff      	movs	r3, #255	; 0xff
   12d18:	e043      	b.n	12da2 <TLV_init_encode+0xbe>
  
  ToSendTLV->data = Ptr;
   12d1a:	68fb      	ldr	r3, [r7, #12]
   12d1c:	687a      	ldr	r2, [r7, #4]
   12d1e:	601a      	str	r2, [r3, #0]
  ToSendTLV->maxSize = SizeMax;
   12d20:	68fb      	ldr	r3, [r7, #12]
   12d22:	2208      	movs	r2, #8
   12d24:	18ba      	adds	r2, r7, r2
   12d26:	8812      	ldrh	r2, [r2, #0]
   12d28:	809a      	strh	r2, [r3, #4]
   
  ToSendTLV->data[0]
    = ToSendTLV->data[1]
      = ToSendTLV->data[2]
        = ToSendTLV->data[3] = TLV_SOF;          /* SOF*/
   12d2a:	68fb      	ldr	r3, [r7, #12]
   12d2c:	681b      	ldr	r3, [r3, #0]
   12d2e:	3303      	adds	r3, #3
   12d30:	22fd      	movs	r2, #253	; 0xfd
   12d32:	701a      	strb	r2, [r3, #0]
      = ToSendTLV->data[2]
   12d34:	68fa      	ldr	r2, [r7, #12]
   12d36:	6812      	ldr	r2, [r2, #0]
   12d38:	3202      	adds	r2, #2
        = ToSendTLV->data[3] = TLV_SOF;          /* SOF*/
   12d3a:	781b      	ldrb	r3, [r3, #0]
   12d3c:	7013      	strb	r3, [r2, #0]
    = ToSendTLV->data[1]
   12d3e:	68fb      	ldr	r3, [r7, #12]
   12d40:	681b      	ldr	r3, [r3, #0]
   12d42:	3301      	adds	r3, #1
      = ToSendTLV->data[2]
   12d44:	7812      	ldrb	r2, [r2, #0]
   12d46:	701a      	strb	r2, [r3, #0]
  ToSendTLV->data[0]
   12d48:	68fa      	ldr	r2, [r7, #12]
   12d4a:	6812      	ldr	r2, [r2, #0]
    = ToSendTLV->data[1]
   12d4c:	781b      	ldrb	r3, [r3, #0]
   12d4e:	7013      	strb	r3, [r2, #0]
  
  ToSendTLV->data[4] = Tag;                      /* Tag*/
   12d50:	68fb      	ldr	r3, [r7, #12]
   12d52:	681b      	ldr	r3, [r3, #0]
   12d54:	3304      	adds	r3, #4
   12d56:	220b      	movs	r2, #11
   12d58:	18ba      	adds	r2, r7, r2
   12d5a:	7812      	ldrb	r2, [r2, #0]
   12d5c:	701a      	strb	r2, [r3, #0]
  
  ToSendTLV->data[5]
    = ToSendTLV->data[6] = 0;                    /* Size*/
   12d5e:	68fb      	ldr	r3, [r7, #12]
   12d60:	681b      	ldr	r3, [r3, #0]
   12d62:	3306      	adds	r3, #6
   12d64:	2200      	movs	r2, #0
   12d66:	701a      	strb	r2, [r3, #0]
  ToSendTLV->data[5]
   12d68:	68fa      	ldr	r2, [r7, #12]
   12d6a:	6812      	ldr	r2, [r2, #0]
   12d6c:	3205      	adds	r2, #5
    = ToSendTLV->data[6] = 0;                    /* Size*/
   12d6e:	781b      	ldrb	r3, [r3, #0]
   12d70:	7013      	strb	r3, [r2, #0]
  
  ToSendTLV->data[7]
    = ToSendTLV->data[8]
      = ToSendTLV->data[9]
        = ToSendTLV->data[10] = TLV_EOF;         /* EOF*/
   12d72:	68fb      	ldr	r3, [r7, #12]
   12d74:	681b      	ldr	r3, [r3, #0]
   12d76:	330a      	adds	r3, #10
   12d78:	22a5      	movs	r2, #165	; 0xa5
   12d7a:	701a      	strb	r2, [r3, #0]
      = ToSendTLV->data[9]
   12d7c:	68fa      	ldr	r2, [r7, #12]
   12d7e:	6812      	ldr	r2, [r2, #0]
   12d80:	3209      	adds	r2, #9
        = ToSendTLV->data[10] = TLV_EOF;         /* EOF*/
   12d82:	781b      	ldrb	r3, [r3, #0]
   12d84:	7013      	strb	r3, [r2, #0]
    = ToSendTLV->data[8]
   12d86:	68fb      	ldr	r3, [r7, #12]
   12d88:	681b      	ldr	r3, [r3, #0]
   12d8a:	3308      	adds	r3, #8
      = ToSendTLV->data[9]
   12d8c:	7812      	ldrb	r2, [r2, #0]
   12d8e:	701a      	strb	r2, [r3, #0]
  ToSendTLV->data[7]
   12d90:	68fa      	ldr	r2, [r7, #12]
   12d92:	6812      	ldr	r2, [r2, #0]
   12d94:	3207      	adds	r2, #7
    = ToSendTLV->data[8]
   12d96:	781b      	ldrb	r3, [r3, #0]
   12d98:	7013      	strb	r3, [r2, #0]
  
  ToSendTLV->EOFposition = 7;
   12d9a:	68fb      	ldr	r3, [r7, #12]
   12d9c:	2207      	movs	r2, #7
   12d9e:	80da      	strh	r2, [r3, #6]
  
  return 0;
   12da0:	2300      	movs	r3, #0
}
   12da2:	0018      	movs	r0, r3
   12da4:	46bd      	mov	sp, r7
   12da6:	b004      	add	sp, #16
   12da8:	bd80      	pop	{r7, pc}
	...

00012dac <TLV_add>:
  * @param    Value        A pointer to the Value to add.
  * @return   The number of bytes written if everything went fine, 0xFFFF otherwise.
  *
  */
uint16_t TLV_add(TLV_ToSend_Data *ToSendTLV, uint8_t Tag, uint16_t Size, const uint8_t *Value)
{
   12dac:	b580      	push	{r7, lr}
   12dae:	b086      	sub	sp, #24
   12db0:	af00      	add	r7, sp, #0
   12db2:	60f8      	str	r0, [r7, #12]
   12db4:	0008      	movs	r0, r1
   12db6:	0011      	movs	r1, r2
   12db8:	607b      	str	r3, [r7, #4]
   12dba:	230b      	movs	r3, #11
   12dbc:	18fb      	adds	r3, r7, r3
   12dbe:	1c02      	adds	r2, r0, #0
   12dc0:	701a      	strb	r2, [r3, #0]
   12dc2:	2308      	movs	r3, #8
   12dc4:	18fb      	adds	r3, r7, r3
   12dc6:	1c0a      	adds	r2, r1, #0
   12dc8:	801a      	strh	r2, [r3, #0]
  if(ToSendTLV->data[ToSendTLV->EOFposition] != TLV_EOF)                return 0xFFFF;       /* EOF has been lost. Has any TLV operation failed, or went interrupted ?*/
   12dca:	68fb      	ldr	r3, [r7, #12]
   12dcc:	681b      	ldr	r3, [r3, #0]
   12dce:	68fa      	ldr	r2, [r7, #12]
   12dd0:	88d2      	ldrh	r2, [r2, #6]
   12dd2:	189b      	adds	r3, r3, r2
   12dd4:	781b      	ldrb	r3, [r3, #0]
   12dd6:	2ba5      	cmp	r3, #165	; 0xa5
   12dd8:	d001      	beq.n	12dde <TLV_add+0x32>
   12dda:	4b5a      	ldr	r3, [pc, #360]	; (12f44 <TLV_add+0x198>)
   12ddc:	e0ae      	b.n	12f3c <TLV_add+0x190>
  if((ToSendTLV->EOFposition + 4 + 3 + Size) > ToSendTLV->maxSize)      return 0xFFFF;       /* Can't add this TLV, because it will overflow the provided buffer.*/
   12dde:	68fb      	ldr	r3, [r7, #12]
   12de0:	88db      	ldrh	r3, [r3, #6]
   12de2:	1dda      	adds	r2, r3, #7
   12de4:	2308      	movs	r3, #8
   12de6:	18fb      	adds	r3, r7, r3
   12de8:	881b      	ldrh	r3, [r3, #0]
   12dea:	18d3      	adds	r3, r2, r3
   12dec:	68fa      	ldr	r2, [r7, #12]
   12dee:	8892      	ldrh	r2, [r2, #4]
   12df0:	4293      	cmp	r3, r2
   12df2:	dd01      	ble.n	12df8 <TLV_add+0x4c>
   12df4:	4b53      	ldr	r3, [pc, #332]	; (12f44 <TLV_add+0x198>)
   12df6:	e0a1      	b.n	12f3c <TLV_add+0x190>
  if(ToSendTLV->data == NULL)                                          return 0xFFFF;        /* Data points to NULL. Has the encoding been initialized with TLV_init_encode ?*/
   12df8:	68fb      	ldr	r3, [r7, #12]
   12dfa:	681b      	ldr	r3, [r3, #0]
   12dfc:	2b00      	cmp	r3, #0
   12dfe:	d101      	bne.n	12e04 <TLV_add+0x58>
   12e00:	4b50      	ldr	r3, [pc, #320]	; (12f44 <TLV_add+0x198>)
   12e02:	e09b      	b.n	12f3c <TLV_add+0x190>
  if(ToSendTLV->EOFposition == 0xFFFF)                                 return 0xFFFF;        /* EOF at -1.  Has the decoding been initialized with TLV_init_decode ?*/
   12e04:	68fb      	ldr	r3, [r7, #12]
   12e06:	88db      	ldrh	r3, [r3, #6]
   12e08:	4a4e      	ldr	r2, [pc, #312]	; (12f44 <TLV_add+0x198>)
   12e0a:	4293      	cmp	r3, r2
   12e0c:	d101      	bne.n	12e12 <TLV_add+0x66>
   12e0e:	4b4d      	ldr	r3, [pc, #308]	; (12f44 <TLV_add+0x198>)
   12e10:	e094      	b.n	12f3c <TLV_add+0x190>
  
  ToSendTLV->data[ToSendTLV->EOFposition] = Tag;                           /* Tag*/
   12e12:	68fb      	ldr	r3, [r7, #12]
   12e14:	681b      	ldr	r3, [r3, #0]
   12e16:	68fa      	ldr	r2, [r7, #12]
   12e18:	88d2      	ldrh	r2, [r2, #6]
   12e1a:	189b      	adds	r3, r3, r2
   12e1c:	220b      	movs	r2, #11
   12e1e:	18ba      	adds	r2, r7, r2
   12e20:	7812      	ldrb	r2, [r2, #0]
   12e22:	701a      	strb	r2, [r3, #0]
  ToSendTLV->EOFposition++;
   12e24:	68fb      	ldr	r3, [r7, #12]
   12e26:	88db      	ldrh	r3, [r3, #6]
   12e28:	3301      	adds	r3, #1
   12e2a:	b29a      	uxth	r2, r3
   12e2c:	68fb      	ldr	r3, [r7, #12]
   12e2e:	80da      	strh	r2, [r3, #6]
  ToSendTLV->SizePosition = ToSendTLV->EOFposition;
   12e30:	68fb      	ldr	r3, [r7, #12]
   12e32:	88da      	ldrh	r2, [r3, #6]
   12e34:	68fb      	ldr	r3, [r7, #12]
   12e36:	811a      	strh	r2, [r3, #8]
  
  ToSendTLV->data[ToSendTLV->EOFposition]   = (Size >> 8) & 0x00FF;        /* Size*/
   12e38:	2008      	movs	r0, #8
   12e3a:	183b      	adds	r3, r7, r0
   12e3c:	881b      	ldrh	r3, [r3, #0]
   12e3e:	0a1b      	lsrs	r3, r3, #8
   12e40:	b299      	uxth	r1, r3
   12e42:	68fb      	ldr	r3, [r7, #12]
   12e44:	681b      	ldr	r3, [r3, #0]
   12e46:	68fa      	ldr	r2, [r7, #12]
   12e48:	88d2      	ldrh	r2, [r2, #6]
   12e4a:	189b      	adds	r3, r3, r2
   12e4c:	b2ca      	uxtb	r2, r1
   12e4e:	701a      	strb	r2, [r3, #0]
  ToSendTLV->data[ToSendTLV->EOFposition+1] = (Size     ) & 0x00FF;
   12e50:	68fb      	ldr	r3, [r7, #12]
   12e52:	681a      	ldr	r2, [r3, #0]
   12e54:	68fb      	ldr	r3, [r7, #12]
   12e56:	88db      	ldrh	r3, [r3, #6]
   12e58:	3301      	adds	r3, #1
   12e5a:	18d3      	adds	r3, r2, r3
   12e5c:	183a      	adds	r2, r7, r0
   12e5e:	8812      	ldrh	r2, [r2, #0]
   12e60:	b2d2      	uxtb	r2, r2
   12e62:	701a      	strb	r2, [r3, #0]
  ToSendTLV->EOFposition += 2;
   12e64:	68fb      	ldr	r3, [r7, #12]
   12e66:	88db      	ldrh	r3, [r3, #6]
   12e68:	3302      	adds	r3, #2
   12e6a:	b29a      	uxth	r2, r3
   12e6c:	68fb      	ldr	r3, [r7, #12]
   12e6e:	80da      	strh	r2, [r3, #6]
  
  for(uint32_t index = 0; index < Size; index++)                                          /* Value*/
   12e70:	2300      	movs	r3, #0
   12e72:	617b      	str	r3, [r7, #20]
   12e74:	e012      	b.n	12e9c <TLV_add+0xf0>
  {
    ToSendTLV->data[ToSendTLV->EOFposition] = Value[index];
   12e76:	687a      	ldr	r2, [r7, #4]
   12e78:	697b      	ldr	r3, [r7, #20]
   12e7a:	18d2      	adds	r2, r2, r3
   12e7c:	68fb      	ldr	r3, [r7, #12]
   12e7e:	681b      	ldr	r3, [r3, #0]
   12e80:	68f9      	ldr	r1, [r7, #12]
   12e82:	88c9      	ldrh	r1, [r1, #6]
   12e84:	185b      	adds	r3, r3, r1
   12e86:	7812      	ldrb	r2, [r2, #0]
   12e88:	701a      	strb	r2, [r3, #0]
    ToSendTLV->EOFposition++;
   12e8a:	68fb      	ldr	r3, [r7, #12]
   12e8c:	88db      	ldrh	r3, [r3, #6]
   12e8e:	3301      	adds	r3, #1
   12e90:	b29a      	uxth	r2, r3
   12e92:	68fb      	ldr	r3, [r7, #12]
   12e94:	80da      	strh	r2, [r3, #6]
  for(uint32_t index = 0; index < Size; index++)                                          /* Value*/
   12e96:	697b      	ldr	r3, [r7, #20]
   12e98:	3301      	adds	r3, #1
   12e9a:	617b      	str	r3, [r7, #20]
   12e9c:	2308      	movs	r3, #8
   12e9e:	18fb      	adds	r3, r7, r3
   12ea0:	881b      	ldrh	r3, [r3, #0]
   12ea2:	697a      	ldr	r2, [r7, #20]
   12ea4:	429a      	cmp	r2, r3
   12ea6:	d3e6      	bcc.n	12e76 <TLV_add+0xca>
  }
  
  ToSendTLV->data[ToSendTLV->EOFposition]
    = ToSendTLV->data[ToSendTLV->EOFposition+1]
      = ToSendTLV->data[ToSendTLV->EOFposition+2]
        = ToSendTLV->data[ToSendTLV->EOFposition+3] = TLV_EOF;             /* EOF*/
   12ea8:	68fb      	ldr	r3, [r7, #12]
   12eaa:	681a      	ldr	r2, [r3, #0]
   12eac:	68fb      	ldr	r3, [r7, #12]
   12eae:	88db      	ldrh	r3, [r3, #6]
   12eb0:	3303      	adds	r3, #3
   12eb2:	18d3      	adds	r3, r2, r3
   12eb4:	22a5      	movs	r2, #165	; 0xa5
   12eb6:	701a      	strb	r2, [r3, #0]
      = ToSendTLV->data[ToSendTLV->EOFposition+2]
   12eb8:	68fa      	ldr	r2, [r7, #12]
   12eba:	6811      	ldr	r1, [r2, #0]
   12ebc:	68fa      	ldr	r2, [r7, #12]
   12ebe:	88d2      	ldrh	r2, [r2, #6]
   12ec0:	3202      	adds	r2, #2
   12ec2:	188a      	adds	r2, r1, r2
        = ToSendTLV->data[ToSendTLV->EOFposition+3] = TLV_EOF;             /* EOF*/
   12ec4:	781b      	ldrb	r3, [r3, #0]
   12ec6:	7013      	strb	r3, [r2, #0]
    = ToSendTLV->data[ToSendTLV->EOFposition+1]
   12ec8:	68fb      	ldr	r3, [r7, #12]
   12eca:	6819      	ldr	r1, [r3, #0]
   12ecc:	68fb      	ldr	r3, [r7, #12]
   12ece:	88db      	ldrh	r3, [r3, #6]
   12ed0:	3301      	adds	r3, #1
   12ed2:	18cb      	adds	r3, r1, r3
      = ToSendTLV->data[ToSendTLV->EOFposition+2]
   12ed4:	7812      	ldrb	r2, [r2, #0]
   12ed6:	701a      	strb	r2, [r3, #0]
  ToSendTLV->data[ToSendTLV->EOFposition]
   12ed8:	68fa      	ldr	r2, [r7, #12]
   12eda:	6812      	ldr	r2, [r2, #0]
   12edc:	68f9      	ldr	r1, [r7, #12]
   12ede:	88c9      	ldrh	r1, [r1, #6]
   12ee0:	1852      	adds	r2, r2, r1
    = ToSendTLV->data[ToSendTLV->EOFposition+1]
   12ee2:	781b      	ldrb	r3, [r3, #0]
   12ee4:	7013      	strb	r3, [r2, #0]
  
  uint16_t total_lgth = (ToSendTLV->data[5] << 8) + ToSendTLV->data[6] + 3 + Size; /* Update of the top level Size marker*/
   12ee6:	68fb      	ldr	r3, [r7, #12]
   12ee8:	681b      	ldr	r3, [r3, #0]
   12eea:	3305      	adds	r3, #5
   12eec:	781b      	ldrb	r3, [r3, #0]
   12eee:	b29b      	uxth	r3, r3
   12ef0:	021b      	lsls	r3, r3, #8
   12ef2:	b29a      	uxth	r2, r3
   12ef4:	68fb      	ldr	r3, [r7, #12]
   12ef6:	681b      	ldr	r3, [r3, #0]
   12ef8:	3306      	adds	r3, #6
   12efa:	781b      	ldrb	r3, [r3, #0]
   12efc:	b29b      	uxth	r3, r3
   12efe:	18d3      	adds	r3, r2, r3
   12f00:	b29a      	uxth	r2, r3
   12f02:	2008      	movs	r0, #8
   12f04:	183b      	adds	r3, r7, r0
   12f06:	881b      	ldrh	r3, [r3, #0]
   12f08:	18d3      	adds	r3, r2, r3
   12f0a:	b29a      	uxth	r2, r3
   12f0c:	2112      	movs	r1, #18
   12f0e:	187b      	adds	r3, r7, r1
   12f10:	3203      	adds	r2, #3
   12f12:	801a      	strh	r2, [r3, #0]
  ToSendTLV->data[5] = total_lgth >> 8;
   12f14:	187b      	adds	r3, r7, r1
   12f16:	881b      	ldrh	r3, [r3, #0]
   12f18:	0a1b      	lsrs	r3, r3, #8
   12f1a:	b29a      	uxth	r2, r3
   12f1c:	68fb      	ldr	r3, [r7, #12]
   12f1e:	681b      	ldr	r3, [r3, #0]
   12f20:	3305      	adds	r3, #5
   12f22:	b2d2      	uxtb	r2, r2
   12f24:	701a      	strb	r2, [r3, #0]
  ToSendTLV->data[6] = total_lgth;
   12f26:	68fb      	ldr	r3, [r7, #12]
   12f28:	681b      	ldr	r3, [r3, #0]
   12f2a:	3306      	adds	r3, #6
   12f2c:	187a      	adds	r2, r7, r1
   12f2e:	8812      	ldrh	r2, [r2, #0]
   12f30:	b2d2      	uxtb	r2, r2
   12f32:	701a      	strb	r2, [r3, #0]
  
  return 3 + Size;
   12f34:	183b      	adds	r3, r7, r0
   12f36:	881b      	ldrh	r3, [r3, #0]
   12f38:	3303      	adds	r3, #3
   12f3a:	b29b      	uxth	r3, r3
}
   12f3c:	0018      	movs	r0, r3
   12f3e:	46bd      	mov	sp, r7
   12f40:	b006      	add	sp, #24
   12f42:	bd80      	pop	{r7, pc}
   12f44:	0000ffff 	.word	0x0000ffff

00012f48 <TLV_addValue>:
  * @param    Value        A pointer to the Value to add.
  * @return   The number of bytes written if everything went fine, 0xFFFF otherwise.
  *
  */
uint16_t TLV_addValue(TLV_ToSend_Data *ToSendTLV, const uint8_t *Value, uint16_t Size)
{
   12f48:	b580      	push	{r7, lr}
   12f4a:	b086      	sub	sp, #24
   12f4c:	af00      	add	r7, sp, #0
   12f4e:	60f8      	str	r0, [r7, #12]
   12f50:	60b9      	str	r1, [r7, #8]
   12f52:	1dbb      	adds	r3, r7, #6
   12f54:	801a      	strh	r2, [r3, #0]
  if(ToSendTLV->data[ToSendTLV->EOFposition] != TLV_EOF)                return 0xFFFF;       /* EOF has been lost. Has any TLV operation failed, or went interrupted ?*/
   12f56:	68fb      	ldr	r3, [r7, #12]
   12f58:	681b      	ldr	r3, [r3, #0]
   12f5a:	68fa      	ldr	r2, [r7, #12]
   12f5c:	88d2      	ldrh	r2, [r2, #6]
   12f5e:	189b      	adds	r3, r3, r2
   12f60:	781b      	ldrb	r3, [r3, #0]
   12f62:	2ba5      	cmp	r3, #165	; 0xa5
   12f64:	d001      	beq.n	12f6a <TLV_addValue+0x22>
   12f66:	4b41      	ldr	r3, [pc, #260]	; (1306c <TLV_addValue+0x124>)
   12f68:	e07b      	b.n	13062 <TLV_addValue+0x11a>
  if((ToSendTLV->EOFposition + 4 + 3 + Size) > ToSendTLV->maxSize)      return 0xFFFF;       /* Can't add this TLV, because it will overflow the provided buffer.*/
   12f6a:	68fb      	ldr	r3, [r7, #12]
   12f6c:	88db      	ldrh	r3, [r3, #6]
   12f6e:	1dda      	adds	r2, r3, #7
   12f70:	1dbb      	adds	r3, r7, #6
   12f72:	881b      	ldrh	r3, [r3, #0]
   12f74:	18d3      	adds	r3, r2, r3
   12f76:	68fa      	ldr	r2, [r7, #12]
   12f78:	8892      	ldrh	r2, [r2, #4]
   12f7a:	4293      	cmp	r3, r2
   12f7c:	dd01      	ble.n	12f82 <TLV_addValue+0x3a>
   12f7e:	4b3b      	ldr	r3, [pc, #236]	; (1306c <TLV_addValue+0x124>)
   12f80:	e06f      	b.n	13062 <TLV_addValue+0x11a>
  if(ToSendTLV->data == NULL)                                          return 0xFFFF;        /* Data points to NULL. Has the encoding been initialized with TLV_init_encode ?*/
   12f82:	68fb      	ldr	r3, [r7, #12]
   12f84:	681b      	ldr	r3, [r3, #0]
   12f86:	2b00      	cmp	r3, #0
   12f88:	d101      	bne.n	12f8e <TLV_addValue+0x46>
   12f8a:	4b38      	ldr	r3, [pc, #224]	; (1306c <TLV_addValue+0x124>)
   12f8c:	e069      	b.n	13062 <TLV_addValue+0x11a>
  if(ToSendTLV->EOFposition == 0xFFFF)                                 return 0xFFFF;        /* EOF at -1.  Has the decoding been initialized with TLV_init_decode ?*/
   12f8e:	68fb      	ldr	r3, [r7, #12]
   12f90:	88db      	ldrh	r3, [r3, #6]
   12f92:	4a36      	ldr	r2, [pc, #216]	; (1306c <TLV_addValue+0x124>)
   12f94:	4293      	cmp	r3, r2
   12f96:	d101      	bne.n	12f9c <TLV_addValue+0x54>
   12f98:	4b34      	ldr	r3, [pc, #208]	; (1306c <TLV_addValue+0x124>)
   12f9a:	e062      	b.n	13062 <TLV_addValue+0x11a>
  
  for(uint32_t index = 0; index < Size; index++)                                          /* Value*/
   12f9c:	2300      	movs	r3, #0
   12f9e:	617b      	str	r3, [r7, #20]
   12fa0:	e012      	b.n	12fc8 <TLV_addValue+0x80>
  {
    ToSendTLV->data[ToSendTLV->EOFposition] = Value[index];
   12fa2:	68ba      	ldr	r2, [r7, #8]
   12fa4:	697b      	ldr	r3, [r7, #20]
   12fa6:	18d2      	adds	r2, r2, r3
   12fa8:	68fb      	ldr	r3, [r7, #12]
   12faa:	681b      	ldr	r3, [r3, #0]
   12fac:	68f9      	ldr	r1, [r7, #12]
   12fae:	88c9      	ldrh	r1, [r1, #6]
   12fb0:	185b      	adds	r3, r3, r1
   12fb2:	7812      	ldrb	r2, [r2, #0]
   12fb4:	701a      	strb	r2, [r3, #0]
    ToSendTLV->EOFposition++;
   12fb6:	68fb      	ldr	r3, [r7, #12]
   12fb8:	88db      	ldrh	r3, [r3, #6]
   12fba:	3301      	adds	r3, #1
   12fbc:	b29a      	uxth	r2, r3
   12fbe:	68fb      	ldr	r3, [r7, #12]
   12fc0:	80da      	strh	r2, [r3, #6]
  for(uint32_t index = 0; index < Size; index++)                                          /* Value*/
   12fc2:	697b      	ldr	r3, [r7, #20]
   12fc4:	3301      	adds	r3, #1
   12fc6:	617b      	str	r3, [r7, #20]
   12fc8:	1dbb      	adds	r3, r7, #6
   12fca:	881b      	ldrh	r3, [r3, #0]
   12fcc:	697a      	ldr	r2, [r7, #20]
   12fce:	429a      	cmp	r2, r3
   12fd0:	d3e7      	bcc.n	12fa2 <TLV_addValue+0x5a>
  }
  
  ToSendTLV->data[ToSendTLV->EOFposition]
    = ToSendTLV->data[ToSendTLV->EOFposition+1]
      = ToSendTLV->data[ToSendTLV->EOFposition+2]
        = ToSendTLV->data[ToSendTLV->EOFposition+3] = TLV_EOF;             /* EOF*/
   12fd2:	68fb      	ldr	r3, [r7, #12]
   12fd4:	681a      	ldr	r2, [r3, #0]
   12fd6:	68fb      	ldr	r3, [r7, #12]
   12fd8:	88db      	ldrh	r3, [r3, #6]
   12fda:	3303      	adds	r3, #3
   12fdc:	18d3      	adds	r3, r2, r3
   12fde:	22a5      	movs	r2, #165	; 0xa5
   12fe0:	701a      	strb	r2, [r3, #0]
      = ToSendTLV->data[ToSendTLV->EOFposition+2]
   12fe2:	68fa      	ldr	r2, [r7, #12]
   12fe4:	6811      	ldr	r1, [r2, #0]
   12fe6:	68fa      	ldr	r2, [r7, #12]
   12fe8:	88d2      	ldrh	r2, [r2, #6]
   12fea:	3202      	adds	r2, #2
   12fec:	188a      	adds	r2, r1, r2
        = ToSendTLV->data[ToSendTLV->EOFposition+3] = TLV_EOF;             /* EOF*/
   12fee:	781b      	ldrb	r3, [r3, #0]
   12ff0:	7013      	strb	r3, [r2, #0]
    = ToSendTLV->data[ToSendTLV->EOFposition+1]
   12ff2:	68fb      	ldr	r3, [r7, #12]
   12ff4:	6819      	ldr	r1, [r3, #0]
   12ff6:	68fb      	ldr	r3, [r7, #12]
   12ff8:	88db      	ldrh	r3, [r3, #6]
   12ffa:	3301      	adds	r3, #1
   12ffc:	18cb      	adds	r3, r1, r3
      = ToSendTLV->data[ToSendTLV->EOFposition+2]
   12ffe:	7812      	ldrb	r2, [r2, #0]
   13000:	701a      	strb	r2, [r3, #0]
  ToSendTLV->data[ToSendTLV->EOFposition]
   13002:	68fa      	ldr	r2, [r7, #12]
   13004:	6812      	ldr	r2, [r2, #0]
   13006:	68f9      	ldr	r1, [r7, #12]
   13008:	88c9      	ldrh	r1, [r1, #6]
   1300a:	1852      	adds	r2, r2, r1
    = ToSendTLV->data[ToSendTLV->EOFposition+1]
   1300c:	781b      	ldrb	r3, [r3, #0]
   1300e:	7013      	strb	r3, [r2, #0]
  
  uint16_t total_lgth = (ToSendTLV->data[5] << 8) + ToSendTLV->data[6] + Size; /* Update of the top level Size marker*/
   13010:	68fb      	ldr	r3, [r7, #12]
   13012:	681b      	ldr	r3, [r3, #0]
   13014:	3305      	adds	r3, #5
   13016:	781b      	ldrb	r3, [r3, #0]
   13018:	b29b      	uxth	r3, r3
   1301a:	021b      	lsls	r3, r3, #8
   1301c:	b29a      	uxth	r2, r3
   1301e:	68fb      	ldr	r3, [r7, #12]
   13020:	681b      	ldr	r3, [r3, #0]
   13022:	3306      	adds	r3, #6
   13024:	781b      	ldrb	r3, [r3, #0]
   13026:	b29b      	uxth	r3, r3
   13028:	18d3      	adds	r3, r2, r3
   1302a:	b299      	uxth	r1, r3
   1302c:	2012      	movs	r0, #18
   1302e:	183b      	adds	r3, r7, r0
   13030:	1dba      	adds	r2, r7, #6
   13032:	8812      	ldrh	r2, [r2, #0]
   13034:	188a      	adds	r2, r1, r2
   13036:	801a      	strh	r2, [r3, #0]
  ToSendTLV->data[5] = total_lgth >> 8;
   13038:	0001      	movs	r1, r0
   1303a:	187b      	adds	r3, r7, r1
   1303c:	881b      	ldrh	r3, [r3, #0]
   1303e:	0a1b      	lsrs	r3, r3, #8
   13040:	b29a      	uxth	r2, r3
   13042:	68fb      	ldr	r3, [r7, #12]
   13044:	681b      	ldr	r3, [r3, #0]
   13046:	3305      	adds	r3, #5
   13048:	b2d2      	uxtb	r2, r2
   1304a:	701a      	strb	r2, [r3, #0]
  ToSendTLV->data[6] = total_lgth;
   1304c:	68fb      	ldr	r3, [r7, #12]
   1304e:	681b      	ldr	r3, [r3, #0]
   13050:	3306      	adds	r3, #6
   13052:	187a      	adds	r2, r7, r1
   13054:	8812      	ldrh	r2, [r2, #0]
   13056:	b2d2      	uxtb	r2, r2
   13058:	701a      	strb	r2, [r3, #0]
  
  return 3 + Size;
   1305a:	1dbb      	adds	r3, r7, #6
   1305c:	881b      	ldrh	r3, [r3, #0]
   1305e:	3303      	adds	r3, #3
   13060:	b29b      	uxth	r3, r3
}
   13062:	0018      	movs	r0, r3
   13064:	46bd      	mov	sp, r7
   13066:	b006      	add	sp, #24
   13068:	bd80      	pop	{r7, pc}
   1306a:	46c0      	nop			; (mov r8, r8)
   1306c:	0000ffff 	.word	0x0000ffff

00013070 <TLV_deinit_encode>:
  *           Once deinitialization is done, the string used can directly be send.
  * @param    ToSendTLV    The TLV_ToSend_Data structure to deinitialize.
  * @return   None
  */
void TLV_deinit_encode(TLV_ToSend_Data *ToSendTLV)
{
   13070:	b580      	push	{r7, lr}
   13072:	b082      	sub	sp, #8
   13074:	af00      	add	r7, sp, #0
   13076:	6078      	str	r0, [r7, #4]
  ToSendTLV->data        = NULL;
   13078:	687b      	ldr	r3, [r7, #4]
   1307a:	2200      	movs	r2, #0
   1307c:	601a      	str	r2, [r3, #0]
  ToSendTLV->EOFposition = 0xFFFF;
   1307e:	687b      	ldr	r3, [r7, #4]
   13080:	2201      	movs	r2, #1
   13082:	4252      	negs	r2, r2
   13084:	80da      	strh	r2, [r3, #6]
  ToSendTLV->maxSize     = 0;
   13086:	687b      	ldr	r3, [r7, #4]
   13088:	2200      	movs	r2, #0
   1308a:	809a      	strh	r2, [r3, #4]
}
   1308c:	46c0      	nop			; (mov r8, r8)
   1308e:	46bd      	mov	sp, r7
   13090:	b002      	add	sp, #8
   13092:	bd80      	pop	{r7, pc}

00013094 <TLV_init_decode>:
  * @param    ToProcessTLV    The TLV_Received_Data that will be used.
  * @param    pReceivedString          The string which will be decoded.
  * @return   The position of the cursor if everything went fine, 0xFF otherwise.
  */
uint8_t TLV_init_decode(TLV_Received_Data *ToProcessTLV, uint8_t *pReceivedString)
{
   13094:	b580      	push	{r7, lr}
   13096:	b082      	sub	sp, #8
   13098:	af00      	add	r7, sp, #0
   1309a:	6078      	str	r0, [r7, #4]
   1309c:	6039      	str	r1, [r7, #0]
  if(pReceivedString == NULL) return 0xFF;               /* Received string is NULL*/
   1309e:	683b      	ldr	r3, [r7, #0]
   130a0:	2b00      	cmp	r3, #0
   130a2:	d101      	bne.n	130a8 <TLV_init_decode+0x14>
   130a4:	23ff      	movs	r3, #255	; 0xff
   130a6:	e01d      	b.n	130e4 <TLV_init_decode+0x50>
  if(  (pReceivedString[0] != TLV_SOF)
   130a8:	683b      	ldr	r3, [r7, #0]
   130aa:	781b      	ldrb	r3, [r3, #0]
   130ac:	2bfd      	cmp	r3, #253	; 0xfd
   130ae:	d10e      	bne.n	130ce <TLV_init_decode+0x3a>
     ||(pReceivedString[1] != TLV_SOF)
   130b0:	683b      	ldr	r3, [r7, #0]
   130b2:	3301      	adds	r3, #1
   130b4:	781b      	ldrb	r3, [r3, #0]
   130b6:	2bfd      	cmp	r3, #253	; 0xfd
   130b8:	d109      	bne.n	130ce <TLV_init_decode+0x3a>
     ||(pReceivedString[2] != TLV_SOF)
   130ba:	683b      	ldr	r3, [r7, #0]
   130bc:	3302      	adds	r3, #2
   130be:	781b      	ldrb	r3, [r3, #0]
   130c0:	2bfd      	cmp	r3, #253	; 0xfd
   130c2:	d104      	bne.n	130ce <TLV_init_decode+0x3a>
     ||(pReceivedString[3] != TLV_SOF)) return 0xFF;       /* Incorrect SOF*/
   130c4:	683b      	ldr	r3, [r7, #0]
   130c6:	3303      	adds	r3, #3
   130c8:	781b      	ldrb	r3, [r3, #0]
   130ca:	2bfd      	cmp	r3, #253	; 0xfd
   130cc:	d001      	beq.n	130d2 <TLV_init_decode+0x3e>
   130ce:	23ff      	movs	r3, #255	; 0xff
   130d0:	e008      	b.n	130e4 <TLV_init_decode+0x50>
  
  ToProcessTLV->data = pReceivedString;
   130d2:	687b      	ldr	r3, [r7, #4]
   130d4:	683a      	ldr	r2, [r7, #0]
   130d6:	601a      	str	r2, [r3, #0]
  ToProcessTLV->cursor = 7; /* Cursor at start of value*/
   130d8:	687b      	ldr	r3, [r7, #4]
   130da:	2207      	movs	r2, #7
   130dc:	809a      	strh	r2, [r3, #4]
  
  return ToProcessTLV->cursor;
   130de:	687b      	ldr	r3, [r7, #4]
   130e0:	889b      	ldrh	r3, [r3, #4]
   130e2:	b2db      	uxtb	r3, r3
}
   130e4:	0018      	movs	r0, r3
   130e6:	46bd      	mov	sp, r7
   130e8:	b002      	add	sp, #8
   130ea:	bd80      	pop	{r7, pc}

000130ec <TLV_get>:
  * @param    Length            A pointer to where the decoded size should be stocked.
  * @param    Value            A double pointer, which will contain a pointer directly to the data in the reception buffer.
  * @return   0 if the reading was fine and there is another parameter after, 1 if the reading was fine and it was the last parameter, 0xFF otherwise.
  */
uint8_t TLV_get(TLV_Received_Data *ToProcessTLV, uint8_t *Tag, uint16_t *Length, uint8_t **Value)
{
   130ec:	b580      	push	{r7, lr}
   130ee:	b084      	sub	sp, #16
   130f0:	af00      	add	r7, sp, #0
   130f2:	60f8      	str	r0, [r7, #12]
   130f4:	60b9      	str	r1, [r7, #8]
   130f6:	607a      	str	r2, [r7, #4]
   130f8:	603b      	str	r3, [r7, #0]
  if(ToProcessTLV->data == NULL) return 0xFF;                           /* Data points to NULL. Has the decoding been initialized with TLV_init_decode ?*/
   130fa:	68fb      	ldr	r3, [r7, #12]
   130fc:	681b      	ldr	r3, [r3, #0]
   130fe:	2b00      	cmp	r3, #0
   13100:	d101      	bne.n	13106 <TLV_get+0x1a>
   13102:	23ff      	movs	r3, #255	; 0xff
   13104:	e048      	b.n	13198 <TLV_get+0xac>
  if(ToProcessTLV->cursor == 0)  return 0xFF;                           /* The cursor is not positioned. Has the decoding been initialized with TLV_init_decode ?*/
   13106:	68fb      	ldr	r3, [r7, #12]
   13108:	889b      	ldrh	r3, [r3, #4]
   1310a:	2b00      	cmp	r3, #0
   1310c:	d101      	bne.n	13112 <TLV_get+0x26>
   1310e:	23ff      	movs	r3, #255	; 0xff
   13110:	e042      	b.n	13198 <TLV_get+0xac>
  if(ToProcessTLV->data[ToProcessTLV->cursor] == TLV_EOF) return 0xFF;  /* EOF reached. There is not any parameter left to read.*/
   13112:	68fb      	ldr	r3, [r7, #12]
   13114:	681b      	ldr	r3, [r3, #0]
   13116:	68fa      	ldr	r2, [r7, #12]
   13118:	8892      	ldrh	r2, [r2, #4]
   1311a:	189b      	adds	r3, r3, r2
   1311c:	781b      	ldrb	r3, [r3, #0]
   1311e:	2ba5      	cmp	r3, #165	; 0xa5
   13120:	d101      	bne.n	13126 <TLV_get+0x3a>
   13122:	23ff      	movs	r3, #255	; 0xff
   13124:	e038      	b.n	13198 <TLV_get+0xac>

  *Tag = ToProcessTLV->data[ToProcessTLV->cursor];                                                         /* Tag*/
   13126:	68fb      	ldr	r3, [r7, #12]
   13128:	681b      	ldr	r3, [r3, #0]
   1312a:	68fa      	ldr	r2, [r7, #12]
   1312c:	8892      	ldrh	r2, [r2, #4]
   1312e:	189b      	adds	r3, r3, r2
   13130:	781a      	ldrb	r2, [r3, #0]
   13132:	68bb      	ldr	r3, [r7, #8]
   13134:	701a      	strb	r2, [r3, #0]
  ToProcessTLV->cursor++;
   13136:	68fb      	ldr	r3, [r7, #12]
   13138:	889b      	ldrh	r3, [r3, #4]
   1313a:	3301      	adds	r3, #1
   1313c:	b29a      	uxth	r2, r3
   1313e:	68fb      	ldr	r3, [r7, #12]
   13140:	809a      	strh	r2, [r3, #4]
  *Length = (ToProcessTLV->data[ToProcessTLV->cursor] << 8) + ToProcessTLV->data[ToProcessTLV->cursor+1];  /* Length*/
   13142:	68fb      	ldr	r3, [r7, #12]
   13144:	681b      	ldr	r3, [r3, #0]
   13146:	68fa      	ldr	r2, [r7, #12]
   13148:	8892      	ldrh	r2, [r2, #4]
   1314a:	189b      	adds	r3, r3, r2
   1314c:	781b      	ldrb	r3, [r3, #0]
   1314e:	b29b      	uxth	r3, r3
   13150:	021b      	lsls	r3, r3, #8
   13152:	b29a      	uxth	r2, r3
   13154:	68fb      	ldr	r3, [r7, #12]
   13156:	6819      	ldr	r1, [r3, #0]
   13158:	68fb      	ldr	r3, [r7, #12]
   1315a:	889b      	ldrh	r3, [r3, #4]
   1315c:	3301      	adds	r3, #1
   1315e:	18cb      	adds	r3, r1, r3
   13160:	781b      	ldrb	r3, [r3, #0]
   13162:	b29b      	uxth	r3, r3
   13164:	18d3      	adds	r3, r2, r3
   13166:	b29a      	uxth	r2, r3
   13168:	687b      	ldr	r3, [r7, #4]
   1316a:	801a      	strh	r2, [r3, #0]
  ToProcessTLV->cursor += 2;
   1316c:	68fb      	ldr	r3, [r7, #12]
   1316e:	889b      	ldrh	r3, [r3, #4]
   13170:	3302      	adds	r3, #2
   13172:	b29a      	uxth	r2, r3
   13174:	68fb      	ldr	r3, [r7, #12]
   13176:	809a      	strh	r2, [r3, #4]
  *Value = &ToProcessTLV->data[ToProcessTLV->cursor];                                                      /* Value*/
   13178:	68fb      	ldr	r3, [r7, #12]
   1317a:	681b      	ldr	r3, [r3, #0]
   1317c:	68fa      	ldr	r2, [r7, #12]
   1317e:	8892      	ldrh	r2, [r2, #4]
   13180:	189a      	adds	r2, r3, r2
   13182:	683b      	ldr	r3, [r7, #0]
   13184:	601a      	str	r2, [r3, #0]
  ToProcessTLV->cursor += *Length;
   13186:	68fb      	ldr	r3, [r7, #12]
   13188:	889a      	ldrh	r2, [r3, #4]
   1318a:	687b      	ldr	r3, [r7, #4]
   1318c:	881b      	ldrh	r3, [r3, #0]
   1318e:	18d3      	adds	r3, r2, r3
   13190:	b29a      	uxth	r2, r3
   13192:	68fb      	ldr	r3, [r7, #12]
   13194:	809a      	strh	r2, [r3, #4]

  return 0;
   13196:	2300      	movs	r3, #0
}
   13198:	0018      	movs	r0, r3
   1319a:	46bd      	mov	sp, r7
   1319c:	b004      	add	sp, #16
   1319e:	bd80      	pop	{r7, pc}

000131a0 <TLV_deinit_decode>:
  *           This function do not handle any deallocation.
  * @param    ToProcessTLV    The TLV_Received_Data structure to deinitialize.
  * @return   None
  */
void TLV_deinit_decode(TLV_Received_Data *ToProcessTLV)
{
   131a0:	b580      	push	{r7, lr}
   131a2:	b082      	sub	sp, #8
   131a4:	af00      	add	r7, sp, #0
   131a6:	6078      	str	r0, [r7, #4]
  ToProcessTLV->data = NULL;
   131a8:	687b      	ldr	r3, [r7, #4]
   131aa:	2200      	movs	r2, #0
   131ac:	601a      	str	r2, [r3, #0]
  ToProcessTLV->cursor = 0;
   131ae:	687b      	ldr	r3, [r7, #4]
   131b0:	2200      	movs	r2, #0
   131b2:	809a      	strh	r2, [r3, #4]
}
   131b4:	46c0      	nop			; (mov r8, r8)
   131b6:	46bd      	mov	sp, r7
   131b8:	b002      	add	sp, #8
   131ba:	bd80      	pop	{r7, pc}

000131bc <TLV_get_string_length>:
  * @note     This function relies on the length marker in the string. Whether there is or not the SOF and/or the EOF, it will return the size of the string without them.
  * @param    pString      A uint8_t pString, under TLV format, with or without SOF or EOF.
  * @return   The size of the pString in bytes; including tag, length, and value; excluding SOF and EOF, if applicable.
  */
uint16_t TLV_get_string_length(const uint8_t* pString)
{
   131bc:	b580      	push	{r7, lr}
   131be:	b084      	sub	sp, #16
   131c0:	af00      	add	r7, sp, #0
   131c2:	6078      	str	r0, [r7, #4]
  uint16_t  length;      /* Variable to be return.*/
  uint8_t   start = 0;    /* To indicate the start of the real pString, in case there is a EOF. */
   131c4:	230f      	movs	r3, #15
   131c6:	18fb      	adds	r3, r7, r3
   131c8:	2200      	movs	r2, #0
   131ca:	701a      	strb	r2, [r3, #0]

  while(pString[start] == TLV_SOF)
   131cc:	e005      	b.n	131da <TLV_get_string_length+0x1e>
  {
    start++;
   131ce:	210f      	movs	r1, #15
   131d0:	187b      	adds	r3, r7, r1
   131d2:	781a      	ldrb	r2, [r3, #0]
   131d4:	187b      	adds	r3, r7, r1
   131d6:	3201      	adds	r2, #1
   131d8:	701a      	strb	r2, [r3, #0]
  while(pString[start] == TLV_SOF)
   131da:	230f      	movs	r3, #15
   131dc:	18fb      	adds	r3, r7, r3
   131de:	781b      	ldrb	r3, [r3, #0]
   131e0:	687a      	ldr	r2, [r7, #4]
   131e2:	18d3      	adds	r3, r2, r3
   131e4:	781b      	ldrb	r3, [r3, #0]
   131e6:	2bfd      	cmp	r3, #253	; 0xfd
   131e8:	d0f1      	beq.n	131ce <TLV_get_string_length+0x12>
  } /* start variable is now after the SOF if there is one.*/

  length =   (uint16_t)pString[start+1] << 8
   131ea:	210f      	movs	r1, #15
   131ec:	187b      	adds	r3, r7, r1
   131ee:	781b      	ldrb	r3, [r3, #0]
   131f0:	3301      	adds	r3, #1
   131f2:	687a      	ldr	r2, [r7, #4]
   131f4:	18d3      	adds	r3, r2, r3
   131f6:	781b      	ldrb	r3, [r3, #0]
   131f8:	021b      	lsls	r3, r3, #8
    |(uint16_t)pString[start+2];
   131fa:	b21a      	sxth	r2, r3
   131fc:	187b      	adds	r3, r7, r1
   131fe:	781b      	ldrb	r3, [r3, #0]
   13200:	3302      	adds	r3, #2
   13202:	6879      	ldr	r1, [r7, #4]
   13204:	18cb      	adds	r3, r1, r3
   13206:	781b      	ldrb	r3, [r3, #0]
   13208:	b21b      	sxth	r3, r3
   1320a:	4313      	orrs	r3, r2
   1320c:	b21a      	sxth	r2, r3
  length =   (uint16_t)pString[start+1] << 8
   1320e:	210c      	movs	r1, #12
   13210:	187b      	adds	r3, r7, r1
   13212:	801a      	strh	r2, [r3, #0]
  length += 3;
   13214:	187b      	adds	r3, r7, r1
   13216:	187a      	adds	r2, r7, r1
   13218:	8812      	ldrh	r2, [r2, #0]
   1321a:	3203      	adds	r2, #3
   1321c:	801a      	strh	r2, [r3, #0]
  
  return length;
   1321e:	187b      	adds	r3, r7, r1
   13220:	881b      	ldrh	r3, [r3, #0]
}
   13222:	0018      	movs	r0, r3
   13224:	46bd      	mov	sp, r7
   13226:	b004      	add	sp, #16
   13228:	bd80      	pop	{r7, pc}
	...

0001322c <GUI_Init>:
  * @param  CB_GetVoltage     BSP callback to retrieve VBUS voltage
  * @param  CB_GetCurrent     BSP callback to retrieve IBUS current
  * @retval Functional state
  */
USBPD_FunctionalState GUI_Init(const uint8_t* (*CB_HWBoardVersion)(void), const uint8_t* (*CB_HWPDType)(void), uint16_t (*CB_GetVoltage)(uint8_t), int16_t (*CB_GetCurrent)(uint8_t))
{
   1322c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1322e:	b08d      	sub	sp, #52	; 0x34
   13230:	af00      	add	r7, sp, #0
   13232:	60f8      	str	r0, [r7, #12]
   13234:	60b9      	str	r1, [r7, #8]
   13236:	607a      	str	r2, [r7, #4]
   13238:	603b      	str	r3, [r7, #0]
  USBPD_FunctionalState _status = USBPD_ENABLE;
   1323a:	232f      	movs	r3, #47	; 0x2f
   1323c:	18fb      	adds	r3, r7, r3
   1323e:	2201      	movs	r2, #1
   13240:	701a      	strb	r2, [r3, #0]
  /* Retrieve data from FLASH if needed */
  GUI_OriginalSettings = ((GUI_OK == BSP_GUI_LoadDataFromFlash()) ? USBPD_FALSE : USBPD_TRUE);
   13242:	f7ff fa3b 	bl	126bc <BSP_GUI_LoadDataFromFlash>
   13246:	0003      	movs	r3, r0
   13248:	1e5a      	subs	r2, r3, #1
   1324a:	4193      	sbcs	r3, r2
   1324c:	b2db      	uxtb	r3, r3
   1324e:	001a      	movs	r2, r3
   13250:	4b4d      	ldr	r3, [pc, #308]	; (13388 <GUI_Init+0x15c>)
   13252:	701a      	strb	r2, [r3, #0]

  /* Need to update CAD_tDRP & CAD_dcSRC_DRP if CAD_SNKToggleTime not initialized */
  if ((0U == DPM_Settings[USBPD_PORT_0].CAD_SNKToggleTime) || (0U == DPM_Settings[USBPD_PORT_0].CAD_SRCToggleTime))
   13254:	4b4d      	ldr	r3, [pc, #308]	; (1338c <GUI_Init+0x160>)
   13256:	799b      	ldrb	r3, [r3, #6]
   13258:	2b00      	cmp	r3, #0
   1325a:	d003      	beq.n	13264 <GUI_Init+0x38>
   1325c:	4b4b      	ldr	r3, [pc, #300]	; (1338c <GUI_Init+0x160>)
   1325e:	79db      	ldrb	r3, [r3, #7]
   13260:	2b00      	cmp	r3, #0
   13262:	d115      	bne.n	13290 <GUI_Init+0x64>
  {
    DPM_USER_Settings[USBPD_PORT_0].CAD_tDRP      = 80U;
   13264:	4b4a      	ldr	r3, [pc, #296]	; (13390 <GUI_Init+0x164>)
   13266:	226b      	movs	r2, #107	; 0x6b
   13268:	189b      	adds	r3, r3, r2
   1326a:	785a      	ldrb	r2, [r3, #1]
   1326c:	2101      	movs	r1, #1
   1326e:	400a      	ands	r2, r1
   13270:	1c11      	adds	r1, r2, #0
   13272:	2260      	movs	r2, #96	; 0x60
   13274:	4252      	negs	r2, r2
   13276:	430a      	orrs	r2, r1
   13278:	705a      	strb	r2, [r3, #1]
    DPM_USER_Settings[USBPD_PORT_0].CAD_dcSRC_DRP = 50U;
   1327a:	4b45      	ldr	r3, [pc, #276]	; (13390 <GUI_Init+0x164>)
   1327c:	226b      	movs	r2, #107	; 0x6b
   1327e:	189b      	adds	r3, r3, r2
   13280:	789a      	ldrb	r2, [r3, #2]
   13282:	217f      	movs	r1, #127	; 0x7f
   13284:	438a      	bics	r2, r1
   13286:	1c11      	adds	r1, r2, #0
   13288:	2232      	movs	r2, #50	; 0x32
   1328a:	430a      	orrs	r2, r1
   1328c:	709a      	strb	r2, [r3, #2]
   1328e:	e040      	b.n	13312 <GUI_Init+0xe6>
  }
  else
  {
    DPM_USER_Settings[USBPD_PORT_0].CAD_dcSRC_DRP = (DPM_Settings[USBPD_PORT_0].CAD_SRCToggleTime * 100) / (DPM_Settings[USBPD_PORT_0].CAD_SRCToggleTime + DPM_Settings[USBPD_PORT_0].CAD_SNKToggleTime);
   13290:	4b3e      	ldr	r3, [pc, #248]	; (1338c <GUI_Init+0x160>)
   13292:	79db      	ldrb	r3, [r3, #7]
   13294:	001a      	movs	r2, r3
   13296:	2364      	movs	r3, #100	; 0x64
   13298:	435a      	muls	r2, r3
   1329a:	4b3c      	ldr	r3, [pc, #240]	; (1338c <GUI_Init+0x160>)
   1329c:	79db      	ldrb	r3, [r3, #7]
   1329e:	0019      	movs	r1, r3
   132a0:	4b3a      	ldr	r3, [pc, #232]	; (1338c <GUI_Init+0x160>)
   132a2:	799b      	ldrb	r3, [r3, #6]
   132a4:	18cb      	adds	r3, r1, r3
   132a6:	0019      	movs	r1, r3
   132a8:	0010      	movs	r0, r2
   132aa:	f00b fe95 	bl	1efd8 <__divsi3>
   132ae:	0003      	movs	r3, r0
   132b0:	1c1a      	adds	r2, r3, #0
   132b2:	237f      	movs	r3, #127	; 0x7f
   132b4:	4013      	ands	r3, r2
   132b6:	b2da      	uxtb	r2, r3
   132b8:	4b35      	ldr	r3, [pc, #212]	; (13390 <GUI_Init+0x164>)
   132ba:	216b      	movs	r1, #107	; 0x6b
   132bc:	185b      	adds	r3, r3, r1
   132be:	217f      	movs	r1, #127	; 0x7f
   132c0:	400a      	ands	r2, r1
   132c2:	0010      	movs	r0, r2
   132c4:	789a      	ldrb	r2, [r3, #2]
   132c6:	217f      	movs	r1, #127	; 0x7f
   132c8:	438a      	bics	r2, r1
   132ca:	1c11      	adds	r1, r2, #0
   132cc:	1c02      	adds	r2, r0, #0
   132ce:	430a      	orrs	r2, r1
   132d0:	709a      	strb	r2, [r3, #2]
    DPM_USER_Settings[USBPD_PORT_0].CAD_tDRP = (DPM_Settings[USBPD_PORT_0].CAD_SRCToggleTime * 100) / DPM_USER_Settings[USBPD_PORT_0].CAD_dcSRC_DRP;
   132d2:	4b2e      	ldr	r3, [pc, #184]	; (1338c <GUI_Init+0x160>)
   132d4:	79db      	ldrb	r3, [r3, #7]
   132d6:	001a      	movs	r2, r3
   132d8:	2364      	movs	r3, #100	; 0x64
   132da:	4353      	muls	r3, r2
   132dc:	0018      	movs	r0, r3
   132de:	4b2c      	ldr	r3, [pc, #176]	; (13390 <GUI_Init+0x164>)
   132e0:	226d      	movs	r2, #109	; 0x6d
   132e2:	5c9b      	ldrb	r3, [r3, r2]
   132e4:	065b      	lsls	r3, r3, #25
   132e6:	0e5b      	lsrs	r3, r3, #25
   132e8:	b2db      	uxtb	r3, r3
   132ea:	0019      	movs	r1, r3
   132ec:	f00b fe74 	bl	1efd8 <__divsi3>
   132f0:	0003      	movs	r3, r0
   132f2:	1c1a      	adds	r2, r3, #0
   132f4:	237f      	movs	r3, #127	; 0x7f
   132f6:	4013      	ands	r3, r2
   132f8:	b2d9      	uxtb	r1, r3
   132fa:	4b25      	ldr	r3, [pc, #148]	; (13390 <GUI_Init+0x164>)
   132fc:	226b      	movs	r2, #107	; 0x6b
   132fe:	189b      	adds	r3, r3, r2
   13300:	1c0a      	adds	r2, r1, #0
   13302:	1890      	adds	r0, r2, r2
   13304:	785a      	ldrb	r2, [r3, #1]
   13306:	2101      	movs	r1, #1
   13308:	400a      	ands	r2, r1
   1330a:	1c11      	adds	r1, r2, #0
   1330c:	1c02      	adds	r2, r0, #0
   1330e:	430a      	orrs	r2, r1
   13310:	705a      	strb	r2, [r3, #1]
    DPM_USER_Settings[USBPD_PORT_1].CAD_tDRP = (DPM_Settings[USBPD_PORT_1].CAD_SRCToggleTime * 100) / DPM_USER_Settings[USBPD_PORT_1].CAD_dcSRC_DRP;
  }
#endif /* USBPD_PORT_COUNT==2 */


  pCB_HWBoardVersion  = CB_HWBoardVersion;
   13312:	4b20      	ldr	r3, [pc, #128]	; (13394 <GUI_Init+0x168>)
   13314:	68fa      	ldr	r2, [r7, #12]
   13316:	601a      	str	r2, [r3, #0]
  pCB_HWPDType        = CB_HWPDType;
   13318:	4b1f      	ldr	r3, [pc, #124]	; (13398 <GUI_Init+0x16c>)
   1331a:	68ba      	ldr	r2, [r7, #8]
   1331c:	601a      	str	r2, [r3, #0]
  pCB_GetVoltage      = CB_GetVoltage;
   1331e:	4b1f      	ldr	r3, [pc, #124]	; (1339c <GUI_Init+0x170>)
   13320:	687a      	ldr	r2, [r7, #4]
   13322:	601a      	str	r2, [r3, #0]
  pCB_GetCurrent      = CB_GetCurrent;
   13324:	4b1e      	ldr	r3, [pc, #120]	; (133a0 <GUI_Init+0x174>)
   13326:	683a      	ldr	r2, [r7, #0]
   13328:	601a      	str	r2, [r3, #0]

  /* Register 2 callbacks for notification in DPM */
  USBPD_DPM_SetNotification_GUI(GUI_FormatAndSendNotification, GUI_PostNotificationMessage, GUI_SaveInfo);
   1332a:	4a1e      	ldr	r2, [pc, #120]	; (133a4 <GUI_Init+0x178>)
   1332c:	491e      	ldr	r1, [pc, #120]	; (133a8 <GUI_Init+0x17c>)
   1332e:	4b1f      	ldr	r3, [pc, #124]	; (133ac <GUI_Init+0x180>)
   13330:	0018      	movs	r0, r3
   13332:	f7f5 f8b9 	bl	84a8 <USBPD_DPM_SetNotification_GUI>

#if defined(_RTOS)
#if (osCMSIS < 0x20000U)
  osMessageQDef(MsgBox, GUI_BOX_MESSAGES_MAX, uint32_t);
   13336:	2124      	movs	r1, #36	; 0x24
   13338:	187b      	adds	r3, r7, r1
   1333a:	4a1d      	ldr	r2, [pc, #116]	; (133b0 <GUI_Init+0x184>)
   1333c:	ca11      	ldmia	r2!, {r0, r4}
   1333e:	c311      	stmia	r3!, {r0, r4}
  osThreadDef(GUI, TaskGUI, FREERTOS_GUI_PRIORITY, 0, FREERTOS_GUI_STACK_SIZE);
   13340:	2410      	movs	r4, #16
   13342:	193b      	adds	r3, r7, r4
   13344:	4a1b      	ldr	r2, [pc, #108]	; (133b4 <GUI_Init+0x188>)
   13346:	ca61      	ldmia	r2!, {r0, r5, r6}
   13348:	c361      	stmia	r3!, {r0, r5, r6}
   1334a:	ca21      	ldmia	r2!, {r0, r5}
   1334c:	c321      	stmia	r3!, {r0, r5}
  GUIMsgBox = osMessageCreate(osMessageQ(MsgBox), NULL);
   1334e:	187b      	adds	r3, r7, r1
   13350:	2100      	movs	r1, #0
   13352:	0018      	movs	r0, r3
   13354:	f7fd fb5e 	bl	10a14 <osMessageCreate>
   13358:	0002      	movs	r2, r0
   1335a:	4b17      	ldr	r3, [pc, #92]	; (133b8 <GUI_Init+0x18c>)
   1335c:	601a      	str	r2, [r3, #0]
  if(NULL == osThreadCreate(osThread(GUI), &GUIMsgBox))
   1335e:	4a16      	ldr	r2, [pc, #88]	; (133b8 <GUI_Init+0x18c>)
   13360:	193b      	adds	r3, r7, r4
   13362:	0011      	movs	r1, r2
   13364:	0018      	movs	r0, r3
   13366:	f7fd fa71 	bl	1084c <osThreadCreate>
   1336a:	1e03      	subs	r3, r0, #0
   1336c:	d103      	bne.n	13376 <GUI_Init+0x14a>
#else
  GUIMsgBox = osMessageQueueNew (GUI_BOX_MESSAGES_MAX, sizeof(uint32_t), NULL);
  if (NULL == osThreadNew(TaskGUI, &GUIMsgBox, &GUI_Thread_Atrr))
#endif /* osCMSIS < 0x20000U */
  {
    _status = USBPD_DISABLE;
   1336e:	232f      	movs	r3, #47	; 0x2f
   13370:	18fb      	adds	r3, r7, r3
   13372:	2200      	movs	r2, #0
   13374:	701a      	strb	r2, [r3, #0]
   13376:	b662      	cpsie	i
  __enable_irq();
#else
  GUI_Start();
#endif /* _RTOS */

  return _status;
   13378:	232f      	movs	r3, #47	; 0x2f
   1337a:	18fb      	adds	r3, r7, r3
   1337c:	781b      	ldrb	r3, [r3, #0]
}
   1337e:	0018      	movs	r0, r3
   13380:	46bd      	mov	sp, r7
   13382:	b00d      	add	sp, #52	; 0x34
   13384:	bdf0      	pop	{r4, r5, r6, r7, pc}
   13386:	46c0      	nop			; (mov r8, r8)
   13388:	000323e8 	.word	0x000323e8
   1338c:	0002fec8 	.word	0x0002fec8
   13390:	0002fedc 	.word	0x0002fedc
   13394:	00031cc0 	.word	0x00031cc0
   13398:	00031cc4 	.word	0x00031cc4
   1339c:	00031cc8 	.word	0x00031cc8
   133a0:	00031ccc 	.word	0x00031ccc
   133a4:	00014439 	.word	0x00014439
   133a8:	0001437d 	.word	0x0001437d
   133ac:	000136b7 	.word	0x000136b7
   133b0:	0001f64c 	.word	0x0001f64c
   133b4:	0001f658 	.word	0x0001f658
   133b8:	000322e4 	.word	0x000322e4

000133bc <GUI_Start>:


void GUI_Start(void)
{
   133bc:	b580      	push	{r7, lr}
   133be:	af00      	add	r7, sp, #0
  /* register the GUI callback to manage UART reception */
  TRACER_EMB_StartRX(GUI_CALLBACK_RX);
   133c0:	4b03      	ldr	r3, [pc, #12]	; (133d0 <GUI_Start+0x14>)
   133c2:	0018      	movs	r0, r3
   133c4:	f003 fda2 	bl	16f0c <TRACER_EMB_StartRX>
}
   133c8:	46c0      	nop			; (mov r8, r8)
   133ca:	46bd      	mov	sp, r7
   133cc:	bd80      	pop	{r7, pc}
   133ce:	46c0      	nop			; (mov r8, r8)
   133d0:	000135b9 	.word	0x000135b9

000133d4 <TaskGUI>:
static void TaskGUI(void *pEvent)
#endif /* osCMSIS < 0x20000U */
#else
void GUI_Execute(void)
#endif /* _RTOS */
{
   133d4:	b590      	push	{r4, r7, lr}
   133d6:	b08b      	sub	sp, #44	; 0x2c
   133d8:	af00      	add	r7, sp, #0
   133da:	6078      	str	r0, [r7, #4]
#ifdef _RTOS
  uint32_t _timing = osWaitForever;
   133dc:	2301      	movs	r3, #1
   133de:	425b      	negs	r3, r3
   133e0:	627b      	str	r3, [r7, #36]	; 0x24
  osMessageQId  queue = *(osMessageQId *)pEvent;
   133e2:	687b      	ldr	r3, [r7, #4]
   133e4:	681b      	ldr	r3, [r3, #0]
   133e6:	61fb      	str	r3, [r7, #28]

  GUI_Start();
   133e8:	f7ff ffe8 	bl	133bc <GUI_Start>
  do
  {
#if (osCMSIS < 0x20000U)
    osEvent event = osMessageGet(queue, _timing);
   133ec:	240c      	movs	r4, #12
   133ee:	193b      	adds	r3, r7, r4
   133f0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   133f2:	69f9      	ldr	r1, [r7, #28]
   133f4:	0018      	movs	r0, r3
   133f6:	f7fd fb5b 	bl	10ab0 <osMessageGet>
    switch (((GUI_USER_EVENT)event.value.v & 0xF))
   133fa:	193b      	adds	r3, r7, r4
   133fc:	685b      	ldr	r3, [r3, #4]
   133fe:	b2db      	uxtb	r3, r3
   13400:	001a      	movs	r2, r3
   13402:	230f      	movs	r3, #15
   13404:	4013      	ands	r3, r2
   13406:	d010      	beq.n	1342a <TaskGUI+0x56>
   13408:	2b01      	cmp	r3, #1
   1340a:	d000      	beq.n	1340e <TaskGUI+0x3a>
#ifdef _RTOS
      break;
    }

    default:
      break;
   1340c:	e092      	b.n	13534 <TaskGUI+0x160>
        GUI_RXProcess((uint32_t)event.value.v);
   1340e:	230c      	movs	r3, #12
   13410:	18fb      	adds	r3, r7, r3
   13412:	685b      	ldr	r3, [r3, #4]
   13414:	0018      	movs	r0, r3
   13416:	f000 f8f5 	bl	13604 <GUI_RXProcess>
        osMessagePut(GUIMsgBox, GUI_USER_EVENT_TIMER, 0);
   1341a:	4b49      	ldr	r3, [pc, #292]	; (13540 <TaskGUI+0x16c>)
   1341c:	681b      	ldr	r3, [r3, #0]
   1341e:	2200      	movs	r2, #0
   13420:	2100      	movs	r1, #0
   13422:	0018      	movs	r0, r3
   13424:	f7fd fb08 	bl	10a38 <osMessagePut>
        break;
   13428:	e084      	b.n	13534 <TaskGUI+0x160>
      for(uint8_t _instance = 0; _instance < USBPD_PORT_COUNT; _instance++)
   1342a:	2323      	movs	r3, #35	; 0x23
   1342c:	18fb      	adds	r3, r7, r3
   1342e:	2200      	movs	r2, #0
   13430:	701a      	strb	r2, [r3, #0]
   13432:	e078      	b.n	13526 <TaskGUI+0x152>
        if ((USBPD_TRUE == DPM_Params[_instance].PE_IsConnected)
   13434:	2323      	movs	r3, #35	; 0x23
   13436:	18fb      	adds	r3, r7, r3
   13438:	781b      	ldrb	r3, [r3, #0]
   1343a:	4a42      	ldr	r2, [pc, #264]	; (13544 <TaskGUI+0x170>)
   1343c:	009b      	lsls	r3, r3, #2
   1343e:	18d3      	adds	r3, r2, r3
   13440:	785b      	ldrb	r3, [r3, #1]
   13442:	06db      	lsls	r3, r3, #27
   13444:	0fdb      	lsrs	r3, r3, #31
   13446:	b2db      	uxtb	r3, r3
   13448:	2b01      	cmp	r3, #1
   1344a:	d15f      	bne.n	1350c <TaskGUI+0x138>
            && (1 == GUI_USER_Params[_instance].u.d.MeasReportActivation)
   1344c:	2323      	movs	r3, #35	; 0x23
   1344e:	18fb      	adds	r3, r7, r3
   13450:	781a      	ldrb	r2, [r3, #0]
   13452:	493d      	ldr	r1, [pc, #244]	; (13548 <TaskGUI+0x174>)
   13454:	0013      	movs	r3, r2
   13456:	005b      	lsls	r3, r3, #1
   13458:	189b      	adds	r3, r3, r2
   1345a:	005b      	lsls	r3, r3, #1
   1345c:	18cb      	adds	r3, r1, r3
   1345e:	791b      	ldrb	r3, [r3, #4]
   13460:	061b      	lsls	r3, r3, #24
   13462:	0fdb      	lsrs	r3, r3, #31
   13464:	b2db      	uxtb	r3, r3
   13466:	2b01      	cmp	r3, #1
   13468:	d150      	bne.n	1350c <TaskGUI+0x138>
              && (0 != GUI_USER_Params[_instance].u.d.MeasReportValue))
   1346a:	2323      	movs	r3, #35	; 0x23
   1346c:	18fb      	adds	r3, r7, r3
   1346e:	781a      	ldrb	r2, [r3, #0]
   13470:	4935      	ldr	r1, [pc, #212]	; (13548 <TaskGUI+0x174>)
   13472:	0013      	movs	r3, r2
   13474:	005b      	lsls	r3, r3, #1
   13476:	189b      	adds	r3, r3, r2
   13478:	005b      	lsls	r3, r3, #1
   1347a:	18cb      	adds	r3, r1, r3
   1347c:	791b      	ldrb	r3, [r3, #4]
   1347e:	065b      	lsls	r3, r3, #25
   13480:	0e5b      	lsrs	r3, r3, #25
   13482:	b2db      	uxtb	r3, r3
   13484:	2b00      	cmp	r3, #0
   13486:	d041      	beq.n	1350c <TaskGUI+0x138>
          if (IS_GUI_TIMER_EXPIRED(_instance, GUI_TimerMeasReport))
   13488:	2323      	movs	r3, #35	; 0x23
   1348a:	18fb      	adds	r3, r7, r3
   1348c:	781a      	ldrb	r2, [r3, #0]
   1348e:	4b2f      	ldr	r3, [pc, #188]	; (1354c <TaskGUI+0x178>)
   13490:	0052      	lsls	r2, r2, #1
   13492:	5ad3      	ldrh	r3, [r2, r3]
   13494:	b29a      	uxth	r2, r3
   13496:	2380      	movs	r3, #128	; 0x80
   13498:	021b      	lsls	r3, r3, #8
   1349a:	429a      	cmp	r2, r3
   1349c:	d10a      	bne.n	134b4 <TaskGUI+0xe0>
            uint32_t event_mr = GUI_USER_EVENT_GUI | (_instance << GUI_PE_PORT_NUM_Pos) | (GUI_NOTIF_MEASUREMENT << GUI_PE_NOTIF_Pos);
   1349e:	2323      	movs	r3, #35	; 0x23
   134a0:	18fb      	adds	r3, r7, r3
   134a2:	781b      	ldrb	r3, [r3, #0]
   134a4:	061b      	lsls	r3, r3, #24
   134a6:	4a2a      	ldr	r2, [pc, #168]	; (13550 <TaskGUI+0x17c>)
   134a8:	4313      	orrs	r3, r2
   134aa:	61bb      	str	r3, [r7, #24]
            GUI_RXProcess(event_mr);
   134ac:	69bb      	ldr	r3, [r7, #24]
   134ae:	0018      	movs	r0, r3
   134b0:	f000 f8a8 	bl	13604 <GUI_RXProcess>
          if (!(IS_GUI_TIMER_RUNNING(_instance, GUI_TimerMeasReport)))
   134b4:	2323      	movs	r3, #35	; 0x23
   134b6:	18fb      	adds	r3, r7, r3
   134b8:	781a      	ldrb	r2, [r3, #0]
   134ba:	4b24      	ldr	r3, [pc, #144]	; (1354c <TaskGUI+0x178>)
   134bc:	0052      	lsls	r2, r2, #1
   134be:	5ad3      	ldrh	r3, [r2, r3]
   134c0:	b29b      	uxth	r3, r3
   134c2:	045b      	lsls	r3, r3, #17
   134c4:	0c5b      	lsrs	r3, r3, #17
   134c6:	2b00      	cmp	r3, #0
   134c8:	dc27      	bgt.n	1351a <TaskGUI+0x146>
            GUI_START_TIMER(_instance, GUI_TimerMeasReport, (GUI_USER_Params[_instance].u.d.MeasReportValue * GUI_NOTIF_MEASUREMENT_STEP));
   134ca:	2023      	movs	r0, #35	; 0x23
   134cc:	183b      	adds	r3, r7, r0
   134ce:	781a      	ldrb	r2, [r3, #0]
   134d0:	491d      	ldr	r1, [pc, #116]	; (13548 <TaskGUI+0x174>)
   134d2:	0013      	movs	r3, r2
   134d4:	005b      	lsls	r3, r3, #1
   134d6:	189b      	adds	r3, r3, r2
   134d8:	005b      	lsls	r3, r3, #1
   134da:	18cb      	adds	r3, r1, r3
   134dc:	791b      	ldrb	r3, [r3, #4]
   134de:	065b      	lsls	r3, r3, #25
   134e0:	0e5b      	lsrs	r3, r3, #25
   134e2:	b2db      	uxtb	r3, r3
   134e4:	b29b      	uxth	r3, r3
   134e6:	2228      	movs	r2, #40	; 0x28
   134e8:	4353      	muls	r3, r2
   134ea:	b29b      	uxth	r3, r3
   134ec:	183a      	adds	r2, r7, r0
   134ee:	7812      	ldrb	r2, [r2, #0]
   134f0:	4918      	ldr	r1, [pc, #96]	; (13554 <TaskGUI+0x180>)
   134f2:	430b      	orrs	r3, r1
   134f4:	b299      	uxth	r1, r3
   134f6:	4b15      	ldr	r3, [pc, #84]	; (1354c <TaskGUI+0x178>)
   134f8:	0052      	lsls	r2, r2, #1
   134fa:	52d1      	strh	r1, [r2, r3]
   134fc:	4b10      	ldr	r3, [pc, #64]	; (13540 <TaskGUI+0x16c>)
   134fe:	681b      	ldr	r3, [r3, #0]
   13500:	2200      	movs	r2, #0
   13502:	2100      	movs	r1, #0
   13504:	0018      	movs	r0, r3
   13506:	f7fd fa97 	bl	10a38 <osMessagePut>
          if (!(IS_GUI_TIMER_RUNNING(_instance, GUI_TimerMeasReport)))
   1350a:	e006      	b.n	1351a <TaskGUI+0x146>
          GUI_TimerMeasReport[_instance] = 0;
   1350c:	2323      	movs	r3, #35	; 0x23
   1350e:	18fb      	adds	r3, r7, r3
   13510:	781a      	ldrb	r2, [r3, #0]
   13512:	4b0e      	ldr	r3, [pc, #56]	; (1354c <TaskGUI+0x178>)
   13514:	0052      	lsls	r2, r2, #1
   13516:	2100      	movs	r1, #0
   13518:	52d1      	strh	r1, [r2, r3]
      for(uint8_t _instance = 0; _instance < USBPD_PORT_COUNT; _instance++)
   1351a:	2123      	movs	r1, #35	; 0x23
   1351c:	187b      	adds	r3, r7, r1
   1351e:	781a      	ldrb	r2, [r3, #0]
   13520:	187b      	adds	r3, r7, r1
   13522:	3201      	adds	r2, #1
   13524:	701a      	strb	r2, [r3, #0]
   13526:	2323      	movs	r3, #35	; 0x23
   13528:	18fb      	adds	r3, r7, r3
   1352a:	781b      	ldrb	r3, [r3, #0]
   1352c:	2b00      	cmp	r3, #0
   1352e:	d100      	bne.n	13532 <TaskGUI+0x15e>
   13530:	e780      	b.n	13434 <TaskGUI+0x60>
      break;
   13532:	46c0      	nop			; (mov r8, r8)
    }
    _timing = CheckGUITimers();
   13534:	f000 f810 	bl	13558 <CheckGUITimers>
   13538:	0003      	movs	r3, r0
   1353a:	627b      	str	r3, [r7, #36]	; 0x24
  {
   1353c:	e756      	b.n	133ec <TaskGUI+0x18>
   1353e:	46c0      	nop			; (mov r8, r8)
   13540:	000322e4 	.word	0x000322e4
   13544:	000321d4 	.word	0x000321d4
   13548:	000322dc 	.word	0x000322dc
   1354c:	000322d8 	.word	0x000322d8
   13550:	00000641 	.word	0x00000641
   13554:	ffff8000 	.word	0xffff8000

00013558 <CheckGUITimers>:
#endif /* !_RTOS */
}

#ifdef _RTOS
static uint32_t CheckGUITimers(void)
{
   13558:	b580      	push	{r7, lr}
   1355a:	b084      	sub	sp, #16
   1355c:	af00      	add	r7, sp, #0
  uint32_t _timing = osWaitForever;
   1355e:	2301      	movs	r3, #1
   13560:	425b      	negs	r3, r3
   13562:	60fb      	str	r3, [r7, #12]
  uint32_t _current_timing;

  /* Calculate the minimum timers to wake-up GUI task */
  for(uint8_t instance = 0; instance < USBPD_PORT_COUNT; instance++)
   13564:	230b      	movs	r3, #11
   13566:	18fb      	adds	r3, r7, r3
   13568:	2200      	movs	r2, #0
   1356a:	701a      	strb	r2, [r3, #0]
   1356c:	e018      	b.n	135a0 <CheckGUITimers+0x48>
  {
    /* Check if Measurement reporting has been enabled by the GUI */
    _current_timing = GUI_TimerMeasReport[instance] & GUI_TIMER_READ_MSK;
   1356e:	230b      	movs	r3, #11
   13570:	18fb      	adds	r3, r7, r3
   13572:	781a      	ldrb	r2, [r3, #0]
   13574:	4b0f      	ldr	r3, [pc, #60]	; (135b4 <CheckGUITimers+0x5c>)
   13576:	0052      	lsls	r2, r2, #1
   13578:	5ad3      	ldrh	r3, [r2, r3]
   1357a:	b29b      	uxth	r3, r3
   1357c:	045b      	lsls	r3, r3, #17
   1357e:	0c5b      	lsrs	r3, r3, #17
   13580:	607b      	str	r3, [r7, #4]
    if(_current_timing > 0)
   13582:	687b      	ldr	r3, [r7, #4]
   13584:	2b00      	cmp	r3, #0
   13586:	d005      	beq.n	13594 <CheckGUITimers+0x3c>
    {
      if (_current_timing < _timing)
   13588:	687a      	ldr	r2, [r7, #4]
   1358a:	68fb      	ldr	r3, [r7, #12]
   1358c:	429a      	cmp	r2, r3
   1358e:	d201      	bcs.n	13594 <CheckGUITimers+0x3c>
      {
        _timing = _current_timing;
   13590:	687b      	ldr	r3, [r7, #4]
   13592:	60fb      	str	r3, [r7, #12]
  for(uint8_t instance = 0; instance < USBPD_PORT_COUNT; instance++)
   13594:	210b      	movs	r1, #11
   13596:	187b      	adds	r3, r7, r1
   13598:	781a      	ldrb	r2, [r3, #0]
   1359a:	187b      	adds	r3, r7, r1
   1359c:	3201      	adds	r2, #1
   1359e:	701a      	strb	r2, [r3, #0]
   135a0:	230b      	movs	r3, #11
   135a2:	18fb      	adds	r3, r7, r3
   135a4:	781b      	ldrb	r3, [r3, #0]
   135a6:	2b00      	cmp	r3, #0
   135a8:	d0e1      	beq.n	1356e <CheckGUITimers+0x16>
      }
    }
  }
  return _timing;
   135aa:	68fb      	ldr	r3, [r7, #12]
}
   135ac:	0018      	movs	r0, r3
   135ae:	46bd      	mov	sp, r7
   135b0:	b004      	add	sp, #16
   135b2:	bd80      	pop	{r7, pc}
   135b4:	000322d8 	.word	0x000322d8

000135b8 <GUI_CALLBACK_RX>:
  * @param  Character Byte received by the device
  * @param  Error     Error detected in the reception
  * @retval 1 if message to send to DPM application
  */
void GUI_CALLBACK_RX(uint8_t Character, uint8_t Error)
{
   135b8:	b580      	push	{r7, lr}
   135ba:	b084      	sub	sp, #16
   135bc:	af00      	add	r7, sp, #0
   135be:	0002      	movs	r2, r0
   135c0:	1dfb      	adds	r3, r7, #7
   135c2:	701a      	strb	r2, [r3, #0]
   135c4:	1dbb      	adds	r3, r7, #6
   135c6:	1c0a      	adds	r2, r1, #0
   135c8:	701a      	strb	r2, [r3, #0]
  __ASM volatile ("cpsid i" : : : "memory");
   135ca:	b672      	cpsid	i
  uint32_t event;
  __disable_irq();
  event = GUI_GetMessage(Character, Error);
   135cc:	1dbb      	adds	r3, r7, #6
   135ce:	781a      	ldrb	r2, [r3, #0]
   135d0:	1dfb      	adds	r3, r7, #7
   135d2:	781b      	ldrb	r3, [r3, #0]
   135d4:	0011      	movs	r1, r2
   135d6:	0018      	movs	r0, r3
   135d8:	f000 f88e 	bl	136f8 <GUI_GetMessage>
   135dc:	0003      	movs	r3, r0
   135de:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("cpsie i" : : : "memory");
   135e0:	b662      	cpsie	i
  __enable_irq();
  if (event == 1)
   135e2:	68fb      	ldr	r3, [r7, #12]
   135e4:	2b01      	cmp	r3, #1
   135e6:	d106      	bne.n	135f6 <GUI_CALLBACK_RX+0x3e>
  {
#if defined(_RTOS)
#if (osCMSIS < 0x20000U)
    (void)osMessagePut(GUIMsgBox, GUI_USER_EVENT_GUI, 1);
   135e8:	4b05      	ldr	r3, [pc, #20]	; (13600 <GUI_CALLBACK_RX+0x48>)
   135ea:	681b      	ldr	r3, [r3, #0]
   135ec:	2201      	movs	r2, #1
   135ee:	2101      	movs	r1, #1
   135f0:	0018      	movs	r0, r3
   135f2:	f7fd fa21 	bl	10a38 <osMessagePut>
#endif /* osCMSIS < 0x20000U */
#else
    GUI_Flag = GUI_USER_EVENT_GUI;
#endif /* _RTOS */
  }
}
   135f6:	46c0      	nop			; (mov r8, r8)
   135f8:	46bd      	mov	sp, r7
   135fa:	b004      	add	sp, #16
   135fc:	bd80      	pop	{r7, pc}
   135fe:	46c0      	nop			; (mov r8, r8)
   13600:	000322e4 	.word	0x000322e4

00013604 <GUI_RXProcess>:
  * @brief  Main Trace RX process to push data on the media.
  * @param  Event     GUI trace event
  * @retval Timing
  */
uint32_t GUI_RXProcess(uint32_t Event)
{
   13604:	b5b0      	push	{r4, r5, r7, lr}
   13606:	b086      	sub	sp, #24
   13608:	af00      	add	r7, sp, #0
   1360a:	6078      	str	r0, [r7, #4]
  uint8_t *msg;
  USBPD_GUI_State state;
  uint8_t size;

  if (0 == (Event & GUI_PE_NOTIF_Msk))
   1360c:	687a      	ldr	r2, [r7, #4]
   1360e:	23ff      	movs	r3, #255	; 0xff
   13610:	011b      	lsls	r3, r3, #4
   13612:	4013      	ands	r3, r2
   13614:	d120      	bne.n	13658 <GUI_RXProcess+0x54>
  {
    /* Message have been received by GUI */
    state = GUI_SendAnswer(&msg, &size);
   13616:	2515      	movs	r5, #21
   13618:	197c      	adds	r4, r7, r5
   1361a:	230f      	movs	r3, #15
   1361c:	18fa      	adds	r2, r7, r3
   1361e:	2310      	movs	r3, #16
   13620:	18fb      	adds	r3, r7, r3
   13622:	0011      	movs	r1, r2
   13624:	0018      	movs	r0, r3
   13626:	f000 f969 	bl	138fc <GUI_SendAnswer>
   1362a:	0003      	movs	r3, r0
   1362c:	7023      	strb	r3, [r4, #0]

    switch (state)
   1362e:	197b      	adds	r3, r7, r5
   13630:	781b      	ldrb	r3, [r3, #0]
   13632:	2b00      	cmp	r3, #0
   13634:	d039      	beq.n	136aa <GUI_RXProcess+0xa6>
   13636:	2b02      	cmp	r3, #2
   13638:	d104      	bne.n	13644 <GUI_RXProcess+0x40>
    {
    case GUI_STATE_RESET:
      /* DPM_RESET_REQ received by the device */
      /* Save parameters in FLASH */
      BSP_GUI_SaveDataInFlash();
   1363a:	f7ff f8e7 	bl	1280c <BSP_GUI_SaveDataInFlash>
      HAL_NVIC_SystemReset();
   1363e:	f7fb f8ca 	bl	e7d6 <HAL_NVIC_SystemReset>
      break;
   13642:	e033      	b.n	136ac <GUI_RXProcess+0xa8>
    case GUI_STATE_INIT:
      /* DPM_INIT_REQ received by the device */
      break;
    default:
      /* Another GUI messages received by the device */
      TRACER_EMB_Add(msg, size);
   13644:	693a      	ldr	r2, [r7, #16]
   13646:	230f      	movs	r3, #15
   13648:	18fb      	adds	r3, r7, r3
   1364a:	781b      	ldrb	r3, [r3, #0]
   1364c:	0019      	movs	r1, r3
   1364e:	0010      	movs	r0, r2
   13650:	f003 fbd2 	bl	16df8 <TRACER_EMB_Add>
      break;
   13654:	46c0      	nop			; (mov r8, r8)
   13656:	e029      	b.n	136ac <GUI_RXProcess+0xa8>
    }
  }
  else
  {
    uint16_t type_event = (Event & GUI_PE_NOTIF_Msk) >> GUI_PE_NOTIF_Pos;
   13658:	687b      	ldr	r3, [r7, #4]
   1365a:	091b      	lsrs	r3, r3, #4
   1365c:	b29a      	uxth	r2, r3
   1365e:	2016      	movs	r0, #22
   13660:	183b      	adds	r3, r7, r0
   13662:	21ff      	movs	r1, #255	; 0xff
   13664:	400a      	ands	r2, r1
   13666:	801a      	strh	r2, [r3, #0]
    if (GUI_NOTIF_MEASUREMENT == type_event)
   13668:	183b      	adds	r3, r7, r0
   1366a:	881b      	ldrh	r3, [r3, #0]
   1366c:	2b64      	cmp	r3, #100	; 0x64
   1366e:	d10e      	bne.n	1368e <GUI_RXProcess+0x8a>
    {
      /* Notification related to timeout for measure reporting */
      /* Send a notification to associated port */
      GUI_FormatAndSendNotification(((Event & GUI_PE_PORT_NUM_Msk) >> GUI_PE_PORT_NUM_Pos), GUI_NOTIF_MEASUREREPORTING, HAL_GetTick());
   13670:	687b      	ldr	r3, [r7, #4]
   13672:	0e1b      	lsrs	r3, r3, #24
   13674:	2203      	movs	r2, #3
   13676:	4013      	ands	r3, r2
   13678:	001c      	movs	r4, r3
   1367a:	f7fa ffa3 	bl	e5c4 <HAL_GetTick>
   1367e:	0002      	movs	r2, r0
   13680:	2380      	movs	r3, #128	; 0x80
   13682:	011b      	lsls	r3, r3, #4
   13684:	0019      	movs	r1, r3
   13686:	0020      	movs	r0, r4
   13688:	f000 f815 	bl	136b6 <GUI_FormatAndSendNotification>
   1368c:	e00e      	b.n	136ac <GUI_RXProcess+0xa8>
    }
    else
    {
      /* Message have been received by PE */
      /* Send a notification to associated port */
      GUI_FormatAndSendNotification(((Event & GUI_PE_PORT_NUM_Msk) >> GUI_PE_PORT_NUM_Pos), GUI_NOTIF_PE_EVENT, type_event);
   1368e:	687b      	ldr	r3, [r7, #4]
   13690:	0e1b      	lsrs	r3, r3, #24
   13692:	2203      	movs	r2, #3
   13694:	4013      	ands	r3, r2
   13696:	0018      	movs	r0, r3
   13698:	2316      	movs	r3, #22
   1369a:	18fb      	adds	r3, r7, r3
   1369c:	881a      	ldrh	r2, [r3, #0]
   1369e:	2380      	movs	r3, #128	; 0x80
   136a0:	019b      	lsls	r3, r3, #6
   136a2:	0019      	movs	r1, r3
   136a4:	f000 f807 	bl	136b6 <GUI_FormatAndSendNotification>
   136a8:	e000      	b.n	136ac <GUI_RXProcess+0xa8>
      break;
   136aa:	46c0      	nop			; (mov r8, r8)
    }
  }

  return 0;
   136ac:	2300      	movs	r3, #0
}
   136ae:	0018      	movs	r0, r3
   136b0:	46bd      	mov	sp, r7
   136b2:	b006      	add	sp, #24
   136b4:	bdb0      	pop	{r4, r5, r7, pc}

000136b6 <GUI_FormatAndSendNotification>:
  * @param  Value             Value depending of TypeNotification
  * @note   If TypeNotification == GUI_NOTIF_ISCONNECTED, Value should be equal to 0 (Not connected) or 1 (connected)
  * @retval USBPD Status
  */
uint32_t GUI_FormatAndSendNotification(uint32_t PortNum, uint32_t TypeNotification, uint32_t Value)
{
   136b6:	b590      	push	{r4, r7, lr}
   136b8:	b089      	sub	sp, #36	; 0x24
   136ba:	af02      	add	r7, sp, #8
   136bc:	60f8      	str	r0, [r7, #12]
   136be:	60b9      	str	r1, [r7, #8]
   136c0:	607a      	str	r2, [r7, #4]
  uint8_t *msg;
  uint8_t size;
  /* Only send notification if GUI is connected */
  if (GUI_STATE_INIT != GUI_SendNotification(PortNum, &msg, &size, TypeNotification, Value))
   136c2:	68fb      	ldr	r3, [r7, #12]
   136c4:	b2d8      	uxtb	r0, r3
   136c6:	68bc      	ldr	r4, [r7, #8]
   136c8:	2313      	movs	r3, #19
   136ca:	18fa      	adds	r2, r7, r3
   136cc:	2314      	movs	r3, #20
   136ce:	18f9      	adds	r1, r7, r3
   136d0:	687b      	ldr	r3, [r7, #4]
   136d2:	9300      	str	r3, [sp, #0]
   136d4:	0023      	movs	r3, r4
   136d6:	f000 fa07 	bl	13ae8 <GUI_SendNotification>
   136da:	1e03      	subs	r3, r0, #0
   136dc:	d007      	beq.n	136ee <GUI_FormatAndSendNotification+0x38>
  {
    TRACER_EMB_Add(msg, size);
   136de:	697a      	ldr	r2, [r7, #20]
   136e0:	2313      	movs	r3, #19
   136e2:	18fb      	adds	r3, r7, r3
   136e4:	781b      	ldrb	r3, [r3, #0]
   136e6:	0019      	movs	r1, r3
   136e8:	0010      	movs	r0, r2
   136ea:	f003 fb85 	bl	16df8 <TRACER_EMB_Add>
  }
  return 0;
   136ee:	2300      	movs	r3, #0
}
   136f0:	0018      	movs	r0, r3
   136f2:	46bd      	mov	sp, r7
   136f4:	b007      	add	sp, #28
   136f6:	bd90      	pop	{r4, r7, pc}

000136f8 <GUI_GetMessage>:
  * @param  Character Received byte
  * @param  Error     Error if issue during reception
  * @retval 1 indicates that a complete GUI message have been received
  */
uint32_t GUI_GetMessage(uint8_t Character, uint8_t Error)
{
   136f8:	b580      	push	{r7, lr}
   136fa:	b084      	sub	sp, #16
   136fc:	af00      	add	r7, sp, #0
   136fe:	0002      	movs	r2, r0
   13700:	1dfb      	adds	r3, r7, #7
   13702:	701a      	strb	r2, [r3, #0]
   13704:	1dbb      	adds	r3, r7, #6
   13706:	1c0a      	adds	r2, r1, #0
   13708:	701a      	strb	r2, [r3, #0]
  uint32_t status = 0;
   1370a:	2300      	movs	r3, #0
   1370c:	60fb      	str	r3, [r7, #12]
    Rsize,
    Rend,
    Rerror
  } Rstate = Rstart;

  if(cursor < TLV_SIZE_MAX)
   1370e:	4b75      	ldr	r3, [pc, #468]	; (138e4 <GUI_GetMessage+0x1ec>)
   13710:	881b      	ldrh	r3, [r3, #0]
   13712:	2bff      	cmp	r3, #255	; 0xff
   13714:	d80b      	bhi.n	1372e <GUI_GetMessage+0x36>
  {
    PtrDataRx[cursor] = Character;
   13716:	4b73      	ldr	r3, [pc, #460]	; (138e4 <GUI_GetMessage+0x1ec>)
   13718:	881b      	ldrh	r3, [r3, #0]
   1371a:	0019      	movs	r1, r3
   1371c:	4b72      	ldr	r3, [pc, #456]	; (138e8 <GUI_GetMessage+0x1f0>)
   1371e:	1dfa      	adds	r2, r7, #7
   13720:	7812      	ldrb	r2, [r2, #0]
   13722:	545a      	strb	r2, [r3, r1]
    counter = 0;
    Rstate = Rstart;
    return 0;
  }

  if(Error) Rstate = Rerror;
   13724:	1dbb      	adds	r3, r7, #6
   13726:	781b      	ldrb	r3, [r3, #0]
   13728:	2b00      	cmp	r3, #0
   1372a:	d00e      	beq.n	1374a <GUI_GetMessage+0x52>
   1372c:	e00a      	b.n	13744 <GUI_GetMessage+0x4c>
    cursor = 0;
   1372e:	4b6d      	ldr	r3, [pc, #436]	; (138e4 <GUI_GetMessage+0x1ec>)
   13730:	2200      	movs	r2, #0
   13732:	801a      	strh	r2, [r3, #0]
    counter = 0;
   13734:	4b6d      	ldr	r3, [pc, #436]	; (138ec <GUI_GetMessage+0x1f4>)
   13736:	2200      	movs	r2, #0
   13738:	801a      	strh	r2, [r3, #0]
    Rstate = Rstart;
   1373a:	4b6d      	ldr	r3, [pc, #436]	; (138f0 <GUI_GetMessage+0x1f8>)
   1373c:	2200      	movs	r2, #0
   1373e:	701a      	strb	r2, [r3, #0]
    return 0;
   13740:	2300      	movs	r3, #0
   13742:	e0ca      	b.n	138da <GUI_GetMessage+0x1e2>
  if(Error) Rstate = Rerror;
   13744:	4b6a      	ldr	r3, [pc, #424]	; (138f0 <GUI_GetMessage+0x1f8>)
   13746:	2204      	movs	r2, #4
   13748:	701a      	strb	r2, [r3, #0]

  switch(Rstate)
   1374a:	4b69      	ldr	r3, [pc, #420]	; (138f0 <GUI_GetMessage+0x1f8>)
   1374c:	781b      	ldrb	r3, [r3, #0]
   1374e:	2b04      	cmp	r3, #4
   13750:	d900      	bls.n	13754 <GUI_GetMessage+0x5c>
   13752:	e0bb      	b.n	138cc <GUI_GetMessage+0x1d4>
   13754:	009a      	lsls	r2, r3, #2
   13756:	4b67      	ldr	r3, [pc, #412]	; (138f4 <GUI_GetMessage+0x1fc>)
   13758:	18d3      	adds	r3, r2, r3
   1375a:	681b      	ldr	r3, [r3, #0]
   1375c:	469f      	mov	pc, r3
  {
  case Rstart :
    if(PtrDataRx[cursor] == TLV_SOF)
   1375e:	4b61      	ldr	r3, [pc, #388]	; (138e4 <GUI_GetMessage+0x1ec>)
   13760:	881b      	ldrh	r3, [r3, #0]
   13762:	001a      	movs	r2, r3
   13764:	4b60      	ldr	r3, [pc, #384]	; (138e8 <GUI_GetMessage+0x1f0>)
   13766:	5c9b      	ldrb	r3, [r3, r2]
   13768:	2bfd      	cmp	r3, #253	; 0xfd
   1376a:	d106      	bne.n	1377a <GUI_GetMessage+0x82>
    {
      counter++;
   1376c:	4b5f      	ldr	r3, [pc, #380]	; (138ec <GUI_GetMessage+0x1f4>)
   1376e:	881b      	ldrh	r3, [r3, #0]
   13770:	3301      	adds	r3, #1
   13772:	b29a      	uxth	r2, r3
   13774:	4b5d      	ldr	r3, [pc, #372]	; (138ec <GUI_GetMessage+0x1f4>)
   13776:	801a      	strh	r2, [r3, #0]
   13778:	e006      	b.n	13788 <GUI_GetMessage+0x90>
    }
    else
    {
      counter = 0;
   1377a:	4b5c      	ldr	r3, [pc, #368]	; (138ec <GUI_GetMessage+0x1f4>)
   1377c:	2200      	movs	r2, #0
   1377e:	801a      	strh	r2, [r3, #0]
      cursor = 0xFFFF; /* cursor is unsigned, but it will inevitably increments at the end of function, and we need a 0 at the next pass here */
   13780:	4b58      	ldr	r3, [pc, #352]	; (138e4 <GUI_GetMessage+0x1ec>)
   13782:	2201      	movs	r2, #1
   13784:	4252      	negs	r2, r2
   13786:	801a      	strh	r2, [r3, #0]
    }

    if(counter == 4) /* The whole SOF is received */
   13788:	4b58      	ldr	r3, [pc, #352]	; (138ec <GUI_GetMessage+0x1f4>)
   1378a:	881b      	ldrh	r3, [r3, #0]
   1378c:	2b04      	cmp	r3, #4
   1378e:	d000      	beq.n	13792 <GUI_GetMessage+0x9a>
   13790:	e095      	b.n	138be <GUI_GetMessage+0x1c6>
    {
      counter = 0;
   13792:	4b56      	ldr	r3, [pc, #344]	; (138ec <GUI_GetMessage+0x1f4>)
   13794:	2200      	movs	r2, #0
   13796:	801a      	strh	r2, [r3, #0]
      Rstate = Rsize;
   13798:	4b55      	ldr	r3, [pc, #340]	; (138f0 <GUI_GetMessage+0x1f8>)
   1379a:	2202      	movs	r2, #2
   1379c:	701a      	strb	r2, [r3, #0]
    }
    break;
   1379e:	e08e      	b.n	138be <GUI_GetMessage+0x1c6>
  case Rsize :
    counter++;
   137a0:	4b52      	ldr	r3, [pc, #328]	; (138ec <GUI_GetMessage+0x1f4>)
   137a2:	881b      	ldrh	r3, [r3, #0]
   137a4:	3301      	adds	r3, #1
   137a6:	b29a      	uxth	r2, r3
   137a8:	4b50      	ldr	r3, [pc, #320]	; (138ec <GUI_GetMessage+0x1f4>)
   137aa:	801a      	strh	r2, [r3, #0]

    if(counter == 3) /* We have received the size */
   137ac:	4b4f      	ldr	r3, [pc, #316]	; (138ec <GUI_GetMessage+0x1f4>)
   137ae:	881b      	ldrh	r3, [r3, #0]
   137b0:	2b03      	cmp	r3, #3
   137b2:	d000      	beq.n	137b6 <GUI_GetMessage+0xbe>
   137b4:	e085      	b.n	138c2 <GUI_GetMessage+0x1ca>
    {
      currentSize = (PtrDataRx[cursor-1] << 8) + PtrDataRx[cursor];
   137b6:	4b4b      	ldr	r3, [pc, #300]	; (138e4 <GUI_GetMessage+0x1ec>)
   137b8:	881b      	ldrh	r3, [r3, #0]
   137ba:	3b01      	subs	r3, #1
   137bc:	4a4a      	ldr	r2, [pc, #296]	; (138e8 <GUI_GetMessage+0x1f0>)
   137be:	5cd3      	ldrb	r3, [r2, r3]
   137c0:	b29b      	uxth	r3, r3
   137c2:	021b      	lsls	r3, r3, #8
   137c4:	b29a      	uxth	r2, r3
   137c6:	4b47      	ldr	r3, [pc, #284]	; (138e4 <GUI_GetMessage+0x1ec>)
   137c8:	881b      	ldrh	r3, [r3, #0]
   137ca:	0019      	movs	r1, r3
   137cc:	4b46      	ldr	r3, [pc, #280]	; (138e8 <GUI_GetMessage+0x1f0>)
   137ce:	5c5b      	ldrb	r3, [r3, r1]
   137d0:	b29b      	uxth	r3, r3
   137d2:	18d3      	adds	r3, r2, r3
   137d4:	b29a      	uxth	r2, r3
   137d6:	4b48      	ldr	r3, [pc, #288]	; (138f8 <GUI_GetMessage+0x200>)
   137d8:	801a      	strh	r2, [r3, #0]
      if (0 == currentSize)
   137da:	4b47      	ldr	r3, [pc, #284]	; (138f8 <GUI_GetMessage+0x200>)
   137dc:	881b      	ldrh	r3, [r3, #0]
   137de:	2b00      	cmp	r3, #0
   137e0:	d103      	bne.n	137ea <GUI_GetMessage+0xf2>
      {
        Rstate = Rend;
   137e2:	4b43      	ldr	r3, [pc, #268]	; (138f0 <GUI_GetMessage+0x1f8>)
   137e4:	2203      	movs	r2, #3
   137e6:	701a      	strb	r2, [r3, #0]
   137e8:	e002      	b.n	137f0 <GUI_GetMessage+0xf8>
      }
      else
      {
        Rstate = RonGoing;
   137ea:	4b41      	ldr	r3, [pc, #260]	; (138f0 <GUI_GetMessage+0x1f8>)
   137ec:	2201      	movs	r2, #1
   137ee:	701a      	strb	r2, [r3, #0]
      }
      counter = 0;
   137f0:	4b3e      	ldr	r3, [pc, #248]	; (138ec <GUI_GetMessage+0x1f4>)
   137f2:	2200      	movs	r2, #0
   137f4:	801a      	strh	r2, [r3, #0]
    }
    break;
   137f6:	e064      	b.n	138c2 <GUI_GetMessage+0x1ca>
  case RonGoing :
    counter++;
   137f8:	4b3c      	ldr	r3, [pc, #240]	; (138ec <GUI_GetMessage+0x1f4>)
   137fa:	881b      	ldrh	r3, [r3, #0]
   137fc:	3301      	adds	r3, #1
   137fe:	b29a      	uxth	r2, r3
   13800:	4b3a      	ldr	r3, [pc, #232]	; (138ec <GUI_GetMessage+0x1f4>)
   13802:	801a      	strh	r2, [r3, #0]

    if(counter == currentSize)
   13804:	4b39      	ldr	r3, [pc, #228]	; (138ec <GUI_GetMessage+0x1f4>)
   13806:	881a      	ldrh	r2, [r3, #0]
   13808:	4b3b      	ldr	r3, [pc, #236]	; (138f8 <GUI_GetMessage+0x200>)
   1380a:	881b      	ldrh	r3, [r3, #0]
   1380c:	429a      	cmp	r2, r3
   1380e:	d15a      	bne.n	138c6 <GUI_GetMessage+0x1ce>
    {
      /* When there is no value, the first EOF is handled by Rongoing, before Rend takes control */
      counter = 0;
   13810:	4b36      	ldr	r3, [pc, #216]	; (138ec <GUI_GetMessage+0x1f4>)
   13812:	2200      	movs	r2, #0
   13814:	801a      	strh	r2, [r3, #0]
      Rstate = Rend;
   13816:	4b36      	ldr	r3, [pc, #216]	; (138f0 <GUI_GetMessage+0x1f8>)
   13818:	2203      	movs	r2, #3
   1381a:	701a      	strb	r2, [r3, #0]
    }
    break;
   1381c:	e053      	b.n	138c6 <GUI_GetMessage+0x1ce>
  case Rend :
    counter++;
   1381e:	4b33      	ldr	r3, [pc, #204]	; (138ec <GUI_GetMessage+0x1f4>)
   13820:	881b      	ldrh	r3, [r3, #0]
   13822:	3301      	adds	r3, #1
   13824:	b29a      	uxth	r2, r3
   13826:	4b31      	ldr	r3, [pc, #196]	; (138ec <GUI_GetMessage+0x1f4>)
   13828:	801a      	strh	r2, [r3, #0]
    if(PtrDataRx[cursor] == TLV_EOF
   1382a:	4b2e      	ldr	r3, [pc, #184]	; (138e4 <GUI_GetMessage+0x1ec>)
   1382c:	881b      	ldrh	r3, [r3, #0]
   1382e:	001a      	movs	r2, r3
   13830:	4b2d      	ldr	r3, [pc, #180]	; (138e8 <GUI_GetMessage+0x1f0>)
   13832:	5c9b      	ldrb	r3, [r3, r2]
   13834:	2ba5      	cmp	r3, #165	; 0xa5
   13836:	d124      	bne.n	13882 <GUI_GetMessage+0x18a>
       && PtrDataRx[cursor-1] == TLV_EOF
   13838:	4b2a      	ldr	r3, [pc, #168]	; (138e4 <GUI_GetMessage+0x1ec>)
   1383a:	881b      	ldrh	r3, [r3, #0]
   1383c:	3b01      	subs	r3, #1
   1383e:	4a2a      	ldr	r2, [pc, #168]	; (138e8 <GUI_GetMessage+0x1f0>)
   13840:	5cd3      	ldrb	r3, [r2, r3]
   13842:	2ba5      	cmp	r3, #165	; 0xa5
   13844:	d11d      	bne.n	13882 <GUI_GetMessage+0x18a>
         && PtrDataRx[cursor-2] == TLV_EOF
   13846:	4b27      	ldr	r3, [pc, #156]	; (138e4 <GUI_GetMessage+0x1ec>)
   13848:	881b      	ldrh	r3, [r3, #0]
   1384a:	3b02      	subs	r3, #2
   1384c:	4a26      	ldr	r2, [pc, #152]	; (138e8 <GUI_GetMessage+0x1f0>)
   1384e:	5cd3      	ldrb	r3, [r2, r3]
   13850:	2ba5      	cmp	r3, #165	; 0xa5
   13852:	d116      	bne.n	13882 <GUI_GetMessage+0x18a>
           && PtrDataRx[cursor-3] == TLV_EOF)
   13854:	4b23      	ldr	r3, [pc, #140]	; (138e4 <GUI_GetMessage+0x1ec>)
   13856:	881b      	ldrh	r3, [r3, #0]
   13858:	3b03      	subs	r3, #3
   1385a:	4a23      	ldr	r2, [pc, #140]	; (138e8 <GUI_GetMessage+0x1f0>)
   1385c:	5cd3      	ldrb	r3, [r2, r3]
   1385e:	2ba5      	cmp	r3, #165	; 0xa5
   13860:	d10f      	bne.n	13882 <GUI_GetMessage+0x18a>
    {
      /* The semaphore must be given only in this case, because otherwise it means we didn't receive the correct size of bytes */
      if(counter == 4)
   13862:	4b22      	ldr	r3, [pc, #136]	; (138ec <GUI_GetMessage+0x1f4>)
   13864:	881b      	ldrh	r3, [r3, #0]
   13866:	2b04      	cmp	r3, #4
   13868:	d101      	bne.n	1386e <GUI_GetMessage+0x176>
      {
        status = 1;
   1386a:	2301      	movs	r3, #1
   1386c:	60fb      	str	r3, [r7, #12]
      }
      counter = 0;
   1386e:	4b1f      	ldr	r3, [pc, #124]	; (138ec <GUI_GetMessage+0x1f4>)
   13870:	2200      	movs	r2, #0
   13872:	801a      	strh	r2, [r3, #0]
      cursor = 0xFFFF;
   13874:	4b1b      	ldr	r3, [pc, #108]	; (138e4 <GUI_GetMessage+0x1ec>)
   13876:	2201      	movs	r2, #1
   13878:	4252      	negs	r2, r2
   1387a:	801a      	strh	r2, [r3, #0]
      Rstate = Rstart;
   1387c:	4b1c      	ldr	r3, [pc, #112]	; (138f0 <GUI_GetMessage+0x1f8>)
   1387e:	2200      	movs	r2, #0
   13880:	701a      	strb	r2, [r3, #0]
    }

    if(cursor == currentSize + 11)
   13882:	4b18      	ldr	r3, [pc, #96]	; (138e4 <GUI_GetMessage+0x1ec>)
   13884:	881b      	ldrh	r3, [r3, #0]
   13886:	001a      	movs	r2, r3
   13888:	4b1b      	ldr	r3, [pc, #108]	; (138f8 <GUI_GetMessage+0x200>)
   1388a:	881b      	ldrh	r3, [r3, #0]
   1388c:	330b      	adds	r3, #11
   1388e:	429a      	cmp	r2, r3
   13890:	d11b      	bne.n	138ca <GUI_GetMessage+0x1d2>
    {
      /* No complete EOF arrived. We reset the buffer for safety even if the instruction might be complete. */
      counter = 0;
   13892:	4b16      	ldr	r3, [pc, #88]	; (138ec <GUI_GetMessage+0x1f4>)
   13894:	2200      	movs	r2, #0
   13896:	801a      	strh	r2, [r3, #0]
      cursor = 0xFFFF;
   13898:	4b12      	ldr	r3, [pc, #72]	; (138e4 <GUI_GetMessage+0x1ec>)
   1389a:	2201      	movs	r2, #1
   1389c:	4252      	negs	r2, r2
   1389e:	801a      	strh	r2, [r3, #0]
      Rstate = Rstart;
   138a0:	4b13      	ldr	r3, [pc, #76]	; (138f0 <GUI_GetMessage+0x1f8>)
   138a2:	2200      	movs	r2, #0
   138a4:	701a      	strb	r2, [r3, #0]
    }
    break;
   138a6:	e010      	b.n	138ca <GUI_GetMessage+0x1d2>
  case Rerror :
    counter = 0;
   138a8:	4b10      	ldr	r3, [pc, #64]	; (138ec <GUI_GetMessage+0x1f4>)
   138aa:	2200      	movs	r2, #0
   138ac:	801a      	strh	r2, [r3, #0]
    cursor = 0xFFFF;
   138ae:	4b0d      	ldr	r3, [pc, #52]	; (138e4 <GUI_GetMessage+0x1ec>)
   138b0:	2201      	movs	r2, #1
   138b2:	4252      	negs	r2, r2
   138b4:	801a      	strh	r2, [r3, #0]
    Rstate = Rstart;
   138b6:	4b0e      	ldr	r3, [pc, #56]	; (138f0 <GUI_GetMessage+0x1f8>)
   138b8:	2200      	movs	r2, #0
   138ba:	701a      	strb	r2, [r3, #0]
    break;
   138bc:	e006      	b.n	138cc <GUI_GetMessage+0x1d4>
    break;
   138be:	46c0      	nop			; (mov r8, r8)
   138c0:	e004      	b.n	138cc <GUI_GetMessage+0x1d4>
    break;
   138c2:	46c0      	nop			; (mov r8, r8)
   138c4:	e002      	b.n	138cc <GUI_GetMessage+0x1d4>
    break;
   138c6:	46c0      	nop			; (mov r8, r8)
   138c8:	e000      	b.n	138cc <GUI_GetMessage+0x1d4>
    break;
   138ca:	46c0      	nop			; (mov r8, r8)
  }

  cursor++;
   138cc:	4b05      	ldr	r3, [pc, #20]	; (138e4 <GUI_GetMessage+0x1ec>)
   138ce:	881b      	ldrh	r3, [r3, #0]
   138d0:	3301      	adds	r3, #1
   138d2:	b29a      	uxth	r2, r3
   138d4:	4b03      	ldr	r3, [pc, #12]	; (138e4 <GUI_GetMessage+0x1ec>)
   138d6:	801a      	strh	r2, [r3, #0]
  return status;
   138d8:	68fb      	ldr	r3, [r7, #12]
}
   138da:	0018      	movs	r0, r3
   138dc:	46bd      	mov	sp, r7
   138de:	b004      	add	sp, #16
   138e0:	bd80      	pop	{r7, pc}
   138e2:	46c0      	nop			; (mov r8, r8)
   138e4:	00031cd0 	.word	0x00031cd0
   138e8:	000322e8 	.word	0x000322e8
   138ec:	00031cd2 	.word	0x00031cd2
   138f0:	00031cd4 	.word	0x00031cd4
   138f4:	0001f6a4 	.word	0x0001f6a4
   138f8:	00031cd6 	.word	0x00031cd6

000138fc <GUI_SendAnswer>:
  * @param  pMsgToSend Pointer on the message to send
  * @param  pSizeMsg   Pointer on the size of the message to send
  * @retval GUI state
  */
USBPD_GUI_State GUI_SendAnswer(uint8_t **pMsgToSend, uint8_t *pSizeMsg)
{
   138fc:	b590      	push	{r4, r7, lr}
   138fe:	b085      	sub	sp, #20
   13900:	af00      	add	r7, sp, #0
   13902:	6078      	str	r0, [r7, #4]
   13904:	6039      	str	r1, [r7, #0]
  /* Extract the port from the tag*/
  uint8_t port = PtrDataRx[TLV_TAG_POSITION] >> GUI_PORT_BIT_POSITION;
   13906:	4b73      	ldr	r3, [pc, #460]	; (13ad4 <GUI_SendAnswer+0x1d8>)
   13908:	791a      	ldrb	r2, [r3, #4]
   1390a:	230f      	movs	r3, #15
   1390c:	18fb      	adds	r3, r7, r3
   1390e:	0952      	lsrs	r2, r2, #5
   13910:	701a      	strb	r2, [r3, #0]

  /* Do the appropriate treatment in response to what we have received */
  switch(PtrDataRx[TLV_TAG_POSITION] & 0x1F)
   13912:	4b70      	ldr	r3, [pc, #448]	; (13ad4 <GUI_SendAnswer+0x1d8>)
   13914:	791b      	ldrb	r3, [r3, #4]
   13916:	001a      	movs	r2, r3
   13918:	231f      	movs	r3, #31
   1391a:	4013      	ands	r3, r2
   1391c:	2b10      	cmp	r3, #16
   1391e:	d900      	bls.n	13922 <GUI_SendAnswer+0x26>
   13920:	e0c3      	b.n	13aaa <GUI_SendAnswer+0x1ae>
   13922:	009a      	lsls	r2, r3, #2
   13924:	4b6c      	ldr	r3, [pc, #432]	; (13ad8 <GUI_SendAnswer+0x1dc>)
   13926:	18d3      	adds	r3, r2, r3
   13928:	681b      	ldr	r3, [r3, #0]
   1392a:	469f      	mov	pc, r3
  {
  case DPM_RESET_REQ:
    /* Reset*/
    return GUI_STATE_RESET;
   1392c:	2302      	movs	r3, #2
   1392e:	e0cc      	b.n	13aca <GUI_SendAnswer+0x1ce>

  case DPM_INIT_REQ:
    {
      Send_DpmInitCnf(port, Processed);
   13930:	4a6a      	ldr	r2, [pc, #424]	; (13adc <GUI_SendAnswer+0x1e0>)
   13932:	240f      	movs	r4, #15
   13934:	193b      	adds	r3, r7, r4
   13936:	781b      	ldrb	r3, [r3, #0]
   13938:	0011      	movs	r1, r2
   1393a:	0018      	movs	r0, r3
   1393c:	f000 feb2 	bl	146a4 <Send_DpmInitCnf>
      *pMsgToSend = Processed;
   13940:	687b      	ldr	r3, [r7, #4]
   13942:	4a66      	ldr	r2, [pc, #408]	; (13adc <GUI_SendAnswer+0x1e0>)
   13944:	601a      	str	r2, [r3, #0]
      *pSizeMsg = TLV_get_string_length(Processed) + 8;
   13946:	4b65      	ldr	r3, [pc, #404]	; (13adc <GUI_SendAnswer+0x1e0>)
   13948:	0018      	movs	r0, r3
   1394a:	f7ff fc37 	bl	131bc <TLV_get_string_length>
   1394e:	0003      	movs	r3, r0
   13950:	b2db      	uxtb	r3, r3
   13952:	3308      	adds	r3, #8
   13954:	b2da      	uxtb	r2, r3
   13956:	683b      	ldr	r3, [r7, #0]
   13958:	701a      	strb	r2, [r3, #0]
      TRACER_EMB_Add(*pMsgToSend, *pSizeMsg);
   1395a:	687b      	ldr	r3, [r7, #4]
   1395c:	681a      	ldr	r2, [r3, #0]
   1395e:	683b      	ldr	r3, [r7, #0]
   13960:	781b      	ldrb	r3, [r3, #0]
   13962:	0019      	movs	r1, r3
   13964:	0010      	movs	r0, r2
   13966:	f003 fa47 	bl	16df8 <TRACER_EMB_Add>
      GUI_State = GUI_STATE_RUNNING;
   1396a:	4b5d      	ldr	r3, [pc, #372]	; (13ae0 <GUI_SendAnswer+0x1e4>)
   1396c:	2201      	movs	r2, #1
   1396e:	701a      	strb	r2, [r3, #0]
      if (0 == port)
   13970:	193b      	adds	r3, r7, r4
   13972:	781b      	ldrb	r3, [r3, #0]
   13974:	2b00      	cmp	r3, #0
   13976:	d105      	bne.n	13984 <GUI_SendAnswer+0x88>
      {
        /* Send a notification all the port */
        GUI_FormatAndSendNotification(USBPD_PORT_0, GUI_NOTIF_ISCONNECTED | GUI_NOTIF_PE_EVENT | GUI_NOTIF_TIMESTAMP, USBPD_NOTIFY_ALL);
   13978:	4b5a      	ldr	r3, [pc, #360]	; (13ae4 <GUI_SendAnswer+0x1e8>)
   1397a:	2263      	movs	r2, #99	; 0x63
   1397c:	0019      	movs	r1, r3
   1397e:	2000      	movs	r0, #0
   13980:	f7ff fe99 	bl	136b6 <GUI_FormatAndSendNotification>
#if USBPD_PORT_COUNT==2
        GUI_FormatAndSendNotification(USBPD_PORT_1, GUI_NOTIF_ISCONNECTED | GUI_NOTIF_PE_EVENT | GUI_NOTIF_TIMESTAMP, USBPD_NOTIFY_ALL);
#endif /* USBPD_PORT_COUNT == 2 */
      }
      return GUI_STATE_INIT;
   13984:	2300      	movs	r3, #0
   13986:	e0a0      	b.n	13aca <GUI_SendAnswer+0x1ce>
    }

  case DPM_CONFIG_GET_REQ:
    if (0 != port)
   13988:	230f      	movs	r3, #15
   1398a:	18fb      	adds	r3, r7, r3
   1398c:	781b      	ldrb	r3, [r3, #0]
   1398e:	2b00      	cmp	r3, #0
   13990:	d00a      	beq.n	139a8 <GUI_SendAnswer+0xac>
    {
      Send_DpmConfigGetCnf((port - 1), PtrDataRx, Processed);
   13992:	230f      	movs	r3, #15
   13994:	18fb      	adds	r3, r7, r3
   13996:	781b      	ldrb	r3, [r3, #0]
   13998:	3b01      	subs	r3, #1
   1399a:	b2db      	uxtb	r3, r3
   1399c:	4a4f      	ldr	r2, [pc, #316]	; (13adc <GUI_SendAnswer+0x1e0>)
   1399e:	494d      	ldr	r1, [pc, #308]	; (13ad4 <GUI_SendAnswer+0x1d8>)
   139a0:	0018      	movs	r0, r3
   139a2:	f002 fc79 	bl	16298 <Send_DpmConfigGetCnf>
    }
    else
    {
      Send_DpmConfigGetRej(port, Processed, GUI_REJ_DPM_INVALID_PORT_NUMBER);
    }
    break;
   139a6:	e081      	b.n	13aac <GUI_SendAnswer+0x1b0>
      Send_DpmConfigGetRej(port, Processed, GUI_REJ_DPM_INVALID_PORT_NUMBER);
   139a8:	494c      	ldr	r1, [pc, #304]	; (13adc <GUI_SendAnswer+0x1e0>)
   139aa:	230f      	movs	r3, #15
   139ac:	18fb      	adds	r3, r7, r3
   139ae:	781b      	ldrb	r3, [r3, #0]
   139b0:	2205      	movs	r2, #5
   139b2:	0018      	movs	r0, r3
   139b4:	f002 ffca 	bl	1694c <Send_DpmConfigGetRej>
    break;
   139b8:	e078      	b.n	13aac <GUI_SendAnswer+0x1b0>
  case DPM_CONFIG_SET_REQ:
    if (0 != port)
   139ba:	230f      	movs	r3, #15
   139bc:	18fb      	adds	r3, r7, r3
   139be:	781b      	ldrb	r3, [r3, #0]
   139c0:	2b00      	cmp	r3, #0
   139c2:	d00a      	beq.n	139da <GUI_SendAnswer+0xde>
    {
      Send_DpmConfigSetCnf((port - 1), PtrDataRx, Processed);
   139c4:	230f      	movs	r3, #15
   139c6:	18fb      	adds	r3, r7, r3
   139c8:	781b      	ldrb	r3, [r3, #0]
   139ca:	3b01      	subs	r3, #1
   139cc:	b2db      	uxtb	r3, r3
   139ce:	4a43      	ldr	r2, [pc, #268]	; (13adc <GUI_SendAnswer+0x1e0>)
   139d0:	4940      	ldr	r1, [pc, #256]	; (13ad4 <GUI_SendAnswer+0x1d8>)
   139d2:	0018      	movs	r0, r3
   139d4:	f001 fd54 	bl	15480 <Send_DpmConfigSetCnf>
    }
    else
    {
      Send_DpmConfigGetRej(port, Processed, GUI_REJ_DPM_INVALID_PORT_NUMBER);
    }
    break;
   139d8:	e068      	b.n	13aac <GUI_SendAnswer+0x1b0>
      Send_DpmConfigGetRej(port, Processed, GUI_REJ_DPM_INVALID_PORT_NUMBER);
   139da:	4940      	ldr	r1, [pc, #256]	; (13adc <GUI_SendAnswer+0x1e0>)
   139dc:	230f      	movs	r3, #15
   139de:	18fb      	adds	r3, r7, r3
   139e0:	781b      	ldrb	r3, [r3, #0]
   139e2:	2205      	movs	r2, #5
   139e4:	0018      	movs	r0, r3
   139e6:	f002 ffb1 	bl	1694c <Send_DpmConfigGetRej>
    break;
   139ea:	e05f      	b.n	13aac <GUI_SendAnswer+0x1b0>
  case DPM_MESSAGE_REQ:
    if (0 != port)
   139ec:	230f      	movs	r3, #15
   139ee:	18fb      	adds	r3, r7, r3
   139f0:	781b      	ldrb	r3, [r3, #0]
   139f2:	2b00      	cmp	r3, #0
   139f4:	d00a      	beq.n	13a0c <GUI_SendAnswer+0x110>
    {
      Request_MessageReq((port - 1), PtrDataRx, Processed);
   139f6:	230f      	movs	r3, #15
   139f8:	18fb      	adds	r3, r7, r3
   139fa:	781b      	ldrb	r3, [r3, #0]
   139fc:	3b01      	subs	r3, #1
   139fe:	b2db      	uxtb	r3, r3
   13a00:	4a36      	ldr	r2, [pc, #216]	; (13adc <GUI_SendAnswer+0x1e0>)
   13a02:	4934      	ldr	r1, [pc, #208]	; (13ad4 <GUI_SendAnswer+0x1d8>)
   13a04:	0018      	movs	r0, r3
   13a06:	f000 fffb 	bl	14a00 <Request_MessageReq>
    }
    else
    {
      Send_DpmMessageRej(port, Processed, GUI_REJ_DPM_INVALID_PORT_NUMBER);
    }
    break;
   13a0a:	e04f      	b.n	13aac <GUI_SendAnswer+0x1b0>
      Send_DpmMessageRej(port, Processed, GUI_REJ_DPM_INVALID_PORT_NUMBER);
   13a0c:	4933      	ldr	r1, [pc, #204]	; (13adc <GUI_SendAnswer+0x1e0>)
   13a0e:	230f      	movs	r3, #15
   13a10:	18fb      	adds	r3, r7, r3
   13a12:	781b      	ldrb	r3, [r3, #0]
   13a14:	2205      	movs	r2, #5
   13a16:	0018      	movs	r0, r3
   13a18:	f002 ffbb 	bl	16992 <Send_DpmMessageRej>
    break;
   13a1c:	e046      	b.n	13aac <GUI_SendAnswer+0x1b0>
  case DPM_REGISTER_READ_REQ:
    if (0 != port)
   13a1e:	230f      	movs	r3, #15
   13a20:	18fb      	adds	r3, r7, r3
   13a22:	781b      	ldrb	r3, [r3, #0]
   13a24:	2b00      	cmp	r3, #0
   13a26:	d01e      	beq.n	13a66 <GUI_SendAnswer+0x16a>
    {
      /* If size is 0*/
      if(!PtrDataRx[TLV_LENGTH_HIGH_POSITION] && !PtrDataRx[TLV_LENGTH_LOW_POSITION])
   13a28:	4b2a      	ldr	r3, [pc, #168]	; (13ad4 <GUI_SendAnswer+0x1d8>)
   13a2a:	795b      	ldrb	r3, [r3, #5]
   13a2c:	2b00      	cmp	r3, #0
   13a2e:	d10e      	bne.n	13a4e <GUI_SendAnswer+0x152>
   13a30:	4b28      	ldr	r3, [pc, #160]	; (13ad4 <GUI_SendAnswer+0x1d8>)
   13a32:	799b      	ldrb	r3, [r3, #6]
   13a34:	2b00      	cmp	r3, #0
   13a36:	d10a      	bne.n	13a4e <GUI_SendAnswer+0x152>
      {
        Send_DpmRegisterReadCnf((port - 1), Processed, 0xFF);
   13a38:	230f      	movs	r3, #15
   13a3a:	18fb      	adds	r3, r7, r3
   13a3c:	781b      	ldrb	r3, [r3, #0]
   13a3e:	3b01      	subs	r3, #1
   13a40:	b2db      	uxtb	r3, r3
   13a42:	4926      	ldr	r1, [pc, #152]	; (13adc <GUI_SendAnswer+0x1e0>)
   13a44:	22ff      	movs	r2, #255	; 0xff
   13a46:	0018      	movs	r0, r3
   13a48:	f002 ffc6 	bl	169d8 <Send_DpmRegisterReadCnf>
    }
    else
    {
      Send_DpmConfigGetRej(port, Processed, GUI_REJ_DPM_INVALID_PORT_NUMBER);
    }
    break;
   13a4c:	e02e      	b.n	13aac <GUI_SendAnswer+0x1b0>
        Send_DpmRegisterReadCnf((port - 1), Processed, PtrDataRx[TLV_VALUE_POSITION]);
   13a4e:	230f      	movs	r3, #15
   13a50:	18fb      	adds	r3, r7, r3
   13a52:	781b      	ldrb	r3, [r3, #0]
   13a54:	3b01      	subs	r3, #1
   13a56:	b2d8      	uxtb	r0, r3
   13a58:	4b1e      	ldr	r3, [pc, #120]	; (13ad4 <GUI_SendAnswer+0x1d8>)
   13a5a:	79da      	ldrb	r2, [r3, #7]
   13a5c:	4b1f      	ldr	r3, [pc, #124]	; (13adc <GUI_SendAnswer+0x1e0>)
   13a5e:	0019      	movs	r1, r3
   13a60:	f002 ffba 	bl	169d8 <Send_DpmRegisterReadCnf>
    break;
   13a64:	e022      	b.n	13aac <GUI_SendAnswer+0x1b0>
      Send_DpmConfigGetRej(port, Processed, GUI_REJ_DPM_INVALID_PORT_NUMBER);
   13a66:	491d      	ldr	r1, [pc, #116]	; (13adc <GUI_SendAnswer+0x1e0>)
   13a68:	230f      	movs	r3, #15
   13a6a:	18fb      	adds	r3, r7, r3
   13a6c:	781b      	ldrb	r3, [r3, #0]
   13a6e:	2205      	movs	r2, #5
   13a70:	0018      	movs	r0, r3
   13a72:	f002 ff6b 	bl	1694c <Send_DpmConfigGetRej>
    break;
   13a76:	e019      	b.n	13aac <GUI_SendAnswer+0x1b0>
  case DPM_REGISTER_WRITE_REQ:
    if (0 != port)
   13a78:	230f      	movs	r3, #15
   13a7a:	18fb      	adds	r3, r7, r3
   13a7c:	781b      	ldrb	r3, [r3, #0]
   13a7e:	2b00      	cmp	r3, #0
   13a80:	d00a      	beq.n	13a98 <GUI_SendAnswer+0x19c>
    {
      Send_DpmRegisterWriteCnf((port - 1), Processed, PtrDataRx);
   13a82:	230f      	movs	r3, #15
   13a84:	18fb      	adds	r3, r7, r3
   13a86:	781b      	ldrb	r3, [r3, #0]
   13a88:	3b01      	subs	r3, #1
   13a8a:	b2db      	uxtb	r3, r3
   13a8c:	4a11      	ldr	r2, [pc, #68]	; (13ad4 <GUI_SendAnswer+0x1d8>)
   13a8e:	4913      	ldr	r1, [pc, #76]	; (13adc <GUI_SendAnswer+0x1e0>)
   13a90:	0018      	movs	r0, r3
   13a92:	f003 f801 	bl	16a98 <Send_DpmRegisterWriteCnf>
    }
    else
    {
      Send_DpmConfigGetRej(port, Processed, GUI_REJ_DPM_INVALID_PORT_NUMBER);
    }
    break;
   13a96:	e009      	b.n	13aac <GUI_SendAnswer+0x1b0>
      Send_DpmConfigGetRej(port, Processed, GUI_REJ_DPM_INVALID_PORT_NUMBER);
   13a98:	4910      	ldr	r1, [pc, #64]	; (13adc <GUI_SendAnswer+0x1e0>)
   13a9a:	230f      	movs	r3, #15
   13a9c:	18fb      	adds	r3, r7, r3
   13a9e:	781b      	ldrb	r3, [r3, #0]
   13aa0:	2205      	movs	r2, #5
   13aa2:	0018      	movs	r0, r3
   13aa4:	f002 ff52 	bl	1694c <Send_DpmConfigGetRej>
    break;
   13aa8:	e000      	b.n	13aac <GUI_SendAnswer+0x1b0>
  default :
    break;
   13aaa:	46c0      	nop			; (mov r8, r8)
  }

  *pMsgToSend = Processed;
   13aac:	687b      	ldr	r3, [r7, #4]
   13aae:	4a0b      	ldr	r2, [pc, #44]	; (13adc <GUI_SendAnswer+0x1e0>)
   13ab0:	601a      	str	r2, [r3, #0]
  *pSizeMsg = TLV_get_string_length(Processed) + 8;
   13ab2:	4b0a      	ldr	r3, [pc, #40]	; (13adc <GUI_SendAnswer+0x1e0>)
   13ab4:	0018      	movs	r0, r3
   13ab6:	f7ff fb81 	bl	131bc <TLV_get_string_length>
   13aba:	0003      	movs	r3, r0
   13abc:	b2db      	uxtb	r3, r3
   13abe:	3308      	adds	r3, #8
   13ac0:	b2da      	uxtb	r2, r3
   13ac2:	683b      	ldr	r3, [r7, #0]
   13ac4:	701a      	strb	r2, [r3, #0]
  return GUI_State;
   13ac6:	4b06      	ldr	r3, [pc, #24]	; (13ae0 <GUI_SendAnswer+0x1e4>)
   13ac8:	781b      	ldrb	r3, [r3, #0]
}
   13aca:	0018      	movs	r0, r3
   13acc:	46bd      	mov	sp, r7
   13ace:	b005      	add	sp, #20
   13ad0:	bd90      	pop	{r4, r7, pc}
   13ad2:	46c0      	nop			; (mov r8, r8)
   13ad4:	000322e8 	.word	0x000322e8
   13ad8:	0001f6b8 	.word	0x0001f6b8
   13adc:	000321d8 	.word	0x000321d8
   13ae0:	00031cbc 	.word	0x00031cbc
   13ae4:	00006020 	.word	0x00006020

00013ae8 <GUI_SendNotification>:
  * @param  TypeNotification  Type of the notification
  * @param  Value             Value of the notification
  * @retval GUI state
  */
USBPD_GUI_State GUI_SendNotification(uint8_t PortNum, uint8_t **pMsgToSend, uint8_t *pSizeMsg, uint32_t TypeNotification, uint32_t Value)
{
   13ae8:	b5f0      	push	{r4, r5, r6, r7, lr}
   13aea:	b0a9      	sub	sp, #164	; 0xa4
   13aec:	af00      	add	r7, sp, #0
   13aee:	60b9      	str	r1, [r7, #8]
   13af0:	607a      	str	r2, [r7, #4]
   13af2:	603b      	str	r3, [r7, #0]
   13af4:	230f      	movs	r3, #15
   13af6:	18fb      	adds	r3, r7, r3
   13af8:	1c02      	adds	r2, r0, #0
   13afa:	701a      	strb	r2, [r3, #0]
  TLV_ToSend_Data send_tlv;
  USBPD_GUI_State gui_state = GUI_STATE_INIT;
   13afc:	239f      	movs	r3, #159	; 0x9f
   13afe:	18fb      	adds	r3, r7, r3
   13b00:	2200      	movs	r2, #0
   13b02:	701a      	strb	r2, [r3, #0]

  /* Send a notitification only if GUI is running */
  if (GUI_State == GUI_STATE_RUNNING)
   13b04:	4bbe      	ldr	r3, [pc, #760]	; (13e00 <GUI_SendNotification+0x318>)
   13b06:	781b      	ldrb	r3, [r3, #0]
   13b08:	2b01      	cmp	r3, #1
   13b0a:	d001      	beq.n	13b10 <GUI_SendNotification+0x28>
   13b0c:	f000 fc26 	bl	1435c <GUI_SendNotification+0x874>
  {
    TLV_init_encode(&send_tlv, __GUI_SET_TAG_ID((PortNum + 1), DPM_MESSAGE_IND), TLV_SIZE_MAX, Processed);
   13b10:	230f      	movs	r3, #15
   13b12:	18fb      	adds	r3, r7, r3
   13b14:	781b      	ldrb	r3, [r3, #0]
   13b16:	3301      	adds	r3, #1
   13b18:	015b      	lsls	r3, r3, #5
   13b1a:	b25b      	sxtb	r3, r3
   13b1c:	220c      	movs	r2, #12
   13b1e:	4313      	orrs	r3, r2
   13b20:	b25b      	sxtb	r3, r3
   13b22:	b2d9      	uxtb	r1, r3
   13b24:	4cb7      	ldr	r4, [pc, #732]	; (13e04 <GUI_SendNotification+0x31c>)
   13b26:	2380      	movs	r3, #128	; 0x80
   13b28:	005a      	lsls	r2, r3, #1
   13b2a:	231c      	movs	r3, #28
   13b2c:	18f8      	adds	r0, r7, r3
   13b2e:	0023      	movs	r3, r4
   13b30:	f7ff f8d8 	bl	12ce4 <TLV_init_encode>

    /* Check PD connection */
    if ((TypeNotification & GUI_NOTIF_ISCONNECTED) == GUI_NOTIF_ISCONNECTED)
   13b34:	683b      	ldr	r3, [r7, #0]
   13b36:	2220      	movs	r2, #32
   13b38:	4013      	ands	r3, r2
   13b3a:	d100      	bne.n	13b3e <GUI_SendNotification+0x56>
   13b3c:	e096      	b.n	13c6c <GUI_SendNotification+0x184>
    {
      /* Is Connected*/
      TLV_add(&send_tlv, GUI_IND_ISCONNECTED, 1, (uint8_t[]){DPM_Params[PortNum].PE_Power});
   13b3e:	240f      	movs	r4, #15
   13b40:	193b      	adds	r3, r7, r4
   13b42:	781b      	ldrb	r3, [r3, #0]
   13b44:	4ab0      	ldr	r2, [pc, #704]	; (13e08 <GUI_SendNotification+0x320>)
   13b46:	009b      	lsls	r3, r3, #2
   13b48:	18d3      	adds	r3, r2, r3
   13b4a:	785b      	ldrb	r3, [r3, #1]
   13b4c:	075b      	lsls	r3, r3, #29
   13b4e:	0f5b      	lsrs	r3, r3, #29
   13b50:	b2db      	uxtb	r3, r3
   13b52:	001a      	movs	r2, r3
   13b54:	2128      	movs	r1, #40	; 0x28
   13b56:	187b      	adds	r3, r7, r1
   13b58:	701a      	strb	r2, [r3, #0]
   13b5a:	187b      	adds	r3, r7, r1
   13b5c:	221c      	movs	r2, #28
   13b5e:	18b8      	adds	r0, r7, r2
   13b60:	2201      	movs	r2, #1
   13b62:	2105      	movs	r1, #5
   13b64:	f7ff f922 	bl	12dac <TLV_add>
      if (USBPD_TRUE == DPM_Params[PortNum].PE_IsConnected)
   13b68:	193b      	adds	r3, r7, r4
   13b6a:	781b      	ldrb	r3, [r3, #0]
   13b6c:	4aa6      	ldr	r2, [pc, #664]	; (13e08 <GUI_SendNotification+0x320>)
   13b6e:	009b      	lsls	r3, r3, #2
   13b70:	18d3      	adds	r3, r2, r3
   13b72:	785b      	ldrb	r3, [r3, #1]
   13b74:	06db      	lsls	r3, r3, #27
   13b76:	0fdb      	lsrs	r3, r3, #31
   13b78:	b2db      	uxtb	r3, r3
   13b7a:	2b01      	cmp	r3, #1
   13b7c:	d176      	bne.n	13c6c <GUI_SendNotification+0x184>
      {
        uint8_t rp_value = 0;
   13b7e:	241b      	movs	r4, #27
   13b80:	193b      	adds	r3, r7, r4
   13b82:	2200      	movs	r2, #0
   13b84:	701a      	strb	r2, [r3, #0]
        /* CC line */
        TLV_add(&send_tlv, GUI_IND_CC, 1, (uint8_t[]){DPM_Params[PortNum].ActiveCCIs});
   13b86:	250f      	movs	r5, #15
   13b88:	197b      	adds	r3, r7, r5
   13b8a:	781a      	ldrb	r2, [r3, #0]
   13b8c:	4b9e      	ldr	r3, [pc, #632]	; (13e08 <GUI_SendNotification+0x320>)
   13b8e:	0092      	lsls	r2, r2, #2
   13b90:	5cd3      	ldrb	r3, [r2, r3]
   13b92:	061b      	lsls	r3, r3, #24
   13b94:	0f9b      	lsrs	r3, r3, #30
   13b96:	b2db      	uxtb	r3, r3
   13b98:	001a      	movs	r2, r3
   13b9a:	212c      	movs	r1, #44	; 0x2c
   13b9c:	187b      	adds	r3, r7, r1
   13b9e:	701a      	strb	r2, [r3, #0]
   13ba0:	187b      	adds	r3, r7, r1
   13ba2:	261c      	movs	r6, #28
   13ba4:	19b8      	adds	r0, r7, r6
   13ba6:	2201      	movs	r2, #1
   13ba8:	2106      	movs	r1, #6
   13baa:	f7ff f8ff 	bl	12dac <TLV_add>
        /* Power Role*/
        TLV_add(&send_tlv, GUI_IND_POWERROLE, 1, (uint8_t[]){DPM_Params[PortNum].PE_PowerRole});
   13bae:	197b      	adds	r3, r7, r5
   13bb0:	781a      	ldrb	r2, [r3, #0]
   13bb2:	4b95      	ldr	r3, [pc, #596]	; (13e08 <GUI_SendNotification+0x320>)
   13bb4:	0092      	lsls	r2, r2, #2
   13bb6:	5cd3      	ldrb	r3, [r2, r3]
   13bb8:	075b      	lsls	r3, r3, #29
   13bba:	0fdb      	lsrs	r3, r3, #31
   13bbc:	b2db      	uxtb	r3, r3
   13bbe:	001a      	movs	r2, r3
   13bc0:	2130      	movs	r1, #48	; 0x30
   13bc2:	187b      	adds	r3, r7, r1
   13bc4:	701a      	strb	r2, [r3, #0]
   13bc6:	187b      	adds	r3, r7, r1
   13bc8:	19b8      	adds	r0, r7, r6
   13bca:	2201      	movs	r2, #1
   13bcc:	2108      	movs	r1, #8
   13bce:	f7ff f8ed 	bl	12dac <TLV_add>
        /* CC Default Current Advertised */
        rp_value = 3; /* (uint8_t)CAD_GetRPValue(PortNum); */
   13bd2:	193b      	adds	r3, r7, r4
   13bd4:	2203      	movs	r2, #3
   13bd6:	701a      	strb	r2, [r3, #0]
        TLV_add(&send_tlv, GUI_IND_CCDEFAULTCURRENTADVERTISED, 1, &rp_value);
   13bd8:	193b      	adds	r3, r7, r4
   13bda:	19b8      	adds	r0, r7, r6
   13bdc:	2201      	movs	r2, #1
   13bde:	2109      	movs	r1, #9
   13be0:	f7ff f8e4 	bl	12dac <TLV_add>
        if (USBPD_POWER_EXPLICITCONTRACT == DPM_Params[PortNum].PE_Power)
   13be4:	197b      	adds	r3, r7, r5
   13be6:	781b      	ldrb	r3, [r3, #0]
   13be8:	4a87      	ldr	r2, [pc, #540]	; (13e08 <GUI_SendNotification+0x320>)
   13bea:	009b      	lsls	r3, r3, #2
   13bec:	18d3      	adds	r3, r2, r3
   13bee:	785b      	ldrb	r3, [r3, #1]
   13bf0:	075b      	lsls	r3, r3, #29
   13bf2:	0f5b      	lsrs	r3, r3, #29
   13bf4:	b2db      	uxtb	r3, r3
   13bf6:	2b03      	cmp	r3, #3
   13bf8:	d138      	bne.n	13c6c <GUI_SendNotification+0x184>
        {
          /* Data Role*/
          TLV_add(&send_tlv, GUI_IND_DATAROLE, 1, (uint8_t[]){DPM_Params[PortNum].PE_DataRole});
   13bfa:	240f      	movs	r4, #15
   13bfc:	193b      	adds	r3, r7, r4
   13bfe:	781a      	ldrb	r2, [r3, #0]
   13c00:	4b81      	ldr	r3, [pc, #516]	; (13e08 <GUI_SendNotification+0x320>)
   13c02:	0092      	lsls	r2, r2, #2
   13c04:	5cd3      	ldrb	r3, [r2, r3]
   13c06:	071b      	lsls	r3, r3, #28
   13c08:	0fdb      	lsrs	r3, r3, #31
   13c0a:	b2db      	uxtb	r3, r3
   13c0c:	001a      	movs	r2, r3
   13c0e:	2134      	movs	r1, #52	; 0x34
   13c10:	187b      	adds	r3, r7, r1
   13c12:	701a      	strb	r2, [r3, #0]
   13c14:	187b      	adds	r3, r7, r1
   13c16:	251c      	movs	r5, #28
   13c18:	1978      	adds	r0, r7, r5
   13c1a:	2201      	movs	r2, #1
   13c1c:	2107      	movs	r1, #7
   13c1e:	f7ff f8c5 	bl	12dac <TLV_add>
          /* Vconn ON*/
          TLV_add(&send_tlv, GUI_IND_VCONNON, 1, (uint8_t[]){DPM_Params[PortNum].VconnStatus});
   13c22:	193b      	adds	r3, r7, r4
   13c24:	781b      	ldrb	r3, [r3, #0]
   13c26:	4a78      	ldr	r2, [pc, #480]	; (13e08 <GUI_SendNotification+0x320>)
   13c28:	009b      	lsls	r3, r3, #2
   13c2a:	18d3      	adds	r3, r2, r3
   13c2c:	785b      	ldrb	r3, [r3, #1]
   13c2e:	061b      	lsls	r3, r3, #24
   13c30:	0fdb      	lsrs	r3, r3, #31
   13c32:	b2db      	uxtb	r3, r3
   13c34:	001a      	movs	r2, r3
   13c36:	2138      	movs	r1, #56	; 0x38
   13c38:	187b      	adds	r3, r7, r1
   13c3a:	701a      	strb	r2, [r3, #0]
   13c3c:	187b      	adds	r3, r7, r1
   13c3e:	1978      	adds	r0, r7, r5
   13c40:	2201      	movs	r2, #1
   13c42:	210a      	movs	r1, #10
   13c44:	f7ff f8b2 	bl	12dac <TLV_add>
          /* PD_Spec Revision */
          TLV_add(&send_tlv, GUI_IND_PD_SPECREVISION, 1, (uint8_t[]){DPM_Params[PortNum].PE_SpecRevision});
   13c48:	193b      	adds	r3, r7, r4
   13c4a:	781a      	ldrb	r2, [r3, #0]
   13c4c:	4b6e      	ldr	r3, [pc, #440]	; (13e08 <GUI_SendNotification+0x320>)
   13c4e:	0092      	lsls	r2, r2, #2
   13c50:	5cd3      	ldrb	r3, [r2, r3]
   13c52:	079b      	lsls	r3, r3, #30
   13c54:	0f9b      	lsrs	r3, r3, #30
   13c56:	b2db      	uxtb	r3, r3
   13c58:	001a      	movs	r2, r3
   13c5a:	213c      	movs	r1, #60	; 0x3c
   13c5c:	187b      	adds	r3, r7, r1
   13c5e:	701a      	strb	r2, [r3, #0]
   13c60:	187b      	adds	r3, r7, r1
   13c62:	1978      	adds	r0, r7, r5
   13c64:	2201      	movs	r2, #1
   13c66:	210d      	movs	r1, #13
   13c68:	f7ff f8a0 	bl	12dac <TLV_add>
        }
      }
    }

    /* Check PD message event */
    if ((TypeNotification & GUI_NOTIF_PE_EVENT) == GUI_NOTIF_PE_EVENT)
   13c6c:	683a      	ldr	r2, [r7, #0]
   13c6e:	2380      	movs	r3, #128	; 0x80
   13c70:	019b      	lsls	r3, r3, #6
   13c72:	4013      	ands	r3, r2
   13c74:	d100      	bne.n	13c78 <GUI_SendNotification+0x190>
   13c76:	e2ae      	b.n	141d6 <GUI_SendNotification+0x6ee>
    {
      if (USBPD_NOTIFY_ALL != Value)
   13c78:	23b0      	movs	r3, #176	; 0xb0
   13c7a:	2208      	movs	r2, #8
   13c7c:	4694      	mov	ip, r2
   13c7e:	44bc      	add	ip, r7
   13c80:	4463      	add	r3, ip
   13c82:	681b      	ldr	r3, [r3, #0]
   13c84:	2b63      	cmp	r3, #99	; 0x63
   13c86:	d100      	bne.n	13c8a <GUI_SendNotification+0x1a2>
   13c88:	e1ff      	b.n	1408a <GUI_SendNotification+0x5a2>
      {
        /* PD_MessageNotif */
        TLV_add(&send_tlv, GUI_IND_PD_MESSAGENOTIF, 1, (uint8_t*)&Value);
   13c8a:	231c      	movs	r3, #28
   13c8c:	18f8      	adds	r0, r7, r3
   13c8e:	23b0      	movs	r3, #176	; 0xb0
   13c90:	001c      	movs	r4, r3
   13c92:	2208      	movs	r2, #8
   13c94:	4694      	mov	ip, r2
   13c96:	44bc      	add	ip, r7
   13c98:	4463      	add	r3, ip
   13c9a:	2201      	movs	r2, #1
   13c9c:	210e      	movs	r1, #14
   13c9e:	f7ff f885 	bl	12dac <TLV_add>

        switch (Value)
   13ca2:	0023      	movs	r3, r4
   13ca4:	2208      	movs	r2, #8
   13ca6:	4694      	mov	ip, r2
   13ca8:	44bc      	add	ip, r7
   13caa:	4463      	add	r3, ip
   13cac:	681b      	ldr	r3, [r3, #0]
   13cae:	3b07      	subs	r3, #7
   13cb0:	2b53      	cmp	r3, #83	; 0x53
   13cb2:	d900      	bls.n	13cb6 <GUI_SendNotification+0x1ce>
   13cb4:	e28f      	b.n	141d6 <GUI_SendNotification+0x6ee>
   13cb6:	009a      	lsls	r2, r3, #2
   13cb8:	4b54      	ldr	r3, [pc, #336]	; (13e0c <GUI_SendNotification+0x324>)
   13cba:	18d3      	adds	r3, r2, r3
   13cbc:	681b      	ldr	r3, [r3, #0]
   13cbe:	469f      	mov	pc, r3
        {
          case USBPD_NOTIFY_POWER_STATE_CHANGE :
            /* Is Connected*/
            TLV_add(&send_tlv, GUI_IND_ISCONNECTED, 1, (uint8_t[]){DPM_Params[PortNum].PE_Power});
   13cc0:	240f      	movs	r4, #15
   13cc2:	193b      	adds	r3, r7, r4
   13cc4:	781b      	ldrb	r3, [r3, #0]
   13cc6:	4a50      	ldr	r2, [pc, #320]	; (13e08 <GUI_SendNotification+0x320>)
   13cc8:	009b      	lsls	r3, r3, #2
   13cca:	18d3      	adds	r3, r2, r3
   13ccc:	785b      	ldrb	r3, [r3, #1]
   13cce:	075b      	lsls	r3, r3, #29
   13cd0:	0f5b      	lsrs	r3, r3, #29
   13cd2:	b2db      	uxtb	r3, r3
   13cd4:	001a      	movs	r2, r3
   13cd6:	2140      	movs	r1, #64	; 0x40
   13cd8:	187b      	adds	r3, r7, r1
   13cda:	701a      	strb	r2, [r3, #0]
   13cdc:	187b      	adds	r3, r7, r1
   13cde:	221c      	movs	r2, #28
   13ce0:	18b8      	adds	r0, r7, r2
   13ce2:	2201      	movs	r2, #1
   13ce4:	2105      	movs	r1, #5
   13ce6:	f7ff f861 	bl	12dac <TLV_add>
            if (USBPD_POWER_NO == DPM_Params[PortNum].PE_Power)
   13cea:	193b      	adds	r3, r7, r4
   13cec:	781b      	ldrb	r3, [r3, #0]
   13cee:	4a46      	ldr	r2, [pc, #280]	; (13e08 <GUI_SendNotification+0x320>)
   13cf0:	009b      	lsls	r3, r3, #2
   13cf2:	18d3      	adds	r3, r2, r3
   13cf4:	785b      	ldrb	r3, [r3, #1]
   13cf6:	075b      	lsls	r3, r3, #29
   13cf8:	0f5b      	lsrs	r3, r3, #29
   13cfa:	b2db      	uxtb	r3, r3
   13cfc:	2b00      	cmp	r3, #0
   13cfe:	d000      	beq.n	13d02 <GUI_SendNotification+0x21a>
   13d00:	e268      	b.n	141d4 <GUI_SendNotification+0x6ec>
            {
              /* CC line */
              TLV_add(&send_tlv, GUI_IND_CC, 1, (uint8_t[]){DPM_Params[PortNum].ActiveCCIs});
   13d02:	240f      	movs	r4, #15
   13d04:	193b      	adds	r3, r7, r4
   13d06:	781a      	ldrb	r2, [r3, #0]
   13d08:	4b3f      	ldr	r3, [pc, #252]	; (13e08 <GUI_SendNotification+0x320>)
   13d0a:	0092      	lsls	r2, r2, #2
   13d0c:	5cd3      	ldrb	r3, [r2, r3]
   13d0e:	061b      	lsls	r3, r3, #24
   13d10:	0f9b      	lsrs	r3, r3, #30
   13d12:	b2db      	uxtb	r3, r3
   13d14:	001a      	movs	r2, r3
   13d16:	2144      	movs	r1, #68	; 0x44
   13d18:	187b      	adds	r3, r7, r1
   13d1a:	701a      	strb	r2, [r3, #0]
   13d1c:	187b      	adds	r3, r7, r1
   13d1e:	251c      	movs	r5, #28
   13d20:	1978      	adds	r0, r7, r5
   13d22:	2201      	movs	r2, #1
   13d24:	2106      	movs	r1, #6
   13d26:	f7ff f841 	bl	12dac <TLV_add>
              /* PowerRole*/
              TLV_add(&send_tlv, GUI_IND_POWERROLE, 1, (uint8_t[]){DPM_Params[PortNum].PE_PowerRole});
   13d2a:	193b      	adds	r3, r7, r4
   13d2c:	781a      	ldrb	r2, [r3, #0]
   13d2e:	4b36      	ldr	r3, [pc, #216]	; (13e08 <GUI_SendNotification+0x320>)
   13d30:	0092      	lsls	r2, r2, #2
   13d32:	5cd3      	ldrb	r3, [r2, r3]
   13d34:	075b      	lsls	r3, r3, #29
   13d36:	0fdb      	lsrs	r3, r3, #31
   13d38:	b2db      	uxtb	r3, r3
   13d3a:	001a      	movs	r2, r3
   13d3c:	2148      	movs	r1, #72	; 0x48
   13d3e:	187b      	adds	r3, r7, r1
   13d40:	701a      	strb	r2, [r3, #0]
   13d42:	187b      	adds	r3, r7, r1
   13d44:	1978      	adds	r0, r7, r5
   13d46:	2201      	movs	r2, #1
   13d48:	2108      	movs	r1, #8
   13d4a:	f7ff f82f 	bl	12dac <TLV_add>
            }
            break;
   13d4e:	e241      	b.n	141d4 <GUI_SendNotification+0x6ec>
          case USBPD_NOTIFY_GETSNKCAP_ACCEPTED :
            /* NumberOfRcvSNKPDO */
            TLV_add(&send_tlv, GUI_IND_NUMBEROFRCVSNKPDO, 1, (uint8_t[]){GUI_SaveInformation[PortNum].NumberOfRcvSNKPDO});
   13d50:	240f      	movs	r4, #15
   13d52:	193b      	adds	r3, r7, r4
   13d54:	781b      	ldrb	r3, [r3, #0]
   13d56:	4a2e      	ldr	r2, [pc, #184]	; (13e10 <GUI_SendNotification+0x328>)
   13d58:	2194      	movs	r1, #148	; 0x94
   13d5a:	434b      	muls	r3, r1
   13d5c:	18d3      	adds	r3, r2, r3
   13d5e:	333c      	adds	r3, #60	; 0x3c
   13d60:	681b      	ldr	r3, [r3, #0]
   13d62:	b2da      	uxtb	r2, r3
   13d64:	214c      	movs	r1, #76	; 0x4c
   13d66:	187b      	adds	r3, r7, r1
   13d68:	701a      	strb	r2, [r3, #0]
   13d6a:	187b      	adds	r3, r7, r1
   13d6c:	251c      	movs	r5, #28
   13d6e:	1978      	adds	r0, r7, r5
   13d70:	2201      	movs	r2, #1
   13d72:	2100      	movs	r1, #0
   13d74:	f7ff f81a 	bl	12dac <TLV_add>
            /* ListOfRcvSNKPDO*/
            TLV_add(&send_tlv, GUI_IND_LISTOFRCVSNKPDO, GUI_SaveInformation[PortNum].NumberOfRcvSNKPDO * 4, (uint8_t *) GUI_SaveInformation[PortNum].ListOfRcvSNKPDO);
   13d78:	193b      	adds	r3, r7, r4
   13d7a:	781b      	ldrb	r3, [r3, #0]
   13d7c:	4a24      	ldr	r2, [pc, #144]	; (13e10 <GUI_SendNotification+0x328>)
   13d7e:	2194      	movs	r1, #148	; 0x94
   13d80:	434b      	muls	r3, r1
   13d82:	18d3      	adds	r3, r2, r3
   13d84:	333c      	adds	r3, #60	; 0x3c
   13d86:	681b      	ldr	r3, [r3, #0]
   13d88:	b29b      	uxth	r3, r3
   13d8a:	009b      	lsls	r3, r3, #2
   13d8c:	b299      	uxth	r1, r3
   13d8e:	193b      	adds	r3, r7, r4
   13d90:	781b      	ldrb	r3, [r3, #0]
   13d92:	2294      	movs	r2, #148	; 0x94
   13d94:	4353      	muls	r3, r2
   13d96:	3320      	adds	r3, #32
   13d98:	001a      	movs	r2, r3
   13d9a:	4b1d      	ldr	r3, [pc, #116]	; (13e10 <GUI_SendNotification+0x328>)
   13d9c:	18d3      	adds	r3, r2, r3
   13d9e:	1978      	adds	r0, r7, r5
   13da0:	000a      	movs	r2, r1
   13da2:	2104      	movs	r1, #4
   13da4:	f7ff f802 	bl	12dac <TLV_add>
            break;
   13da8:	e215      	b.n	141d6 <GUI_SendNotification+0x6ee>
          case USBPD_NOTIFY_GETSRCCAP_ACCEPTED :
            /* NumberOfRcvSRCPDO*/
            TLV_add(&send_tlv, GUI_IND_NUMBEROFRCVSRCPDO, 1, (uint8_t[]){GUI_SaveInformation[PortNum].NumberOfRcvSRCPDO});
   13daa:	240f      	movs	r4, #15
   13dac:	193b      	adds	r3, r7, r4
   13dae:	781b      	ldrb	r3, [r3, #0]
   13db0:	4a17      	ldr	r2, [pc, #92]	; (13e10 <GUI_SendNotification+0x328>)
   13db2:	2194      	movs	r1, #148	; 0x94
   13db4:	434b      	muls	r3, r1
   13db6:	18d3      	adds	r3, r2, r3
   13db8:	331c      	adds	r3, #28
   13dba:	681b      	ldr	r3, [r3, #0]
   13dbc:	b2da      	uxtb	r2, r3
   13dbe:	2150      	movs	r1, #80	; 0x50
   13dc0:	187b      	adds	r3, r7, r1
   13dc2:	701a      	strb	r2, [r3, #0]
   13dc4:	187b      	adds	r3, r7, r1
   13dc6:	251c      	movs	r5, #28
   13dc8:	1978      	adds	r0, r7, r5
   13dca:	2201      	movs	r2, #1
   13dcc:	2103      	movs	r1, #3
   13dce:	f7fe ffed 	bl	12dac <TLV_add>
            /* ListOfRcvSRCPDO*/
            TLV_add(&send_tlv, GUI_IND_LISTOFRCVSRCPDO, GUI_SaveInformation[PortNum].NumberOfRcvSRCPDO * 4, (uint8_t *) GUI_SaveInformation[PortNum].ListOfRcvSRCPDO);
   13dd2:	193b      	adds	r3, r7, r4
   13dd4:	781b      	ldrb	r3, [r3, #0]
   13dd6:	4a0e      	ldr	r2, [pc, #56]	; (13e10 <GUI_SendNotification+0x328>)
   13dd8:	2194      	movs	r1, #148	; 0x94
   13dda:	434b      	muls	r3, r1
   13ddc:	18d3      	adds	r3, r2, r3
   13dde:	331c      	adds	r3, #28
   13de0:	681b      	ldr	r3, [r3, #0]
   13de2:	b29b      	uxth	r3, r3
   13de4:	009b      	lsls	r3, r3, #2
   13de6:	b299      	uxth	r1, r3
   13de8:	193b      	adds	r3, r7, r4
   13dea:	781b      	ldrb	r3, [r3, #0]
   13dec:	2294      	movs	r2, #148	; 0x94
   13dee:	435a      	muls	r2, r3
   13df0:	4b07      	ldr	r3, [pc, #28]	; (13e10 <GUI_SendNotification+0x328>)
   13df2:	18d3      	adds	r3, r2, r3
   13df4:	1978      	adds	r0, r7, r5
   13df6:	000a      	movs	r2, r1
   13df8:	2102      	movs	r1, #2
   13dfa:	f7fe ffd7 	bl	12dac <TLV_add>
            break;
   13dfe:	e1ea      	b.n	141d6 <GUI_SendNotification+0x6ee>
   13e00:	00031cbc 	.word	0x00031cbc
   13e04:	000321d8 	.word	0x000321d8
   13e08:	000321d4 	.word	0x000321d4
   13e0c:	0001f6fc 	.word	0x0001f6fc
   13e10:	000323ec 	.word	0x000323ec
          case USBPD_NOTIFY_POWER_EXPLICIT_CONTRACT :
            if (USBPD_PORTPOWERROLE_SNK == DPM_Params[PortNum].PE_PowerRole)
   13e14:	230f      	movs	r3, #15
   13e16:	18fb      	adds	r3, r7, r3
   13e18:	781a      	ldrb	r2, [r3, #0]
   13e1a:	4bec      	ldr	r3, [pc, #944]	; (141cc <GUI_SendNotification+0x6e4>)
   13e1c:	0092      	lsls	r2, r2, #2
   13e1e:	5cd3      	ldrb	r3, [r2, r3]
   13e20:	075b      	lsls	r3, r3, #29
   13e22:	0fdb      	lsrs	r3, r3, #31
   13e24:	b2db      	uxtb	r3, r3
   13e26:	2b00      	cmp	r3, #0
   13e28:	d129      	bne.n	13e7e <GUI_SendNotification+0x396>
            {
              /* NumberOfRcvSRCPDO*/
              TLV_add(&send_tlv, GUI_IND_NUMBEROFRCVSRCPDO, 1, (uint8_t[]){GUI_SaveInformation[PortNum].NumberOfRcvSRCPDO});
   13e2a:	240f      	movs	r4, #15
   13e2c:	193b      	adds	r3, r7, r4
   13e2e:	781b      	ldrb	r3, [r3, #0]
   13e30:	4ae7      	ldr	r2, [pc, #924]	; (141d0 <GUI_SendNotification+0x6e8>)
   13e32:	2194      	movs	r1, #148	; 0x94
   13e34:	434b      	muls	r3, r1
   13e36:	18d3      	adds	r3, r2, r3
   13e38:	331c      	adds	r3, #28
   13e3a:	681b      	ldr	r3, [r3, #0]
   13e3c:	b2da      	uxtb	r2, r3
   13e3e:	2154      	movs	r1, #84	; 0x54
   13e40:	187b      	adds	r3, r7, r1
   13e42:	701a      	strb	r2, [r3, #0]
   13e44:	187b      	adds	r3, r7, r1
   13e46:	251c      	movs	r5, #28
   13e48:	1978      	adds	r0, r7, r5
   13e4a:	2201      	movs	r2, #1
   13e4c:	2103      	movs	r1, #3
   13e4e:	f7fe ffad 	bl	12dac <TLV_add>
              /* ListOfRcvSRCPDO*/
              TLV_add(&send_tlv, GUI_IND_LISTOFRCVSRCPDO, GUI_SaveInformation[PortNum].NumberOfRcvSRCPDO * 4, (uint8_t *) GUI_SaveInformation[PortNum].ListOfRcvSRCPDO);
   13e52:	193b      	adds	r3, r7, r4
   13e54:	781b      	ldrb	r3, [r3, #0]
   13e56:	4ade      	ldr	r2, [pc, #888]	; (141d0 <GUI_SendNotification+0x6e8>)
   13e58:	2194      	movs	r1, #148	; 0x94
   13e5a:	434b      	muls	r3, r1
   13e5c:	18d3      	adds	r3, r2, r3
   13e5e:	331c      	adds	r3, #28
   13e60:	681b      	ldr	r3, [r3, #0]
   13e62:	b29b      	uxth	r3, r3
   13e64:	009b      	lsls	r3, r3, #2
   13e66:	b299      	uxth	r1, r3
   13e68:	193b      	adds	r3, r7, r4
   13e6a:	781b      	ldrb	r3, [r3, #0]
   13e6c:	2294      	movs	r2, #148	; 0x94
   13e6e:	435a      	muls	r2, r3
   13e70:	4bd7      	ldr	r3, [pc, #860]	; (141d0 <GUI_SendNotification+0x6e8>)
   13e72:	18d3      	adds	r3, r2, r3
   13e74:	1978      	adds	r0, r7, r5
   13e76:	000a      	movs	r2, r1
   13e78:	2102      	movs	r1, #2
   13e7a:	f7fe ff97 	bl	12dac <TLV_add>
            }
            /* RDOPosition */
            TLV_add(&send_tlv, GUI_IND_RDOPOSITION, 1, (uint8_t[]){GUI_SaveInformation[PortNum].RDOPosition});
   13e7e:	240f      	movs	r4, #15
   13e80:	193b      	adds	r3, r7, r4
   13e82:	781b      	ldrb	r3, [r3, #0]
   13e84:	4ad2      	ldr	r2, [pc, #840]	; (141d0 <GUI_SendNotification+0x6e8>)
   13e86:	2194      	movs	r1, #148	; 0x94
   13e88:	434b      	muls	r3, r1
   13e8a:	18d3      	adds	r3, r2, r3
   13e8c:	3340      	adds	r3, #64	; 0x40
   13e8e:	681b      	ldr	r3, [r3, #0]
   13e90:	b2da      	uxtb	r2, r3
   13e92:	2158      	movs	r1, #88	; 0x58
   13e94:	187b      	adds	r3, r7, r1
   13e96:	701a      	strb	r2, [r3, #0]
   13e98:	187b      	adds	r3, r7, r1
   13e9a:	251c      	movs	r5, #28
   13e9c:	1978      	adds	r0, r7, r5
   13e9e:	2201      	movs	r2, #1
   13ea0:	2101      	movs	r1, #1
   13ea2:	f7fe ff83 	bl	12dac <TLV_add>
            /* DataRole*/
            TLV_add(&send_tlv, GUI_IND_DATAROLE, 1, (uint8_t[]){DPM_Params[PortNum].PE_DataRole});
   13ea6:	193b      	adds	r3, r7, r4
   13ea8:	781a      	ldrb	r2, [r3, #0]
   13eaa:	4bc8      	ldr	r3, [pc, #800]	; (141cc <GUI_SendNotification+0x6e4>)
   13eac:	0092      	lsls	r2, r2, #2
   13eae:	5cd3      	ldrb	r3, [r2, r3]
   13eb0:	071b      	lsls	r3, r3, #28
   13eb2:	0fdb      	lsrs	r3, r3, #31
   13eb4:	b2db      	uxtb	r3, r3
   13eb6:	001a      	movs	r2, r3
   13eb8:	215c      	movs	r1, #92	; 0x5c
   13eba:	187b      	adds	r3, r7, r1
   13ebc:	701a      	strb	r2, [r3, #0]
   13ebe:	187b      	adds	r3, r7, r1
   13ec0:	1978      	adds	r0, r7, r5
   13ec2:	2201      	movs	r2, #1
   13ec4:	2107      	movs	r1, #7
   13ec6:	f7fe ff71 	bl	12dac <TLV_add>
            /* PowerRole*/
            TLV_add(&send_tlv, GUI_IND_POWERROLE, 1, (uint8_t[]){DPM_Params[PortNum].PE_PowerRole});
   13eca:	193b      	adds	r3, r7, r4
   13ecc:	781a      	ldrb	r2, [r3, #0]
   13ece:	4bbf      	ldr	r3, [pc, #764]	; (141cc <GUI_SendNotification+0x6e4>)
   13ed0:	0092      	lsls	r2, r2, #2
   13ed2:	5cd3      	ldrb	r3, [r2, r3]
   13ed4:	075b      	lsls	r3, r3, #29
   13ed6:	0fdb      	lsrs	r3, r3, #31
   13ed8:	b2db      	uxtb	r3, r3
   13eda:	001a      	movs	r2, r3
   13edc:	2160      	movs	r1, #96	; 0x60
   13ede:	187b      	adds	r3, r7, r1
   13ee0:	701a      	strb	r2, [r3, #0]
   13ee2:	187b      	adds	r3, r7, r1
   13ee4:	1978      	adds	r0, r7, r5
   13ee6:	2201      	movs	r2, #1
   13ee8:	2108      	movs	r1, #8
   13eea:	f7fe ff5f 	bl	12dac <TLV_add>
            /* VconnON*/
            TLV_add(&send_tlv, GUI_IND_VCONNON, 1, (uint8_t[]){DPM_Params[PortNum].VconnStatus});
   13eee:	193b      	adds	r3, r7, r4
   13ef0:	781b      	ldrb	r3, [r3, #0]
   13ef2:	4ab6      	ldr	r2, [pc, #728]	; (141cc <GUI_SendNotification+0x6e4>)
   13ef4:	009b      	lsls	r3, r3, #2
   13ef6:	18d3      	adds	r3, r2, r3
   13ef8:	785b      	ldrb	r3, [r3, #1]
   13efa:	061b      	lsls	r3, r3, #24
   13efc:	0fdb      	lsrs	r3, r3, #31
   13efe:	b2db      	uxtb	r3, r3
   13f00:	001a      	movs	r2, r3
   13f02:	2164      	movs	r1, #100	; 0x64
   13f04:	187b      	adds	r3, r7, r1
   13f06:	701a      	strb	r2, [r3, #0]
   13f08:	187b      	adds	r3, r7, r1
   13f0a:	1978      	adds	r0, r7, r5
   13f0c:	2201      	movs	r2, #1
   13f0e:	210a      	movs	r1, #10
   13f10:	f7fe ff4c 	bl	12dac <TLV_add>
            /* PD_SpecRevision */
            TLV_add(&send_tlv, GUI_IND_PD_SPECREVISION, 1, (uint8_t[]){DPM_Params[PortNum].PE_SpecRevision});
   13f14:	193b      	adds	r3, r7, r4
   13f16:	781a      	ldrb	r2, [r3, #0]
   13f18:	4bac      	ldr	r3, [pc, #688]	; (141cc <GUI_SendNotification+0x6e4>)
   13f1a:	0092      	lsls	r2, r2, #2
   13f1c:	5cd3      	ldrb	r3, [r2, r3]
   13f1e:	079b      	lsls	r3, r3, #30
   13f20:	0f9b      	lsrs	r3, r3, #30
   13f22:	b2db      	uxtb	r3, r3
   13f24:	001a      	movs	r2, r3
   13f26:	2168      	movs	r1, #104	; 0x68
   13f28:	187b      	adds	r3, r7, r1
   13f2a:	701a      	strb	r2, [r3, #0]
   13f2c:	187b      	adds	r3, r7, r1
   13f2e:	1978      	adds	r0, r7, r5
   13f30:	2201      	movs	r2, #1
   13f32:	210d      	movs	r1, #13
   13f34:	f7fe ff3a 	bl	12dac <TLV_add>
            break;
   13f38:	e14d      	b.n	141d6 <GUI_SendNotification+0x6ee>
          case USBPD_NOTIFY_POWER_SWAP_TO_SNK_DONE :
          case USBPD_NOTIFY_POWER_SWAP_TO_SRC_DONE :
            /* PowerRole*/
            TLV_add(&send_tlv, GUI_IND_POWERROLE, 1, (uint8_t[]){DPM_Params[PortNum].PE_PowerRole});
   13f3a:	230f      	movs	r3, #15
   13f3c:	18fb      	adds	r3, r7, r3
   13f3e:	781a      	ldrb	r2, [r3, #0]
   13f40:	4ba2      	ldr	r3, [pc, #648]	; (141cc <GUI_SendNotification+0x6e4>)
   13f42:	0092      	lsls	r2, r2, #2
   13f44:	5cd3      	ldrb	r3, [r2, r3]
   13f46:	075b      	lsls	r3, r3, #29
   13f48:	0fdb      	lsrs	r3, r3, #31
   13f4a:	b2db      	uxtb	r3, r3
   13f4c:	001a      	movs	r2, r3
   13f4e:	216c      	movs	r1, #108	; 0x6c
   13f50:	187b      	adds	r3, r7, r1
   13f52:	701a      	strb	r2, [r3, #0]
   13f54:	187b      	adds	r3, r7, r1
   13f56:	221c      	movs	r2, #28
   13f58:	18b8      	adds	r0, r7, r2
   13f5a:	2201      	movs	r2, #1
   13f5c:	2108      	movs	r1, #8
   13f5e:	f7fe ff25 	bl	12dac <TLV_add>
            break;
   13f62:	e138      	b.n	141d6 <GUI_SendNotification+0x6ee>
          case USBPD_NOTIFY_DATAROLESWAP_UFP :
          case USBPD_NOTIFY_DATAROLESWAP_DFP :
            /* DataRole*/
            TLV_add(&send_tlv, GUI_IND_DATAROLE, 1, (uint8_t[]){DPM_Params[PortNum].PE_DataRole});
   13f64:	230f      	movs	r3, #15
   13f66:	18fb      	adds	r3, r7, r3
   13f68:	781a      	ldrb	r2, [r3, #0]
   13f6a:	4b98      	ldr	r3, [pc, #608]	; (141cc <GUI_SendNotification+0x6e4>)
   13f6c:	0092      	lsls	r2, r2, #2
   13f6e:	5cd3      	ldrb	r3, [r2, r3]
   13f70:	071b      	lsls	r3, r3, #28
   13f72:	0fdb      	lsrs	r3, r3, #31
   13f74:	b2db      	uxtb	r3, r3
   13f76:	001a      	movs	r2, r3
   13f78:	2170      	movs	r1, #112	; 0x70
   13f7a:	187b      	adds	r3, r7, r1
   13f7c:	701a      	strb	r2, [r3, #0]
   13f7e:	187b      	adds	r3, r7, r1
   13f80:	221c      	movs	r2, #28
   13f82:	18b8      	adds	r0, r7, r2
   13f84:	2201      	movs	r2, #1
   13f86:	2107      	movs	r1, #7
   13f88:	f7fe ff10 	bl	12dac <TLV_add>
            break;
   13f8c:	e123      	b.n	141d6 <GUI_SendNotification+0x6ee>
          case USBPD_NOTIFY_PD_SPECIFICATION_CHANGE :
            /* PD_SpecRevision */
            TLV_add(&send_tlv, GUI_IND_PD_SPECREVISION, 1, (uint8_t[]){DPM_Params[PortNum].PE_SpecRevision});
   13f8e:	230f      	movs	r3, #15
   13f90:	18fb      	adds	r3, r7, r3
   13f92:	781a      	ldrb	r2, [r3, #0]
   13f94:	4b8d      	ldr	r3, [pc, #564]	; (141cc <GUI_SendNotification+0x6e4>)
   13f96:	0092      	lsls	r2, r2, #2
   13f98:	5cd3      	ldrb	r3, [r2, r3]
   13f9a:	079b      	lsls	r3, r3, #30
   13f9c:	0f9b      	lsrs	r3, r3, #30
   13f9e:	b2db      	uxtb	r3, r3
   13fa0:	001a      	movs	r2, r3
   13fa2:	2174      	movs	r1, #116	; 0x74
   13fa4:	187b      	adds	r3, r7, r1
   13fa6:	701a      	strb	r2, [r3, #0]
   13fa8:	187b      	adds	r3, r7, r1
   13faa:	221c      	movs	r2, #28
   13fac:	18b8      	adds	r0, r7, r2
   13fae:	2201      	movs	r2, #1
   13fb0:	210d      	movs	r1, #13
   13fb2:	f7fe fefb 	bl	12dac <TLV_add>
            break;
   13fb6:	e10e      	b.n	141d6 <GUI_SendNotification+0x6ee>
          case USBPD_NOTIFY_VCONN_SWAP_COMPLETE :
            /* VconnON */
            TLV_add(&send_tlv, GUI_IND_VCONNON, 1, (uint8_t[]){DPM_Params[PortNum].VconnStatus});
   13fb8:	230f      	movs	r3, #15
   13fba:	18fb      	adds	r3, r7, r3
   13fbc:	781b      	ldrb	r3, [r3, #0]
   13fbe:	4a83      	ldr	r2, [pc, #524]	; (141cc <GUI_SendNotification+0x6e4>)
   13fc0:	009b      	lsls	r3, r3, #2
   13fc2:	18d3      	adds	r3, r2, r3
   13fc4:	785b      	ldrb	r3, [r3, #1]
   13fc6:	061b      	lsls	r3, r3, #24
   13fc8:	0fdb      	lsrs	r3, r3, #31
   13fca:	b2db      	uxtb	r3, r3
   13fcc:	001a      	movs	r2, r3
   13fce:	2178      	movs	r1, #120	; 0x78
   13fd0:	187b      	adds	r3, r7, r1
   13fd2:	701a      	strb	r2, [r3, #0]
   13fd4:	187b      	adds	r3, r7, r1
   13fd6:	221c      	movs	r2, #28
   13fd8:	18b8      	adds	r0, r7, r2
   13fda:	2201      	movs	r2, #1
   13fdc:	210a      	movs	r1, #10
   13fde:	f7fe fee5 	bl	12dac <TLV_add>
            break;
   13fe2:	e0f8      	b.n	141d6 <GUI_SendNotification+0x6ee>
#endif /* _PPS */
#if _STATUS
          case USBPD_NOTIFY_STATUS_RECEIVED :
            {
              uint8_t tab[5] = {
                GUI_SaveInformation[PortNum].RcvStatus.InternalTemp,
   13fe4:	250f      	movs	r5, #15
   13fe6:	197b      	adds	r3, r7, r5
   13fe8:	781b      	ldrb	r3, [r3, #0]
   13fea:	4a79      	ldr	r2, [pc, #484]	; (141d0 <GUI_SendNotification+0x6e8>)
   13fec:	2154      	movs	r1, #84	; 0x54
   13fee:	2094      	movs	r0, #148	; 0x94
   13ff0:	4343      	muls	r3, r0
   13ff2:	18d3      	adds	r3, r2, r3
   13ff4:	185b      	adds	r3, r3, r1
   13ff6:	781a      	ldrb	r2, [r3, #0]
              uint8_t tab[5] = {
   13ff8:	2414      	movs	r4, #20
   13ffa:	193b      	adds	r3, r7, r4
   13ffc:	701a      	strb	r2, [r3, #0]
                GUI_SaveInformation[PortNum].RcvStatus.PresentInput,
   13ffe:	197b      	adds	r3, r7, r5
   14000:	781b      	ldrb	r3, [r3, #0]
   14002:	4a73      	ldr	r2, [pc, #460]	; (141d0 <GUI_SendNotification+0x6e8>)
   14004:	2155      	movs	r1, #85	; 0x55
   14006:	2094      	movs	r0, #148	; 0x94
   14008:	4343      	muls	r3, r0
   1400a:	18d3      	adds	r3, r2, r3
   1400c:	185b      	adds	r3, r3, r1
   1400e:	781a      	ldrb	r2, [r3, #0]
              uint8_t tab[5] = {
   14010:	193b      	adds	r3, r7, r4
   14012:	705a      	strb	r2, [r3, #1]
                GUI_SaveInformation[PortNum].RcvStatus.PresentBatteryInput,
   14014:	197b      	adds	r3, r7, r5
   14016:	781b      	ldrb	r3, [r3, #0]
   14018:	4a6d      	ldr	r2, [pc, #436]	; (141d0 <GUI_SendNotification+0x6e8>)
   1401a:	2156      	movs	r1, #86	; 0x56
   1401c:	2094      	movs	r0, #148	; 0x94
   1401e:	4343      	muls	r3, r0
   14020:	18d3      	adds	r3, r2, r3
   14022:	185b      	adds	r3, r3, r1
   14024:	781a      	ldrb	r2, [r3, #0]
              uint8_t tab[5] = {
   14026:	193b      	adds	r3, r7, r4
   14028:	709a      	strb	r2, [r3, #2]
                GUI_SaveInformation[PortNum].RcvStatus.EventFlags,
   1402a:	197b      	adds	r3, r7, r5
   1402c:	781b      	ldrb	r3, [r3, #0]
   1402e:	4a68      	ldr	r2, [pc, #416]	; (141d0 <GUI_SendNotification+0x6e8>)
   14030:	2157      	movs	r1, #87	; 0x57
   14032:	2094      	movs	r0, #148	; 0x94
   14034:	4343      	muls	r3, r0
   14036:	18d3      	adds	r3, r2, r3
   14038:	185b      	adds	r3, r3, r1
   1403a:	781a      	ldrb	r2, [r3, #0]
              uint8_t tab[5] = {
   1403c:	193b      	adds	r3, r7, r4
   1403e:	70da      	strb	r2, [r3, #3]
                GUI_SaveInformation[PortNum].RcvStatus.TemperatureStatus
   14040:	197b      	adds	r3, r7, r5
   14042:	781b      	ldrb	r3, [r3, #0]
   14044:	4a62      	ldr	r2, [pc, #392]	; (141d0 <GUI_SendNotification+0x6e8>)
   14046:	2158      	movs	r1, #88	; 0x58
   14048:	2094      	movs	r0, #148	; 0x94
   1404a:	4343      	muls	r3, r0
   1404c:	18d3      	adds	r3, r2, r3
   1404e:	185b      	adds	r3, r3, r1
   14050:	781a      	ldrb	r2, [r3, #0]
              uint8_t tab[5] = {
   14052:	193b      	adds	r3, r7, r4
   14054:	711a      	strb	r2, [r3, #4]
              };
              /* Status value */
              TLV_add(&send_tlv, GUI_IND_STATUS, 5, tab);
   14056:	193b      	adds	r3, r7, r4
   14058:	221c      	movs	r2, #28
   1405a:	18b8      	adds	r0, r7, r2
   1405c:	2205      	movs	r2, #5
   1405e:	2115      	movs	r1, #21
   14060:	f7fe fea4 	bl	12dac <TLV_add>
            }
            break;
   14064:	e0b7      	b.n	141d6 <GUI_SendNotification+0x6ee>
            }
            break;
#endif /* _VDM */
#if defined(_VCONN_SUPPORT)
          case USBPD_NOTIFY_VDM_CABLE_IDENT_RECEIVED :
            TLV_add(&send_tlv, GUI_IND_CABLE_VDO, 4, (uint8_t*)&GUI_SaveInformation[PortNum].VDM_DiscoCableIdentify.CableVDO.d32);
   14066:	230f      	movs	r3, #15
   14068:	18fb      	adds	r3, r7, r3
   1406a:	781b      	ldrb	r3, [r3, #0]
   1406c:	2294      	movs	r2, #148	; 0x94
   1406e:	4353      	muls	r3, r2
   14070:	3380      	adds	r3, #128	; 0x80
   14072:	001a      	movs	r2, r3
   14074:	4b56      	ldr	r3, [pc, #344]	; (141d0 <GUI_SendNotification+0x6e8>)
   14076:	18d3      	adds	r3, r2, r3
   14078:	3308      	adds	r3, #8
   1407a:	221c      	movs	r2, #28
   1407c:	18b8      	adds	r0, r7, r2
   1407e:	2204      	movs	r2, #4
   14080:	2119      	movs	r1, #25
   14082:	f7fe fe93 	bl	12dac <TLV_add>
            break;
   14086:	46c0      	nop			; (mov r8, r8)
   14088:	e0a5      	b.n	141d6 <GUI_SendNotification+0x6ee>
        }
      }
      else
      {
        /* Send all the indication parameters if connected */
        if (USBPD_TRUE == DPM_Params[PortNum].PE_IsConnected)
   1408a:	230f      	movs	r3, #15
   1408c:	18fb      	adds	r3, r7, r3
   1408e:	781b      	ldrb	r3, [r3, #0]
   14090:	4a4e      	ldr	r2, [pc, #312]	; (141cc <GUI_SendNotification+0x6e4>)
   14092:	009b      	lsls	r3, r3, #2
   14094:	18d3      	adds	r3, r2, r3
   14096:	785b      	ldrb	r3, [r3, #1]
   14098:	06db      	lsls	r3, r3, #27
   1409a:	0fdb      	lsrs	r3, r3, #31
   1409c:	b2db      	uxtb	r3, r3
   1409e:	2b01      	cmp	r3, #1
   140a0:	d000      	beq.n	140a4 <GUI_SendNotification+0x5bc>
   140a2:	e098      	b.n	141d6 <GUI_SendNotification+0x6ee>
        {
#if defined(_VDM)
          uint32_t index;
#endif /* _VDM */

          if (0 != GUI_SaveInformation[PortNum].NumberOfRcvSNKPDO)
   140a4:	230f      	movs	r3, #15
   140a6:	18fb      	adds	r3, r7, r3
   140a8:	781b      	ldrb	r3, [r3, #0]
   140aa:	4a49      	ldr	r2, [pc, #292]	; (141d0 <GUI_SendNotification+0x6e8>)
   140ac:	2194      	movs	r1, #148	; 0x94
   140ae:	434b      	muls	r3, r1
   140b0:	18d3      	adds	r3, r2, r3
   140b2:	333c      	adds	r3, #60	; 0x3c
   140b4:	681b      	ldr	r3, [r3, #0]
   140b6:	2b00      	cmp	r3, #0
   140b8:	d02b      	beq.n	14112 <GUI_SendNotification+0x62a>
          {
            /* NumberOfRcvSNKPDO */
            TLV_add(&send_tlv, GUI_IND_NUMBEROFRCVSNKPDO, 1, (uint8_t[]){GUI_SaveInformation[PortNum].NumberOfRcvSNKPDO});
   140ba:	240f      	movs	r4, #15
   140bc:	193b      	adds	r3, r7, r4
   140be:	781b      	ldrb	r3, [r3, #0]
   140c0:	4a43      	ldr	r2, [pc, #268]	; (141d0 <GUI_SendNotification+0x6e8>)
   140c2:	2194      	movs	r1, #148	; 0x94
   140c4:	434b      	muls	r3, r1
   140c6:	18d3      	adds	r3, r2, r3
   140c8:	333c      	adds	r3, #60	; 0x3c
   140ca:	681b      	ldr	r3, [r3, #0]
   140cc:	b2da      	uxtb	r2, r3
   140ce:	217c      	movs	r1, #124	; 0x7c
   140d0:	187b      	adds	r3, r7, r1
   140d2:	701a      	strb	r2, [r3, #0]
   140d4:	187b      	adds	r3, r7, r1
   140d6:	251c      	movs	r5, #28
   140d8:	1978      	adds	r0, r7, r5
   140da:	2201      	movs	r2, #1
   140dc:	2100      	movs	r1, #0
   140de:	f7fe fe65 	bl	12dac <TLV_add>
            /* ListOfRcvSNKPDO*/
            TLV_add(&send_tlv, GUI_IND_LISTOFRCVSNKPDO, GUI_SaveInformation[PortNum].NumberOfRcvSNKPDO * 4, (uint8_t *) GUI_SaveInformation[PortNum].ListOfRcvSNKPDO);
   140e2:	193b      	adds	r3, r7, r4
   140e4:	781b      	ldrb	r3, [r3, #0]
   140e6:	4a3a      	ldr	r2, [pc, #232]	; (141d0 <GUI_SendNotification+0x6e8>)
   140e8:	2194      	movs	r1, #148	; 0x94
   140ea:	434b      	muls	r3, r1
   140ec:	18d3      	adds	r3, r2, r3
   140ee:	333c      	adds	r3, #60	; 0x3c
   140f0:	681b      	ldr	r3, [r3, #0]
   140f2:	b29b      	uxth	r3, r3
   140f4:	009b      	lsls	r3, r3, #2
   140f6:	b299      	uxth	r1, r3
   140f8:	193b      	adds	r3, r7, r4
   140fa:	781b      	ldrb	r3, [r3, #0]
   140fc:	2294      	movs	r2, #148	; 0x94
   140fe:	4353      	muls	r3, r2
   14100:	3320      	adds	r3, #32
   14102:	001a      	movs	r2, r3
   14104:	4b32      	ldr	r3, [pc, #200]	; (141d0 <GUI_SendNotification+0x6e8>)
   14106:	18d3      	adds	r3, r2, r3
   14108:	1978      	adds	r0, r7, r5
   1410a:	000a      	movs	r2, r1
   1410c:	2104      	movs	r1, #4
   1410e:	f7fe fe4d 	bl	12dac <TLV_add>
          }
          /* RDOPosition */
          TLV_add(&send_tlv, GUI_IND_RDOPOSITION, 1, (uint8_t[]){GUI_SaveInformation[PortNum].RDOPosition});
   14112:	240f      	movs	r4, #15
   14114:	193b      	adds	r3, r7, r4
   14116:	781b      	ldrb	r3, [r3, #0]
   14118:	4a2d      	ldr	r2, [pc, #180]	; (141d0 <GUI_SendNotification+0x6e8>)
   1411a:	2194      	movs	r1, #148	; 0x94
   1411c:	434b      	muls	r3, r1
   1411e:	18d3      	adds	r3, r2, r3
   14120:	3340      	adds	r3, #64	; 0x40
   14122:	681b      	ldr	r3, [r3, #0]
   14124:	b2da      	uxtb	r2, r3
   14126:	2180      	movs	r1, #128	; 0x80
   14128:	187b      	adds	r3, r7, r1
   1412a:	701a      	strb	r2, [r3, #0]
   1412c:	187b      	adds	r3, r7, r1
   1412e:	221c      	movs	r2, #28
   14130:	18b8      	adds	r0, r7, r2
   14132:	2201      	movs	r2, #1
   14134:	2101      	movs	r1, #1
   14136:	f7fe fe39 	bl	12dac <TLV_add>
          if (USBPD_PORTPOWERROLE_SNK == DPM_Params[PortNum].PE_PowerRole)
   1413a:	193b      	adds	r3, r7, r4
   1413c:	781a      	ldrb	r2, [r3, #0]
   1413e:	4b23      	ldr	r3, [pc, #140]	; (141cc <GUI_SendNotification+0x6e4>)
   14140:	0092      	lsls	r2, r2, #2
   14142:	5cd3      	ldrb	r3, [r2, r3]
   14144:	075b      	lsls	r3, r3, #29
   14146:	0fdb      	lsrs	r3, r3, #31
   14148:	b2db      	uxtb	r3, r3
   1414a:	2b00      	cmp	r3, #0
   1414c:	d129      	bne.n	141a2 <GUI_SendNotification+0x6ba>
          {
            /* NumberOfRcvSRCPDO*/
            TLV_add(&send_tlv, GUI_IND_NUMBEROFRCVSRCPDO, 1, (uint8_t[]){GUI_SaveInformation[PortNum].NumberOfRcvSRCPDO});
   1414e:	240f      	movs	r4, #15
   14150:	193b      	adds	r3, r7, r4
   14152:	781b      	ldrb	r3, [r3, #0]
   14154:	4a1e      	ldr	r2, [pc, #120]	; (141d0 <GUI_SendNotification+0x6e8>)
   14156:	2194      	movs	r1, #148	; 0x94
   14158:	434b      	muls	r3, r1
   1415a:	18d3      	adds	r3, r2, r3
   1415c:	331c      	adds	r3, #28
   1415e:	681b      	ldr	r3, [r3, #0]
   14160:	b2da      	uxtb	r2, r3
   14162:	2184      	movs	r1, #132	; 0x84
   14164:	187b      	adds	r3, r7, r1
   14166:	701a      	strb	r2, [r3, #0]
   14168:	187b      	adds	r3, r7, r1
   1416a:	251c      	movs	r5, #28
   1416c:	1978      	adds	r0, r7, r5
   1416e:	2201      	movs	r2, #1
   14170:	2103      	movs	r1, #3
   14172:	f7fe fe1b 	bl	12dac <TLV_add>
            /* ListOfRcvSRCPDO*/
            TLV_add(&send_tlv, GUI_IND_LISTOFRCVSRCPDO, GUI_SaveInformation[PortNum].NumberOfRcvSRCPDO * 4, (uint8_t *) GUI_SaveInformation[PortNum].ListOfRcvSRCPDO);
   14176:	193b      	adds	r3, r7, r4
   14178:	781b      	ldrb	r3, [r3, #0]
   1417a:	4a15      	ldr	r2, [pc, #84]	; (141d0 <GUI_SendNotification+0x6e8>)
   1417c:	2194      	movs	r1, #148	; 0x94
   1417e:	434b      	muls	r3, r1
   14180:	18d3      	adds	r3, r2, r3
   14182:	331c      	adds	r3, #28
   14184:	681b      	ldr	r3, [r3, #0]
   14186:	b29b      	uxth	r3, r3
   14188:	009b      	lsls	r3, r3, #2
   1418a:	b299      	uxth	r1, r3
   1418c:	193b      	adds	r3, r7, r4
   1418e:	781b      	ldrb	r3, [r3, #0]
   14190:	2294      	movs	r2, #148	; 0x94
   14192:	435a      	muls	r2, r3
   14194:	4b0e      	ldr	r3, [pc, #56]	; (141d0 <GUI_SendNotification+0x6e8>)
   14196:	18d3      	adds	r3, r2, r3
   14198:	1978      	adds	r0, r7, r5
   1419a:	000a      	movs	r2, r1
   1419c:	2102      	movs	r1, #2
   1419e:	f7fe fe05 	bl	12dac <TLV_add>
          }
          /* PD_SpecRevision */
          TLV_add(&send_tlv, GUI_IND_PD_SPECREVISION, 1, (uint8_t[]){DPM_Params[PortNum].PE_SpecRevision});
   141a2:	230f      	movs	r3, #15
   141a4:	18fb      	adds	r3, r7, r3
   141a6:	781a      	ldrb	r2, [r3, #0]
   141a8:	4b08      	ldr	r3, [pc, #32]	; (141cc <GUI_SendNotification+0x6e4>)
   141aa:	0092      	lsls	r2, r2, #2
   141ac:	5cd3      	ldrb	r3, [r2, r3]
   141ae:	079b      	lsls	r3, r3, #30
   141b0:	0f9b      	lsrs	r3, r3, #30
   141b2:	b2db      	uxtb	r3, r3
   141b4:	001a      	movs	r2, r3
   141b6:	2188      	movs	r1, #136	; 0x88
   141b8:	187b      	adds	r3, r7, r1
   141ba:	701a      	strb	r2, [r3, #0]
   141bc:	187b      	adds	r3, r7, r1
   141be:	221c      	movs	r2, #28
   141c0:	18b8      	adds	r0, r7, r2
   141c2:	2201      	movs	r2, #1
   141c4:	210d      	movs	r1, #13
   141c6:	f7fe fdf1 	bl	12dac <TLV_add>
   141ca:	e004      	b.n	141d6 <GUI_SendNotification+0x6ee>
   141cc:	000321d4 	.word	0x000321d4
   141d0:	000323ec 	.word	0x000323ec
            break;
   141d4:	46c0      	nop			; (mov r8, r8)
        }
      }
    }

    /* Check if notification linked to a measure report */
    if ((TypeNotification & GUI_NOTIF_MEASUREREPORTING) == GUI_NOTIF_MEASUREREPORTING)
   141d6:	683a      	ldr	r2, [r7, #0]
   141d8:	2380      	movs	r3, #128	; 0x80
   141da:	011b      	lsls	r3, r3, #4
   141dc:	4013      	ands	r3, r2
   141de:	d046      	beq.n	1426e <GUI_SendNotification+0x786>
    {
      uint32_t vsense = 0;
   141e0:	2300      	movs	r3, #0
   141e2:	613b      	str	r3, [r7, #16]
      int32_t isense = 0;
   141e4:	2300      	movs	r3, #0
   141e6:	2298      	movs	r2, #152	; 0x98
   141e8:	18ba      	adds	r2, r7, r2
   141ea:	6013      	str	r3, [r2, #0]

      TLV_add(&send_tlv, GUI_IND_TIMESTAMP, 4, (uint8_t*)&Value);
   141ec:	231c      	movs	r3, #28
   141ee:	18f8      	adds	r0, r7, r3
   141f0:	23b0      	movs	r3, #176	; 0xb0
   141f2:	2208      	movs	r2, #8
   141f4:	4694      	mov	ip, r2
   141f6:	44bc      	add	ip, r7
   141f8:	4463      	add	r3, ip
   141fa:	2204      	movs	r2, #4
   141fc:	2113      	movs	r1, #19
   141fe:	f7fe fdd5 	bl	12dac <TLV_add>

      if (NULL != pCB_GetVoltage)
   14202:	4b5a      	ldr	r3, [pc, #360]	; (1436c <GUI_SendNotification+0x884>)
   14204:	681b      	ldr	r3, [r3, #0]
   14206:	2b00      	cmp	r3, #0
   14208:	d008      	beq.n	1421c <GUI_SendNotification+0x734>
      {
        vsense = pCB_GetVoltage(PortNum);
   1420a:	4b58      	ldr	r3, [pc, #352]	; (1436c <GUI_SendNotification+0x884>)
   1420c:	681b      	ldr	r3, [r3, #0]
   1420e:	220f      	movs	r2, #15
   14210:	18ba      	adds	r2, r7, r2
   14212:	7812      	ldrb	r2, [r2, #0]
   14214:	0010      	movs	r0, r2
   14216:	4798      	blx	r3
   14218:	0003      	movs	r3, r0
   1421a:	613b      	str	r3, [r7, #16]
      }
      if (NULL != pCB_GetVoltage)
   1421c:	4b53      	ldr	r3, [pc, #332]	; (1436c <GUI_SendNotification+0x884>)
   1421e:	681b      	ldr	r3, [r3, #0]
   14220:	2b00      	cmp	r3, #0
   14222:	d014      	beq.n	1424e <GUI_SendNotification+0x766>
      {
        isense = pCB_GetCurrent(PortNum);
   14224:	4b52      	ldr	r3, [pc, #328]	; (14370 <GUI_SendNotification+0x888>)
   14226:	681b      	ldr	r3, [r3, #0]
   14228:	220f      	movs	r2, #15
   1422a:	18ba      	adds	r2, r7, r2
   1422c:	7812      	ldrb	r2, [r2, #0]
   1422e:	0010      	movs	r0, r2
   14230:	4798      	blx	r3
   14232:	0003      	movs	r3, r0
   14234:	2298      	movs	r2, #152	; 0x98
   14236:	18b9      	adds	r1, r7, r2
   14238:	600b      	str	r3, [r1, #0]
      if(isense < 0)
   1423a:	18bb      	adds	r3, r7, r2
   1423c:	681b      	ldr	r3, [r3, #0]
   1423e:	2b00      	cmp	r3, #0
   14240:	da05      	bge.n	1424e <GUI_SendNotification+0x766>
      {
        isense = -isense;
   14242:	2298      	movs	r2, #152	; 0x98
   14244:	18bb      	adds	r3, r7, r2
   14246:	681b      	ldr	r3, [r3, #0]
   14248:	425b      	negs	r3, r3
   1424a:	18ba      	adds	r2, r7, r2
   1424c:	6013      	str	r3, [r2, #0]
      }
      }

      /* VBUS & IBUS level */
      vsense = (isense << 16) | vsense;
   1424e:	2398      	movs	r3, #152	; 0x98
   14250:	18fb      	adds	r3, r7, r3
   14252:	681b      	ldr	r3, [r3, #0]
   14254:	041b      	lsls	r3, r3, #16
   14256:	001a      	movs	r2, r3
   14258:	693b      	ldr	r3, [r7, #16]
   1425a:	4313      	orrs	r3, r2
   1425c:	613b      	str	r3, [r7, #16]
      TLV_add(&send_tlv, GUI_IND_VBUS_LEVEL, 4, (uint8_t*)&vsense);
   1425e:	2310      	movs	r3, #16
   14260:	18fb      	adds	r3, r7, r3
   14262:	221c      	movs	r2, #28
   14264:	18b8      	adds	r0, r7, r2
   14266:	2204      	movs	r2, #4
   14268:	210c      	movs	r1, #12
   1426a:	f7fe fd9f 	bl	12dac <TLV_add>
    }

    /* Check if timestamp */
    if ((TypeNotification & GUI_NOTIF_TIMESTAMP) == GUI_NOTIF_TIMESTAMP)
   1426e:	683a      	ldr	r2, [r7, #0]
   14270:	2380      	movs	r3, #128	; 0x80
   14272:	01db      	lsls	r3, r3, #7
   14274:	4013      	ands	r3, r2
   14276:	d00a      	beq.n	1428e <GUI_SendNotification+0x7a6>
    {
      TLV_add(&send_tlv, GUI_IND_TIMESTAMP, 4, (uint8_t*)&Value);
   14278:	231c      	movs	r3, #28
   1427a:	18f8      	adds	r0, r7, r3
   1427c:	23b0      	movs	r3, #176	; 0xb0
   1427e:	2208      	movs	r2, #8
   14280:	4694      	mov	ip, r2
   14282:	44bc      	add	ip, r7
   14284:	4463      	add	r3, ip
   14286:	2204      	movs	r2, #4
   14288:	2113      	movs	r1, #19
   1428a:	f7fe fd8f 	bl	12dac <TLV_add>
    }

    /* Check if power change */
    if ((TypeNotification & GUI_NOTIF_POWER_EVENT) == GUI_NOTIF_POWER_EVENT)
   1428e:	683a      	ldr	r2, [r7, #0]
   14290:	2380      	movs	r3, #128	; 0x80
   14292:	021b      	lsls	r3, r3, #8
   14294:	4013      	ands	r3, r2
   14296:	d045      	beq.n	14324 <GUI_SendNotification+0x83c>
    {
      /* Is Connected*/
      TLV_add(&send_tlv, GUI_IND_ISCONNECTED, 1, (uint8_t[]){DPM_Params[PortNum].PE_Power});
   14298:	240f      	movs	r4, #15
   1429a:	193b      	adds	r3, r7, r4
   1429c:	781b      	ldrb	r3, [r3, #0]
   1429e:	4a35      	ldr	r2, [pc, #212]	; (14374 <GUI_SendNotification+0x88c>)
   142a0:	009b      	lsls	r3, r3, #2
   142a2:	18d3      	adds	r3, r2, r3
   142a4:	785b      	ldrb	r3, [r3, #1]
   142a6:	075b      	lsls	r3, r3, #29
   142a8:	0f5b      	lsrs	r3, r3, #29
   142aa:	b2db      	uxtb	r3, r3
   142ac:	001a      	movs	r2, r3
   142ae:	218c      	movs	r1, #140	; 0x8c
   142b0:	187b      	adds	r3, r7, r1
   142b2:	701a      	strb	r2, [r3, #0]
   142b4:	187b      	adds	r3, r7, r1
   142b6:	221c      	movs	r2, #28
   142b8:	18b8      	adds	r0, r7, r2
   142ba:	2201      	movs	r2, #1
   142bc:	2105      	movs	r1, #5
   142be:	f7fe fd75 	bl	12dac <TLV_add>
      if (USBPD_POWER_NO == DPM_Params[PortNum].PE_Power)
   142c2:	193b      	adds	r3, r7, r4
   142c4:	781b      	ldrb	r3, [r3, #0]
   142c6:	4a2b      	ldr	r2, [pc, #172]	; (14374 <GUI_SendNotification+0x88c>)
   142c8:	009b      	lsls	r3, r3, #2
   142ca:	18d3      	adds	r3, r2, r3
   142cc:	785b      	ldrb	r3, [r3, #1]
   142ce:	075b      	lsls	r3, r3, #29
   142d0:	0f5b      	lsrs	r3, r3, #29
   142d2:	b2db      	uxtb	r3, r3
   142d4:	2b00      	cmp	r3, #0
   142d6:	d125      	bne.n	14324 <GUI_SendNotification+0x83c>
      {
        /* CC line */
        TLV_add(&send_tlv, GUI_IND_CC, 1, (uint8_t[]){DPM_Params[PortNum].ActiveCCIs});
   142d8:	240f      	movs	r4, #15
   142da:	193b      	adds	r3, r7, r4
   142dc:	781a      	ldrb	r2, [r3, #0]
   142de:	4b25      	ldr	r3, [pc, #148]	; (14374 <GUI_SendNotification+0x88c>)
   142e0:	0092      	lsls	r2, r2, #2
   142e2:	5cd3      	ldrb	r3, [r2, r3]
   142e4:	061b      	lsls	r3, r3, #24
   142e6:	0f9b      	lsrs	r3, r3, #30
   142e8:	b2db      	uxtb	r3, r3
   142ea:	001a      	movs	r2, r3
   142ec:	2190      	movs	r1, #144	; 0x90
   142ee:	187b      	adds	r3, r7, r1
   142f0:	701a      	strb	r2, [r3, #0]
   142f2:	187b      	adds	r3, r7, r1
   142f4:	251c      	movs	r5, #28
   142f6:	1978      	adds	r0, r7, r5
   142f8:	2201      	movs	r2, #1
   142fa:	2106      	movs	r1, #6
   142fc:	f7fe fd56 	bl	12dac <TLV_add>
        /* PowerRole*/
        TLV_add(&send_tlv, GUI_IND_POWERROLE, 1, (uint8_t[]){DPM_Params[PortNum].PE_PowerRole});
   14300:	193b      	adds	r3, r7, r4
   14302:	781a      	ldrb	r2, [r3, #0]
   14304:	4b1b      	ldr	r3, [pc, #108]	; (14374 <GUI_SendNotification+0x88c>)
   14306:	0092      	lsls	r2, r2, #2
   14308:	5cd3      	ldrb	r3, [r2, r3]
   1430a:	075b      	lsls	r3, r3, #29
   1430c:	0fdb      	lsrs	r3, r3, #31
   1430e:	b2db      	uxtb	r3, r3
   14310:	001a      	movs	r2, r3
   14312:	2194      	movs	r1, #148	; 0x94
   14314:	187b      	adds	r3, r7, r1
   14316:	701a      	strb	r2, [r3, #0]
   14318:	187b      	adds	r3, r7, r1
   1431a:	1978      	adds	r0, r7, r5
   1431c:	2201      	movs	r2, #1
   1431e:	2108      	movs	r1, #8
   14320:	f7fe fd44 	bl	12dac <TLV_add>
      }
    }

    TLV_deinit_encode(&send_tlv);
   14324:	231c      	movs	r3, #28
   14326:	18fb      	adds	r3, r7, r3
   14328:	0018      	movs	r0, r3
   1432a:	f7fe fea1 	bl	13070 <TLV_deinit_encode>

    if (0 != TLV_get_string_length(Processed))
   1432e:	4b12      	ldr	r3, [pc, #72]	; (14378 <GUI_SendNotification+0x890>)
   14330:	0018      	movs	r0, r3
   14332:	f7fe ff43 	bl	131bc <TLV_get_string_length>
   14336:	1e03      	subs	r3, r0, #0
   14338:	d010      	beq.n	1435c <GUI_SendNotification+0x874>
    {
      *pMsgToSend = Processed;
   1433a:	68bb      	ldr	r3, [r7, #8]
   1433c:	4a0e      	ldr	r2, [pc, #56]	; (14378 <GUI_SendNotification+0x890>)
   1433e:	601a      	str	r2, [r3, #0]
      *pSizeMsg = TLV_get_string_length(Processed) + 8;
   14340:	4b0d      	ldr	r3, [pc, #52]	; (14378 <GUI_SendNotification+0x890>)
   14342:	0018      	movs	r0, r3
   14344:	f7fe ff3a 	bl	131bc <TLV_get_string_length>
   14348:	0003      	movs	r3, r0
   1434a:	b2db      	uxtb	r3, r3
   1434c:	3308      	adds	r3, #8
   1434e:	b2da      	uxtb	r2, r3
   14350:	687b      	ldr	r3, [r7, #4]
   14352:	701a      	strb	r2, [r3, #0]
      gui_state = GUI_STATE_RUNNING;
   14354:	239f      	movs	r3, #159	; 0x9f
   14356:	18fb      	adds	r3, r7, r3
   14358:	2201      	movs	r2, #1
   1435a:	701a      	strb	r2, [r3, #0]

    }
  }

  return gui_state;
   1435c:	239f      	movs	r3, #159	; 0x9f
   1435e:	18fb      	adds	r3, r7, r3
   14360:	781b      	ldrb	r3, [r3, #0]
}
   14362:	0018      	movs	r0, r3
   14364:	46bd      	mov	sp, r7
   14366:	b029      	add	sp, #164	; 0xa4
   14368:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1436a:	46c0      	nop			; (mov r8, r8)
   1436c:	00031cc8 	.word	0x00031cc8
   14370:	00031ccc 	.word	0x00031ccc
   14374:	000321d4 	.word	0x000321d4
   14378:	000321d8 	.word	0x000321d8

0001437c <GUI_PostNotificationMessage>:
  * @param  PortNum   Port number
  * @param  EventVal Event vale @ref USBPD_NotifyEventValue_TypeDef
  * @retval None
  */
void GUI_PostNotificationMessage(uint8_t PortNum, uint16_t EventVal)
{
   1437c:	b590      	push	{r4, r7, lr}
   1437e:	b085      	sub	sp, #20
   14380:	af00      	add	r7, sp, #0
   14382:	0002      	movs	r2, r0
   14384:	1dfb      	adds	r3, r7, #7
   14386:	701a      	strb	r2, [r3, #0]
   14388:	1d3b      	adds	r3, r7, #4
   1438a:	1c0a      	adds	r2, r1, #0
   1438c:	801a      	strh	r2, [r3, #0]
#if defined(_SNK) || defined(_DRP)
  if (USBPD_NOTIFY_REQUEST_ACCEPTED == EventVal)
   1438e:	1d3b      	adds	r3, r7, #4
   14390:	881b      	ldrh	r3, [r3, #0]
   14392:	2b01      	cmp	r3, #1
   14394:	d12f      	bne.n	143f6 <GUI_PostNotificationMessage+0x7a>
  {
    DPM_USER_Settings[PortNum].DPM_SNKRequestedPower.OperatingVoltageInmVunits    = GUI_SaveInformation[PortNum].RequestedVoltage;
   14396:	1dfb      	adds	r3, r7, #7
   14398:	781b      	ldrb	r3, [r3, #0]
   1439a:	1dfa      	adds	r2, r7, #7
   1439c:	7810      	ldrb	r0, [r2, #0]
   1439e:	4a22      	ldr	r2, [pc, #136]	; (14428 <GUI_PostNotificationMessage+0xac>)
   143a0:	2194      	movs	r1, #148	; 0x94
   143a2:	434b      	muls	r3, r1
   143a4:	18d3      	adds	r3, r2, r3
   143a6:	3344      	adds	r3, #68	; 0x44
   143a8:	681a      	ldr	r2, [r3, #0]
   143aa:	4920      	ldr	r1, [pc, #128]	; (1442c <GUI_PostNotificationMessage+0xb0>)
   143ac:	2374      	movs	r3, #116	; 0x74
   143ae:	4343      	muls	r3, r0
   143b0:	18cb      	adds	r3, r1, r3
   143b2:	3308      	adds	r3, #8
   143b4:	601a      	str	r2, [r3, #0]
    DPM_USER_Settings[PortNum].DPM_SNKRequestedPower.OperatingPowerInmWunits      = (GUI_SaveInformation[PortNum].RequestedVoltage * GUI_SaveInformation[PortNum].RequestedCurrent) / 1000;
   143b6:	1dfb      	adds	r3, r7, #7
   143b8:	781b      	ldrb	r3, [r3, #0]
   143ba:	4a1b      	ldr	r2, [pc, #108]	; (14428 <GUI_PostNotificationMessage+0xac>)
   143bc:	2194      	movs	r1, #148	; 0x94
   143be:	434b      	muls	r3, r1
   143c0:	18d3      	adds	r3, r2, r3
   143c2:	3344      	adds	r3, #68	; 0x44
   143c4:	681a      	ldr	r2, [r3, #0]
   143c6:	1dfb      	adds	r3, r7, #7
   143c8:	781b      	ldrb	r3, [r3, #0]
   143ca:	4917      	ldr	r1, [pc, #92]	; (14428 <GUI_PostNotificationMessage+0xac>)
   143cc:	2094      	movs	r0, #148	; 0x94
   143ce:	4343      	muls	r3, r0
   143d0:	18cb      	adds	r3, r1, r3
   143d2:	3348      	adds	r3, #72	; 0x48
   143d4:	681b      	ldr	r3, [r3, #0]
   143d6:	435a      	muls	r2, r3
   143d8:	1dfb      	adds	r3, r7, #7
   143da:	781c      	ldrb	r4, [r3, #0]
   143dc:	23fa      	movs	r3, #250	; 0xfa
   143de:	0099      	lsls	r1, r3, #2
   143e0:	0010      	movs	r0, r2
   143e2:	f00a fd6f 	bl	1eec4 <__udivsi3>
   143e6:	0003      	movs	r3, r0
   143e8:	0019      	movs	r1, r3
   143ea:	4a10      	ldr	r2, [pc, #64]	; (1442c <GUI_PostNotificationMessage+0xb0>)
   143ec:	2374      	movs	r3, #116	; 0x74
   143ee:	4363      	muls	r3, r4
   143f0:	18d3      	adds	r3, r2, r3
   143f2:	3314      	adds	r3, #20
   143f4:	6019      	str	r1, [r3, #0]
  }
#endif /* _SNK || _DRP */
  
  /* Send a notitification only if GUI is running */
  if (GUI_State == GUI_STATE_RUNNING)
   143f6:	4b0e      	ldr	r3, [pc, #56]	; (14430 <GUI_PostNotificationMessage+0xb4>)
   143f8:	781b      	ldrb	r3, [r3, #0]
   143fa:	2b01      	cmp	r3, #1
   143fc:	d110      	bne.n	14420 <GUI_PostNotificationMessage+0xa4>
  {
    uint32_t event = GUI_USER_EVENT_GUI | (PortNum << GUI_PE_PORT_NUM_Pos) | (EventVal << GUI_PE_NOTIF_Pos);
   143fe:	1dfb      	adds	r3, r7, #7
   14400:	781b      	ldrb	r3, [r3, #0]
   14402:	061b      	lsls	r3, r3, #24
   14404:	2201      	movs	r2, #1
   14406:	431a      	orrs	r2, r3
   14408:	1d3b      	adds	r3, r7, #4
   1440a:	881b      	ldrh	r3, [r3, #0]
   1440c:	011b      	lsls	r3, r3, #4
   1440e:	4313      	orrs	r3, r2
   14410:	60fb      	str	r3, [r7, #12]
#if defined(_RTOS)
#if (osCMSIS < 0x20000U)
    (void)osMessagePut(GUIMsgBox, event, 0);
   14412:	4b08      	ldr	r3, [pc, #32]	; (14434 <GUI_PostNotificationMessage+0xb8>)
   14414:	681b      	ldr	r3, [r3, #0]
   14416:	68f9      	ldr	r1, [r7, #12]
   14418:	2200      	movs	r2, #0
   1441a:	0018      	movs	r0, r3
   1441c:	f7fc fb0c 	bl	10a38 <osMessagePut>
    
#else
    GUI_Flag = event;
#endif /* _RTOS */
  }
}
   14420:	46c0      	nop			; (mov r8, r8)
   14422:	46bd      	mov	sp, r7
   14424:	b005      	add	sp, #20
   14426:	bd90      	pop	{r4, r7, pc}
   14428:	000323ec 	.word	0x000323ec
   1442c:	0002fedc 	.word	0x0002fedc
   14430:	00031cbc 	.word	0x00031cbc
   14434:	000322e4 	.word	0x000322e4

00014438 <GUI_SaveInfo>:
  * @param  Ptr     Pointer on the data
  * @param  Size    Nb of bytes to be updated in GUI
  * @retval None
  */
void GUI_SaveInfo(uint8_t PortNum, uint8_t DataId, uint8_t *Ptr, uint32_t Size)
{
   14438:	b5b0      	push	{r4, r5, r7, lr}
   1443a:	b08e      	sub	sp, #56	; 0x38
   1443c:	af00      	add	r7, sp, #0
   1443e:	60ba      	str	r2, [r7, #8]
   14440:	607b      	str	r3, [r7, #4]
   14442:	230f      	movs	r3, #15
   14444:	18fb      	adds	r3, r7, r3
   14446:	1c02      	adds	r2, r0, #0
   14448:	701a      	strb	r2, [r3, #0]
   1444a:	200e      	movs	r0, #14
   1444c:	183b      	adds	r3, r7, r0
   1444e:	1c0a      	adds	r2, r1, #0
   14450:	701a      	strb	r2, [r3, #0]
  uint32_t index;

  /* Check type of information targeted by request */
  switch (DataId)
   14452:	183b      	adds	r3, r7, r0
   14454:	781b      	ldrb	r3, [r3, #0]
   14456:	2b14      	cmp	r3, #20
   14458:	d900      	bls.n	1445c <GUI_SaveInfo+0x24>
   1445a:	e111      	b.n	14680 <GUI_SaveInfo+0x248>
   1445c:	009a      	lsls	r2, r3, #2
   1445e:	4b8f      	ldr	r3, [pc, #572]	; (1469c <GUI_SaveInfo+0x264>)
   14460:	18d3      	adds	r3, r2, r3
   14462:	681b      	ldr	r3, [r3, #0]
   14464:	469f      	mov	pc, r3
  {
    /* Case requested DO position Data information :
    */
  case USBPD_CORE_DATATYPE_RDO_POSITION :
    if (Size == 4)
   14466:	687b      	ldr	r3, [r7, #4]
   14468:	2b04      	cmp	r3, #4
   1446a:	d000      	beq.n	1446e <GUI_SaveInfo+0x36>
   1446c:	e10a      	b.n	14684 <GUI_SaveInfo+0x24c>
    {
      uint8_t* temp;
      temp = (uint8_t*)&GUI_SaveInformation[PortNum].RDOPosition;
   1446e:	240f      	movs	r4, #15
   14470:	193b      	adds	r3, r7, r4
   14472:	781b      	ldrb	r3, [r3, #0]
   14474:	2294      	movs	r2, #148	; 0x94
   14476:	4353      	muls	r3, r2
   14478:	3340      	adds	r3, #64	; 0x40
   1447a:	001a      	movs	r2, r3
   1447c:	4b88      	ldr	r3, [pc, #544]	; (146a0 <GUI_SaveInfo+0x268>)
   1447e:	18d3      	adds	r3, r2, r3
   14480:	613b      	str	r3, [r7, #16]
      (void)memcpy(temp, Ptr, Size);
   14482:	687a      	ldr	r2, [r7, #4]
   14484:	68b9      	ldr	r1, [r7, #8]
   14486:	693b      	ldr	r3, [r7, #16]
   14488:	0018      	movs	r0, r3
   1448a:	f00a f903 	bl	1e694 <memcpy>
      GUI_SaveInformation[PortNum].RDOPositionPrevious = *Ptr;
   1448e:	68bb      	ldr	r3, [r7, #8]
   14490:	781a      	ldrb	r2, [r3, #0]
   14492:	193b      	adds	r3, r7, r4
   14494:	781b      	ldrb	r3, [r3, #0]
   14496:	0010      	movs	r0, r2
   14498:	4a81      	ldr	r2, [pc, #516]	; (146a0 <GUI_SaveInfo+0x268>)
   1449a:	2194      	movs	r1, #148	; 0x94
   1449c:	434b      	muls	r3, r1
   1449e:	18d3      	adds	r3, r2, r3
   144a0:	334c      	adds	r3, #76	; 0x4c
   144a2:	6018      	str	r0, [r3, #0]
      temp = (uint8_t*)&GUI_SaveInformation[PortNum].RDOPositionPrevious;
   144a4:	193b      	adds	r3, r7, r4
   144a6:	781b      	ldrb	r3, [r3, #0]
   144a8:	2294      	movs	r2, #148	; 0x94
   144aa:	4353      	muls	r3, r2
   144ac:	3348      	adds	r3, #72	; 0x48
   144ae:	001a      	movs	r2, r3
   144b0:	4b7b      	ldr	r3, [pc, #492]	; (146a0 <GUI_SaveInfo+0x268>)
   144b2:	18d3      	adds	r3, r2, r3
   144b4:	3304      	adds	r3, #4
   144b6:	613b      	str	r3, [r7, #16]
      (void)memcpy(temp, Ptr, Size);
   144b8:	687a      	ldr	r2, [r7, #4]
   144ba:	68b9      	ldr	r1, [r7, #8]
   144bc:	693b      	ldr	r3, [r7, #16]
   144be:	0018      	movs	r0, r3
   144c0:	f00a f8e8 	bl	1e694 <memcpy>
    }
    break;
   144c4:	e0de      	b.n	14684 <GUI_SaveInfo+0x24c>

    /* Case Received Source PDO values Data information :
    */
  case USBPD_CORE_DATATYPE_RCV_SRC_PDO :
    if (Size <= (USBPD_MAX_NB_PDO * 4))
   144c6:	687b      	ldr	r3, [r7, #4]
   144c8:	2b1c      	cmp	r3, #28
   144ca:	d900      	bls.n	144ce <GUI_SaveInfo+0x96>
   144cc:	e0dc      	b.n	14688 <GUI_SaveInfo+0x250>
    {
      uint8_t* rdo;
      GUI_SaveInformation[PortNum].NumberOfRcvSRCPDO = (Size / 4);
   144ce:	230f      	movs	r3, #15
   144d0:	18fb      	adds	r3, r7, r3
   144d2:	781b      	ldrb	r3, [r3, #0]
   144d4:	687a      	ldr	r2, [r7, #4]
   144d6:	0892      	lsrs	r2, r2, #2
   144d8:	4971      	ldr	r1, [pc, #452]	; (146a0 <GUI_SaveInfo+0x268>)
   144da:	2094      	movs	r0, #148	; 0x94
   144dc:	4343      	muls	r3, r0
   144de:	18cb      	adds	r3, r1, r3
   144e0:	331c      	adds	r3, #28
   144e2:	601a      	str	r2, [r3, #0]
      /* Copy PDO data in DPM Handle field */
      for (index = 0; index < (Size / 4); index++)
   144e4:	2300      	movs	r3, #0
   144e6:	637b      	str	r3, [r7, #52]	; 0x34
   144e8:	e019      	b.n	1451e <GUI_SaveInfo+0xe6>
      {
        rdo = (uint8_t*)&GUI_SaveInformation[PortNum].ListOfRcvSRCPDO[index];
   144ea:	230f      	movs	r3, #15
   144ec:	18fb      	adds	r3, r7, r3
   144ee:	781a      	ldrb	r2, [r3, #0]
   144f0:	0013      	movs	r3, r2
   144f2:	00db      	lsls	r3, r3, #3
   144f4:	189b      	adds	r3, r3, r2
   144f6:	009b      	lsls	r3, r3, #2
   144f8:	189b      	adds	r3, r3, r2
   144fa:	6b7a      	ldr	r2, [r7, #52]	; 0x34
   144fc:	189b      	adds	r3, r3, r2
   144fe:	009a      	lsls	r2, r3, #2
   14500:	4b67      	ldr	r3, [pc, #412]	; (146a0 <GUI_SaveInfo+0x268>)
   14502:	18d3      	adds	r3, r2, r3
   14504:	617b      	str	r3, [r7, #20]
        (void)memcpy(rdo, (Ptr + (index * 4u)), (4u * sizeof(uint8_t)));
   14506:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   14508:	009b      	lsls	r3, r3, #2
   1450a:	68ba      	ldr	r2, [r7, #8]
   1450c:	18d1      	adds	r1, r2, r3
   1450e:	697b      	ldr	r3, [r7, #20]
   14510:	2204      	movs	r2, #4
   14512:	0018      	movs	r0, r3
   14514:	f00a f8be 	bl	1e694 <memcpy>
      for (index = 0; index < (Size / 4); index++)
   14518:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   1451a:	3301      	adds	r3, #1
   1451c:	637b      	str	r3, [r7, #52]	; 0x34
   1451e:	687b      	ldr	r3, [r7, #4]
   14520:	089b      	lsrs	r3, r3, #2
   14522:	6b7a      	ldr	r2, [r7, #52]	; 0x34
   14524:	429a      	cmp	r2, r3
   14526:	d3e0      	bcc.n	144ea <GUI_SaveInfo+0xb2>
      }
    }
    break;
   14528:	e0ae      	b.n	14688 <GUI_SaveInfo+0x250>

    /* Case Received Sink PDO values Data information :
    */
  case USBPD_CORE_DATATYPE_RCV_SNK_PDO :
    if (Size <= (USBPD_MAX_NB_PDO * 4))
   1452a:	687b      	ldr	r3, [r7, #4]
   1452c:	2b1c      	cmp	r3, #28
   1452e:	d900      	bls.n	14532 <GUI_SaveInfo+0xfa>
   14530:	e0ac      	b.n	1468c <GUI_SaveInfo+0x254>
    {
      uint8_t* rdo;
      GUI_SaveInformation[PortNum].NumberOfRcvSNKPDO = (Size / 4);
   14532:	230f      	movs	r3, #15
   14534:	18fb      	adds	r3, r7, r3
   14536:	781b      	ldrb	r3, [r3, #0]
   14538:	687a      	ldr	r2, [r7, #4]
   1453a:	0892      	lsrs	r2, r2, #2
   1453c:	4958      	ldr	r1, [pc, #352]	; (146a0 <GUI_SaveInfo+0x268>)
   1453e:	2094      	movs	r0, #148	; 0x94
   14540:	4343      	muls	r3, r0
   14542:	18cb      	adds	r3, r1, r3
   14544:	333c      	adds	r3, #60	; 0x3c
   14546:	601a      	str	r2, [r3, #0]
      /* Copy PDO data in DPM Handle field */
      for (index = 0; index < (Size / 4); index++)
   14548:	2300      	movs	r3, #0
   1454a:	637b      	str	r3, [r7, #52]	; 0x34
   1454c:	e01a      	b.n	14584 <GUI_SaveInfo+0x14c>
      {
        rdo = (uint8_t*)&GUI_SaveInformation[PortNum].ListOfRcvSNKPDO[index];
   1454e:	230f      	movs	r3, #15
   14550:	18fb      	adds	r3, r7, r3
   14552:	781a      	ldrb	r2, [r3, #0]
   14554:	0013      	movs	r3, r2
   14556:	00db      	lsls	r3, r3, #3
   14558:	189b      	adds	r3, r3, r2
   1455a:	009b      	lsls	r3, r3, #2
   1455c:	189b      	adds	r3, r3, r2
   1455e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
   14560:	189b      	adds	r3, r3, r2
   14562:	3308      	adds	r3, #8
   14564:	009a      	lsls	r2, r3, #2
   14566:	4b4e      	ldr	r3, [pc, #312]	; (146a0 <GUI_SaveInfo+0x268>)
   14568:	18d3      	adds	r3, r2, r3
   1456a:	61bb      	str	r3, [r7, #24]
        (void)memcpy(rdo, (Ptr + (index * 4u)), (4u * sizeof(uint8_t)));
   1456c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   1456e:	009b      	lsls	r3, r3, #2
   14570:	68ba      	ldr	r2, [r7, #8]
   14572:	18d1      	adds	r1, r2, r3
   14574:	69bb      	ldr	r3, [r7, #24]
   14576:	2204      	movs	r2, #4
   14578:	0018      	movs	r0, r3
   1457a:	f00a f88b 	bl	1e694 <memcpy>
      for (index = 0; index < (Size / 4); index++)
   1457e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   14580:	3301      	adds	r3, #1
   14582:	637b      	str	r3, [r7, #52]	; 0x34
   14584:	687b      	ldr	r3, [r7, #4]
   14586:	089b      	lsrs	r3, r3, #2
   14588:	6b7a      	ldr	r2, [r7, #52]	; 0x34
   1458a:	429a      	cmp	r2, r3
   1458c:	d3df      	bcc.n	1454e <GUI_SaveInfo+0x116>
      }
    }
    break;
   1458e:	e07d      	b.n	1468c <GUI_SaveInfo+0x254>

    /* Case Received Request PDO Data information :
    */
  case USBPD_CORE_DATATYPE_RCV_REQ_PDO :
    if (Size == 4)
   14590:	687b      	ldr	r3, [r7, #4]
   14592:	2b04      	cmp	r3, #4
   14594:	d000      	beq.n	14598 <GUI_SaveInfo+0x160>
   14596:	e07b      	b.n	14690 <GUI_SaveInfo+0x258>
    {
      uint8_t* rdo;
      rdo = (uint8_t*)&GUI_SaveInformation[PortNum].RcvRequestDOMsg;
   14598:	230f      	movs	r3, #15
   1459a:	18fb      	adds	r3, r7, r3
   1459c:	781b      	ldrb	r3, [r3, #0]
   1459e:	2294      	movs	r2, #148	; 0x94
   145a0:	4353      	muls	r3, r2
   145a2:	3350      	adds	r3, #80	; 0x50
   145a4:	001a      	movs	r2, r3
   145a6:	4b3e      	ldr	r3, [pc, #248]	; (146a0 <GUI_SaveInfo+0x268>)
   145a8:	18d3      	adds	r3, r2, r3
   145aa:	61fb      	str	r3, [r7, #28]
      (void)memcpy(rdo, Ptr, Size);
   145ac:	687a      	ldr	r2, [r7, #4]
   145ae:	68b9      	ldr	r1, [r7, #8]
   145b0:	69fb      	ldr	r3, [r7, #28]
   145b2:	0018      	movs	r0, r3
   145b4:	f00a f86e 	bl	1e694 <memcpy>
    }
    break;
   145b8:	e06a      	b.n	14690 <GUI_SaveInfo+0x258>
#if defined(USBPD_REV30_SUPPORT)
#if _STATUS
  case USBPD_CORE_INFO_STATUS :
    {
      uint8_t* info_status;
      info_status = (uint8_t*)&GUI_SaveInformation[PortNum].RcvStatus;
   145ba:	230f      	movs	r3, #15
   145bc:	18fb      	adds	r3, r7, r3
   145be:	781b      	ldrb	r3, [r3, #0]
   145c0:	2294      	movs	r2, #148	; 0x94
   145c2:	4353      	muls	r3, r2
   145c4:	3350      	adds	r3, #80	; 0x50
   145c6:	001a      	movs	r2, r3
   145c8:	4b35      	ldr	r3, [pc, #212]	; (146a0 <GUI_SaveInfo+0x268>)
   145ca:	18d3      	adds	r3, r2, r3
   145cc:	3304      	adds	r3, #4
   145ce:	623b      	str	r3, [r7, #32]
      memcpy(info_status, Ptr, Size);
   145d0:	687a      	ldr	r2, [r7, #4]
   145d2:	68b9      	ldr	r1, [r7, #8]
   145d4:	6a3b      	ldr	r3, [r7, #32]
   145d6:	0018      	movs	r0, r3
   145d8:	f00a f85c 	bl	1e694 <memcpy>
    }
    break;
   145dc:	e059      	b.n	14692 <GUI_SaveInfo+0x25a>
    break;
#endif /* _SRC_CAPA_EXT */
  case USBPD_CORE_SNK_EXTENDED_CAPA :
    {
      uint8_t*  _snk_ext_capa;
      _snk_ext_capa = (uint8_t*)&GUI_SaveInformation[PortNum].RcvSNKExtendedCapa;
   145de:	230f      	movs	r3, #15
   145e0:	18fb      	adds	r3, r7, r3
   145e2:	781b      	ldrb	r3, [r3, #0]
   145e4:	2294      	movs	r2, #148	; 0x94
   145e6:	4353      	muls	r3, r2
   145e8:	3358      	adds	r3, #88	; 0x58
   145ea:	001a      	movs	r2, r3
   145ec:	4b2c      	ldr	r3, [pc, #176]	; (146a0 <GUI_SaveInfo+0x268>)
   145ee:	18d3      	adds	r3, r2, r3
   145f0:	3304      	adds	r3, #4
   145f2:	62fb      	str	r3, [r7, #44]	; 0x2c
      memcpy(_snk_ext_capa, Ptr, Size);
   145f4:	687a      	ldr	r2, [r7, #4]
   145f6:	68b9      	ldr	r1, [r7, #8]
   145f8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   145fa:	0018      	movs	r0, r3
   145fc:	f00a f84a 	bl	1e694 <memcpy>
    }
    break;
   14600:	e047      	b.n	14692 <GUI_SaveInfo+0x25a>
#if _MANU_INFO
  case USBPD_CORE_GET_MANUFACTURER_INFO:
    {
      uint8_t* temp = (uint8_t*)Ptr;
   14602:	68bb      	ldr	r3, [r7, #8]
   14604:	62bb      	str	r3, [r7, #40]	; 0x28
      GUI_SaveInformation[PortNum].GetManufacturerInfo.ManufacturerInfoTarget = *temp;
   14606:	250f      	movs	r5, #15
   14608:	197b      	adds	r3, r7, r5
   1460a:	781b      	ldrb	r3, [r3, #0]
   1460c:	6aba      	ldr	r2, [r7, #40]	; 0x28
   1460e:	7814      	ldrb	r4, [r2, #0]
   14610:	4a23      	ldr	r2, [pc, #140]	; (146a0 <GUI_SaveInfo+0x268>)
   14612:	2174      	movs	r1, #116	; 0x74
   14614:	2094      	movs	r0, #148	; 0x94
   14616:	4343      	muls	r3, r0
   14618:	18d3      	adds	r3, r2, r3
   1461a:	185b      	adds	r3, r3, r1
   1461c:	1c22      	adds	r2, r4, #0
   1461e:	701a      	strb	r2, [r3, #0]
      GUI_SaveInformation[PortNum].GetManufacturerInfo.ManufacturerInfoRef    = *(temp + 1);
   14620:	197b      	adds	r3, r7, r5
   14622:	781b      	ldrb	r3, [r3, #0]
   14624:	6aba      	ldr	r2, [r7, #40]	; 0x28
   14626:	7854      	ldrb	r4, [r2, #1]
   14628:	4a1d      	ldr	r2, [pc, #116]	; (146a0 <GUI_SaveInfo+0x268>)
   1462a:	2175      	movs	r1, #117	; 0x75
   1462c:	2094      	movs	r0, #148	; 0x94
   1462e:	4343      	muls	r3, r0
   14630:	18d3      	adds	r3, r2, r3
   14632:	185b      	adds	r3, r3, r1
   14634:	1c22      	adds	r2, r4, #0
   14636:	701a      	strb	r2, [r3, #0]
    }
    break;
   14638:	e02b      	b.n	14692 <GUI_SaveInfo+0x25a>
#endif /* _BATTERY */
#if _ALERT
    case USBPD_CORE_ALERT:
      {
        uint8_t*  alert;
        alert = (uint8_t*)&GUI_SaveInformation[PortNum].RcvAlert.d32;
   1463a:	230f      	movs	r3, #15
   1463c:	18fb      	adds	r3, r7, r3
   1463e:	781b      	ldrb	r3, [r3, #0]
   14640:	2294      	movs	r2, #148	; 0x94
   14642:	4353      	muls	r3, r2
   14644:	3378      	adds	r3, #120	; 0x78
   14646:	001a      	movs	r2, r3
   14648:	4b15      	ldr	r3, [pc, #84]	; (146a0 <GUI_SaveInfo+0x268>)
   1464a:	18d3      	adds	r3, r2, r3
   1464c:	627b      	str	r3, [r7, #36]	; 0x24
        memcpy(alert, Ptr, Size);
   1464e:	687a      	ldr	r2, [r7, #4]
   14650:	68b9      	ldr	r1, [r7, #8]
   14652:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   14654:	0018      	movs	r0, r3
   14656:	f00a f81d 	bl	1e694 <memcpy>
      }
      break;
   1465a:	e01a      	b.n	14692 <GUI_SaveInfo+0x25a>
#endif /* USBPD_REV30_SUPPORT */
#if defined(_VCONN_SUPPORT)
    case GUI_VDM_CABLE_INFO:
      {
        uint8_t*  disco_ident;
        disco_ident = (uint8_t*)&GUI_SaveInformation[PortNum].VDM_DiscoCableIdentify;
   1465c:	230f      	movs	r3, #15
   1465e:	18fb      	adds	r3, r7, r3
   14660:	781b      	ldrb	r3, [r3, #0]
   14662:	2294      	movs	r2, #148	; 0x94
   14664:	4353      	muls	r3, r2
   14666:	3378      	adds	r3, #120	; 0x78
   14668:	001a      	movs	r2, r3
   1466a:	4b0d      	ldr	r3, [pc, #52]	; (146a0 <GUI_SaveInfo+0x268>)
   1466c:	18d3      	adds	r3, r2, r3
   1466e:	3304      	adds	r3, #4
   14670:	633b      	str	r3, [r7, #48]	; 0x30
        memcpy(disco_ident, Ptr, Size);
   14672:	687a      	ldr	r2, [r7, #4]
   14674:	68b9      	ldr	r1, [r7, #8]
   14676:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   14678:	0018      	movs	r0, r3
   1467a:	f00a f80b 	bl	1e694 <memcpy>
      }
      break;
   1467e:	e008      	b.n	14692 <GUI_SaveInfo+0x25a>
#endif /* _VCONN_SUPPORT */

  /* In case of unexpected data type (Set request could not be fulfilled) :
   */
  default :
    break;
   14680:	46c0      	nop			; (mov r8, r8)
   14682:	e006      	b.n	14692 <GUI_SaveInfo+0x25a>
    break;
   14684:	46c0      	nop			; (mov r8, r8)
   14686:	e004      	b.n	14692 <GUI_SaveInfo+0x25a>
    break;
   14688:	46c0      	nop			; (mov r8, r8)
   1468a:	e002      	b.n	14692 <GUI_SaveInfo+0x25a>
    break;
   1468c:	46c0      	nop			; (mov r8, r8)
   1468e:	e000      	b.n	14692 <GUI_SaveInfo+0x25a>
    break;
   14690:	46c0      	nop			; (mov r8, r8)
  }
}
   14692:	46c0      	nop			; (mov r8, r8)
   14694:	46bd      	mov	sp, r7
   14696:	b00e      	add	sp, #56	; 0x38
   14698:	bdb0      	pop	{r4, r5, r7, pc}
   1469a:	46c0      	nop			; (mov r8, r8)
   1469c:	0001f84c 	.word	0x0001f84c
   146a0:	000323ec 	.word	0x000323ec

000146a4 <Send_DpmInitCnf>:
  * @param  PortNum   Port number
  * @param  pEncodedMsg Pointer on the message to be encoded
  * @retval None
  */
static void Send_DpmInitCnf(uint8_t PortNum, uint8_t *pEncodedMsg)
{
   146a4:	b5f0      	push	{r4, r5, r6, r7, lr}
   146a6:	b091      	sub	sp, #68	; 0x44
   146a8:	af00      	add	r7, sp, #0
   146aa:	0002      	movs	r2, r0
   146ac:	6039      	str	r1, [r7, #0]
   146ae:	1dfb      	adds	r3, r7, #7
   146b0:	701a      	strb	r2, [r3, #0]
  TLV_ToSend_Data ToSendTLV;
  TLV_init_encode(&ToSendTLV, __GUI_SET_TAG_ID(PortNum, DPM_INIT_CNF), TLV_SIZE_MAX, pEncodedMsg);
   146b2:	1dfb      	adds	r3, r7, #7
   146b4:	781b      	ldrb	r3, [r3, #0]
   146b6:	015b      	lsls	r3, r3, #5
   146b8:	b25b      	sxtb	r3, r3
   146ba:	2203      	movs	r2, #3
   146bc:	4313      	orrs	r3, r2
   146be:	b25b      	sxtb	r3, r3
   146c0:	b2d9      	uxtb	r1, r3
   146c2:	683c      	ldr	r4, [r7, #0]
   146c4:	2380      	movs	r3, #128	; 0x80
   146c6:	005a      	lsls	r2, r3, #1
   146c8:	2310      	movs	r3, #16
   146ca:	18f8      	adds	r0, r7, r3
   146cc:	0023      	movs	r3, r4
   146ce:	f7fe fb09 	bl	12ce4 <TLV_init_encode>

  /* Information by board */
  if (0 == PortNum)
   146d2:	1dfb      	adds	r3, r7, #7
   146d4:	781b      	ldrb	r3, [r3, #0]
   146d6:	2b00      	cmp	r3, #0
   146d8:	d163      	bne.n	147a2 <Send_DpmInitCnf+0xfe>
  {
    /* HWBoardVersion */
    const uint8_t* hwversion;
    if (NULL != pCB_HWBoardVersion)
   146da:	4bc2      	ldr	r3, [pc, #776]	; (149e4 <Send_DpmInitCnf+0x340>)
   146dc:	681b      	ldr	r3, [r3, #0]
   146de:	2b00      	cmp	r3, #0
   146e0:	d005      	beq.n	146ee <Send_DpmInitCnf+0x4a>
    {
      hwversion = pCB_HWBoardVersion();
   146e2:	4bc0      	ldr	r3, [pc, #768]	; (149e4 <Send_DpmInitCnf+0x340>)
   146e4:	681b      	ldr	r3, [r3, #0]
   146e6:	4798      	blx	r3
   146e8:	0003      	movs	r3, r0
   146ea:	63fb      	str	r3, [r7, #60]	; 0x3c
   146ec:	e001      	b.n	146f2 <Send_DpmInitCnf+0x4e>
    }
    else
    {
      hwversion = (uint8_t*) "UNKNOWN";
   146ee:	4bbe      	ldr	r3, [pc, #760]	; (149e8 <Send_DpmInitCnf+0x344>)
   146f0:	63fb      	str	r3, [r7, #60]	; 0x3c
    }
    TLV_add(&ToSendTLV, GUI_INIT_HWBOARDVERSION, strlen((const char*)hwversion), hwversion);
   146f2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   146f4:	0018      	movs	r0, r3
   146f6:	f00a f8b9 	bl	1e86c <strlen>
   146fa:	0003      	movs	r3, r0
   146fc:	b29a      	uxth	r2, r3
   146fe:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   14700:	2110      	movs	r1, #16
   14702:	1878      	adds	r0, r7, r1
   14704:	2100      	movs	r1, #0
   14706:	f7fe fb51 	bl	12dac <TLV_add>

    /* HWPDType */
    const uint8_t* hwpdtype;
    if (NULL != pCB_HWBoardVersion)
   1470a:	4bb6      	ldr	r3, [pc, #728]	; (149e4 <Send_DpmInitCnf+0x340>)
   1470c:	681b      	ldr	r3, [r3, #0]
   1470e:	2b00      	cmp	r3, #0
   14710:	d005      	beq.n	1471e <Send_DpmInitCnf+0x7a>
    {
      hwpdtype  = pCB_HWPDType();
   14712:	4bb6      	ldr	r3, [pc, #728]	; (149ec <Send_DpmInitCnf+0x348>)
   14714:	681b      	ldr	r3, [r3, #0]
   14716:	4798      	blx	r3
   14718:	0003      	movs	r3, r0
   1471a:	63bb      	str	r3, [r7, #56]	; 0x38
   1471c:	e001      	b.n	14722 <Send_DpmInitCnf+0x7e>
    }
    else
    {
      hwpdtype = (uint8_t*) "UNKNOWN";
   1471e:	4bb2      	ldr	r3, [pc, #712]	; (149e8 <Send_DpmInitCnf+0x344>)
   14720:	63bb      	str	r3, [r7, #56]	; 0x38
    }
    TLV_add(&ToSendTLV, GUI_INIT_HWPDTYPE, strlen((const char*)hwpdtype), hwpdtype);
   14722:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   14724:	0018      	movs	r0, r3
   14726:	f00a f8a1 	bl	1e86c <strlen>
   1472a:	0003      	movs	r3, r0
   1472c:	b29a      	uxth	r2, r3
   1472e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   14730:	2410      	movs	r4, #16
   14732:	1938      	adds	r0, r7, r4
   14734:	2101      	movs	r1, #1
   14736:	f7fe fb39 	bl	12dac <TLV_add>

    /* NbPortMax */
    TLV_add(&ToSendTLV, GUI_INIT_NBPORTMAX, 1, (uint8_t[]){USBPD_PORT_COUNT});
   1473a:	211c      	movs	r1, #28
   1473c:	187b      	adds	r3, r7, r1
   1473e:	2201      	movs	r2, #1
   14740:	701a      	strb	r2, [r3, #0]
   14742:	187b      	adds	r3, r7, r1
   14744:	1938      	adds	r0, r7, r4
   14746:	2201      	movs	r2, #1
   14748:	2102      	movs	r1, #2
   1474a:	f7fe fb2f 	bl	12dac <TLV_add>
    /* FW Version */
    TLV_add(&ToSendTLV, GUI_INIT_FWVERSION, 8, (uint8_t[]){
   1474e:	2120      	movs	r1, #32
   14750:	187b      	adds	r3, r7, r1
   14752:	4aa7      	ldr	r2, [pc, #668]	; (149f0 <Send_DpmInitCnf+0x34c>)
   14754:	ca21      	ldmia	r2!, {r0, r5}
   14756:	c321      	stmia	r3!, {r0, r5}
   14758:	187b      	adds	r3, r7, r1
   1475a:	1938      	adds	r0, r7, r4
   1475c:	2208      	movs	r2, #8
   1475e:	2103      	movs	r1, #3
   14760:	f7fe fb24 	bl	12dac <TLV_add>
        (_LIB_ID & 0x0000FF00) >> 8,
          (_LIB_ID & 0x00FF0000) >> 16,
            (_LIB_ID & 0xFF000000) >> 24}
    );
    /* Start Port number */
    TLV_add(&ToSendTLV, GUI_INIT_NB_PORT_START, 1, (uint8_t[]){USBPD_START_PORT_NUMBER});
   14764:	2128      	movs	r1, #40	; 0x28
   14766:	187b      	adds	r3, r7, r1
   14768:	2200      	movs	r2, #0
   1476a:	701a      	strb	r2, [r3, #0]
   1476c:	187b      	adds	r3, r7, r1
   1476e:	1938      	adds	r0, r7, r4
   14770:	2201      	movs	r2, #1
   14772:	211e      	movs	r1, #30
   14774:	f7fe fb1a 	bl	12dac <TLV_add>
    /* Start Port number */
    TLV_add(&ToSendTLV, GUI_INIT_NB_PORT_START, 1, (uint8_t[]){USBPD_START_PORT_NUMBER});
   14778:	212c      	movs	r1, #44	; 0x2c
   1477a:	187b      	adds	r3, r7, r1
   1477c:	2200      	movs	r2, #0
   1477e:	701a      	strb	r2, [r3, #0]
   14780:	187b      	adds	r3, r7, r1
   14782:	1938      	adds	r0, r7, r4
   14784:	2201      	movs	r2, #1
   14786:	211e      	movs	r1, #30
   14788:	f7fe fb10 	bl	12dac <TLV_add>

    /* Original settings */
    TLV_add(&ToSendTLV, GUI_INIT_ORIGINAL_SETTINGS, 1, (uint8_t*)&GUI_OriginalSettings);
   1478c:	4b99      	ldr	r3, [pc, #612]	; (149f4 <Send_DpmInitCnf+0x350>)
   1478e:	1938      	adds	r0, r7, r4
   14790:	2201      	movs	r2, #1
   14792:	211f      	movs	r1, #31
   14794:	f7fe fb0a 	bl	12dac <TLV_add>

    TLV_deinit_encode(&ToSendTLV);
   14798:	193b      	adds	r3, r7, r4
   1479a:	0018      	movs	r0, r3
   1479c:	f7fe fc68 	bl	13070 <TLV_deinit_encode>
    TLV_add(&ToSendTLV, GUI_INIT_VCONNSUPPLY, 2, (uint8_t*)&fake);
#endif /*MB1303*/

    TLV_deinit_encode(&ToSendTLV);
  }
}
   147a0:	e11c      	b.n	149dc <Send_DpmInitCnf+0x338>
    uint8_t port = PortNum - 1;
   147a2:	2637      	movs	r6, #55	; 0x37
   147a4:	19bb      	adds	r3, r7, r6
   147a6:	1dfa      	adds	r2, r7, #7
   147a8:	7812      	ldrb	r2, [r2, #0]
   147aa:	3a01      	subs	r2, #1
   147ac:	701a      	strb	r2, [r3, #0]
    settings = DPM_Settings[port].PE_SpecRevision;
   147ae:	19bb      	adds	r3, r7, r6
   147b0:	781a      	ldrb	r2, [r3, #0]
   147b2:	4991      	ldr	r1, [pc, #580]	; (149f8 <Send_DpmInitCnf+0x354>)
   147b4:	0013      	movs	r3, r2
   147b6:	005b      	lsls	r3, r3, #1
   147b8:	189b      	adds	r3, r3, r2
   147ba:	009b      	lsls	r3, r3, #2
   147bc:	18cb      	adds	r3, r1, r3
   147be:	791b      	ldrb	r3, [r3, #4]
   147c0:	079b      	lsls	r3, r3, #30
   147c2:	0f9b      	lsrs	r3, r3, #30
   147c4:	b2db      	uxtb	r3, r3
   147c6:	b29a      	uxth	r2, r3
   147c8:	240e      	movs	r4, #14
   147ca:	193b      	adds	r3, r7, r4
   147cc:	801a      	strh	r2, [r3, #0]
    TLV_add(&ToSendTLV, GUI_INIT_TYPECSPECREVISION, 2, (uint8_t[]){0x12, settings});
   147ce:	2130      	movs	r1, #48	; 0x30
   147d0:	187b      	adds	r3, r7, r1
   147d2:	2212      	movs	r2, #18
   147d4:	701a      	strb	r2, [r3, #0]
   147d6:	193b      	adds	r3, r7, r4
   147d8:	881b      	ldrh	r3, [r3, #0]
   147da:	b2da      	uxtb	r2, r3
   147dc:	187b      	adds	r3, r7, r1
   147de:	705a      	strb	r2, [r3, #1]
   147e0:	187b      	adds	r3, r7, r1
   147e2:	2510      	movs	r5, #16
   147e4:	1978      	adds	r0, r7, r5
   147e6:	2202      	movs	r2, #2
   147e8:	2104      	movs	r1, #4
   147ea:	f7fe fadf 	bl	12dac <TLV_add>
    settings = DPM_Settings[port].PE_PD3_Support.d.PE_UnchunkSupport;
   147ee:	19bb      	adds	r3, r7, r6
   147f0:	781a      	ldrb	r2, [r3, #0]
   147f2:	4981      	ldr	r1, [pc, #516]	; (149f8 <Send_DpmInitCnf+0x354>)
   147f4:	2008      	movs	r0, #8
   147f6:	0013      	movs	r3, r2
   147f8:	005b      	lsls	r3, r3, #1
   147fa:	189b      	adds	r3, r3, r2
   147fc:	009b      	lsls	r3, r3, #2
   147fe:	18cb      	adds	r3, r1, r3
   14800:	181b      	adds	r3, r3, r0
   14802:	781b      	ldrb	r3, [r3, #0]
   14804:	07db      	lsls	r3, r3, #31
   14806:	0fdb      	lsrs	r3, r3, #31
   14808:	b2db      	uxtb	r3, r3
   1480a:	b29a      	uxth	r2, r3
   1480c:	193b      	adds	r3, r7, r4
   1480e:	801a      	strh	r2, [r3, #0]
    TLV_add(&ToSendTLV, GUI_INIT_EXTENDEDMESSAGESUNCKUNKED, 1, (uint8_t*)&settings);
   14810:	193b      	adds	r3, r7, r4
   14812:	1978      	adds	r0, r7, r5
   14814:	2201      	movs	r2, #1
   14816:	2106      	movs	r1, #6
   14818:	f7fe fac8 	bl	12dac <TLV_add>
    settings = DPM_Settings[port].CAD_AccesorySupport;
   1481c:	19bb      	adds	r3, r7, r6
   1481e:	781a      	ldrb	r2, [r3, #0]
   14820:	4975      	ldr	r1, [pc, #468]	; (149f8 <Send_DpmInitCnf+0x354>)
   14822:	0013      	movs	r3, r2
   14824:	005b      	lsls	r3, r3, #1
   14826:	189b      	adds	r3, r3, r2
   14828:	009b      	lsls	r3, r3, #2
   1482a:	18cb      	adds	r3, r1, r3
   1482c:	795b      	ldrb	r3, [r3, #5]
   1482e:	06db      	lsls	r3, r3, #27
   14830:	0fdb      	lsrs	r3, r3, #31
   14832:	b2db      	uxtb	r3, r3
   14834:	b29a      	uxth	r2, r3
   14836:	193b      	adds	r3, r7, r4
   14838:	801a      	strh	r2, [r3, #0]
    TLV_add(&ToSendTLV, GUI_INIT_ACCESSORYSUPP, 1, (uint8_t*)&settings);
   1483a:	193b      	adds	r3, r7, r4
   1483c:	1978      	adds	r0, r7, r5
   1483e:	2201      	movs	r2, #1
   14840:	2107      	movs	r1, #7
   14842:	f7fe fab3 	bl	12dac <TLV_add>
    settings = DPM_USER_Settings[port].PWR_AccessoryDetection;
   14846:	19bb      	adds	r3, r7, r6
   14848:	781b      	ldrb	r3, [r3, #0]
   1484a:	4a6c      	ldr	r2, [pc, #432]	; (149fc <Send_DpmInitCnf+0x358>)
   1484c:	2168      	movs	r1, #104	; 0x68
   1484e:	2074      	movs	r0, #116	; 0x74
   14850:	4343      	muls	r3, r0
   14852:	18d3      	adds	r3, r2, r3
   14854:	185b      	adds	r3, r3, r1
   14856:	78db      	ldrb	r3, [r3, #3]
   14858:	07db      	lsls	r3, r3, #31
   1485a:	0fdb      	lsrs	r3, r3, #31
   1485c:	b2db      	uxtb	r3, r3
   1485e:	b29a      	uxth	r2, r3
   14860:	193b      	adds	r3, r7, r4
   14862:	801a      	strh	r2, [r3, #0]
    TLV_add(&ToSendTLV, GUI_INIT_POWERACCESSORYDETECTION, 1, (uint8_t*)&settings);
   14864:	193b      	adds	r3, r7, r4
   14866:	1978      	adds	r0, r7, r5
   14868:	2201      	movs	r2, #1
   1486a:	2108      	movs	r1, #8
   1486c:	f7fe fa9e 	bl	12dac <TLV_add>
    settings = DPM_USER_Settings[port].PWR_AccessoryTransition;
   14870:	19bb      	adds	r3, r7, r6
   14872:	781b      	ldrb	r3, [r3, #0]
   14874:	4a61      	ldr	r2, [pc, #388]	; (149fc <Send_DpmInitCnf+0x358>)
   14876:	2168      	movs	r1, #104	; 0x68
   14878:	2074      	movs	r0, #116	; 0x74
   1487a:	4343      	muls	r3, r0
   1487c:	18d3      	adds	r3, r2, r3
   1487e:	185b      	adds	r3, r3, r1
   14880:	78db      	ldrb	r3, [r3, #3]
   14882:	079b      	lsls	r3, r3, #30
   14884:	0fdb      	lsrs	r3, r3, #31
   14886:	b2db      	uxtb	r3, r3
   14888:	b29a      	uxth	r2, r3
   1488a:	193b      	adds	r3, r7, r4
   1488c:	801a      	strh	r2, [r3, #0]
    TLV_add(&ToSendTLV, GUI_INIT_POWERACCESSORYTRANSITION, 1, (uint8_t*)&settings);
   1488e:	193b      	adds	r3, r7, r4
   14890:	1978      	adds	r0, r7, r5
   14892:	2201      	movs	r2, #1
   14894:	2109      	movs	r1, #9
   14896:	f7fe fa89 	bl	12dac <TLV_add>
    TLV_add(&ToSendTLV, GUI_INIT_ISCABLE, 1, (uint8_t[]){0x00});
   1489a:	2134      	movs	r1, #52	; 0x34
   1489c:	187b      	adds	r3, r7, r1
   1489e:	2200      	movs	r2, #0
   148a0:	701a      	strb	r2, [r3, #0]
   148a2:	187b      	adds	r3, r7, r1
   148a4:	1978      	adds	r0, r7, r5
   148a6:	2201      	movs	r2, #1
   148a8:	210b      	movs	r1, #11
   148aa:	f7fe fa7f 	bl	12dac <TLV_add>
    settings = DPM_Settings[port].CAD_TryFeature;
   148ae:	19bb      	adds	r3, r7, r6
   148b0:	781a      	ldrb	r2, [r3, #0]
   148b2:	4951      	ldr	r1, [pc, #324]	; (149f8 <Send_DpmInitCnf+0x354>)
   148b4:	0013      	movs	r3, r2
   148b6:	005b      	lsls	r3, r3, #1
   148b8:	189b      	adds	r3, r3, r2
   148ba:	009b      	lsls	r3, r3, #2
   148bc:	18cb      	adds	r3, r1, r3
   148be:	795b      	ldrb	r3, [r3, #5]
   148c0:	071b      	lsls	r3, r3, #28
   148c2:	0f9b      	lsrs	r3, r3, #30
   148c4:	b2db      	uxtb	r3, r3
   148c6:	b29a      	uxth	r2, r3
   148c8:	193b      	adds	r3, r7, r4
   148ca:	801a      	strh	r2, [r3, #0]
    TLV_add(&ToSendTLV, GUI_INIT_TRYFEATURE, 1, (uint8_t*)&settings);
   148cc:	193b      	adds	r3, r7, r4
   148ce:	1978      	adds	r0, r7, r5
   148d0:	2201      	movs	r2, #1
   148d2:	2110      	movs	r1, #16
   148d4:	f7fe fa6a 	bl	12dac <TLV_add>
    settings = DPM_USER_Settings[port].PWR_RpResistorValue;
   148d8:	19bb      	adds	r3, r7, r6
   148da:	781b      	ldrb	r3, [r3, #0]
   148dc:	4a47      	ldr	r2, [pc, #284]	; (149fc <Send_DpmInitCnf+0x358>)
   148de:	2168      	movs	r1, #104	; 0x68
   148e0:	2074      	movs	r0, #116	; 0x74
   148e2:	4343      	muls	r3, r0
   148e4:	18d3      	adds	r3, r2, r3
   148e6:	185b      	adds	r3, r3, r1
   148e8:	78db      	ldrb	r3, [r3, #3]
   148ea:	06db      	lsls	r3, r3, #27
   148ec:	0f9b      	lsrs	r3, r3, #30
   148ee:	b2db      	uxtb	r3, r3
   148f0:	b29a      	uxth	r2, r3
   148f2:	193b      	adds	r3, r7, r4
   148f4:	801a      	strh	r2, [r3, #0]
    TLV_add(&ToSendTLV, GUI_INIT_RPRESISTORVALUE, 1, (uint8_t*)&settings);
   148f6:	193b      	adds	r3, r7, r4
   148f8:	1978      	adds	r0, r7, r5
   148fa:	2201      	movs	r2, #1
   148fc:	2112      	movs	r1, #18
   148fe:	f7fe fa55 	bl	12dac <TLV_add>
    settings = DPM_USER_Settings[port].USB_Support;
   14902:	19bb      	adds	r3, r7, r6
   14904:	781b      	ldrb	r3, [r3, #0]
   14906:	4a3d      	ldr	r2, [pc, #244]	; (149fc <Send_DpmInitCnf+0x358>)
   14908:	2168      	movs	r1, #104	; 0x68
   1490a:	2074      	movs	r0, #116	; 0x74
   1490c:	4343      	muls	r3, r0
   1490e:	18d3      	adds	r3, r2, r3
   14910:	185b      	adds	r3, r3, r1
   14912:	78db      	ldrb	r3, [r3, #3]
   14914:	069b      	lsls	r3, r3, #26
   14916:	0fdb      	lsrs	r3, r3, #31
   14918:	b2db      	uxtb	r3, r3
   1491a:	b29a      	uxth	r2, r3
   1491c:	193b      	adds	r3, r7, r4
   1491e:	801a      	strh	r2, [r3, #0]
    TLV_add(&ToSendTLV, GUI_INIT_USBSUPPORT, 1, (uint8_t*)&settings);
   14920:	193b      	adds	r3, r7, r4
   14922:	1978      	adds	r0, r7, r5
   14924:	2201      	movs	r2, #1
   14926:	2113      	movs	r1, #19
   14928:	f7fe fa40 	bl	12dac <TLV_add>
    settings = DPM_USER_Settings[port].USB_Device;
   1492c:	19bb      	adds	r3, r7, r6
   1492e:	781b      	ldrb	r3, [r3, #0]
   14930:	4a32      	ldr	r2, [pc, #200]	; (149fc <Send_DpmInitCnf+0x358>)
   14932:	2168      	movs	r1, #104	; 0x68
   14934:	2074      	movs	r0, #116	; 0x74
   14936:	4343      	muls	r3, r0
   14938:	18d3      	adds	r3, r2, r3
   1493a:	185b      	adds	r3, r3, r1
   1493c:	78db      	ldrb	r3, [r3, #3]
   1493e:	065b      	lsls	r3, r3, #25
   14940:	0fdb      	lsrs	r3, r3, #31
   14942:	b2db      	uxtb	r3, r3
   14944:	b29a      	uxth	r2, r3
   14946:	193b      	adds	r3, r7, r4
   14948:	801a      	strh	r2, [r3, #0]
    TLV_add(&ToSendTLV, GUI_INIT_USBDEVICE, 1, (uint8_t*)&settings);
   1494a:	193b      	adds	r3, r7, r4
   1494c:	1978      	adds	r0, r7, r5
   1494e:	2201      	movs	r2, #1
   14950:	2114      	movs	r1, #20
   14952:	f7fe fa2b 	bl	12dac <TLV_add>
    settings = DPM_USER_Settings[port].USB_Host;
   14956:	19bb      	adds	r3, r7, r6
   14958:	781b      	ldrb	r3, [r3, #0]
   1495a:	4a28      	ldr	r2, [pc, #160]	; (149fc <Send_DpmInitCnf+0x358>)
   1495c:	2168      	movs	r1, #104	; 0x68
   1495e:	2074      	movs	r0, #116	; 0x74
   14960:	4343      	muls	r3, r0
   14962:	18d3      	adds	r3, r2, r3
   14964:	185b      	adds	r3, r3, r1
   14966:	78db      	ldrb	r3, [r3, #3]
   14968:	061b      	lsls	r3, r3, #24
   1496a:	0fdb      	lsrs	r3, r3, #31
   1496c:	b2db      	uxtb	r3, r3
   1496e:	b29a      	uxth	r2, r3
   14970:	193b      	adds	r3, r7, r4
   14972:	801a      	strh	r2, [r3, #0]
    TLV_add(&ToSendTLV, GUI_INIT_USBHOST, 1, (uint8_t*)&settings);
   14974:	193b      	adds	r3, r7, r4
   14976:	1978      	adds	r0, r7, r5
   14978:	2201      	movs	r2, #1
   1497a:	2115      	movs	r1, #21
   1497c:	f7fe fa16 	bl	12dac <TLV_add>
    settings = DPM_USER_Settings[port].PWR_UnconstrainedPower;
   14980:	19bb      	adds	r3, r7, r6
   14982:	781b      	ldrb	r3, [r3, #0]
   14984:	4a1d      	ldr	r2, [pc, #116]	; (149fc <Send_DpmInitCnf+0x358>)
   14986:	2168      	movs	r1, #104	; 0x68
   14988:	2074      	movs	r0, #116	; 0x74
   1498a:	4343      	muls	r3, r0
   1498c:	18d3      	adds	r3, r2, r3
   1498e:	185b      	adds	r3, r3, r1
   14990:	78db      	ldrb	r3, [r3, #3]
   14992:	075b      	lsls	r3, r3, #29
   14994:	0fdb      	lsrs	r3, r3, #31
   14996:	b2db      	uxtb	r3, r3
   14998:	b29a      	uxth	r2, r3
   1499a:	193b      	adds	r3, r7, r4
   1499c:	801a      	strh	r2, [r3, #0]
    TLV_add(&ToSendTLV, GUI_INIT_UNCONSTRAINED_POWERED, 1, (uint8_t*)&settings);
   1499e:	193b      	adds	r3, r7, r4
   149a0:	1978      	adds	r0, r7, r5
   149a2:	2201      	movs	r2, #1
   149a4:	2116      	movs	r1, #22
   149a6:	f7fe fa01 	bl	12dac <TLV_add>
    settings = DPM_USER_Settings[port].USB_SuspendSupport;
   149aa:	19bb      	adds	r3, r7, r6
   149ac:	781b      	ldrb	r3, [r3, #0]
   149ae:	4a13      	ldr	r2, [pc, #76]	; (149fc <Send_DpmInitCnf+0x358>)
   149b0:	2168      	movs	r1, #104	; 0x68
   149b2:	2074      	movs	r0, #116	; 0x74
   149b4:	4343      	muls	r3, r0
   149b6:	18d3      	adds	r3, r2, r3
   149b8:	185b      	adds	r3, r3, r1
   149ba:	791b      	ldrb	r3, [r3, #4]
   149bc:	07db      	lsls	r3, r3, #31
   149be:	0fdb      	lsrs	r3, r3, #31
   149c0:	b2db      	uxtb	r3, r3
   149c2:	b29a      	uxth	r2, r3
   149c4:	193b      	adds	r3, r7, r4
   149c6:	801a      	strh	r2, [r3, #0]
    TLV_add(&ToSendTLV, GUI_INIT_USBSUSPENDSUPPORT, 1, (uint8_t*)&settings);
   149c8:	193b      	adds	r3, r7, r4
   149ca:	1978      	adds	r0, r7, r5
   149cc:	2201      	movs	r2, #1
   149ce:	2117      	movs	r1, #23
   149d0:	f7fe f9ec 	bl	12dac <TLV_add>
    TLV_deinit_encode(&ToSendTLV);
   149d4:	197b      	adds	r3, r7, r5
   149d6:	0018      	movs	r0, r3
   149d8:	f7fe fb4a 	bl	13070 <TLV_deinit_encode>
}
   149dc:	46c0      	nop			; (mov r8, r8)
   149de:	46bd      	mov	sp, r7
   149e0:	b011      	add	sp, #68	; 0x44
   149e2:	bdf0      	pop	{r4, r5, r6, r7, pc}
   149e4:	00031cc0 	.word	0x00031cc0
   149e8:	0001f66c 	.word	0x0001f66c
   149ec:	00031cc4 	.word	0x00031cc4
   149f0:	0001f674 	.word	0x0001f674
   149f4:	000323e8 	.word	0x000323e8
   149f8:	0002fec8 	.word	0x0002fec8
   149fc:	0002fedc 	.word	0x0002fedc

00014a00 <Request_MessageReq>:
/**
  * @brief      Execution of the message received
  * @note       Generation of a TLV instruction to send in the context of DPM_MESSAGE
  */
static void Request_MessageReq(uint8_t PortNum, uint8_t* instruction, uint8_t *pEncodedMsg)
{
   14a00:	b5b0      	push	{r4, r5, r7, lr}
   14a02:	b094      	sub	sp, #80	; 0x50
   14a04:	af00      	add	r7, sp, #0
   14a06:	60b9      	str	r1, [r7, #8]
   14a08:	607a      	str	r2, [r7, #4]
   14a0a:	240f      	movs	r4, #15
   14a0c:	193b      	adds	r3, r7, r4
   14a0e:	1c02      	adds	r2, r0, #0
   14a10:	701a      	strb	r2, [r3, #0]
  USBPD_StatusTypeDef status = USBPD_ERROR;
   14a12:	234f      	movs	r3, #79	; 0x4f
   14a14:	18fb      	adds	r3, r7, r3
   14a16:	2202      	movs	r2, #2
   14a18:	701a      	strb	r2, [r3, #0]
  TLV_Received_Data process_tlv;
  TLV_ToSend_Data send_tlv;

  TLV_init_decode(&process_tlv, instruction);
   14a1a:	68ba      	ldr	r2, [r7, #8]
   14a1c:	252c      	movs	r5, #44	; 0x2c
   14a1e:	197b      	adds	r3, r7, r5
   14a20:	0011      	movs	r1, r2
   14a22:	0018      	movs	r0, r3
   14a24:	f7fe fb36 	bl	13094 <TLV_init_decode>
  TLV_init_encode(&send_tlv, __GUI_SET_TAG_ID((PortNum + 1), DPM_MESSAGE_CNF), TLV_SIZE_MAX, pEncodedMsg);
   14a28:	193b      	adds	r3, r7, r4
   14a2a:	781b      	ldrb	r3, [r3, #0]
   14a2c:	3301      	adds	r3, #1
   14a2e:	015b      	lsls	r3, r3, #5
   14a30:	b25b      	sxtb	r3, r3
   14a32:	220a      	movs	r2, #10
   14a34:	4313      	orrs	r3, r2
   14a36:	b25b      	sxtb	r3, r3
   14a38:	b2d9      	uxtb	r1, r3
   14a3a:	687c      	ldr	r4, [r7, #4]
   14a3c:	2380      	movs	r3, #128	; 0x80
   14a3e:	005a      	lsls	r2, r3, #1
   14a40:	2320      	movs	r3, #32
   14a42:	18f8      	adds	r0, r7, r3
   14a44:	0023      	movs	r3, r4
   14a46:	f7fe f94d 	bl	12ce4 <TLV_init_encode>

  /*
    In case there is an error, we use this variable to know when to send a DPM_MESSAGE_REJ
    instead of a DPM_MESSAGE_CNF. This variable contains the cause if there is one.
  */
  USBPD_GUI_Reject_Reason error = GUI_REJ_DPM_REJECT;
   14a4a:	231f      	movs	r3, #31
   14a4c:	18fb      	adds	r3, r7, r3
   14a4e:	2200      	movs	r2, #0
   14a50:	701a      	strb	r2, [r3, #0]

  uint8_t tag;
  uint16_t length;
  uint8_t *value;
  TLV_get(&process_tlv, &tag, &length, &value);
   14a52:	2318      	movs	r3, #24
   14a54:	18fb      	adds	r3, r7, r3
   14a56:	221c      	movs	r2, #28
   14a58:	18ba      	adds	r2, r7, r2
   14a5a:	241e      	movs	r4, #30
   14a5c:	1939      	adds	r1, r7, r4
   14a5e:	1978      	adds	r0, r7, r5
   14a60:	f7fe fb44 	bl	130ec <TLV_get>
  switch(tag)
   14a64:	193b      	adds	r3, r7, r4
   14a66:	781b      	ldrb	r3, [r3, #0]
   14a68:	2b2b      	cmp	r3, #43	; 0x2b
   14a6a:	d901      	bls.n	14a70 <Request_MessageReq+0x70>
   14a6c:	f000 fc8e 	bl	1538c <Request_MessageReq+0x98c>
   14a70:	009a      	lsls	r2, r3, #2
   14a72:	4be6      	ldr	r3, [pc, #920]	; (14e0c <Request_MessageReq+0x40c>)
   14a74:	18d3      	adds	r3, r2, r3
   14a76:	681b      	ldr	r3, [r3, #0]
   14a78:	469f      	mov	pc, r3
      - If there is an error, set the error variable according to it (cf USBPD_GUI_Specification)
      - Otherwise in case of success, do nothing else
    */
  {
  case GUI_MSG_GOTOMIN :
    status = USBPD_DPM_RequestGotoMin(PortNum);
   14a7a:	234f      	movs	r3, #79	; 0x4f
   14a7c:	18fc      	adds	r4, r7, r3
   14a7e:	230f      	movs	r3, #15
   14a80:	18fb      	adds	r3, r7, r3
   14a82:	781b      	ldrb	r3, [r3, #0]
   14a84:	0018      	movs	r0, r3
   14a86:	f7f4 fda8 	bl	95da <USBPD_DPM_RequestGotoMin>
   14a8a:	0003      	movs	r3, r0
   14a8c:	7023      	strb	r3, [r4, #0]
    break;
   14a8e:	f000 fcb0 	bl	153f2 <Request_MessageReq+0x9f2>
  case GUI_MSG_PING :
    status = USBPD_DPM_RequestPing(PortNum);
   14a92:	234f      	movs	r3, #79	; 0x4f
   14a94:	18fc      	adds	r4, r7, r3
   14a96:	230f      	movs	r3, #15
   14a98:	18fb      	adds	r3, r7, r3
   14a9a:	781b      	ldrb	r3, [r3, #0]
   14a9c:	0018      	movs	r0, r3
   14a9e:	f7f4 fdae 	bl	95fe <USBPD_DPM_RequestPing>
   14aa2:	0003      	movs	r3, r0
   14aa4:	7023      	strb	r3, [r4, #0]
    break;
   14aa6:	f000 fca4 	bl	153f2 <Request_MessageReq+0x9f2>
  case GUI_MSG_GET_SRC_CAPA :
    status = USBPD_DPM_RequestGetSourceCapability(PortNum);
   14aaa:	234f      	movs	r3, #79	; 0x4f
   14aac:	18fc      	adds	r4, r7, r3
   14aae:	230f      	movs	r3, #15
   14ab0:	18fb      	adds	r3, r7, r3
   14ab2:	781b      	ldrb	r3, [r3, #0]
   14ab4:	0018      	movs	r0, r3
   14ab6:	f7f4 fe47 	bl	9748 <USBPD_DPM_RequestGetSourceCapability>
   14aba:	0003      	movs	r3, r0
   14abc:	7023      	strb	r3, [r4, #0]
    break;
   14abe:	f000 fc98 	bl	153f2 <Request_MessageReq+0x9f2>
  case GUI_MSG_GET_SNK_CAPA :
    status = USBPD_DPM_RequestGetSinkCapability(PortNum);
   14ac2:	234f      	movs	r3, #79	; 0x4f
   14ac4:	18fc      	adds	r4, r7, r3
   14ac6:	230f      	movs	r3, #15
   14ac8:	18fb      	adds	r3, r7, r3
   14aca:	781b      	ldrb	r3, [r3, #0]
   14acc:	0018      	movs	r0, r3
   14ace:	f7f4 fe4d 	bl	976c <USBPD_DPM_RequestGetSinkCapability>
   14ad2:	0003      	movs	r3, r0
   14ad4:	7023      	strb	r3, [r4, #0]
    break;
   14ad6:	f000 fc8c 	bl	153f2 <Request_MessageReq+0x9f2>
  case GUI_MSG_DR_SWAP :
    status = USBPD_DPM_RequestDataRoleSwap(PortNum);
   14ada:	234f      	movs	r3, #79	; 0x4f
   14adc:	18fc      	adds	r4, r7, r3
   14ade:	230f      	movs	r3, #15
   14ae0:	18fb      	adds	r3, r7, r3
   14ae2:	781b      	ldrb	r3, [r3, #0]
   14ae4:	0018      	movs	r0, r3
   14ae6:	f7f4 fe53 	bl	9790 <USBPD_DPM_RequestDataRoleSwap>
   14aea:	0003      	movs	r3, r0
   14aec:	7023      	strb	r3, [r4, #0]
    break;
   14aee:	f000 fc80 	bl	153f2 <Request_MessageReq+0x9f2>
  case GUI_MSG_PR_SWAP :
    status = USBPD_DPM_RequestPowerRoleSwap(PortNum);
   14af2:	234f      	movs	r3, #79	; 0x4f
   14af4:	18fc      	adds	r4, r7, r3
   14af6:	230f      	movs	r3, #15
   14af8:	18fb      	adds	r3, r7, r3
   14afa:	781b      	ldrb	r3, [r3, #0]
   14afc:	0018      	movs	r0, r3
   14afe:	f7f4 fe59 	bl	97b4 <USBPD_DPM_RequestPowerRoleSwap>
   14b02:	0003      	movs	r3, r0
   14b04:	7023      	strb	r3, [r4, #0]
    break;
   14b06:	f000 fc74 	bl	153f2 <Request_MessageReq+0x9f2>
  case GUI_MSG_VCONN_SWAP :
    status = USBPD_DPM_RequestVconnSwap(PortNum);
   14b0a:	234f      	movs	r3, #79	; 0x4f
   14b0c:	18fc      	adds	r4, r7, r3
   14b0e:	230f      	movs	r3, #15
   14b10:	18fb      	adds	r3, r7, r3
   14b12:	781b      	ldrb	r3, [r3, #0]
   14b14:	0018      	movs	r0, r3
   14b16:	f7f4 fe5f 	bl	97d8 <USBPD_DPM_RequestVconnSwap>
   14b1a:	0003      	movs	r3, r0
   14b1c:	7023      	strb	r3, [r4, #0]
    break;
   14b1e:	f000 fc68 	bl	153f2 <Request_MessageReq+0x9f2>
  case GUI_MSG_SOURCE_CAPA :
    status = USBPD_DPM_RequestSourceCapability(PortNum);
   14b22:	234f      	movs	r3, #79	; 0x4f
   14b24:	18fc      	adds	r4, r7, r3
   14b26:	230f      	movs	r3, #15
   14b28:	18fb      	adds	r3, r7, r3
   14b2a:	781b      	ldrb	r3, [r3, #0]
   14b2c:	0018      	movs	r0, r3
   14b2e:	f7f4 fe7b 	bl	9828 <USBPD_DPM_RequestSourceCapability>
   14b32:	0003      	movs	r3, r0
   14b34:	7023      	strb	r3, [r4, #0]
    break;
   14b36:	f000 fc5c 	bl	153f2 <Request_MessageReq+0x9f2>
  case GUI_MSG_REQUEST :
    {
      uint16_t voltage = 0;
   14b3a:	234c      	movs	r3, #76	; 0x4c
   14b3c:	18fb      	adds	r3, r7, r3
   14b3e:	2200      	movs	r2, #0
   14b40:	801a      	strh	r2, [r3, #0]
      uint8_t nb_expected_tag = 0;
   14b42:	234b      	movs	r3, #75	; 0x4b
   14b44:	18fb      	adds	r3, r7, r3
   14b46:	2200      	movs	r2, #0
   14b48:	701a      	strb	r2, [r3, #0]
      uint8_t index_pdo = 0;
   14b4a:	234a      	movs	r3, #74	; 0x4a
   14b4c:	18fb      	adds	r3, r7, r3
   14b4e:	2200      	movs	r2, #0
   14b50:	701a      	strb	r2, [r3, #0]
      if (length > TLV_SIZE_MAX) break;
   14b52:	231c      	movs	r3, #28
   14b54:	18fb      	adds	r3, r7, r3
   14b56:	881a      	ldrh	r2, [r3, #0]
   14b58:	2380      	movs	r3, #128	; 0x80
   14b5a:	005b      	lsls	r3, r3, #1
   14b5c:	429a      	cmp	r2, r3
   14b5e:	d901      	bls.n	14b64 <Request_MessageReq+0x164>
   14b60:	f000 fc16 	bl	15390 <Request_MessageReq+0x990>
      TLV_get(&process_tlv, &tag, &length, &value);
   14b64:	2318      	movs	r3, #24
   14b66:	18fb      	adds	r3, r7, r3
   14b68:	221c      	movs	r2, #28
   14b6a:	18ba      	adds	r2, r7, r2
   14b6c:	211e      	movs	r1, #30
   14b6e:	1879      	adds	r1, r7, r1
   14b70:	202c      	movs	r0, #44	; 0x2c
   14b72:	1838      	adds	r0, r7, r0
   14b74:	f7fe faba 	bl	130ec <TLV_get>
      while((0 != length) && (TLV_SIZE_MAX > length) && (nb_expected_tag < 2))
   14b78:	e02c      	b.n	14bd4 <Request_MessageReq+0x1d4>
      {
        nb_expected_tag++;
   14b7a:	214b      	movs	r1, #75	; 0x4b
   14b7c:	187b      	adds	r3, r7, r1
   14b7e:	781a      	ldrb	r2, [r3, #0]
   14b80:	187b      	adds	r3, r7, r1
   14b82:	3201      	adds	r2, #1
   14b84:	701a      	strb	r2, [r3, #0]
        if (GUI_PARAM_MSG_RDOPOSITION == (USBPD_GUI_Tag_ParamMsg)tag)
   14b86:	231e      	movs	r3, #30
   14b88:	18fb      	adds	r3, r7, r3
   14b8a:	781b      	ldrb	r3, [r3, #0]
   14b8c:	2b01      	cmp	r3, #1
   14b8e:	d105      	bne.n	14b9c <Request_MessageReq+0x19c>
        {
          index_pdo = value[0];
   14b90:	69ba      	ldr	r2, [r7, #24]
   14b92:	234a      	movs	r3, #74	; 0x4a
   14b94:	18fb      	adds	r3, r7, r3
   14b96:	7812      	ldrb	r2, [r2, #0]
   14b98:	701a      	strb	r2, [r3, #0]
   14b9a:	e011      	b.n	14bc0 <Request_MessageReq+0x1c0>
        }
        else if (GUI_PARAM_MSG_REQUESTEDVOLTAGE == (USBPD_GUI_Tag_ParamMsg)tag)
   14b9c:	231e      	movs	r3, #30
   14b9e:	18fb      	adds	r3, r7, r3
   14ba0:	781b      	ldrb	r3, [r3, #0]
   14ba2:	2b02      	cmp	r3, #2
   14ba4:	d10c      	bne.n	14bc0 <Request_MessageReq+0x1c0>
        {
          voltage = LE16(&value[0]);
   14ba6:	69bb      	ldr	r3, [r7, #24]
   14ba8:	781b      	ldrb	r3, [r3, #0]
   14baa:	b299      	uxth	r1, r3
   14bac:	69bb      	ldr	r3, [r7, #24]
   14bae:	3301      	adds	r3, #1
   14bb0:	781b      	ldrb	r3, [r3, #0]
   14bb2:	b29b      	uxth	r3, r3
   14bb4:	021b      	lsls	r3, r3, #8
   14bb6:	b29a      	uxth	r2, r3
   14bb8:	234c      	movs	r3, #76	; 0x4c
   14bba:	18fb      	adds	r3, r7, r3
   14bbc:	188a      	adds	r2, r1, r2
   14bbe:	801a      	strh	r2, [r3, #0]
        }
        TLV_get(&process_tlv, &tag, &length, &value);
   14bc0:	2318      	movs	r3, #24
   14bc2:	18fb      	adds	r3, r7, r3
   14bc4:	221c      	movs	r2, #28
   14bc6:	18ba      	adds	r2, r7, r2
   14bc8:	211e      	movs	r1, #30
   14bca:	1879      	adds	r1, r7, r1
   14bcc:	202c      	movs	r0, #44	; 0x2c
   14bce:	1838      	adds	r0, r7, r0
   14bd0:	f7fe fa8c 	bl	130ec <TLV_get>
      while((0 != length) && (TLV_SIZE_MAX > length) && (nb_expected_tag < 2))
   14bd4:	231c      	movs	r3, #28
   14bd6:	18fb      	adds	r3, r7, r3
   14bd8:	881b      	ldrh	r3, [r3, #0]
   14bda:	2b00      	cmp	r3, #0
   14bdc:	d009      	beq.n	14bf2 <Request_MessageReq+0x1f2>
   14bde:	231c      	movs	r3, #28
   14be0:	18fb      	adds	r3, r7, r3
   14be2:	881b      	ldrh	r3, [r3, #0]
   14be4:	2bff      	cmp	r3, #255	; 0xff
   14be6:	d804      	bhi.n	14bf2 <Request_MessageReq+0x1f2>
   14be8:	234b      	movs	r3, #75	; 0x4b
   14bea:	18fb      	adds	r3, r7, r3
   14bec:	781b      	ldrb	r3, [r3, #0]
   14bee:	2b01      	cmp	r3, #1
   14bf0:	d9c3      	bls.n	14b7a <Request_MessageReq+0x17a>
      }
      if (2 == nb_expected_tag)
   14bf2:	234b      	movs	r3, #75	; 0x4b
   14bf4:	18fb      	adds	r3, r7, r3
   14bf6:	781b      	ldrb	r3, [r3, #0]
   14bf8:	2b02      	cmp	r3, #2
   14bfa:	d001      	beq.n	14c00 <Request_MessageReq+0x200>
   14bfc:	f000 fbca 	bl	15394 <Request_MessageReq+0x994>
      {
        status = USBPD_DPM_RequestMessageRequest(PortNum, index_pdo, voltage);
   14c00:	234f      	movs	r3, #79	; 0x4f
   14c02:	18fc      	adds	r4, r7, r3
   14c04:	234c      	movs	r3, #76	; 0x4c
   14c06:	18fb      	adds	r3, r7, r3
   14c08:	881a      	ldrh	r2, [r3, #0]
   14c0a:	234a      	movs	r3, #74	; 0x4a
   14c0c:	18fb      	adds	r3, r7, r3
   14c0e:	7819      	ldrb	r1, [r3, #0]
   14c10:	230f      	movs	r3, #15
   14c12:	18fb      	adds	r3, r7, r3
   14c14:	781b      	ldrb	r3, [r3, #0]
   14c16:	0018      	movs	r0, r3
   14c18:	f7f4 fd04 	bl	9624 <USBPD_DPM_RequestMessageRequest>
   14c1c:	0003      	movs	r3, r0
   14c1e:	7023      	strb	r3, [r4, #0]
      }
    }
    break;
   14c20:	f000 fbb8 	bl	15394 <Request_MessageReq+0x994>
  case GUI_MSG_SOFT_RESET :
    TLV_get(&process_tlv, &tag, &length, &value);
   14c24:	2318      	movs	r3, #24
   14c26:	18fb      	adds	r3, r7, r3
   14c28:	221c      	movs	r2, #28
   14c2a:	18ba      	adds	r2, r7, r2
   14c2c:	241e      	movs	r4, #30
   14c2e:	1939      	adds	r1, r7, r4
   14c30:	202c      	movs	r0, #44	; 0x2c
   14c32:	1838      	adds	r0, r7, r0
   14c34:	f7fe fa5a 	bl	130ec <TLV_get>
    if (GUI_PARAM_MSG_SOPTYPE == (USBPD_GUI_Tag_ParamMsg)tag)
   14c38:	193b      	adds	r3, r7, r4
   14c3a:	781b      	ldrb	r3, [r3, #0]
   14c3c:	2b00      	cmp	r3, #0
   14c3e:	d001      	beq.n	14c44 <Request_MessageReq+0x244>
   14c40:	f000 fbaa 	bl	15398 <Request_MessageReq+0x998>
    {
      status = USBPD_DPM_RequestSoftReset(PortNum, (USBPD_SOPType_TypeDef)value[0]);
   14c44:	69bb      	ldr	r3, [r7, #24]
   14c46:	781a      	ldrb	r2, [r3, #0]
   14c48:	234f      	movs	r3, #79	; 0x4f
   14c4a:	18fc      	adds	r4, r7, r3
   14c4c:	230f      	movs	r3, #15
   14c4e:	18fb      	adds	r3, r7, r3
   14c50:	781b      	ldrb	r3, [r3, #0]
   14c52:	0011      	movs	r1, r2
   14c54:	0018      	movs	r0, r3
   14c56:	f7f4 fdd1 	bl	97fc <USBPD_DPM_RequestSoftReset>
   14c5a:	0003      	movs	r3, r0
   14c5c:	7023      	strb	r3, [r4, #0]
    }
    break;
   14c5e:	f000 fb9b 	bl	15398 <Request_MessageReq+0x998>
  case GUI_MSG_HARD_RESET :
    status = USBPD_DPM_RequestHardReset(PortNum);
   14c62:	234f      	movs	r3, #79	; 0x4f
   14c64:	18fc      	adds	r4, r7, r3
   14c66:	230f      	movs	r3, #15
   14c68:	18fb      	adds	r3, r7, r3
   14c6a:	781b      	ldrb	r3, [r3, #0]
   14c6c:	0018      	movs	r0, r3
   14c6e:	f7f4 fc94 	bl	959a <USBPD_DPM_RequestHardReset>
   14c72:	0003      	movs	r3, r0
   14c74:	7023      	strb	r3, [r4, #0]
    break;
   14c76:	f000 fbbc 	bl	153f2 <Request_MessageReq+0x9f2>
  case GUI_MSG_CABLE_RESET :
    status = USBPD_DPM_RequestCableReset(PortNum);
   14c7a:	234f      	movs	r3, #79	; 0x4f
   14c7c:	18fc      	adds	r4, r7, r3
   14c7e:	230f      	movs	r3, #15
   14c80:	18fb      	adds	r3, r7, r3
   14c82:	781b      	ldrb	r3, [r3, #0]
   14c84:	0018      	movs	r0, r3
   14c86:	f7f4 fc98 	bl	95ba <USBPD_DPM_RequestCableReset>
   14c8a:	0003      	movs	r3, r0
   14c8c:	7023      	strb	r3, [r4, #0]
    break;
   14c8e:	f000 fbb0 	bl	153f2 <Request_MessageReq+0x9f2>
#if defined(_VDM) || defined(_VCONN_SUPPORT)
  case GUI_MSG_VDM_DISCO_IDENT :
    if (length > TLV_SIZE_MAX) break;
   14c92:	231c      	movs	r3, #28
   14c94:	18fb      	adds	r3, r7, r3
   14c96:	881a      	ldrh	r2, [r3, #0]
   14c98:	2380      	movs	r3, #128	; 0x80
   14c9a:	005b      	lsls	r3, r3, #1
   14c9c:	429a      	cmp	r2, r3
   14c9e:	d901      	bls.n	14ca4 <Request_MessageReq+0x2a4>
   14ca0:	f000 fb7c 	bl	1539c <Request_MessageReq+0x99c>
    TLV_get(&process_tlv, &tag, &length, &value);
   14ca4:	2318      	movs	r3, #24
   14ca6:	18fb      	adds	r3, r7, r3
   14ca8:	221c      	movs	r2, #28
   14caa:	18ba      	adds	r2, r7, r2
   14cac:	241e      	movs	r4, #30
   14cae:	1939      	adds	r1, r7, r4
   14cb0:	202c      	movs	r0, #44	; 0x2c
   14cb2:	1838      	adds	r0, r7, r0
   14cb4:	f7fe fa1a 	bl	130ec <TLV_get>
    if (GUI_PARAM_MSG_SOPTYPE == (USBPD_GUI_Tag_ParamMsg)tag)
   14cb8:	193b      	adds	r3, r7, r4
   14cba:	781b      	ldrb	r3, [r3, #0]
   14cbc:	2b00      	cmp	r3, #0
   14cbe:	d000      	beq.n	14cc2 <Request_MessageReq+0x2c2>
   14cc0:	e36e      	b.n	153a0 <Request_MessageReq+0x9a0>
    {
      status = USBPD_DPM_RequestVDM_DiscoveryIdentify(PortNum, (USBPD_SOPType_TypeDef)value[0]);
   14cc2:	69bb      	ldr	r3, [r7, #24]
   14cc4:	781a      	ldrb	r2, [r3, #0]
   14cc6:	234f      	movs	r3, #79	; 0x4f
   14cc8:	18fc      	adds	r4, r7, r3
   14cca:	230f      	movs	r3, #15
   14ccc:	18fb      	adds	r3, r7, r3
   14cce:	781b      	ldrb	r3, [r3, #0]
   14cd0:	0011      	movs	r1, r2
   14cd2:	0018      	movs	r0, r3
   14cd4:	f7f4 fdba 	bl	984c <USBPD_DPM_RequestVDM_DiscoveryIdentify>
   14cd8:	0003      	movs	r3, r0
   14cda:	7023      	strb	r3, [r4, #0]
    }
    break;
   14cdc:	e360      	b.n	153a0 <Request_MessageReq+0x9a0>
  case GUI_MSG_VDM_DISCO_SVID :
    if (length > TLV_SIZE_MAX) break;
   14cde:	231c      	movs	r3, #28
   14ce0:	18fb      	adds	r3, r7, r3
   14ce2:	881a      	ldrh	r2, [r3, #0]
   14ce4:	2380      	movs	r3, #128	; 0x80
   14ce6:	005b      	lsls	r3, r3, #1
   14ce8:	429a      	cmp	r2, r3
   14cea:	d900      	bls.n	14cee <Request_MessageReq+0x2ee>
   14cec:	e35a      	b.n	153a4 <Request_MessageReq+0x9a4>
    TLV_get(&process_tlv, &tag, &length, &value);
   14cee:	2318      	movs	r3, #24
   14cf0:	18fb      	adds	r3, r7, r3
   14cf2:	221c      	movs	r2, #28
   14cf4:	18ba      	adds	r2, r7, r2
   14cf6:	241e      	movs	r4, #30
   14cf8:	1939      	adds	r1, r7, r4
   14cfa:	202c      	movs	r0, #44	; 0x2c
   14cfc:	1838      	adds	r0, r7, r0
   14cfe:	f7fe f9f5 	bl	130ec <TLV_get>
    if (GUI_PARAM_MSG_SOPTYPE == (USBPD_GUI_Tag_ParamMsg)tag)
   14d02:	193b      	adds	r3, r7, r4
   14d04:	781b      	ldrb	r3, [r3, #0]
   14d06:	2b00      	cmp	r3, #0
   14d08:	d000      	beq.n	14d0c <Request_MessageReq+0x30c>
   14d0a:	e34d      	b.n	153a8 <Request_MessageReq+0x9a8>
    {
      status = USBPD_DPM_RequestVDM_DiscoverySVID(PortNum, (USBPD_SOPType_TypeDef)value[0]);
   14d0c:	69bb      	ldr	r3, [r7, #24]
   14d0e:	781a      	ldrb	r2, [r3, #0]
   14d10:	234f      	movs	r3, #79	; 0x4f
   14d12:	18fc      	adds	r4, r7, r3
   14d14:	230f      	movs	r3, #15
   14d16:	18fb      	adds	r3, r7, r3
   14d18:	781b      	ldrb	r3, [r3, #0]
   14d1a:	0011      	movs	r1, r2
   14d1c:	0018      	movs	r0, r3
   14d1e:	f7f4 fdc9 	bl	98b4 <USBPD_DPM_RequestVDM_DiscoverySVID>
   14d22:	0003      	movs	r3, r0
   14d24:	7023      	strb	r3, [r4, #0]
    }
    break;
   14d26:	e33f      	b.n	153a8 <Request_MessageReq+0x9a8>
  case GUI_MSG_VDM_DISCO_MODE :
    {
      uint16_t svid = 0;
   14d28:	2348      	movs	r3, #72	; 0x48
   14d2a:	18fb      	adds	r3, r7, r3
   14d2c:	2200      	movs	r2, #0
   14d2e:	801a      	strh	r2, [r3, #0]
      uint8_t nb_expected_tag = 0;
   14d30:	2347      	movs	r3, #71	; 0x47
   14d32:	18fb      	adds	r3, r7, r3
   14d34:	2200      	movs	r2, #0
   14d36:	701a      	strb	r2, [r3, #0]
      uint8_t sop = USBPD_SOPTYPE_SOP;
   14d38:	2346      	movs	r3, #70	; 0x46
   14d3a:	18fb      	adds	r3, r7, r3
   14d3c:	2200      	movs	r2, #0
   14d3e:	701a      	strb	r2, [r3, #0]
      if (length > TLV_SIZE_MAX) break;
   14d40:	231c      	movs	r3, #28
   14d42:	18fb      	adds	r3, r7, r3
   14d44:	881a      	ldrh	r2, [r3, #0]
   14d46:	2380      	movs	r3, #128	; 0x80
   14d48:	005b      	lsls	r3, r3, #1
   14d4a:	429a      	cmp	r2, r3
   14d4c:	d900      	bls.n	14d50 <Request_MessageReq+0x350>
   14d4e:	e32d      	b.n	153ac <Request_MessageReq+0x9ac>
      TLV_get(&process_tlv, &tag, &length, &value);
   14d50:	2318      	movs	r3, #24
   14d52:	18fb      	adds	r3, r7, r3
   14d54:	221c      	movs	r2, #28
   14d56:	18ba      	adds	r2, r7, r2
   14d58:	211e      	movs	r1, #30
   14d5a:	1879      	adds	r1, r7, r1
   14d5c:	202c      	movs	r0, #44	; 0x2c
   14d5e:	1838      	adds	r0, r7, r0
   14d60:	f7fe f9c4 	bl	130ec <TLV_get>
      while((0 != length) && (TLV_SIZE_MAX > length) && (nb_expected_tag < 2))
   14d64:	e02c      	b.n	14dc0 <Request_MessageReq+0x3c0>
      {
        nb_expected_tag++;
   14d66:	2147      	movs	r1, #71	; 0x47
   14d68:	187b      	adds	r3, r7, r1
   14d6a:	781a      	ldrb	r2, [r3, #0]
   14d6c:	187b      	adds	r3, r7, r1
   14d6e:	3201      	adds	r2, #1
   14d70:	701a      	strb	r2, [r3, #0]
        if (GUI_PARAM_MSG_SOPTYPE == (USBPD_GUI_Tag_ParamMsg)tag)
   14d72:	231e      	movs	r3, #30
   14d74:	18fb      	adds	r3, r7, r3
   14d76:	781b      	ldrb	r3, [r3, #0]
   14d78:	2b00      	cmp	r3, #0
   14d7a:	d105      	bne.n	14d88 <Request_MessageReq+0x388>
        {
          sop = value[0];
   14d7c:	69ba      	ldr	r2, [r7, #24]
   14d7e:	2346      	movs	r3, #70	; 0x46
   14d80:	18fb      	adds	r3, r7, r3
   14d82:	7812      	ldrb	r2, [r2, #0]
   14d84:	701a      	strb	r2, [r3, #0]
   14d86:	e011      	b.n	14dac <Request_MessageReq+0x3ac>
        }
        else if (GUI_PARAM_MSG_SVDM_SVID == (USBPD_GUI_Tag_ParamMsg)tag)
   14d88:	231e      	movs	r3, #30
   14d8a:	18fb      	adds	r3, r7, r3
   14d8c:	781b      	ldrb	r3, [r3, #0]
   14d8e:	2b06      	cmp	r3, #6
   14d90:	d10c      	bne.n	14dac <Request_MessageReq+0x3ac>
        {
          svid = LE16(&value[0]);
   14d92:	69bb      	ldr	r3, [r7, #24]
   14d94:	781b      	ldrb	r3, [r3, #0]
   14d96:	b299      	uxth	r1, r3
   14d98:	69bb      	ldr	r3, [r7, #24]
   14d9a:	3301      	adds	r3, #1
   14d9c:	781b      	ldrb	r3, [r3, #0]
   14d9e:	b29b      	uxth	r3, r3
   14da0:	021b      	lsls	r3, r3, #8
   14da2:	b29a      	uxth	r2, r3
   14da4:	2348      	movs	r3, #72	; 0x48
   14da6:	18fb      	adds	r3, r7, r3
   14da8:	188a      	adds	r2, r1, r2
   14daa:	801a      	strh	r2, [r3, #0]
        }
        TLV_get(&process_tlv, &tag, &length, &value);
   14dac:	2318      	movs	r3, #24
   14dae:	18fb      	adds	r3, r7, r3
   14db0:	221c      	movs	r2, #28
   14db2:	18ba      	adds	r2, r7, r2
   14db4:	211e      	movs	r1, #30
   14db6:	1879      	adds	r1, r7, r1
   14db8:	202c      	movs	r0, #44	; 0x2c
   14dba:	1838      	adds	r0, r7, r0
   14dbc:	f7fe f996 	bl	130ec <TLV_get>
      while((0 != length) && (TLV_SIZE_MAX > length) && (nb_expected_tag < 2))
   14dc0:	231c      	movs	r3, #28
   14dc2:	18fb      	adds	r3, r7, r3
   14dc4:	881b      	ldrh	r3, [r3, #0]
   14dc6:	2b00      	cmp	r3, #0
   14dc8:	d009      	beq.n	14dde <Request_MessageReq+0x3de>
   14dca:	231c      	movs	r3, #28
   14dcc:	18fb      	adds	r3, r7, r3
   14dce:	881b      	ldrh	r3, [r3, #0]
   14dd0:	2bff      	cmp	r3, #255	; 0xff
   14dd2:	d804      	bhi.n	14dde <Request_MessageReq+0x3de>
   14dd4:	2347      	movs	r3, #71	; 0x47
   14dd6:	18fb      	adds	r3, r7, r3
   14dd8:	781b      	ldrb	r3, [r3, #0]
   14dda:	2b01      	cmp	r3, #1
   14ddc:	d9c3      	bls.n	14d66 <Request_MessageReq+0x366>
      }
      if (2 == nb_expected_tag)
   14dde:	2347      	movs	r3, #71	; 0x47
   14de0:	18fb      	adds	r3, r7, r3
   14de2:	781b      	ldrb	r3, [r3, #0]
   14de4:	2b02      	cmp	r3, #2
   14de6:	d000      	beq.n	14dea <Request_MessageReq+0x3ea>
   14de8:	e2e2      	b.n	153b0 <Request_MessageReq+0x9b0>
      {
        status = USBPD_DPM_RequestVDM_DiscoveryMode(PortNum, (USBPD_SOPType_TypeDef)sop, svid);
   14dea:	234f      	movs	r3, #79	; 0x4f
   14dec:	18fc      	adds	r4, r7, r3
   14dee:	2348      	movs	r3, #72	; 0x48
   14df0:	18fb      	adds	r3, r7, r3
   14df2:	881a      	ldrh	r2, [r3, #0]
   14df4:	2346      	movs	r3, #70	; 0x46
   14df6:	18fb      	adds	r3, r7, r3
   14df8:	7819      	ldrb	r1, [r3, #0]
   14dfa:	230f      	movs	r3, #15
   14dfc:	18fb      	adds	r3, r7, r3
   14dfe:	781b      	ldrb	r3, [r3, #0]
   14e00:	0018      	movs	r0, r3
   14e02:	f7f4 fd6d 	bl	98e0 <USBPD_DPM_RequestVDM_DiscoveryMode>
   14e06:	0003      	movs	r3, r0
   14e08:	7023      	strb	r3, [r4, #0]
      }
    }
    break;
   14e0a:	e2d1      	b.n	153b0 <Request_MessageReq+0x9b0>
   14e0c:	0001f8a0 	.word	0x0001f8a0
  case GUI_MSG_VDM_ENTER_MODE :
    {
      uint16_t mode = 0, svid = 0;
   14e10:	2344      	movs	r3, #68	; 0x44
   14e12:	18fb      	adds	r3, r7, r3
   14e14:	2200      	movs	r2, #0
   14e16:	801a      	strh	r2, [r3, #0]
   14e18:	2342      	movs	r3, #66	; 0x42
   14e1a:	18fb      	adds	r3, r7, r3
   14e1c:	2200      	movs	r2, #0
   14e1e:	801a      	strh	r2, [r3, #0]
      uint8_t nb_expected_tag = 0;
   14e20:	2341      	movs	r3, #65	; 0x41
   14e22:	18fb      	adds	r3, r7, r3
   14e24:	2200      	movs	r2, #0
   14e26:	701a      	strb	r2, [r3, #0]
      uint8_t sop = USBPD_SOPTYPE_SOP;
   14e28:	2340      	movs	r3, #64	; 0x40
   14e2a:	18fb      	adds	r3, r7, r3
   14e2c:	2200      	movs	r2, #0
   14e2e:	701a      	strb	r2, [r3, #0]
      if (length > TLV_SIZE_MAX) break;
   14e30:	231c      	movs	r3, #28
   14e32:	18fb      	adds	r3, r7, r3
   14e34:	881a      	ldrh	r2, [r3, #0]
   14e36:	2380      	movs	r3, #128	; 0x80
   14e38:	005b      	lsls	r3, r3, #1
   14e3a:	429a      	cmp	r2, r3
   14e3c:	d900      	bls.n	14e40 <Request_MessageReq+0x440>
   14e3e:	e2b9      	b.n	153b4 <Request_MessageReq+0x9b4>
      TLV_get(&process_tlv, &tag, &length, &value);
   14e40:	2318      	movs	r3, #24
   14e42:	18fb      	adds	r3, r7, r3
   14e44:	221c      	movs	r2, #28
   14e46:	18ba      	adds	r2, r7, r2
   14e48:	211e      	movs	r1, #30
   14e4a:	1879      	adds	r1, r7, r1
   14e4c:	202c      	movs	r0, #44	; 0x2c
   14e4e:	1838      	adds	r0, r7, r0
   14e50:	f7fe f94c 	bl	130ec <TLV_get>
      while((0 != length) && (TLV_SIZE_MAX > length) && (nb_expected_tag < 3))
   14e54:	e03f      	b.n	14ed6 <Request_MessageReq+0x4d6>
      {
        nb_expected_tag++;
   14e56:	2141      	movs	r1, #65	; 0x41
   14e58:	187b      	adds	r3, r7, r1
   14e5a:	781a      	ldrb	r2, [r3, #0]
   14e5c:	187b      	adds	r3, r7, r1
   14e5e:	3201      	adds	r2, #1
   14e60:	701a      	strb	r2, [r3, #0]
        if (GUI_PARAM_MSG_SOPTYPE == (USBPD_GUI_Tag_ParamMsg)tag)
   14e62:	231e      	movs	r3, #30
   14e64:	18fb      	adds	r3, r7, r3
   14e66:	781b      	ldrb	r3, [r3, #0]
   14e68:	2b00      	cmp	r3, #0
   14e6a:	d105      	bne.n	14e78 <Request_MessageReq+0x478>
        {
          sop = value[0];
   14e6c:	69ba      	ldr	r2, [r7, #24]
   14e6e:	2340      	movs	r3, #64	; 0x40
   14e70:	18fb      	adds	r3, r7, r3
   14e72:	7812      	ldrb	r2, [r2, #0]
   14e74:	701a      	strb	r2, [r3, #0]
   14e76:	e024      	b.n	14ec2 <Request_MessageReq+0x4c2>
        }
        else if (GUI_PARAM_MSG_SVDM_SVID == (USBPD_GUI_Tag_ParamMsg)tag)
   14e78:	231e      	movs	r3, #30
   14e7a:	18fb      	adds	r3, r7, r3
   14e7c:	781b      	ldrb	r3, [r3, #0]
   14e7e:	2b06      	cmp	r3, #6
   14e80:	d10d      	bne.n	14e9e <Request_MessageReq+0x49e>
        {
          svid = LE16(&value[0]);
   14e82:	69bb      	ldr	r3, [r7, #24]
   14e84:	781b      	ldrb	r3, [r3, #0]
   14e86:	b299      	uxth	r1, r3
   14e88:	69bb      	ldr	r3, [r7, #24]
   14e8a:	3301      	adds	r3, #1
   14e8c:	781b      	ldrb	r3, [r3, #0]
   14e8e:	b29b      	uxth	r3, r3
   14e90:	021b      	lsls	r3, r3, #8
   14e92:	b29a      	uxth	r2, r3
   14e94:	2342      	movs	r3, #66	; 0x42
   14e96:	18fb      	adds	r3, r7, r3
   14e98:	188a      	adds	r2, r1, r2
   14e9a:	801a      	strh	r2, [r3, #0]
   14e9c:	e011      	b.n	14ec2 <Request_MessageReq+0x4c2>
        }
        else if (GUI_PARAM_MSG_SVDM_MODEINDEX == (USBPD_GUI_Tag_ParamMsg)tag)
   14e9e:	231e      	movs	r3, #30
   14ea0:	18fb      	adds	r3, r7, r3
   14ea2:	781b      	ldrb	r3, [r3, #0]
   14ea4:	2b07      	cmp	r3, #7
   14ea6:	d10c      	bne.n	14ec2 <Request_MessageReq+0x4c2>
        {
          mode = LE16(&value[0]);
   14ea8:	69bb      	ldr	r3, [r7, #24]
   14eaa:	781b      	ldrb	r3, [r3, #0]
   14eac:	b299      	uxth	r1, r3
   14eae:	69bb      	ldr	r3, [r7, #24]
   14eb0:	3301      	adds	r3, #1
   14eb2:	781b      	ldrb	r3, [r3, #0]
   14eb4:	b29b      	uxth	r3, r3
   14eb6:	021b      	lsls	r3, r3, #8
   14eb8:	b29a      	uxth	r2, r3
   14eba:	2344      	movs	r3, #68	; 0x44
   14ebc:	18fb      	adds	r3, r7, r3
   14ebe:	188a      	adds	r2, r1, r2
   14ec0:	801a      	strh	r2, [r3, #0]
        }
        TLV_get(&process_tlv, &tag, &length, &value);
   14ec2:	2318      	movs	r3, #24
   14ec4:	18fb      	adds	r3, r7, r3
   14ec6:	221c      	movs	r2, #28
   14ec8:	18ba      	adds	r2, r7, r2
   14eca:	211e      	movs	r1, #30
   14ecc:	1879      	adds	r1, r7, r1
   14ece:	202c      	movs	r0, #44	; 0x2c
   14ed0:	1838      	adds	r0, r7, r0
   14ed2:	f7fe f90b 	bl	130ec <TLV_get>
      while((0 != length) && (TLV_SIZE_MAX > length) && (nb_expected_tag < 3))
   14ed6:	231c      	movs	r3, #28
   14ed8:	18fb      	adds	r3, r7, r3
   14eda:	881b      	ldrh	r3, [r3, #0]
   14edc:	2b00      	cmp	r3, #0
   14ede:	d009      	beq.n	14ef4 <Request_MessageReq+0x4f4>
   14ee0:	231c      	movs	r3, #28
   14ee2:	18fb      	adds	r3, r7, r3
   14ee4:	881b      	ldrh	r3, [r3, #0]
   14ee6:	2bff      	cmp	r3, #255	; 0xff
   14ee8:	d804      	bhi.n	14ef4 <Request_MessageReq+0x4f4>
   14eea:	2341      	movs	r3, #65	; 0x41
   14eec:	18fb      	adds	r3, r7, r3
   14eee:	781b      	ldrb	r3, [r3, #0]
   14ef0:	2b02      	cmp	r3, #2
   14ef2:	d9b0      	bls.n	14e56 <Request_MessageReq+0x456>
      }
      if (3 == nb_expected_tag)
   14ef4:	2341      	movs	r3, #65	; 0x41
   14ef6:	18fb      	adds	r3, r7, r3
   14ef8:	781b      	ldrb	r3, [r3, #0]
   14efa:	2b03      	cmp	r3, #3
   14efc:	d000      	beq.n	14f00 <Request_MessageReq+0x500>
   14efe:	e25b      	b.n	153b8 <Request_MessageReq+0x9b8>
      {
        status = USBPD_DPM_RequestVDM_EnterMode(PortNum, (USBPD_SOPType_TypeDef)sop, svid, mode);
   14f00:	2344      	movs	r3, #68	; 0x44
   14f02:	18fb      	adds	r3, r7, r3
   14f04:	881b      	ldrh	r3, [r3, #0]
   14f06:	b2dd      	uxtb	r5, r3
   14f08:	234f      	movs	r3, #79	; 0x4f
   14f0a:	18fc      	adds	r4, r7, r3
   14f0c:	2342      	movs	r3, #66	; 0x42
   14f0e:	18fb      	adds	r3, r7, r3
   14f10:	881a      	ldrh	r2, [r3, #0]
   14f12:	2340      	movs	r3, #64	; 0x40
   14f14:	18fb      	adds	r3, r7, r3
   14f16:	7819      	ldrb	r1, [r3, #0]
   14f18:	230f      	movs	r3, #15
   14f1a:	18fb      	adds	r3, r7, r3
   14f1c:	7818      	ldrb	r0, [r3, #0]
   14f1e:	002b      	movs	r3, r5
   14f20:	f7f4 fcfb 	bl	991a <USBPD_DPM_RequestVDM_EnterMode>
   14f24:	0003      	movs	r3, r0
   14f26:	7023      	strb	r3, [r4, #0]
      }
    }
    break;
   14f28:	e246      	b.n	153b8 <Request_MessageReq+0x9b8>
  case GUI_MSG_VDM_EXIT_MODE :
    {
      uint16_t svid = 0, mode = 0;
   14f2a:	233e      	movs	r3, #62	; 0x3e
   14f2c:	18fb      	adds	r3, r7, r3
   14f2e:	2200      	movs	r2, #0
   14f30:	801a      	strh	r2, [r3, #0]
   14f32:	233c      	movs	r3, #60	; 0x3c
   14f34:	18fb      	adds	r3, r7, r3
   14f36:	2200      	movs	r2, #0
   14f38:	801a      	strh	r2, [r3, #0]
      uint8_t nb_expected_tag = 0;
   14f3a:	233b      	movs	r3, #59	; 0x3b
   14f3c:	18fb      	adds	r3, r7, r3
   14f3e:	2200      	movs	r2, #0
   14f40:	701a      	strb	r2, [r3, #0]
      uint8_t sop = USBPD_SOPTYPE_SOP;
   14f42:	233a      	movs	r3, #58	; 0x3a
   14f44:	18fb      	adds	r3, r7, r3
   14f46:	2200      	movs	r2, #0
   14f48:	701a      	strb	r2, [r3, #0]
      if (length > TLV_SIZE_MAX) break;
   14f4a:	231c      	movs	r3, #28
   14f4c:	18fb      	adds	r3, r7, r3
   14f4e:	881a      	ldrh	r2, [r3, #0]
   14f50:	2380      	movs	r3, #128	; 0x80
   14f52:	005b      	lsls	r3, r3, #1
   14f54:	429a      	cmp	r2, r3
   14f56:	d900      	bls.n	14f5a <Request_MessageReq+0x55a>
   14f58:	e230      	b.n	153bc <Request_MessageReq+0x9bc>
      TLV_get(&process_tlv, &tag, &length, &value);
   14f5a:	2318      	movs	r3, #24
   14f5c:	18fb      	adds	r3, r7, r3
   14f5e:	221c      	movs	r2, #28
   14f60:	18ba      	adds	r2, r7, r2
   14f62:	211e      	movs	r1, #30
   14f64:	1879      	adds	r1, r7, r1
   14f66:	202c      	movs	r0, #44	; 0x2c
   14f68:	1838      	adds	r0, r7, r0
   14f6a:	f7fe f8bf 	bl	130ec <TLV_get>
      while((0 != length) && (TLV_SIZE_MAX > length) && (nb_expected_tag < 3))
   14f6e:	e037      	b.n	14fe0 <Request_MessageReq+0x5e0>
      {
        nb_expected_tag++;
   14f70:	213b      	movs	r1, #59	; 0x3b
   14f72:	187b      	adds	r3, r7, r1
   14f74:	781a      	ldrb	r2, [r3, #0]
   14f76:	187b      	adds	r3, r7, r1
   14f78:	3201      	adds	r2, #1
   14f7a:	701a      	strb	r2, [r3, #0]
        if (GUI_PARAM_MSG_SOPTYPE == (USBPD_GUI_Tag_ParamMsg)tag)
   14f7c:	231e      	movs	r3, #30
   14f7e:	18fb      	adds	r3, r7, r3
   14f80:	781b      	ldrb	r3, [r3, #0]
   14f82:	2b00      	cmp	r3, #0
   14f84:	d105      	bne.n	14f92 <Request_MessageReq+0x592>
        {
          sop = value[0];
   14f86:	69ba      	ldr	r2, [r7, #24]
   14f88:	233a      	movs	r3, #58	; 0x3a
   14f8a:	18fb      	adds	r3, r7, r3
   14f8c:	7812      	ldrb	r2, [r2, #0]
   14f8e:	701a      	strb	r2, [r3, #0]
   14f90:	e01c      	b.n	14fcc <Request_MessageReq+0x5cc>
        }
        else if (GUI_PARAM_MSG_SVDM_SVID == (USBPD_GUI_Tag_ParamMsg)tag)
   14f92:	231e      	movs	r3, #30
   14f94:	18fb      	adds	r3, r7, r3
   14f96:	781b      	ldrb	r3, [r3, #0]
   14f98:	2b06      	cmp	r3, #6
   14f9a:	d10d      	bne.n	14fb8 <Request_MessageReq+0x5b8>
        {
          svid = LE16(&value[0]);
   14f9c:	69bb      	ldr	r3, [r7, #24]
   14f9e:	781b      	ldrb	r3, [r3, #0]
   14fa0:	b299      	uxth	r1, r3
   14fa2:	69bb      	ldr	r3, [r7, #24]
   14fa4:	3301      	adds	r3, #1
   14fa6:	781b      	ldrb	r3, [r3, #0]
   14fa8:	b29b      	uxth	r3, r3
   14faa:	021b      	lsls	r3, r3, #8
   14fac:	b29a      	uxth	r2, r3
   14fae:	233e      	movs	r3, #62	; 0x3e
   14fb0:	18fb      	adds	r3, r7, r3
   14fb2:	188a      	adds	r2, r1, r2
   14fb4:	801a      	strh	r2, [r3, #0]
   14fb6:	e009      	b.n	14fcc <Request_MessageReq+0x5cc>
        }
        else if (GUI_PARAM_MSG_SVDM_MODEINDEX == (USBPD_GUI_Tag_ParamMsg)tag)
   14fb8:	231e      	movs	r3, #30
   14fba:	18fb      	adds	r3, r7, r3
   14fbc:	781b      	ldrb	r3, [r3, #0]
   14fbe:	2b07      	cmp	r3, #7
   14fc0:	d104      	bne.n	14fcc <Request_MessageReq+0x5cc>
        {
          mode = value[0];
   14fc2:	69bb      	ldr	r3, [r7, #24]
   14fc4:	781a      	ldrb	r2, [r3, #0]
   14fc6:	233c      	movs	r3, #60	; 0x3c
   14fc8:	18fb      	adds	r3, r7, r3
   14fca:	801a      	strh	r2, [r3, #0]
        }
        TLV_get(&process_tlv, &tag, &length, &value);
   14fcc:	2318      	movs	r3, #24
   14fce:	18fb      	adds	r3, r7, r3
   14fd0:	221c      	movs	r2, #28
   14fd2:	18ba      	adds	r2, r7, r2
   14fd4:	211e      	movs	r1, #30
   14fd6:	1879      	adds	r1, r7, r1
   14fd8:	202c      	movs	r0, #44	; 0x2c
   14fda:	1838      	adds	r0, r7, r0
   14fdc:	f7fe f886 	bl	130ec <TLV_get>
      while((0 != length) && (TLV_SIZE_MAX > length) && (nb_expected_tag < 3))
   14fe0:	231c      	movs	r3, #28
   14fe2:	18fb      	adds	r3, r7, r3
   14fe4:	881b      	ldrh	r3, [r3, #0]
   14fe6:	2b00      	cmp	r3, #0
   14fe8:	d009      	beq.n	14ffe <Request_MessageReq+0x5fe>
   14fea:	231c      	movs	r3, #28
   14fec:	18fb      	adds	r3, r7, r3
   14fee:	881b      	ldrh	r3, [r3, #0]
   14ff0:	2bff      	cmp	r3, #255	; 0xff
   14ff2:	d804      	bhi.n	14ffe <Request_MessageReq+0x5fe>
   14ff4:	233b      	movs	r3, #59	; 0x3b
   14ff6:	18fb      	adds	r3, r7, r3
   14ff8:	781b      	ldrb	r3, [r3, #0]
   14ffa:	2b02      	cmp	r3, #2
   14ffc:	d9b8      	bls.n	14f70 <Request_MessageReq+0x570>
      }
      if (3 == nb_expected_tag)
   14ffe:	233b      	movs	r3, #59	; 0x3b
   15000:	18fb      	adds	r3, r7, r3
   15002:	781b      	ldrb	r3, [r3, #0]
   15004:	2b03      	cmp	r3, #3
   15006:	d000      	beq.n	1500a <Request_MessageReq+0x60a>
   15008:	e1da      	b.n	153c0 <Request_MessageReq+0x9c0>
      {
        status = USBPD_DPM_RequestVDM_ExitMode(PortNum, (USBPD_SOPType_TypeDef)sop, svid, mode);
   1500a:	233c      	movs	r3, #60	; 0x3c
   1500c:	18fb      	adds	r3, r7, r3
   1500e:	881b      	ldrh	r3, [r3, #0]
   15010:	b2dd      	uxtb	r5, r3
   15012:	234f      	movs	r3, #79	; 0x4f
   15014:	18fc      	adds	r4, r7, r3
   15016:	233e      	movs	r3, #62	; 0x3e
   15018:	18fb      	adds	r3, r7, r3
   1501a:	881a      	ldrh	r2, [r3, #0]
   1501c:	233a      	movs	r3, #58	; 0x3a
   1501e:	18fb      	adds	r3, r7, r3
   15020:	7819      	ldrb	r1, [r3, #0]
   15022:	230f      	movs	r3, #15
   15024:	18fb      	adds	r3, r7, r3
   15026:	7818      	ldrb	r0, [r3, #0]
   15028:	002b      	movs	r3, r5
   1502a:	f7f4 fc99 	bl	9960 <USBPD_DPM_RequestVDM_ExitMode>
   1502e:	0003      	movs	r3, r0
   15030:	7023      	strb	r3, [r4, #0]
      }
    }
    break;
   15032:	e1c5      	b.n	153c0 <Request_MessageReq+0x9c0>
    }
    break;
#endif /* _VDM */
  case GUI_MSG_FREE_TEXT :
    {
      uint8_t nb_expected_tag = 0;
   15034:	2339      	movs	r3, #57	; 0x39
   15036:	18fb      	adds	r3, r7, r3
   15038:	2200      	movs	r2, #0
   1503a:	701a      	strb	r2, [r3, #0]
      if (length > TLV_SIZE_MAX) break;
   1503c:	231c      	movs	r3, #28
   1503e:	18fb      	adds	r3, r7, r3
   15040:	881a      	ldrh	r2, [r3, #0]
   15042:	2380      	movs	r3, #128	; 0x80
   15044:	005b      	lsls	r3, r3, #1
   15046:	429a      	cmp	r2, r3
   15048:	d900      	bls.n	1504c <Request_MessageReq+0x64c>
   1504a:	e1bb      	b.n	153c4 <Request_MessageReq+0x9c4>
      TLV_get(&process_tlv, &tag, &length, &value);
   1504c:	2318      	movs	r3, #24
   1504e:	18fb      	adds	r3, r7, r3
   15050:	221c      	movs	r2, #28
   15052:	18ba      	adds	r2, r7, r2
   15054:	211e      	movs	r1, #30
   15056:	1879      	adds	r1, r7, r1
   15058:	202c      	movs	r0, #44	; 0x2c
   1505a:	1838      	adds	r0, r7, r0
   1505c:	f7fe f846 	bl	130ec <TLV_get>
      while((0 != length) && (TLV_SIZE_MAX > length) && (nb_expected_tag < 1))
   15060:	e005      	b.n	1506e <Request_MessageReq+0x66e>
      {
        nb_expected_tag++;
   15062:	2139      	movs	r1, #57	; 0x39
   15064:	187b      	adds	r3, r7, r1
   15066:	781a      	ldrb	r2, [r3, #0]
   15068:	187b      	adds	r3, r7, r1
   1506a:	3201      	adds	r2, #1
   1506c:	701a      	strb	r2, [r3, #0]
      while((0 != length) && (TLV_SIZE_MAX > length) && (nb_expected_tag < 1))
   1506e:	231c      	movs	r3, #28
   15070:	18fb      	adds	r3, r7, r3
   15072:	881b      	ldrh	r3, [r3, #0]
   15074:	2b00      	cmp	r3, #0
   15076:	d009      	beq.n	1508c <Request_MessageReq+0x68c>
   15078:	231c      	movs	r3, #28
   1507a:	18fb      	adds	r3, r7, r3
   1507c:	881b      	ldrh	r3, [r3, #0]
   1507e:	2bff      	cmp	r3, #255	; 0xff
   15080:	d804      	bhi.n	1508c <Request_MessageReq+0x68c>
   15082:	2339      	movs	r3, #57	; 0x39
   15084:	18fb      	adds	r3, r7, r3
   15086:	781b      	ldrb	r3, [r3, #0]
   15088:	2b00      	cmp	r3, #0
   1508a:	d0ea      	beq.n	15062 <Request_MessageReq+0x662>
      }
      if (1 == nb_expected_tag)
   1508c:	2339      	movs	r3, #57	; 0x39
   1508e:	18fb      	adds	r3, r7, r3
   15090:	781b      	ldrb	r3, [r3, #0]
   15092:	2b01      	cmp	r3, #1
   15094:	d000      	beq.n	15098 <Request_MessageReq+0x698>
   15096:	e197      	b.n	153c8 <Request_MessageReq+0x9c8>
      {
        status = Manage_FreeText(PortNum, value, length);
   15098:	69b9      	ldr	r1, [r7, #24]
   1509a:	231c      	movs	r3, #28
   1509c:	18fb      	adds	r3, r7, r3
   1509e:	881a      	ldrh	r2, [r3, #0]
   150a0:	234f      	movs	r3, #79	; 0x4f
   150a2:	18fc      	adds	r4, r7, r3
   150a4:	230f      	movs	r3, #15
   150a6:	18fb      	adds	r3, r7, r3
   150a8:	781b      	ldrb	r3, [r3, #0]
   150aa:	0018      	movs	r0, r3
   150ac:	f001 fd36 	bl	16b1c <Manage_FreeText>
   150b0:	0003      	movs	r3, r0
   150b2:	7023      	strb	r3, [r4, #0]
      }
    }
    break;
   150b4:	e188      	b.n	153c8 <Request_MessageReq+0x9c8>
#ifdef USBPD_REV30_SUPPORT
  case GUI_MSG_FR_SWAP :
    status = USBPD_DPM_RequestFastRoleSwap(PortNum);
   150b6:	234f      	movs	r3, #79	; 0x4f
   150b8:	18fc      	adds	r4, r7, r3
   150ba:	230f      	movs	r3, #15
   150bc:	18fb      	adds	r3, r7, r3
   150be:	781b      	ldrb	r3, [r3, #0]
   150c0:	0018      	movs	r0, r3
   150c2:	f7f4 fcd7 	bl	9a74 <USBPD_DPM_RequestFastRoleSwap>
   150c6:	0003      	movs	r3, r0
   150c8:	7023      	strb	r3, [r4, #0]
    break;
   150ca:	e192      	b.n	153f2 <Request_MessageReq+0x9f2>
  case GUI_MSG_GET_PPS_STATUS :
    status = USBPD_DPM_RequestGetPPS_Status(PortNum);
   150cc:	234f      	movs	r3, #79	; 0x4f
   150ce:	18fc      	adds	r4, r7, r3
   150d0:	230f      	movs	r3, #15
   150d2:	18fb      	adds	r3, r7, r3
   150d4:	781b      	ldrb	r3, [r3, #0]
   150d6:	0018      	movs	r0, r3
   150d8:	f7f4 fcaf 	bl	9a3a <USBPD_DPM_RequestGetPPS_Status>
   150dc:	0003      	movs	r3, r0
   150de:	7023      	strb	r3, [r4, #0]
    break;
   150e0:	e187      	b.n	153f2 <Request_MessageReq+0x9f2>
  case GUI_MSG_GET_COUNTRY_CODES :
    status = USBPD_DPM_RequestGetCountryCodes(PortNum);
   150e2:	234f      	movs	r3, #79	; 0x4f
   150e4:	18fc      	adds	r4, r7, r3
   150e6:	230f      	movs	r3, #15
   150e8:	18fb      	adds	r3, r7, r3
   150ea:	781b      	ldrb	r3, [r3, #0]
   150ec:	0018      	movs	r0, r3
   150ee:	f7f4 fcd3 	bl	9a98 <USBPD_DPM_RequestGetCountryCodes>
   150f2:	0003      	movs	r3, r0
   150f4:	7023      	strb	r3, [r4, #0]
    break;
   150f6:	e17c      	b.n	153f2 <Request_MessageReq+0x9f2>
  case GUI_MSG_GET_STATUS :
    status = USBPD_DPM_RequestGetStatus(PortNum);
   150f8:	234f      	movs	r3, #79	; 0x4f
   150fa:	18fc      	adds	r4, r7, r3
   150fc:	230f      	movs	r3, #15
   150fe:	18fb      	adds	r3, r7, r3
   15100:	781b      	ldrb	r3, [r3, #0]
   15102:	0018      	movs	r0, r3
   15104:	f7f4 fca4 	bl	9a50 <USBPD_DPM_RequestGetStatus>
   15108:	0003      	movs	r3, r0
   1510a:	7023      	strb	r3, [r4, #0]
    break;
   1510c:	e171      	b.n	153f2 <Request_MessageReq+0x9f2>
  case GUI_MSG_GET_SOURCE_CAPA_EXTENDED :
    status = USBPD_DPM_RequestGetSourceCapabilityExt(PortNum);
   1510e:	234f      	movs	r3, #79	; 0x4f
   15110:	18fc      	adds	r4, r7, r3
   15112:	230f      	movs	r3, #15
   15114:	18fb      	adds	r3, r7, r3
   15116:	781b      	ldrb	r3, [r3, #0]
   15118:	0018      	movs	r0, r3
   1511a:	f7f4 fc57 	bl	99cc <USBPD_DPM_RequestGetSourceCapabilityExt>
   1511e:	0003      	movs	r3, r0
   15120:	7023      	strb	r3, [r4, #0]
    break;
   15122:	e166      	b.n	153f2 <Request_MessageReq+0x9f2>
  case GUI_MSG_GET_SINK_CAPA_EXTENDED :
    status = USBPD_DPM_RequestGetSinkCapabilityExt(PortNum);
   15124:	234f      	movs	r3, #79	; 0x4f
   15126:	18fc      	adds	r4, r7, r3
   15128:	230f      	movs	r3, #15
   1512a:	18fb      	adds	r3, r7, r3
   1512c:	781b      	ldrb	r3, [r3, #0]
   1512e:	0018      	movs	r0, r3
   15130:	f7f4 fc57 	bl	99e2 <USBPD_DPM_RequestGetSinkCapabilityExt>
   15134:	0003      	movs	r3, r0
   15136:	7023      	strb	r3, [r4, #0]
    break;
   15138:	e15b      	b.n	153f2 <Request_MessageReq+0x9f2>
  case GUI_MSG_ALERT :
    if (length > TLV_SIZE_MAX) break;
   1513a:	231c      	movs	r3, #28
   1513c:	18fb      	adds	r3, r7, r3
   1513e:	881a      	ldrh	r2, [r3, #0]
   15140:	2380      	movs	r3, #128	; 0x80
   15142:	005b      	lsls	r3, r3, #1
   15144:	429a      	cmp	r2, r3
   15146:	d900      	bls.n	1514a <Request_MessageReq+0x74a>
   15148:	e140      	b.n	153cc <Request_MessageReq+0x9cc>
    TLV_get(&process_tlv, &tag, &length, &value);
   1514a:	2318      	movs	r3, #24
   1514c:	18fb      	adds	r3, r7, r3
   1514e:	221c      	movs	r2, #28
   15150:	18ba      	adds	r2, r7, r2
   15152:	241e      	movs	r4, #30
   15154:	1939      	adds	r1, r7, r4
   15156:	202c      	movs	r0, #44	; 0x2c
   15158:	1838      	adds	r0, r7, r0
   1515a:	f7fd ffc7 	bl	130ec <TLV_get>
    if (GUI_PARAM_MSG_ALERTMSG == (USBPD_GUI_Tag_ParamMsg)tag)
   1515e:	193b      	adds	r3, r7, r4
   15160:	781b      	ldrb	r3, [r3, #0]
   15162:	2b04      	cmp	r3, #4
   15164:	d000      	beq.n	15168 <Request_MessageReq+0x768>
   15166:	e133      	b.n	153d0 <Request_MessageReq+0x9d0>
    {
      USBPD_ADO_TypeDef alert;
      alert.d32 = LE32(&value[0]);
   15168:	69bb      	ldr	r3, [r7, #24]
   1516a:	781b      	ldrb	r3, [r3, #0]
   1516c:	001a      	movs	r2, r3
   1516e:	69bb      	ldr	r3, [r7, #24]
   15170:	3301      	adds	r3, #1
   15172:	781b      	ldrb	r3, [r3, #0]
   15174:	021b      	lsls	r3, r3, #8
   15176:	18d2      	adds	r2, r2, r3
   15178:	69bb      	ldr	r3, [r7, #24]
   1517a:	3302      	adds	r3, #2
   1517c:	781b      	ldrb	r3, [r3, #0]
   1517e:	041b      	lsls	r3, r3, #16
   15180:	18d2      	adds	r2, r2, r3
   15182:	69bb      	ldr	r3, [r7, #24]
   15184:	3303      	adds	r3, #3
   15186:	781b      	ldrb	r3, [r3, #0]
   15188:	061b      	lsls	r3, r3, #24
   1518a:	18d3      	adds	r3, r2, r3
   1518c:	617b      	str	r3, [r7, #20]
      status = USBPD_DPM_RequestAlert(PortNum, alert);
   1518e:	234f      	movs	r3, #79	; 0x4f
   15190:	18fc      	adds	r4, r7, r3
   15192:	697a      	ldr	r2, [r7, #20]
   15194:	230f      	movs	r3, #15
   15196:	18fb      	adds	r3, r7, r3
   15198:	781b      	ldrb	r3, [r3, #0]
   1519a:	0011      	movs	r1, r2
   1519c:	0018      	movs	r0, r3
   1519e:	f7f4 fc02 	bl	99a6 <USBPD_DPM_RequestAlert>
   151a2:	0003      	movs	r3, r0
   151a4:	7023      	strb	r3, [r4, #0]
    }
    break;
   151a6:	e113      	b.n	153d0 <Request_MessageReq+0x9d0>
  case GUI_MSG_GET_COUNTRY_INFO :
    if (length > TLV_SIZE_MAX) break;
   151a8:	231c      	movs	r3, #28
   151aa:	18fb      	adds	r3, r7, r3
   151ac:	881a      	ldrh	r2, [r3, #0]
   151ae:	2380      	movs	r3, #128	; 0x80
   151b0:	005b      	lsls	r3, r3, #1
   151b2:	429a      	cmp	r2, r3
   151b4:	d900      	bls.n	151b8 <Request_MessageReq+0x7b8>
   151b6:	e10d      	b.n	153d4 <Request_MessageReq+0x9d4>
    TLV_get(&process_tlv, &tag, &length, &value);
   151b8:	2318      	movs	r3, #24
   151ba:	18fb      	adds	r3, r7, r3
   151bc:	221c      	movs	r2, #28
   151be:	18ba      	adds	r2, r7, r2
   151c0:	241e      	movs	r4, #30
   151c2:	1939      	adds	r1, r7, r4
   151c4:	202c      	movs	r0, #44	; 0x2c
   151c6:	1838      	adds	r0, r7, r0
   151c8:	f7fd ff90 	bl	130ec <TLV_get>
    if (GUI_PARAM_MSG_COUNTRYCODE == (USBPD_GUI_Tag_ParamMsg)tag)
   151cc:	193b      	adds	r3, r7, r4
   151ce:	781b      	ldrb	r3, [r3, #0]
   151d0:	2b05      	cmp	r3, #5
   151d2:	d000      	beq.n	151d6 <Request_MessageReq+0x7d6>
   151d4:	e100      	b.n	153d8 <Request_MessageReq+0x9d8>
    {
      uint16_t country_code;
      country_code = LE16(&value[0]);
   151d6:	69bb      	ldr	r3, [r7, #24]
   151d8:	781b      	ldrb	r3, [r3, #0]
   151da:	b299      	uxth	r1, r3
   151dc:	69bb      	ldr	r3, [r7, #24]
   151de:	3301      	adds	r3, #1
   151e0:	781b      	ldrb	r3, [r3, #0]
   151e2:	b29b      	uxth	r3, r3
   151e4:	021b      	lsls	r3, r3, #8
   151e6:	b29a      	uxth	r2, r3
   151e8:	2034      	movs	r0, #52	; 0x34
   151ea:	183b      	adds	r3, r7, r0
   151ec:	188a      	adds	r2, r1, r2
   151ee:	801a      	strh	r2, [r3, #0]
      status = USBPD_DPM_RequestGetCountryInfo(PortNum, country_code);
   151f0:	234f      	movs	r3, #79	; 0x4f
   151f2:	18fc      	adds	r4, r7, r3
   151f4:	183b      	adds	r3, r7, r0
   151f6:	881a      	ldrh	r2, [r3, #0]
   151f8:	230f      	movs	r3, #15
   151fa:	18fb      	adds	r3, r7, r3
   151fc:	781b      	ldrb	r3, [r3, #0]
   151fe:	0011      	movs	r1, r2
   15200:	0018      	movs	r0, r3
   15202:	f7f4 fc5b 	bl	9abc <USBPD_DPM_RequestGetCountryInfo>
   15206:	0003      	movs	r3, r0
   15208:	7023      	strb	r3, [r4, #0]
    }
    break;
   1520a:	e0e5      	b.n	153d8 <Request_MessageReq+0x9d8>
  case GUI_MSG_GET_BAT_CAPA :
    if (length > TLV_SIZE_MAX) break;
   1520c:	231c      	movs	r3, #28
   1520e:	18fb      	adds	r3, r7, r3
   15210:	881a      	ldrh	r2, [r3, #0]
   15212:	2380      	movs	r3, #128	; 0x80
   15214:	005b      	lsls	r3, r3, #1
   15216:	429a      	cmp	r2, r3
   15218:	d900      	bls.n	1521c <Request_MessageReq+0x81c>
   1521a:	e0df      	b.n	153dc <Request_MessageReq+0x9dc>
    TLV_get(&process_tlv, &tag, &length, &value);
   1521c:	2318      	movs	r3, #24
   1521e:	18fb      	adds	r3, r7, r3
   15220:	221c      	movs	r2, #28
   15222:	18ba      	adds	r2, r7, r2
   15224:	241e      	movs	r4, #30
   15226:	1939      	adds	r1, r7, r4
   15228:	202c      	movs	r0, #44	; 0x2c
   1522a:	1838      	adds	r0, r7, r0
   1522c:	f7fd ff5e 	bl	130ec <TLV_get>
    if (GUI_PARAM_MSG_BATTERYREF == (USBPD_GUI_Tag_ParamMsg)tag)
   15230:	193b      	adds	r3, r7, r4
   15232:	781b      	ldrb	r3, [r3, #0]
   15234:	2b0c      	cmp	r3, #12
   15236:	d000      	beq.n	1523a <Request_MessageReq+0x83a>
   15238:	e0d2      	b.n	153e0 <Request_MessageReq+0x9e0>
    {
      status = USBPD_DPM_RequestGetBatteryCapability(PortNum, (uint8_t*)&value[0]);
   1523a:	69ba      	ldr	r2, [r7, #24]
   1523c:	234f      	movs	r3, #79	; 0x4f
   1523e:	18fc      	adds	r4, r7, r3
   15240:	230f      	movs	r3, #15
   15242:	18fb      	adds	r3, r7, r3
   15244:	781b      	ldrb	r3, [r3, #0]
   15246:	0011      	movs	r1, r2
   15248:	0018      	movs	r0, r3
   1524a:	f7f4 fc4c 	bl	9ae6 <USBPD_DPM_RequestGetBatteryCapability>
   1524e:	0003      	movs	r3, r0
   15250:	7023      	strb	r3, [r4, #0]
    }
    break;
   15252:	e0c5      	b.n	153e0 <Request_MessageReq+0x9e0>
  case GUI_MSG_GET_BAT_STATUS :
    if (length > TLV_SIZE_MAX) break;
   15254:	231c      	movs	r3, #28
   15256:	18fb      	adds	r3, r7, r3
   15258:	881a      	ldrh	r2, [r3, #0]
   1525a:	2380      	movs	r3, #128	; 0x80
   1525c:	005b      	lsls	r3, r3, #1
   1525e:	429a      	cmp	r2, r3
   15260:	d900      	bls.n	15264 <Request_MessageReq+0x864>
   15262:	e0bf      	b.n	153e4 <Request_MessageReq+0x9e4>
    TLV_get(&process_tlv, &tag, &length, &value);
   15264:	2318      	movs	r3, #24
   15266:	18fb      	adds	r3, r7, r3
   15268:	221c      	movs	r2, #28
   1526a:	18ba      	adds	r2, r7, r2
   1526c:	241e      	movs	r4, #30
   1526e:	1939      	adds	r1, r7, r4
   15270:	202c      	movs	r0, #44	; 0x2c
   15272:	1838      	adds	r0, r7, r0
   15274:	f7fd ff3a 	bl	130ec <TLV_get>
    if (GUI_PARAM_MSG_BATTERYREF == (USBPD_GUI_Tag_ParamMsg)tag)
   15278:	193b      	adds	r3, r7, r4
   1527a:	781b      	ldrb	r3, [r3, #0]
   1527c:	2b0c      	cmp	r3, #12
   1527e:	d000      	beq.n	15282 <Request_MessageReq+0x882>
   15280:	e0b2      	b.n	153e8 <Request_MessageReq+0x9e8>
    {
      status = USBPD_DPM_RequestGetBatteryStatus(PortNum, (uint8_t*)&value[0]);
   15282:	69ba      	ldr	r2, [r7, #24]
   15284:	234f      	movs	r3, #79	; 0x4f
   15286:	18fc      	adds	r4, r7, r3
   15288:	230f      	movs	r3, #15
   1528a:	18fb      	adds	r3, r7, r3
   1528c:	781b      	ldrb	r3, [r3, #0]
   1528e:	0011      	movs	r1, r2
   15290:	0018      	movs	r0, r3
   15292:	f7f4 fc34 	bl	9afe <USBPD_DPM_RequestGetBatteryStatus>
   15296:	0003      	movs	r3, r0
   15298:	7023      	strb	r3, [r4, #0]
    }
    break;
   1529a:	e0a5      	b.n	153e8 <Request_MessageReq+0x9e8>
  case GUI_MSG_GET_MANU_INFO :
    {
      uint16_t manu_info;
      uint8_t nb_expected_tag = 0;
   1529c:	2338      	movs	r3, #56	; 0x38
   1529e:	18fb      	adds	r3, r7, r3
   152a0:	2200      	movs	r2, #0
   152a2:	701a      	strb	r2, [r3, #0]
      uint8_t sop = USBPD_SOPTYPE_SOP;
   152a4:	2337      	movs	r3, #55	; 0x37
   152a6:	18fb      	adds	r3, r7, r3
   152a8:	2200      	movs	r2, #0
   152aa:	701a      	strb	r2, [r3, #0]
      if (length > TLV_SIZE_MAX) break;
   152ac:	231c      	movs	r3, #28
   152ae:	18fb      	adds	r3, r7, r3
   152b0:	881a      	ldrh	r2, [r3, #0]
   152b2:	2380      	movs	r3, #128	; 0x80
   152b4:	005b      	lsls	r3, r3, #1
   152b6:	429a      	cmp	r2, r3
   152b8:	d900      	bls.n	152bc <Request_MessageReq+0x8bc>
   152ba:	e097      	b.n	153ec <Request_MessageReq+0x9ec>
      TLV_get(&process_tlv, &tag, &length, &value);
   152bc:	2318      	movs	r3, #24
   152be:	18fb      	adds	r3, r7, r3
   152c0:	221c      	movs	r2, #28
   152c2:	18ba      	adds	r2, r7, r2
   152c4:	211e      	movs	r1, #30
   152c6:	1879      	adds	r1, r7, r1
   152c8:	202c      	movs	r0, #44	; 0x2c
   152ca:	1838      	adds	r0, r7, r0
   152cc:	f7fd ff0e 	bl	130ec <TLV_get>
      while((0 != length) && (TLV_SIZE_MAX > length) && (nb_expected_tag < 2))
   152d0:	e02d      	b.n	1532e <Request_MessageReq+0x92e>
      {
        nb_expected_tag++;
   152d2:	2138      	movs	r1, #56	; 0x38
   152d4:	187b      	adds	r3, r7, r1
   152d6:	781a      	ldrb	r2, [r3, #0]
   152d8:	187b      	adds	r3, r7, r1
   152da:	3201      	adds	r2, #1
   152dc:	701a      	strb	r2, [r3, #0]
        if (GUI_PARAM_MSG_SOPTYPE == (USBPD_GUI_Tag_ParamMsg)tag)
   152de:	231e      	movs	r3, #30
   152e0:	18fb      	adds	r3, r7, r3
   152e2:	781b      	ldrb	r3, [r3, #0]
   152e4:	2b00      	cmp	r3, #0
   152e6:	d105      	bne.n	152f4 <Request_MessageReq+0x8f4>
        {
          sop = value[0];
   152e8:	69ba      	ldr	r2, [r7, #24]
   152ea:	2337      	movs	r3, #55	; 0x37
   152ec:	18fb      	adds	r3, r7, r3
   152ee:	7812      	ldrb	r2, [r2, #0]
   152f0:	701a      	strb	r2, [r3, #0]
   152f2:	e012      	b.n	1531a <Request_MessageReq+0x91a>
        }
        else if (GUI_PARAM_MSG_MANUINFODATA == (USBPD_GUI_Tag_ParamMsg)tag)
   152f4:	231e      	movs	r3, #30
   152f6:	18fb      	adds	r3, r7, r3
   152f8:	781b      	ldrb	r3, [r3, #0]
   152fa:	2b0d      	cmp	r3, #13
   152fc:	d10d      	bne.n	1531a <Request_MessageReq+0x91a>
        {
          manu_info = LE16(&value[0]);
   152fe:	69bb      	ldr	r3, [r7, #24]
   15300:	781b      	ldrb	r3, [r3, #0]
   15302:	b29a      	uxth	r2, r3
   15304:	69bb      	ldr	r3, [r7, #24]
   15306:	3301      	adds	r3, #1
   15308:	781b      	ldrb	r3, [r3, #0]
   1530a:	b29b      	uxth	r3, r3
   1530c:	021b      	lsls	r3, r3, #8
   1530e:	b29b      	uxth	r3, r3
   15310:	18d3      	adds	r3, r2, r3
   15312:	b29a      	uxth	r2, r3
   15314:	2312      	movs	r3, #18
   15316:	18fb      	adds	r3, r7, r3
   15318:	801a      	strh	r2, [r3, #0]
        }
        TLV_get(&process_tlv, &tag, &length, &value);
   1531a:	2318      	movs	r3, #24
   1531c:	18fb      	adds	r3, r7, r3
   1531e:	221c      	movs	r2, #28
   15320:	18ba      	adds	r2, r7, r2
   15322:	211e      	movs	r1, #30
   15324:	1879      	adds	r1, r7, r1
   15326:	202c      	movs	r0, #44	; 0x2c
   15328:	1838      	adds	r0, r7, r0
   1532a:	f7fd fedf 	bl	130ec <TLV_get>
      while((0 != length) && (TLV_SIZE_MAX > length) && (nb_expected_tag < 2))
   1532e:	231c      	movs	r3, #28
   15330:	18fb      	adds	r3, r7, r3
   15332:	881b      	ldrh	r3, [r3, #0]
   15334:	2b00      	cmp	r3, #0
   15336:	d009      	beq.n	1534c <Request_MessageReq+0x94c>
   15338:	231c      	movs	r3, #28
   1533a:	18fb      	adds	r3, r7, r3
   1533c:	881b      	ldrh	r3, [r3, #0]
   1533e:	2bff      	cmp	r3, #255	; 0xff
   15340:	d804      	bhi.n	1534c <Request_MessageReq+0x94c>
   15342:	2338      	movs	r3, #56	; 0x38
   15344:	18fb      	adds	r3, r7, r3
   15346:	781b      	ldrb	r3, [r3, #0]
   15348:	2b01      	cmp	r3, #1
   1534a:	d9c2      	bls.n	152d2 <Request_MessageReq+0x8d2>
      }
      if (2 == nb_expected_tag)
   1534c:	2338      	movs	r3, #56	; 0x38
   1534e:	18fb      	adds	r3, r7, r3
   15350:	781b      	ldrb	r3, [r3, #0]
   15352:	2b02      	cmp	r3, #2
   15354:	d14c      	bne.n	153f0 <Request_MessageReq+0x9f0>
      {
        status = USBPD_DPM_RequestGetManufacturerInfo(PortNum, (USBPD_SOPType_TypeDef)sop, (uint8_t*)&manu_info);
   15356:	234f      	movs	r3, #79	; 0x4f
   15358:	18fc      	adds	r4, r7, r3
   1535a:	2312      	movs	r3, #18
   1535c:	18fa      	adds	r2, r7, r3
   1535e:	2337      	movs	r3, #55	; 0x37
   15360:	18fb      	adds	r3, r7, r3
   15362:	7819      	ldrb	r1, [r3, #0]
   15364:	230f      	movs	r3, #15
   15366:	18fb      	adds	r3, r7, r3
   15368:	781b      	ldrb	r3, [r3, #0]
   1536a:	0018      	movs	r0, r3
   1536c:	f7f4 fb4b 	bl	9a06 <USBPD_DPM_RequestGetManufacturerInfo>
   15370:	0003      	movs	r3, r0
   15372:	7023      	strb	r3, [r4, #0]
      }
    }
    break;
   15374:	e03c      	b.n	153f0 <Request_MessageReq+0x9f0>
  case GUI_MSG_SECU_REQUEST :
    status = USBPD_DPM_RequestSecurityRequest(PortNum);
   15376:	234f      	movs	r3, #79	; 0x4f
   15378:	18fc      	adds	r4, r7, r3
   1537a:	230f      	movs	r3, #15
   1537c:	18fb      	adds	r3, r7, r3
   1537e:	781b      	ldrb	r3, [r3, #0]
   15380:	0018      	movs	r0, r3
   15382:	f7f4 fbc8 	bl	9b16 <USBPD_DPM_RequestSecurityRequest>
   15386:	0003      	movs	r3, r0
   15388:	7023      	strb	r3, [r4, #0]
    break;
   1538a:	e032      	b.n	153f2 <Request_MessageReq+0x9f2>
  case GUI_MSG_FIRM_UPDATE_REQUEST :
    break;
#endif /* USBPD_REV30_SUPPORT */
  default :
    break;
   1538c:	46c0      	nop			; (mov r8, r8)
   1538e:	e030      	b.n	153f2 <Request_MessageReq+0x9f2>
      if (length > TLV_SIZE_MAX) break;
   15390:	46c0      	nop			; (mov r8, r8)
   15392:	e02e      	b.n	153f2 <Request_MessageReq+0x9f2>
    break;
   15394:	46c0      	nop			; (mov r8, r8)
   15396:	e02c      	b.n	153f2 <Request_MessageReq+0x9f2>
    break;
   15398:	46c0      	nop			; (mov r8, r8)
   1539a:	e02a      	b.n	153f2 <Request_MessageReq+0x9f2>
    if (length > TLV_SIZE_MAX) break;
   1539c:	46c0      	nop			; (mov r8, r8)
   1539e:	e028      	b.n	153f2 <Request_MessageReq+0x9f2>
    break;
   153a0:	46c0      	nop			; (mov r8, r8)
   153a2:	e026      	b.n	153f2 <Request_MessageReq+0x9f2>
    if (length > TLV_SIZE_MAX) break;
   153a4:	46c0      	nop			; (mov r8, r8)
   153a6:	e024      	b.n	153f2 <Request_MessageReq+0x9f2>
    break;
   153a8:	46c0      	nop			; (mov r8, r8)
   153aa:	e022      	b.n	153f2 <Request_MessageReq+0x9f2>
      if (length > TLV_SIZE_MAX) break;
   153ac:	46c0      	nop			; (mov r8, r8)
   153ae:	e020      	b.n	153f2 <Request_MessageReq+0x9f2>
    break;
   153b0:	46c0      	nop			; (mov r8, r8)
   153b2:	e01e      	b.n	153f2 <Request_MessageReq+0x9f2>
      if (length > TLV_SIZE_MAX) break;
   153b4:	46c0      	nop			; (mov r8, r8)
   153b6:	e01c      	b.n	153f2 <Request_MessageReq+0x9f2>
    break;
   153b8:	46c0      	nop			; (mov r8, r8)
   153ba:	e01a      	b.n	153f2 <Request_MessageReq+0x9f2>
      if (length > TLV_SIZE_MAX) break;
   153bc:	46c0      	nop			; (mov r8, r8)
   153be:	e018      	b.n	153f2 <Request_MessageReq+0x9f2>
    break;
   153c0:	46c0      	nop			; (mov r8, r8)
   153c2:	e016      	b.n	153f2 <Request_MessageReq+0x9f2>
      if (length > TLV_SIZE_MAX) break;
   153c4:	46c0      	nop			; (mov r8, r8)
   153c6:	e014      	b.n	153f2 <Request_MessageReq+0x9f2>
    break;
   153c8:	46c0      	nop			; (mov r8, r8)
   153ca:	e012      	b.n	153f2 <Request_MessageReq+0x9f2>
    if (length > TLV_SIZE_MAX) break;
   153cc:	46c0      	nop			; (mov r8, r8)
   153ce:	e010      	b.n	153f2 <Request_MessageReq+0x9f2>
    break;
   153d0:	46c0      	nop			; (mov r8, r8)
   153d2:	e00e      	b.n	153f2 <Request_MessageReq+0x9f2>
    if (length > TLV_SIZE_MAX) break;
   153d4:	46c0      	nop			; (mov r8, r8)
   153d6:	e00c      	b.n	153f2 <Request_MessageReq+0x9f2>
    break;
   153d8:	46c0      	nop			; (mov r8, r8)
   153da:	e00a      	b.n	153f2 <Request_MessageReq+0x9f2>
    if (length > TLV_SIZE_MAX) break;
   153dc:	46c0      	nop			; (mov r8, r8)
   153de:	e008      	b.n	153f2 <Request_MessageReq+0x9f2>
    break;
   153e0:	46c0      	nop			; (mov r8, r8)
   153e2:	e006      	b.n	153f2 <Request_MessageReq+0x9f2>
    if (length > TLV_SIZE_MAX) break;
   153e4:	46c0      	nop			; (mov r8, r8)
   153e6:	e004      	b.n	153f2 <Request_MessageReq+0x9f2>
    break;
   153e8:	46c0      	nop			; (mov r8, r8)
   153ea:	e002      	b.n	153f2 <Request_MessageReq+0x9f2>
      if (length > TLV_SIZE_MAX) break;
   153ec:	46c0      	nop			; (mov r8, r8)
   153ee:	e000      	b.n	153f2 <Request_MessageReq+0x9f2>
    break;
   153f0:	46c0      	nop			; (mov r8, r8)
  }

  /* Only applies if an error was specified (= if the case couldn't success)*/
  if (USBPD_OK != status)
   153f2:	234f      	movs	r3, #79	; 0x4f
   153f4:	18fb      	adds	r3, r7, r3
   153f6:	781b      	ldrb	r3, [r3, #0]
   153f8:	2b00      	cmp	r3, #0
   153fa:	d033      	beq.n	15464 <Request_MessageReq+0xa64>
  {
    switch (status)
   153fc:	234f      	movs	r3, #79	; 0x4f
   153fe:	18fb      	adds	r3, r7, r3
   15400:	781b      	ldrb	r3, [r3, #0]
   15402:	2b03      	cmp	r3, #3
   15404:	d002      	beq.n	1540c <Request_MessageReq+0xa0c>
   15406:	2b04      	cmp	r3, #4
   15408:	d005      	beq.n	15416 <Request_MessageReq+0xa16>
   1540a:	e009      	b.n	15420 <Request_MessageReq+0xa20>
    {
    case USBPD_BUSY:
      error = GUI_REJ_DPM_NOT_READY;
   1540c:	231f      	movs	r3, #31
   1540e:	18fb      	adds	r3, r7, r3
   15410:	2206      	movs	r2, #6
   15412:	701a      	strb	r2, [r3, #0]
      break;
   15414:	e009      	b.n	1542a <Request_MessageReq+0xa2a>
    case USBPD_TIMEOUT:
      error = GUI_REJ_DPM_TIMEOUT;
   15416:	231f      	movs	r3, #31
   15418:	18fb      	adds	r3, r7, r3
   1541a:	2202      	movs	r2, #2
   1541c:	701a      	strb	r2, [r3, #0]
      break;
   1541e:	e004      	b.n	1542a <Request_MessageReq+0xa2a>
    default:
    case USBPD_NOTSUPPORTED:
    case USBPD_ERROR:
      error = GUI_REJ_DPM_REJECT;
   15420:	231f      	movs	r3, #31
   15422:	18fb      	adds	r3, r7, r3
   15424:	2200      	movs	r2, #0
   15426:	701a      	strb	r2, [r3, #0]
      break;
   15428:	46c0      	nop			; (mov r8, r8)
    }
    TLV_deinit_encode(&send_tlv);
   1542a:	2520      	movs	r5, #32
   1542c:	197b      	adds	r3, r7, r5
   1542e:	0018      	movs	r0, r3
   15430:	f7fd fe1e 	bl	13070 <TLV_deinit_encode>
    TLV_init_encode(&send_tlv, __GUI_SET_TAG_ID((PortNum + 1), DPM_MESSAGE_REJ), TLV_SIZE_MAX, pEncodedMsg); /* Turn the tag 0x0A into 0x0B to signal an error*/
   15434:	230f      	movs	r3, #15
   15436:	18fb      	adds	r3, r7, r3
   15438:	781b      	ldrb	r3, [r3, #0]
   1543a:	3301      	adds	r3, #1
   1543c:	015b      	lsls	r3, r3, #5
   1543e:	b25b      	sxtb	r3, r3
   15440:	220b      	movs	r2, #11
   15442:	4313      	orrs	r3, r2
   15444:	b25b      	sxtb	r3, r3
   15446:	b2d9      	uxtb	r1, r3
   15448:	687c      	ldr	r4, [r7, #4]
   1544a:	2380      	movs	r3, #128	; 0x80
   1544c:	005a      	lsls	r2, r3, #1
   1544e:	1978      	adds	r0, r7, r5
   15450:	0023      	movs	r3, r4
   15452:	f7fd fc47 	bl	12ce4 <TLV_init_encode>
    TLV_addValue(&send_tlv, (uint8_t*)&error, 1);
   15456:	231f      	movs	r3, #31
   15458:	18f9      	adds	r1, r7, r3
   1545a:	197b      	adds	r3, r7, r5
   1545c:	2201      	movs	r2, #1
   1545e:	0018      	movs	r0, r3
   15460:	f7fd fd72 	bl	12f48 <TLV_addValue>
  }

  TLV_deinit_encode(&send_tlv);
   15464:	2320      	movs	r3, #32
   15466:	18fb      	adds	r3, r7, r3
   15468:	0018      	movs	r0, r3
   1546a:	f7fd fe01 	bl	13070 <TLV_deinit_encode>
  TLV_deinit_decode(&process_tlv);
   1546e:	232c      	movs	r3, #44	; 0x2c
   15470:	18fb      	adds	r3, r7, r3
   15472:	0018      	movs	r0, r3
   15474:	f7fd fe94 	bl	131a0 <TLV_deinit_decode>
}
   15478:	46c0      	nop			; (mov r8, r8)
   1547a:	46bd      	mov	sp, r7
   1547c:	b014      	add	sp, #80	; 0x50
   1547e:	bdb0      	pop	{r4, r5, r7, pc}

00015480 <Send_DpmConfigSetCnf>:
/**
  * @brief      Application of the received configuration
  * @note       Generation of a TLV instruction to send in the context of DPM_CONFIG_SET
  */
static void Send_DpmConfigSetCnf(uint8_t PortNum, uint8_t* instruction, uint8_t *pEncodedMsg)
{
   15480:	b5f0      	push	{r4, r5, r6, r7, lr}
   15482:	b0d7      	sub	sp, #348	; 0x15c
   15484:	af00      	add	r7, sp, #0
   15486:	60b9      	str	r1, [r7, #8]
   15488:	607a      	str	r2, [r7, #4]
   1548a:	4be8      	ldr	r3, [pc, #928]	; (1582c <Send_DpmConfigSetCnf+0x3ac>)
   1548c:	22ac      	movs	r2, #172	; 0xac
   1548e:	0052      	lsls	r2, r2, #1
   15490:	4694      	mov	ip, r2
   15492:	44bc      	add	ip, r7
   15494:	4463      	add	r3, ip
   15496:	1c02      	adds	r2, r0, #0
   15498:	701a      	strb	r2, [r3, #0]
    In case there is an error, we use this variable to know when to send a DPM_CONFIG_SET instead
    of a DPM_MESSAGE_CNF. This variable contains the cause if there is one.
  */
  uint8_t *value;
  uint16_t size;
  uint16_t dcdrp = 0;
   1549a:	23ab      	movs	r3, #171	; 0xab
   1549c:	005b      	lsls	r3, r3, #1
   1549e:	18fb      	adds	r3, r7, r3
   154a0:	2200      	movs	r2, #0
   154a2:	801a      	strh	r2, [r3, #0]
  uint8_t error = 0xFF;
   154a4:	2316      	movs	r3, #22
   154a6:	33ff      	adds	r3, #255	; 0xff
   154a8:	18fb      	adds	r3, r7, r3
   154aa:	22ff      	movs	r2, #255	; 0xff
   154ac:	701a      	strb	r2, [r3, #0]
  uint8_t param_not_applicated[GUI_PARAM_ALL];         /* List of parameters who could not be applied. */
  uint8_t counter_param_not_applicated = 0;  /* Counter of not applicated parameters */
   154ae:	2356      	movs	r3, #86	; 0x56
   154b0:	33ff      	adds	r3, #255	; 0xff
   154b2:	18fb      	adds	r3, r7, r3
   154b4:	2200      	movs	r2, #0
   154b6:	701a      	strb	r2, [r3, #0]
  uint8_t tag, flag_drp = 0, tdrp = 0;
   154b8:	23aa      	movs	r3, #170	; 0xaa
   154ba:	005b      	lsls	r3, r3, #1
   154bc:	18fb      	adds	r3, r7, r3
   154be:	2200      	movs	r2, #0
   154c0:	701a      	strb	r2, [r3, #0]
   154c2:	2354      	movs	r3, #84	; 0x54
   154c4:	33ff      	adds	r3, #255	; 0xff
   154c6:	18fb      	adds	r3, r7, r3
   154c8:	2200      	movs	r2, #0
   154ca:	701a      	strb	r2, [r3, #0]

  TLV_init_decode(&process_tlv, instruction);
   154cc:	68ba      	ldr	r2, [r7, #8]
   154ce:	238e      	movs	r3, #142	; 0x8e
   154d0:	005b      	lsls	r3, r3, #1
   154d2:	18fb      	adds	r3, r7, r3
   154d4:	0011      	movs	r1, r2
   154d6:	0018      	movs	r0, r3
   154d8:	f7fd fddc 	bl	13094 <TLV_init_decode>
  /* This is the pEncodedMsg can be sent as it is at this point, if there isn't any error during application of settings*/
  TLV_init_encode(&send_tlv, __GUI_SET_TAG_ID((PortNum + 1), DPM_CONFIG_SET_CNF), TLV_SIZE_MAX, pEncodedMsg);
   154dc:	4bd3      	ldr	r3, [pc, #844]	; (1582c <Send_DpmConfigSetCnf+0x3ac>)
   154de:	22ac      	movs	r2, #172	; 0xac
   154e0:	0052      	lsls	r2, r2, #1
   154e2:	4694      	mov	ip, r2
   154e4:	44bc      	add	ip, r7
   154e6:	4463      	add	r3, ip
   154e8:	781b      	ldrb	r3, [r3, #0]
   154ea:	3301      	adds	r3, #1
   154ec:	015b      	lsls	r3, r3, #5
   154ee:	b25b      	sxtb	r3, r3
   154f0:	2207      	movs	r2, #7
   154f2:	4313      	orrs	r3, r2
   154f4:	b25b      	sxtb	r3, r3
   154f6:	b2d9      	uxtb	r1, r3
   154f8:	687c      	ldr	r4, [r7, #4]
   154fa:	2380      	movs	r3, #128	; 0x80
   154fc:	005a      	lsls	r2, r3, #1
   154fe:	2392      	movs	r3, #146	; 0x92
   15500:	005b      	lsls	r3, r3, #1
   15502:	18f8      	adds	r0, r7, r3
   15504:	0023      	movs	r3, r4
   15506:	f7fd fbed 	bl	12ce4 <TLV_init_encode>

  /* Do while loop, used to parse and apply each parameter */
  while(0xFF != TLV_get(&process_tlv, &tag, &size, &value))
   1550a:	f000 fd96 	bl	1603a <Send_DpmConfigSetCnf+0xbba>
      As long as we haven't read all the parameters. If error is set, we continue to loop
      to apply the other parameters if it's because of a DPM_REJECT
      While loop, used to parse and apply each parameter
    */
  {
    switch((USBPD_GUI_Tag_Param)tag)
   1550e:	4bc8      	ldr	r3, [pc, #800]	; (15830 <Send_DpmConfigSetCnf+0x3b0>)
   15510:	22ac      	movs	r2, #172	; 0xac
   15512:	0052      	lsls	r2, r2, #1
   15514:	4694      	mov	ip, r2
   15516:	44bc      	add	ip, r7
   15518:	4463      	add	r3, ip
   1551a:	781b      	ldrb	r3, [r3, #0]
   1551c:	2b1c      	cmp	r3, #28
   1551e:	d901      	bls.n	15524 <Send_DpmConfigSetCnf+0xa4>
   15520:	f000 fd5c 	bl	15fdc <Send_DpmConfigSetCnf+0xb5c>
   15524:	009a      	lsls	r2, r3, #2
   15526:	4bc3      	ldr	r3, [pc, #780]	; (15834 <Send_DpmConfigSetCnf+0x3b4>)
   15528:	18d3      	adds	r3, r2, r3
   1552a:	681b      	ldr	r3, [r3, #0]
   1552c:	469f      	mov	pc, r3
      */
    {
    case GUI_PARAM_SOP :
      /* SOP & SOP1 & SOP2 */
      /* SOP1_Debug & SOP2_Debug not implemented */
      DPM_Settings[PortNum].PE_SupportedSOP = value[0];
   1552e:	238c      	movs	r3, #140	; 0x8c
   15530:	005b      	lsls	r3, r3, #1
   15532:	18fb      	adds	r3, r7, r3
   15534:	681b      	ldr	r3, [r3, #0]
   15536:	7819      	ldrb	r1, [r3, #0]
   15538:	4bbc      	ldr	r3, [pc, #752]	; (1582c <Send_DpmConfigSetCnf+0x3ac>)
   1553a:	22ac      	movs	r2, #172	; 0xac
   1553c:	0052      	lsls	r2, r2, #1
   1553e:	4694      	mov	ip, r2
   15540:	44bc      	add	ip, r7
   15542:	4463      	add	r3, ip
   15544:	781a      	ldrb	r2, [r3, #0]
   15546:	0008      	movs	r0, r1
   15548:	49bb      	ldr	r1, [pc, #748]	; (15838 <Send_DpmConfigSetCnf+0x3b8>)
   1554a:	0013      	movs	r3, r2
   1554c:	005b      	lsls	r3, r3, #1
   1554e:	189b      	adds	r3, r3, r2
   15550:	009b      	lsls	r3, r3, #2
   15552:	5058      	str	r0, [r3, r1]
   15554:	22ab      	movs	r2, #171	; 0xab
   15556:	0052      	lsls	r2, r2, #1
   15558:	18bb      	adds	r3, r7, r2
   1555a:	18ba      	adds	r2, r7, r2
   1555c:	8812      	ldrh	r2, [r2, #0]
   1555e:	801a      	strh	r2, [r3, #0]
   15560:	2256      	movs	r2, #86	; 0x56
   15562:	32ff      	adds	r2, #255	; 0xff
   15564:	18bb      	adds	r3, r7, r2
   15566:	18ba      	adds	r2, r7, r2
   15568:	7812      	ldrb	r2, [r2, #0]
   1556a:	701a      	strb	r2, [r3, #0]
   1556c:	22aa      	movs	r2, #170	; 0xaa
   1556e:	0052      	lsls	r2, r2, #1
   15570:	18bb      	adds	r3, r7, r2
   15572:	18ba      	adds	r2, r7, r2
   15574:	7812      	ldrb	r2, [r2, #0]
   15576:	701a      	strb	r2, [r3, #0]
   15578:	2254      	movs	r2, #84	; 0x54
   1557a:	32ff      	adds	r2, #255	; 0xff
   1557c:	18bb      	adds	r3, r7, r2
   1557e:	18ba      	adds	r2, r7, r2
   15580:	7812      	ldrb	r2, [r2, #0]
   15582:	701a      	strb	r2, [r3, #0]
      break;
   15584:	f000 fd59 	bl	1603a <Send_DpmConfigSetCnf+0xbba>
#if defined(USBPD_REV30_SUPPORT)
    case GUI_PARAM_FASTROLESWAP :
      /*FastRoleSwap*/
      DPM_Settings[PortNum].PE_PD3_Support.d.PE_FastRoleSwapSupport = value[0];
   15588:	238c      	movs	r3, #140	; 0x8c
   1558a:	005b      	lsls	r3, r3, #1
   1558c:	18fb      	adds	r3, r7, r3
   1558e:	681b      	ldr	r3, [r3, #0]
   15590:	7819      	ldrb	r1, [r3, #0]
   15592:	4ba6      	ldr	r3, [pc, #664]	; (1582c <Send_DpmConfigSetCnf+0x3ac>)
   15594:	22ac      	movs	r2, #172	; 0xac
   15596:	0052      	lsls	r2, r2, #1
   15598:	4694      	mov	ip, r2
   1559a:	44bc      	add	ip, r7
   1559c:	4463      	add	r3, ip
   1559e:	781a      	ldrb	r2, [r3, #0]
   155a0:	2301      	movs	r3, #1
   155a2:	400b      	ands	r3, r1
   155a4:	b2d9      	uxtb	r1, r3
   155a6:	48a4      	ldr	r0, [pc, #656]	; (15838 <Send_DpmConfigSetCnf+0x3b8>)
   155a8:	2408      	movs	r4, #8
   155aa:	0013      	movs	r3, r2
   155ac:	005b      	lsls	r3, r3, #1
   155ae:	189b      	adds	r3, r3, r2
   155b0:	009b      	lsls	r3, r3, #2
   155b2:	18c3      	adds	r3, r0, r3
   155b4:	191b      	adds	r3, r3, r4
   155b6:	2201      	movs	r2, #1
   155b8:	400a      	ands	r2, r1
   155ba:	1890      	adds	r0, r2, r2
   155bc:	781a      	ldrb	r2, [r3, #0]
   155be:	2102      	movs	r1, #2
   155c0:	438a      	bics	r2, r1
   155c2:	1c11      	adds	r1, r2, #0
   155c4:	1c02      	adds	r2, r0, #0
   155c6:	430a      	orrs	r2, r1
   155c8:	701a      	strb	r2, [r3, #0]
   155ca:	22ab      	movs	r2, #171	; 0xab
   155cc:	0052      	lsls	r2, r2, #1
   155ce:	18bb      	adds	r3, r7, r2
   155d0:	18ba      	adds	r2, r7, r2
   155d2:	8812      	ldrh	r2, [r2, #0]
   155d4:	801a      	strh	r2, [r3, #0]
   155d6:	2256      	movs	r2, #86	; 0x56
   155d8:	32ff      	adds	r2, #255	; 0xff
   155da:	18bb      	adds	r3, r7, r2
   155dc:	18ba      	adds	r2, r7, r2
   155de:	7812      	ldrb	r2, [r2, #0]
   155e0:	701a      	strb	r2, [r3, #0]
   155e2:	22aa      	movs	r2, #170	; 0xaa
   155e4:	0052      	lsls	r2, r2, #1
   155e6:	18bb      	adds	r3, r7, r2
   155e8:	18ba      	adds	r2, r7, r2
   155ea:	7812      	ldrb	r2, [r2, #0]
   155ec:	701a      	strb	r2, [r3, #0]
   155ee:	2254      	movs	r2, #84	; 0x54
   155f0:	32ff      	adds	r2, #255	; 0xff
   155f2:	18bb      	adds	r3, r7, r2
   155f4:	18ba      	adds	r2, r7, r2
   155f6:	7812      	ldrb	r2, [r2, #0]
   155f8:	701a      	strb	r2, [r3, #0]
      break;
   155fa:	f000 fd1e 	bl	1603a <Send_DpmConfigSetCnf+0xbba>
#endif /*USBPD_REV30_SUPPORT*/
    case GUI_PARAM_DATAROLESWAP_TO_UFP :
      /*DataRoleSwap to UFP */
      DPM_USER_Settings[PortNum].PE_DR_Swap_To_UFP = value[0];
   155fe:	238c      	movs	r3, #140	; 0x8c
   15600:	005b      	lsls	r3, r3, #1
   15602:	18fb      	adds	r3, r7, r3
   15604:	681b      	ldr	r3, [r3, #0]
   15606:	7819      	ldrb	r1, [r3, #0]
   15608:	4b88      	ldr	r3, [pc, #544]	; (1582c <Send_DpmConfigSetCnf+0x3ac>)
   1560a:	22ac      	movs	r2, #172	; 0xac
   1560c:	0052      	lsls	r2, r2, #1
   1560e:	4694      	mov	ip, r2
   15610:	44bc      	add	ip, r7
   15612:	4463      	add	r3, ip
   15614:	781a      	ldrb	r2, [r3, #0]
   15616:	2301      	movs	r3, #1
   15618:	400b      	ands	r3, r1
   1561a:	b2d9      	uxtb	r1, r3
   1561c:	4b87      	ldr	r3, [pc, #540]	; (1583c <Send_DpmConfigSetCnf+0x3bc>)
   1561e:	2074      	movs	r0, #116	; 0x74
   15620:	4342      	muls	r2, r0
   15622:	2001      	movs	r0, #1
   15624:	4001      	ands	r1, r0
   15626:	00cc      	lsls	r4, r1, #3
   15628:	5cd1      	ldrb	r1, [r2, r3]
   1562a:	2008      	movs	r0, #8
   1562c:	4381      	bics	r1, r0
   1562e:	1c08      	adds	r0, r1, #0
   15630:	1c21      	adds	r1, r4, #0
   15632:	4301      	orrs	r1, r0
   15634:	54d1      	strb	r1, [r2, r3]
   15636:	22ab      	movs	r2, #171	; 0xab
   15638:	0052      	lsls	r2, r2, #1
   1563a:	18bb      	adds	r3, r7, r2
   1563c:	18ba      	adds	r2, r7, r2
   1563e:	8812      	ldrh	r2, [r2, #0]
   15640:	801a      	strh	r2, [r3, #0]
   15642:	2256      	movs	r2, #86	; 0x56
   15644:	32ff      	adds	r2, #255	; 0xff
   15646:	18bb      	adds	r3, r7, r2
   15648:	18ba      	adds	r2, r7, r2
   1564a:	7812      	ldrb	r2, [r2, #0]
   1564c:	701a      	strb	r2, [r3, #0]
   1564e:	22aa      	movs	r2, #170	; 0xaa
   15650:	0052      	lsls	r2, r2, #1
   15652:	18bb      	adds	r3, r7, r2
   15654:	18ba      	adds	r2, r7, r2
   15656:	7812      	ldrb	r2, [r2, #0]
   15658:	701a      	strb	r2, [r3, #0]
   1565a:	2254      	movs	r2, #84	; 0x54
   1565c:	32ff      	adds	r2, #255	; 0xff
   1565e:	18bb      	adds	r3, r7, r2
   15660:	18ba      	adds	r2, r7, r2
   15662:	7812      	ldrb	r2, [r2, #0]
   15664:	701a      	strb	r2, [r3, #0]
      break;
   15666:	f000 fce8 	bl	1603a <Send_DpmConfigSetCnf+0xbba>
    case GUI_PARAM_DATAROLESWAP_TO_DFP :
      /*DataRoleSwap to DFP */
      DPM_USER_Settings[PortNum].PE_DR_Swap_To_DFP = value[0];
   1566a:	238c      	movs	r3, #140	; 0x8c
   1566c:	005b      	lsls	r3, r3, #1
   1566e:	18fb      	adds	r3, r7, r3
   15670:	681b      	ldr	r3, [r3, #0]
   15672:	7819      	ldrb	r1, [r3, #0]
   15674:	4b6d      	ldr	r3, [pc, #436]	; (1582c <Send_DpmConfigSetCnf+0x3ac>)
   15676:	22ac      	movs	r2, #172	; 0xac
   15678:	0052      	lsls	r2, r2, #1
   1567a:	4694      	mov	ip, r2
   1567c:	44bc      	add	ip, r7
   1567e:	4463      	add	r3, ip
   15680:	781a      	ldrb	r2, [r3, #0]
   15682:	2301      	movs	r3, #1
   15684:	400b      	ands	r3, r1
   15686:	b2d9      	uxtb	r1, r3
   15688:	4b6c      	ldr	r3, [pc, #432]	; (1583c <Send_DpmConfigSetCnf+0x3bc>)
   1568a:	2074      	movs	r0, #116	; 0x74
   1568c:	4342      	muls	r2, r0
   1568e:	2001      	movs	r0, #1
   15690:	4001      	ands	r1, r0
   15692:	008c      	lsls	r4, r1, #2
   15694:	5cd1      	ldrb	r1, [r2, r3]
   15696:	2004      	movs	r0, #4
   15698:	4381      	bics	r1, r0
   1569a:	1c08      	adds	r0, r1, #0
   1569c:	1c21      	adds	r1, r4, #0
   1569e:	4301      	orrs	r1, r0
   156a0:	54d1      	strb	r1, [r2, r3]
   156a2:	22ab      	movs	r2, #171	; 0xab
   156a4:	0052      	lsls	r2, r2, #1
   156a6:	18bb      	adds	r3, r7, r2
   156a8:	18ba      	adds	r2, r7, r2
   156aa:	8812      	ldrh	r2, [r2, #0]
   156ac:	801a      	strh	r2, [r3, #0]
   156ae:	2256      	movs	r2, #86	; 0x56
   156b0:	32ff      	adds	r2, #255	; 0xff
   156b2:	18bb      	adds	r3, r7, r2
   156b4:	18ba      	adds	r2, r7, r2
   156b6:	7812      	ldrb	r2, [r2, #0]
   156b8:	701a      	strb	r2, [r3, #0]
   156ba:	22aa      	movs	r2, #170	; 0xaa
   156bc:	0052      	lsls	r2, r2, #1
   156be:	18bb      	adds	r3, r7, r2
   156c0:	18ba      	adds	r2, r7, r2
   156c2:	7812      	ldrb	r2, [r2, #0]
   156c4:	701a      	strb	r2, [r3, #0]
   156c6:	2254      	movs	r2, #84	; 0x54
   156c8:	32ff      	adds	r2, #255	; 0xff
   156ca:	18bb      	adds	r3, r7, r2
   156cc:	18ba      	adds	r2, r7, r2
   156ce:	7812      	ldrb	r2, [r2, #0]
   156d0:	701a      	strb	r2, [r3, #0]
      break;
   156d2:	f000 fcb2 	bl	1603a <Send_DpmConfigSetCnf+0xbba>
    case GUI_PARAM_DEFAULTPOWERROLE :
      /*DefaultPowerRole*/
      DPM_Settings[PortNum].PE_DefaultRole = (USBPD_PortPowerRole_TypeDef)value[0];
   156d6:	238c      	movs	r3, #140	; 0x8c
   156d8:	005b      	lsls	r3, r3, #1
   156da:	18fb      	adds	r3, r7, r3
   156dc:	681b      	ldr	r3, [r3, #0]
   156de:	7819      	ldrb	r1, [r3, #0]
   156e0:	4b52      	ldr	r3, [pc, #328]	; (1582c <Send_DpmConfigSetCnf+0x3ac>)
   156e2:	22ac      	movs	r2, #172	; 0xac
   156e4:	0052      	lsls	r2, r2, #1
   156e6:	4694      	mov	ip, r2
   156e8:	44bc      	add	ip, r7
   156ea:	4463      	add	r3, ip
   156ec:	781a      	ldrb	r2, [r3, #0]
   156ee:	2301      	movs	r3, #1
   156f0:	400b      	ands	r3, r1
   156f2:	b2d9      	uxtb	r1, r3
   156f4:	4850      	ldr	r0, [pc, #320]	; (15838 <Send_DpmConfigSetCnf+0x3b8>)
   156f6:	0013      	movs	r3, r2
   156f8:	005b      	lsls	r3, r3, #1
   156fa:	189b      	adds	r3, r3, r2
   156fc:	009b      	lsls	r3, r3, #2
   156fe:	18c3      	adds	r3, r0, r3
   15700:	2201      	movs	r2, #1
   15702:	400a      	ands	r2, r1
   15704:	0090      	lsls	r0, r2, #2
   15706:	791a      	ldrb	r2, [r3, #4]
   15708:	2104      	movs	r1, #4
   1570a:	438a      	bics	r2, r1
   1570c:	1c11      	adds	r1, r2, #0
   1570e:	1c02      	adds	r2, r0, #0
   15710:	430a      	orrs	r2, r1
   15712:	711a      	strb	r2, [r3, #4]
   15714:	22ab      	movs	r2, #171	; 0xab
   15716:	0052      	lsls	r2, r2, #1
   15718:	18bb      	adds	r3, r7, r2
   1571a:	18ba      	adds	r2, r7, r2
   1571c:	8812      	ldrh	r2, [r2, #0]
   1571e:	801a      	strh	r2, [r3, #0]
   15720:	2256      	movs	r2, #86	; 0x56
   15722:	32ff      	adds	r2, #255	; 0xff
   15724:	18bb      	adds	r3, r7, r2
   15726:	18ba      	adds	r2, r7, r2
   15728:	7812      	ldrb	r2, [r2, #0]
   1572a:	701a      	strb	r2, [r3, #0]
   1572c:	22aa      	movs	r2, #170	; 0xaa
   1572e:	0052      	lsls	r2, r2, #1
   15730:	18bb      	adds	r3, r7, r2
   15732:	18ba      	adds	r2, r7, r2
   15734:	7812      	ldrb	r2, [r2, #0]
   15736:	701a      	strb	r2, [r3, #0]
   15738:	2254      	movs	r2, #84	; 0x54
   1573a:	32ff      	adds	r2, #255	; 0xff
   1573c:	18bb      	adds	r3, r7, r2
   1573e:	18ba      	adds	r2, r7, r2
   15740:	7812      	ldrb	r2, [r2, #0]
   15742:	701a      	strb	r2, [r3, #0]
      break;
   15744:	f000 fc79 	bl	1603a <Send_DpmConfigSetCnf+0xbba>
    case GUI_PARAM_DRP_SUPPORT :
      /*DRP_Support*/
      DPM_Settings[PortNum].PE_RoleSwap = value[0];
   15748:	238c      	movs	r3, #140	; 0x8c
   1574a:	005b      	lsls	r3, r3, #1
   1574c:	18fb      	adds	r3, r7, r3
   1574e:	681b      	ldr	r3, [r3, #0]
   15750:	7819      	ldrb	r1, [r3, #0]
   15752:	4b36      	ldr	r3, [pc, #216]	; (1582c <Send_DpmConfigSetCnf+0x3ac>)
   15754:	22ac      	movs	r2, #172	; 0xac
   15756:	0052      	lsls	r2, r2, #1
   15758:	4694      	mov	ip, r2
   1575a:	44bc      	add	ip, r7
   1575c:	4463      	add	r3, ip
   1575e:	781a      	ldrb	r2, [r3, #0]
   15760:	2301      	movs	r3, #1
   15762:	400b      	ands	r3, r1
   15764:	b2d9      	uxtb	r1, r3
   15766:	4834      	ldr	r0, [pc, #208]	; (15838 <Send_DpmConfigSetCnf+0x3b8>)
   15768:	0013      	movs	r3, r2
   1576a:	005b      	lsls	r3, r3, #1
   1576c:	189b      	adds	r3, r3, r2
   1576e:	009b      	lsls	r3, r3, #2
   15770:	18c3      	adds	r3, r0, r3
   15772:	2201      	movs	r2, #1
   15774:	400a      	ands	r2, r1
   15776:	00d0      	lsls	r0, r2, #3
   15778:	791a      	ldrb	r2, [r3, #4]
   1577a:	2108      	movs	r1, #8
   1577c:	438a      	bics	r2, r1
   1577e:	1c11      	adds	r1, r2, #0
   15780:	1c02      	adds	r2, r0, #0
   15782:	430a      	orrs	r2, r1
   15784:	711a      	strb	r2, [r3, #4]
   15786:	22ab      	movs	r2, #171	; 0xab
   15788:	0052      	lsls	r2, r2, #1
   1578a:	18bb      	adds	r3, r7, r2
   1578c:	18ba      	adds	r2, r7, r2
   1578e:	8812      	ldrh	r2, [r2, #0]
   15790:	801a      	strh	r2, [r3, #0]
   15792:	2256      	movs	r2, #86	; 0x56
   15794:	32ff      	adds	r2, #255	; 0xff
   15796:	18bb      	adds	r3, r7, r2
   15798:	18ba      	adds	r2, r7, r2
   1579a:	7812      	ldrb	r2, [r2, #0]
   1579c:	701a      	strb	r2, [r3, #0]
   1579e:	22aa      	movs	r2, #170	; 0xaa
   157a0:	0052      	lsls	r2, r2, #1
   157a2:	18bb      	adds	r3, r7, r2
   157a4:	18ba      	adds	r2, r7, r2
   157a6:	7812      	ldrb	r2, [r2, #0]
   157a8:	701a      	strb	r2, [r3, #0]
   157aa:	2254      	movs	r2, #84	; 0x54
   157ac:	32ff      	adds	r2, #255	; 0xff
   157ae:	18bb      	adds	r3, r7, r2
   157b0:	18ba      	adds	r2, r7, r2
   157b2:	7812      	ldrb	r2, [r2, #0]
   157b4:	701a      	strb	r2, [r3, #0]
      break;
   157b6:	f000 fc40 	bl	1603a <Send_DpmConfigSetCnf+0xbba>
    case GUI_PARAM_CADROLETOGGLE :
      /*CADRoleToggle*/
      DPM_Settings[PortNum].CAD_RoleToggle = value[0];
   157ba:	238c      	movs	r3, #140	; 0x8c
   157bc:	005b      	lsls	r3, r3, #1
   157be:	18fb      	adds	r3, r7, r3
   157c0:	681b      	ldr	r3, [r3, #0]
   157c2:	7819      	ldrb	r1, [r3, #0]
   157c4:	4b19      	ldr	r3, [pc, #100]	; (1582c <Send_DpmConfigSetCnf+0x3ac>)
   157c6:	22ac      	movs	r2, #172	; 0xac
   157c8:	0052      	lsls	r2, r2, #1
   157ca:	4694      	mov	ip, r2
   157cc:	44bc      	add	ip, r7
   157ce:	4463      	add	r3, ip
   157d0:	781a      	ldrb	r2, [r3, #0]
   157d2:	2301      	movs	r3, #1
   157d4:	400b      	ands	r3, r1
   157d6:	b2d9      	uxtb	r1, r3
   157d8:	4817      	ldr	r0, [pc, #92]	; (15838 <Send_DpmConfigSetCnf+0x3b8>)
   157da:	0013      	movs	r3, r2
   157dc:	005b      	lsls	r3, r3, #1
   157de:	189b      	adds	r3, r3, r2
   157e0:	009b      	lsls	r3, r3, #2
   157e2:	18c3      	adds	r3, r0, r3
   157e4:	2201      	movs	r2, #1
   157e6:	400a      	ands	r2, r1
   157e8:	0150      	lsls	r0, r2, #5
   157ea:	795a      	ldrb	r2, [r3, #5]
   157ec:	2120      	movs	r1, #32
   157ee:	438a      	bics	r2, r1
   157f0:	1c11      	adds	r1, r2, #0
   157f2:	1c02      	adds	r2, r0, #0
   157f4:	430a      	orrs	r2, r1
   157f6:	715a      	strb	r2, [r3, #5]
   157f8:	22ab      	movs	r2, #171	; 0xab
   157fa:	0052      	lsls	r2, r2, #1
   157fc:	18bb      	adds	r3, r7, r2
   157fe:	18ba      	adds	r2, r7, r2
   15800:	8812      	ldrh	r2, [r2, #0]
   15802:	801a      	strh	r2, [r3, #0]
   15804:	2256      	movs	r2, #86	; 0x56
   15806:	32ff      	adds	r2, #255	; 0xff
   15808:	18bb      	adds	r3, r7, r2
   1580a:	18ba      	adds	r2, r7, r2
   1580c:	7812      	ldrb	r2, [r2, #0]
   1580e:	701a      	strb	r2, [r3, #0]
   15810:	22aa      	movs	r2, #170	; 0xaa
   15812:	0052      	lsls	r2, r2, #1
   15814:	18bb      	adds	r3, r7, r2
   15816:	18ba      	adds	r2, r7, r2
   15818:	7812      	ldrb	r2, [r2, #0]
   1581a:	701a      	strb	r2, [r3, #0]
   1581c:	2254      	movs	r2, #84	; 0x54
   1581e:	32ff      	adds	r2, #255	; 0xff
   15820:	18bb      	adds	r3, r7, r2
   15822:	18ba      	adds	r2, r7, r2
   15824:	7812      	ldrb	r2, [r2, #0]
   15826:	701a      	strb	r2, [r3, #0]
      break;
   15828:	f000 fc07 	bl	1603a <Send_DpmConfigSetCnf+0xbba>
   1582c:	fffffeb7 	.word	0xfffffeb7
   15830:	fffffebb 	.word	0xfffffebb
   15834:	0001f950 	.word	0x0001f950
   15838:	0002fec8 	.word	0x0002fec8
   1583c:	0002fedc 	.word	0x0002fedc
    case GUI_PARAM_PE_SCAP_HR :
      /*PE_SCAP_HR*/
      DPM_Settings[PortNum].PE_CapscounterSupport = value[0];
   15840:	238c      	movs	r3, #140	; 0x8c
   15842:	005b      	lsls	r3, r3, #1
   15844:	18fb      	adds	r3, r7, r3
   15846:	681b      	ldr	r3, [r3, #0]
   15848:	7819      	ldrb	r1, [r3, #0]
   1584a:	4be7      	ldr	r3, [pc, #924]	; (15be8 <Send_DpmConfigSetCnf+0x768>)
   1584c:	22ac      	movs	r2, #172	; 0xac
   1584e:	0052      	lsls	r2, r2, #1
   15850:	4694      	mov	ip, r2
   15852:	44bc      	add	ip, r7
   15854:	4463      	add	r3, ip
   15856:	781a      	ldrb	r2, [r3, #0]
   15858:	2301      	movs	r3, #1
   1585a:	400b      	ands	r3, r1
   1585c:	b2d9      	uxtb	r1, r3
   1585e:	48e3      	ldr	r0, [pc, #908]	; (15bec <Send_DpmConfigSetCnf+0x76c>)
   15860:	0013      	movs	r3, r2
   15862:	005b      	lsls	r3, r3, #1
   15864:	189b      	adds	r3, r3, r2
   15866:	009b      	lsls	r3, r3, #2
   15868:	18c3      	adds	r3, r0, r3
   1586a:	01c8      	lsls	r0, r1, #7
   1586c:	791a      	ldrb	r2, [r3, #4]
   1586e:	217f      	movs	r1, #127	; 0x7f
   15870:	400a      	ands	r2, r1
   15872:	1c11      	adds	r1, r2, #0
   15874:	1c02      	adds	r2, r0, #0
   15876:	430a      	orrs	r2, r1
   15878:	711a      	strb	r2, [r3, #4]
   1587a:	22ab      	movs	r2, #171	; 0xab
   1587c:	0052      	lsls	r2, r2, #1
   1587e:	18bb      	adds	r3, r7, r2
   15880:	18ba      	adds	r2, r7, r2
   15882:	8812      	ldrh	r2, [r2, #0]
   15884:	801a      	strh	r2, [r3, #0]
   15886:	2256      	movs	r2, #86	; 0x56
   15888:	32ff      	adds	r2, #255	; 0xff
   1588a:	18bb      	adds	r3, r7, r2
   1588c:	18ba      	adds	r2, r7, r2
   1588e:	7812      	ldrb	r2, [r2, #0]
   15890:	701a      	strb	r2, [r3, #0]
   15892:	22aa      	movs	r2, #170	; 0xaa
   15894:	0052      	lsls	r2, r2, #1
   15896:	18bb      	adds	r3, r7, r2
   15898:	18ba      	adds	r2, r7, r2
   1589a:	7812      	ldrb	r2, [r2, #0]
   1589c:	701a      	strb	r2, [r3, #0]
   1589e:	2254      	movs	r2, #84	; 0x54
   158a0:	32ff      	adds	r2, #255	; 0xff
   158a2:	18bb      	adds	r3, r7, r2
   158a4:	18ba      	adds	r2, r7, r2
   158a6:	7812      	ldrb	r2, [r2, #0]
   158a8:	701a      	strb	r2, [r3, #0]
      break;
   158aa:	e3c6      	b.n	1603a <Send_DpmConfigSetCnf+0xbba>
    case GUI_PARAM_VCONNSWAP :
      /*VConnSwap*/
      DPM_USER_Settings[PortNum].PE_VconnSwap = value[0];
   158ac:	238c      	movs	r3, #140	; 0x8c
   158ae:	005b      	lsls	r3, r3, #1
   158b0:	18fb      	adds	r3, r7, r3
   158b2:	681b      	ldr	r3, [r3, #0]
   158b4:	7819      	ldrb	r1, [r3, #0]
   158b6:	4bcc      	ldr	r3, [pc, #816]	; (15be8 <Send_DpmConfigSetCnf+0x768>)
   158b8:	22ac      	movs	r2, #172	; 0xac
   158ba:	0052      	lsls	r2, r2, #1
   158bc:	4694      	mov	ip, r2
   158be:	44bc      	add	ip, r7
   158c0:	4463      	add	r3, ip
   158c2:	781a      	ldrb	r2, [r3, #0]
   158c4:	2301      	movs	r3, #1
   158c6:	400b      	ands	r3, r1
   158c8:	b2d9      	uxtb	r1, r3
   158ca:	4bc9      	ldr	r3, [pc, #804]	; (15bf0 <Send_DpmConfigSetCnf+0x770>)
   158cc:	2074      	movs	r0, #116	; 0x74
   158ce:	4342      	muls	r2, r0
   158d0:	2001      	movs	r0, #1
   158d2:	4001      	ands	r1, r0
   158d4:	184c      	adds	r4, r1, r1
   158d6:	5cd1      	ldrb	r1, [r2, r3]
   158d8:	2002      	movs	r0, #2
   158da:	4381      	bics	r1, r0
   158dc:	1c08      	adds	r0, r1, #0
   158de:	1c21      	adds	r1, r4, #0
   158e0:	4301      	orrs	r1, r0
   158e2:	54d1      	strb	r1, [r2, r3]
   158e4:	22ab      	movs	r2, #171	; 0xab
   158e6:	0052      	lsls	r2, r2, #1
   158e8:	18bb      	adds	r3, r7, r2
   158ea:	18ba      	adds	r2, r7, r2
   158ec:	8812      	ldrh	r2, [r2, #0]
   158ee:	801a      	strh	r2, [r3, #0]
   158f0:	2256      	movs	r2, #86	; 0x56
   158f2:	32ff      	adds	r2, #255	; 0xff
   158f4:	18bb      	adds	r3, r7, r2
   158f6:	18ba      	adds	r2, r7, r2
   158f8:	7812      	ldrb	r2, [r2, #0]
   158fa:	701a      	strb	r2, [r3, #0]
   158fc:	22aa      	movs	r2, #170	; 0xaa
   158fe:	0052      	lsls	r2, r2, #1
   15900:	18bb      	adds	r3, r7, r2
   15902:	18ba      	adds	r2, r7, r2
   15904:	7812      	ldrb	r2, [r2, #0]
   15906:	701a      	strb	r2, [r3, #0]
   15908:	2254      	movs	r2, #84	; 0x54
   1590a:	32ff      	adds	r2, #255	; 0xff
   1590c:	18bb      	adds	r3, r7, r2
   1590e:	18ba      	adds	r2, r7, r2
   15910:	7812      	ldrb	r2, [r2, #0]
   15912:	701a      	strb	r2, [r3, #0]
      break;
   15914:	e391      	b.n	1603a <Send_DpmConfigSetCnf+0xbba>
      DPM_Settings[PortNum].PE_VDMSupport = value[0];
      break;
#endif /*_VDM*/
    case GUI_PARAM_PING_SUPPORT :
      /* Ping Support */
      DPM_Settings[PortNum].PE_PingSupport = value[0];
   15916:	238c      	movs	r3, #140	; 0x8c
   15918:	005b      	lsls	r3, r3, #1
   1591a:	18fb      	adds	r3, r7, r3
   1591c:	681b      	ldr	r3, [r3, #0]
   1591e:	7819      	ldrb	r1, [r3, #0]
   15920:	4bb1      	ldr	r3, [pc, #708]	; (15be8 <Send_DpmConfigSetCnf+0x768>)
   15922:	22ac      	movs	r2, #172	; 0xac
   15924:	0052      	lsls	r2, r2, #1
   15926:	4694      	mov	ip, r2
   15928:	44bc      	add	ip, r7
   1592a:	4463      	add	r3, ip
   1592c:	781a      	ldrb	r2, [r3, #0]
   1592e:	2301      	movs	r3, #1
   15930:	400b      	ands	r3, r1
   15932:	b2d9      	uxtb	r1, r3
   15934:	48ad      	ldr	r0, [pc, #692]	; (15bec <Send_DpmConfigSetCnf+0x76c>)
   15936:	0013      	movs	r3, r2
   15938:	005b      	lsls	r3, r3, #1
   1593a:	189b      	adds	r3, r3, r2
   1593c:	009b      	lsls	r3, r3, #2
   1593e:	18c3      	adds	r3, r0, r3
   15940:	2201      	movs	r2, #1
   15942:	400a      	ands	r2, r1
   15944:	0190      	lsls	r0, r2, #6
   15946:	791a      	ldrb	r2, [r3, #4]
   15948:	2140      	movs	r1, #64	; 0x40
   1594a:	438a      	bics	r2, r1
   1594c:	1c11      	adds	r1, r2, #0
   1594e:	1c02      	adds	r2, r0, #0
   15950:	430a      	orrs	r2, r1
   15952:	711a      	strb	r2, [r3, #4]
   15954:	22ab      	movs	r2, #171	; 0xab
   15956:	0052      	lsls	r2, r2, #1
   15958:	18bb      	adds	r3, r7, r2
   1595a:	18ba      	adds	r2, r7, r2
   1595c:	8812      	ldrh	r2, [r2, #0]
   1595e:	801a      	strh	r2, [r3, #0]
   15960:	2256      	movs	r2, #86	; 0x56
   15962:	32ff      	adds	r2, #255	; 0xff
   15964:	18bb      	adds	r3, r7, r2
   15966:	18ba      	adds	r2, r7, r2
   15968:	7812      	ldrb	r2, [r2, #0]
   1596a:	701a      	strb	r2, [r3, #0]
   1596c:	22aa      	movs	r2, #170	; 0xaa
   1596e:	0052      	lsls	r2, r2, #1
   15970:	18bb      	adds	r3, r7, r2
   15972:	18ba      	adds	r2, r7, r2
   15974:	7812      	ldrb	r2, [r2, #0]
   15976:	701a      	strb	r2, [r3, #0]
   15978:	2254      	movs	r2, #84	; 0x54
   1597a:	32ff      	adds	r2, #255	; 0xff
   1597c:	18bb      	adds	r3, r7, r2
   1597e:	18ba      	adds	r2, r7, r2
   15980:	7812      	ldrb	r2, [r2, #0]
   15982:	701a      	strb	r2, [r3, #0]
      break;
   15984:	e359      	b.n	1603a <Send_DpmConfigSetCnf+0xbba>
#if defined(USBPD_REV30_SUPPORT)
    case GUI_PARAM_PPS_SUPPORT :
      DPM_Settings[PortNum].PE_PD3_Support.PD3_Support = LE16(&value[0]);
   15986:	228c      	movs	r2, #140	; 0x8c
   15988:	0052      	lsls	r2, r2, #1
   1598a:	18bb      	adds	r3, r7, r2
   1598c:	681b      	ldr	r3, [r3, #0]
   1598e:	781b      	ldrb	r3, [r3, #0]
   15990:	b299      	uxth	r1, r3
   15992:	18bb      	adds	r3, r7, r2
   15994:	681b      	ldr	r3, [r3, #0]
   15996:	3301      	adds	r3, #1
   15998:	781b      	ldrb	r3, [r3, #0]
   1599a:	b29b      	uxth	r3, r3
   1599c:	021b      	lsls	r3, r3, #8
   1599e:	b29b      	uxth	r3, r3
   159a0:	4a91      	ldr	r2, [pc, #580]	; (15be8 <Send_DpmConfigSetCnf+0x768>)
   159a2:	20ac      	movs	r0, #172	; 0xac
   159a4:	0040      	lsls	r0, r0, #1
   159a6:	4684      	mov	ip, r0
   159a8:	44bc      	add	ip, r7
   159aa:	4462      	add	r2, ip
   159ac:	7812      	ldrb	r2, [r2, #0]
   159ae:	18cb      	adds	r3, r1, r3
   159b0:	b298      	uxth	r0, r3
   159b2:	498e      	ldr	r1, [pc, #568]	; (15bec <Send_DpmConfigSetCnf+0x76c>)
   159b4:	0013      	movs	r3, r2
   159b6:	005b      	lsls	r3, r3, #1
   159b8:	189b      	adds	r3, r3, r2
   159ba:	009b      	lsls	r3, r3, #2
   159bc:	18cb      	adds	r3, r1, r3
   159be:	3308      	adds	r3, #8
   159c0:	1c02      	adds	r2, r0, #0
   159c2:	801a      	strh	r2, [r3, #0]
   159c4:	22ab      	movs	r2, #171	; 0xab
   159c6:	0052      	lsls	r2, r2, #1
   159c8:	18bb      	adds	r3, r7, r2
   159ca:	18ba      	adds	r2, r7, r2
   159cc:	8812      	ldrh	r2, [r2, #0]
   159ce:	801a      	strh	r2, [r3, #0]
   159d0:	2256      	movs	r2, #86	; 0x56
   159d2:	32ff      	adds	r2, #255	; 0xff
   159d4:	18bb      	adds	r3, r7, r2
   159d6:	18ba      	adds	r2, r7, r2
   159d8:	7812      	ldrb	r2, [r2, #0]
   159da:	701a      	strb	r2, [r3, #0]
   159dc:	22aa      	movs	r2, #170	; 0xaa
   159de:	0052      	lsls	r2, r2, #1
   159e0:	18bb      	adds	r3, r7, r2
   159e2:	18ba      	adds	r2, r7, r2
   159e4:	7812      	ldrb	r2, [r2, #0]
   159e6:	701a      	strb	r2, [r3, #0]
   159e8:	2254      	movs	r2, #84	; 0x54
   159ea:	32ff      	adds	r2, #255	; 0xff
   159ec:	18bb      	adds	r3, r7, r2
   159ee:	18ba      	adds	r2, r7, r2
   159f0:	7812      	ldrb	r2, [r2, #0]
   159f2:	701a      	strb	r2, [r3, #0]
      break;
   159f4:	e321      	b.n	1603a <Send_DpmConfigSetCnf+0xbba>
        uint32_t pdo;
#if USBPD_PORT_COUNT==2
        if (USBPD_PORT_0 == PortNum)
#endif /* USBPD_PORT_COUNT==2 */
        {
          memset(PORT0_PDO_ListSNK, 0, sizeof(PORT0_PDO_ListSNK));
   159f6:	4b7f      	ldr	r3, [pc, #508]	; (15bf4 <Send_DpmConfigSetCnf+0x774>)
   159f8:	221c      	movs	r2, #28
   159fa:	2100      	movs	r1, #0
   159fc:	0018      	movs	r0, r3
   159fe:	f008 fe52 	bl	1e6a6 <memset>
          for (index_pdo = 0, index_gui = 0; index_gui < size; index_pdo++)
   15a02:	2300      	movs	r3, #0
   15a04:	22a6      	movs	r2, #166	; 0xa6
   15a06:	0052      	lsls	r2, r2, #1
   15a08:	18ba      	adds	r2, r7, r2
   15a0a:	6013      	str	r3, [r2, #0]
   15a0c:	2300      	movs	r3, #0
   15a0e:	22a4      	movs	r2, #164	; 0xa4
   15a10:	0052      	lsls	r2, r2, #1
   15a12:	18ba      	adds	r2, r7, r2
   15a14:	6013      	str	r3, [r2, #0]
   15a16:	e03c      	b.n	15a92 <Send_DpmConfigSetCnf+0x612>
          {
            pdo = LE32(&value[index_gui]);
   15a18:	248c      	movs	r4, #140	; 0x8c
   15a1a:	0064      	lsls	r4, r4, #1
   15a1c:	193b      	adds	r3, r7, r4
   15a1e:	681a      	ldr	r2, [r3, #0]
   15a20:	20a4      	movs	r0, #164	; 0xa4
   15a22:	0040      	lsls	r0, r0, #1
   15a24:	183b      	adds	r3, r7, r0
   15a26:	681b      	ldr	r3, [r3, #0]
   15a28:	18d3      	adds	r3, r2, r3
   15a2a:	781b      	ldrb	r3, [r3, #0]
   15a2c:	0019      	movs	r1, r3
   15a2e:	193b      	adds	r3, r7, r4
   15a30:	681a      	ldr	r2, [r3, #0]
   15a32:	183b      	adds	r3, r7, r0
   15a34:	681b      	ldr	r3, [r3, #0]
   15a36:	3301      	adds	r3, #1
   15a38:	18d3      	adds	r3, r2, r3
   15a3a:	781b      	ldrb	r3, [r3, #0]
   15a3c:	021b      	lsls	r3, r3, #8
   15a3e:	18ca      	adds	r2, r1, r3
   15a40:	193b      	adds	r3, r7, r4
   15a42:	6819      	ldr	r1, [r3, #0]
   15a44:	183b      	adds	r3, r7, r0
   15a46:	681b      	ldr	r3, [r3, #0]
   15a48:	3302      	adds	r3, #2
   15a4a:	18cb      	adds	r3, r1, r3
   15a4c:	781b      	ldrb	r3, [r3, #0]
   15a4e:	041b      	lsls	r3, r3, #16
   15a50:	18d2      	adds	r2, r2, r3
   15a52:	193b      	adds	r3, r7, r4
   15a54:	6819      	ldr	r1, [r3, #0]
   15a56:	183b      	adds	r3, r7, r0
   15a58:	681b      	ldr	r3, [r3, #0]
   15a5a:	3303      	adds	r3, #3
   15a5c:	18cb      	adds	r3, r1, r3
   15a5e:	781b      	ldrb	r3, [r3, #0]
   15a60:	061b      	lsls	r3, r3, #24
   15a62:	18d3      	adds	r3, r2, r3
   15a64:	2198      	movs	r1, #152	; 0x98
   15a66:	0049      	lsls	r1, r1, #1
   15a68:	187a      	adds	r2, r7, r1
   15a6a:	6013      	str	r3, [r2, #0]
            PORT0_PDO_ListSNK[index_pdo] = pdo;
   15a6c:	4b61      	ldr	r3, [pc, #388]	; (15bf4 <Send_DpmConfigSetCnf+0x774>)
   15a6e:	24a6      	movs	r4, #166	; 0xa6
   15a70:	0064      	lsls	r4, r4, #1
   15a72:	193a      	adds	r2, r7, r4
   15a74:	6812      	ldr	r2, [r2, #0]
   15a76:	0092      	lsls	r2, r2, #2
   15a78:	1879      	adds	r1, r7, r1
   15a7a:	6809      	ldr	r1, [r1, #0]
   15a7c:	50d1      	str	r1, [r2, r3]
            index_gui = index_gui + 4;
   15a7e:	183b      	adds	r3, r7, r0
   15a80:	681b      	ldr	r3, [r3, #0]
   15a82:	3304      	adds	r3, #4
   15a84:	183a      	adds	r2, r7, r0
   15a86:	6013      	str	r3, [r2, #0]
          for (index_pdo = 0, index_gui = 0; index_gui < size; index_pdo++)
   15a88:	193b      	adds	r3, r7, r4
   15a8a:	681b      	ldr	r3, [r3, #0]
   15a8c:	3301      	adds	r3, #1
   15a8e:	193a      	adds	r2, r7, r4
   15a90:	6013      	str	r3, [r2, #0]
   15a92:	238b      	movs	r3, #139	; 0x8b
   15a94:	005b      	lsls	r3, r3, #1
   15a96:	18fb      	adds	r3, r7, r3
   15a98:	881b      	ldrh	r3, [r3, #0]
   15a9a:	001a      	movs	r2, r3
   15a9c:	23a4      	movs	r3, #164	; 0xa4
   15a9e:	005b      	lsls	r3, r3, #1
   15aa0:	18fb      	adds	r3, r7, r3
   15aa2:	681b      	ldr	r3, [r3, #0]
   15aa4:	4293      	cmp	r3, r2
   15aa6:	d3b7      	bcc.n	15a18 <Send_DpmConfigSetCnf+0x598>
          }
          USBPD_NbPDO[0] = (size / 4);
   15aa8:	238b      	movs	r3, #139	; 0x8b
   15aaa:	005b      	lsls	r3, r3, #1
   15aac:	18fb      	adds	r3, r7, r3
   15aae:	881b      	ldrh	r3, [r3, #0]
   15ab0:	089b      	lsrs	r3, r3, #2
   15ab2:	b29b      	uxth	r3, r3
   15ab4:	b2da      	uxtb	r2, r3
   15ab6:	4b50      	ldr	r3, [pc, #320]	; (15bf8 <Send_DpmConfigSetCnf+0x778>)
   15ab8:	701a      	strb	r2, [r3, #0]
          UpdateSNKPowerPort0();
   15aba:	f001 f851 	bl	16b60 <UpdateSNKPowerPort0>
   15abe:	22ab      	movs	r2, #171	; 0xab
   15ac0:	0052      	lsls	r2, r2, #1
   15ac2:	18bb      	adds	r3, r7, r2
   15ac4:	18ba      	adds	r2, r7, r2
   15ac6:	8812      	ldrh	r2, [r2, #0]
   15ac8:	801a      	strh	r2, [r3, #0]
   15aca:	2256      	movs	r2, #86	; 0x56
   15acc:	32ff      	adds	r2, #255	; 0xff
   15ace:	18bb      	adds	r3, r7, r2
   15ad0:	18ba      	adds	r2, r7, r2
   15ad2:	7812      	ldrb	r2, [r2, #0]
   15ad4:	701a      	strb	r2, [r3, #0]
   15ad6:	22aa      	movs	r2, #170	; 0xaa
   15ad8:	0052      	lsls	r2, r2, #1
   15ada:	18bb      	adds	r3, r7, r2
   15adc:	18ba      	adds	r2, r7, r2
   15ade:	7812      	ldrb	r2, [r2, #0]
   15ae0:	701a      	strb	r2, [r3, #0]
   15ae2:	2254      	movs	r2, #84	; 0x54
   15ae4:	32ff      	adds	r2, #255	; 0xff
   15ae6:	18bb      	adds	r3, r7, r2
   15ae8:	18ba      	adds	r2, r7, r2
   15aea:	7812      	ldrb	r2, [r2, #0]
   15aec:	701a      	strb	r2, [r3, #0]
          USBPD_NbPDO[2] = (size / 4);
          UpdateSNKPowerPort1();
        }
#endif /* USBPD_PORT_COUNT==2 */
      }
      break;
   15aee:	e2a4      	b.n	1603a <Send_DpmConfigSetCnf+0xbba>
        uint32_t pdo;
#if USBPD_PORT_COUNT==2
        if (USBPD_PORT_0 == PortNum)
#endif /* USBPD_PORT_COUNT==2 */
        {
          memset(PORT0_PDO_ListSRC, 0, sizeof(PORT0_PDO_ListSRC));
   15af0:	4b42      	ldr	r3, [pc, #264]	; (15bfc <Send_DpmConfigSetCnf+0x77c>)
   15af2:	221c      	movs	r2, #28
   15af4:	2100      	movs	r1, #0
   15af6:	0018      	movs	r0, r3
   15af8:	f008 fdd5 	bl	1e6a6 <memset>
          for (index_pdo = 0, index_gui = 0; index_gui < size; index_pdo++)
   15afc:	2300      	movs	r3, #0
   15afe:	22a2      	movs	r2, #162	; 0xa2
   15b00:	0052      	lsls	r2, r2, #1
   15b02:	18ba      	adds	r2, r7, r2
   15b04:	6013      	str	r3, [r2, #0]
   15b06:	2300      	movs	r3, #0
   15b08:	22a0      	movs	r2, #160	; 0xa0
   15b0a:	0052      	lsls	r2, r2, #1
   15b0c:	18ba      	adds	r2, r7, r2
   15b0e:	6013      	str	r3, [r2, #0]
   15b10:	e03c      	b.n	15b8c <Send_DpmConfigSetCnf+0x70c>
          {
            pdo = LE32(&value[index_gui]);
   15b12:	248c      	movs	r4, #140	; 0x8c
   15b14:	0064      	lsls	r4, r4, #1
   15b16:	193b      	adds	r3, r7, r4
   15b18:	681a      	ldr	r2, [r3, #0]
   15b1a:	20a0      	movs	r0, #160	; 0xa0
   15b1c:	0040      	lsls	r0, r0, #1
   15b1e:	183b      	adds	r3, r7, r0
   15b20:	681b      	ldr	r3, [r3, #0]
   15b22:	18d3      	adds	r3, r2, r3
   15b24:	781b      	ldrb	r3, [r3, #0]
   15b26:	0019      	movs	r1, r3
   15b28:	193b      	adds	r3, r7, r4
   15b2a:	681a      	ldr	r2, [r3, #0]
   15b2c:	183b      	adds	r3, r7, r0
   15b2e:	681b      	ldr	r3, [r3, #0]
   15b30:	3301      	adds	r3, #1
   15b32:	18d3      	adds	r3, r2, r3
   15b34:	781b      	ldrb	r3, [r3, #0]
   15b36:	021b      	lsls	r3, r3, #8
   15b38:	18ca      	adds	r2, r1, r3
   15b3a:	193b      	adds	r3, r7, r4
   15b3c:	6819      	ldr	r1, [r3, #0]
   15b3e:	183b      	adds	r3, r7, r0
   15b40:	681b      	ldr	r3, [r3, #0]
   15b42:	3302      	adds	r3, #2
   15b44:	18cb      	adds	r3, r1, r3
   15b46:	781b      	ldrb	r3, [r3, #0]
   15b48:	041b      	lsls	r3, r3, #16
   15b4a:	18d2      	adds	r2, r2, r3
   15b4c:	193b      	adds	r3, r7, r4
   15b4e:	6819      	ldr	r1, [r3, #0]
   15b50:	183b      	adds	r3, r7, r0
   15b52:	681b      	ldr	r3, [r3, #0]
   15b54:	3303      	adds	r3, #3
   15b56:	18cb      	adds	r3, r1, r3
   15b58:	781b      	ldrb	r3, [r3, #0]
   15b5a:	061b      	lsls	r3, r3, #24
   15b5c:	18d3      	adds	r3, r2, r3
   15b5e:	219a      	movs	r1, #154	; 0x9a
   15b60:	0049      	lsls	r1, r1, #1
   15b62:	187a      	adds	r2, r7, r1
   15b64:	6013      	str	r3, [r2, #0]
            PORT0_PDO_ListSRC[index_pdo] = pdo;
   15b66:	4b25      	ldr	r3, [pc, #148]	; (15bfc <Send_DpmConfigSetCnf+0x77c>)
   15b68:	24a2      	movs	r4, #162	; 0xa2
   15b6a:	0064      	lsls	r4, r4, #1
   15b6c:	193a      	adds	r2, r7, r4
   15b6e:	6812      	ldr	r2, [r2, #0]
   15b70:	0092      	lsls	r2, r2, #2
   15b72:	1879      	adds	r1, r7, r1
   15b74:	6809      	ldr	r1, [r1, #0]
   15b76:	50d1      	str	r1, [r2, r3]
            index_gui = index_gui + 4;
   15b78:	183b      	adds	r3, r7, r0
   15b7a:	681b      	ldr	r3, [r3, #0]
   15b7c:	3304      	adds	r3, #4
   15b7e:	183a      	adds	r2, r7, r0
   15b80:	6013      	str	r3, [r2, #0]
          for (index_pdo = 0, index_gui = 0; index_gui < size; index_pdo++)
   15b82:	193b      	adds	r3, r7, r4
   15b84:	681b      	ldr	r3, [r3, #0]
   15b86:	3301      	adds	r3, #1
   15b88:	193a      	adds	r2, r7, r4
   15b8a:	6013      	str	r3, [r2, #0]
   15b8c:	238b      	movs	r3, #139	; 0x8b
   15b8e:	005b      	lsls	r3, r3, #1
   15b90:	18fb      	adds	r3, r7, r3
   15b92:	881b      	ldrh	r3, [r3, #0]
   15b94:	001a      	movs	r2, r3
   15b96:	23a0      	movs	r3, #160	; 0xa0
   15b98:	005b      	lsls	r3, r3, #1
   15b9a:	18fb      	adds	r3, r7, r3
   15b9c:	681b      	ldr	r3, [r3, #0]
   15b9e:	4293      	cmp	r3, r2
   15ba0:	d3b7      	bcc.n	15b12 <Send_DpmConfigSetCnf+0x692>
          }
          USBPD_NbPDO[1] = (size / 4);
   15ba2:	238b      	movs	r3, #139	; 0x8b
   15ba4:	005b      	lsls	r3, r3, #1
   15ba6:	18fb      	adds	r3, r7, r3
   15ba8:	881b      	ldrh	r3, [r3, #0]
   15baa:	089b      	lsrs	r3, r3, #2
   15bac:	b29b      	uxth	r3, r3
   15bae:	b2da      	uxtb	r2, r3
   15bb0:	4b11      	ldr	r3, [pc, #68]	; (15bf8 <Send_DpmConfigSetCnf+0x778>)
   15bb2:	705a      	strb	r2, [r3, #1]
   15bb4:	22ab      	movs	r2, #171	; 0xab
   15bb6:	0052      	lsls	r2, r2, #1
   15bb8:	18bb      	adds	r3, r7, r2
   15bba:	18ba      	adds	r2, r7, r2
   15bbc:	8812      	ldrh	r2, [r2, #0]
   15bbe:	801a      	strh	r2, [r3, #0]
   15bc0:	2256      	movs	r2, #86	; 0x56
   15bc2:	32ff      	adds	r2, #255	; 0xff
   15bc4:	18bb      	adds	r3, r7, r2
   15bc6:	18ba      	adds	r2, r7, r2
   15bc8:	7812      	ldrb	r2, [r2, #0]
   15bca:	701a      	strb	r2, [r3, #0]
   15bcc:	22aa      	movs	r2, #170	; 0xaa
   15bce:	0052      	lsls	r2, r2, #1
   15bd0:	18bb      	adds	r3, r7, r2
   15bd2:	18ba      	adds	r2, r7, r2
   15bd4:	7812      	ldrb	r2, [r2, #0]
   15bd6:	701a      	strb	r2, [r3, #0]
   15bd8:	2254      	movs	r2, #84	; 0x54
   15bda:	32ff      	adds	r2, #255	; 0xff
   15bdc:	18bb      	adds	r3, r7, r2
   15bde:	18ba      	adds	r2, r7, r2
   15be0:	7812      	ldrb	r2, [r2, #0]
   15be2:	701a      	strb	r2, [r3, #0]
          }
          USBPD_NbPDO[3] = (size / 4);
        }
#endif /* USBPD_PORT_COUNT==2 */
      }
      break;
   15be4:	e229      	b.n	1603a <Send_DpmConfigSetCnf+0xbba>
   15be6:	46c0      	nop			; (mov r8, r8)
   15be8:	fffffeb7 	.word	0xfffffeb7
   15bec:	0002fec8 	.word	0x0002fec8
   15bf0:	0002fedc 	.word	0x0002fedc
   15bf4:	0002fe40 	.word	0x0002fe40
   15bf8:	0002fe20 	.word	0x0002fe20
   15bfc:	0002fe24 	.word	0x0002fe24
#endif /* (_SRC) || (_DRP) */
    case GUI_PARAM_TDRP :
      tdrp = value[0];
   15c00:	238c      	movs	r3, #140	; 0x8c
   15c02:	005b      	lsls	r3, r3, #1
   15c04:	18fb      	adds	r3, r7, r3
   15c06:	681a      	ldr	r2, [r3, #0]
   15c08:	2154      	movs	r1, #84	; 0x54
   15c0a:	31ff      	adds	r1, #255	; 0xff
   15c0c:	187b      	adds	r3, r7, r1
   15c0e:	7812      	ldrb	r2, [r2, #0]
   15c10:	701a      	strb	r2, [r3, #0]
      DPM_USER_Settings[PortNum].CAD_tDRP = tdrp;
   15c12:	4bec      	ldr	r3, [pc, #944]	; (15fc4 <Send_DpmConfigSetCnf+0xb44>)
   15c14:	22ac      	movs	r2, #172	; 0xac
   15c16:	0052      	lsls	r2, r2, #1
   15c18:	4694      	mov	ip, r2
   15c1a:	44bc      	add	ip, r7
   15c1c:	4463      	add	r3, ip
   15c1e:	781b      	ldrb	r3, [r3, #0]
   15c20:	187a      	adds	r2, r7, r1
   15c22:	7812      	ldrb	r2, [r2, #0]
   15c24:	217f      	movs	r1, #127	; 0x7f
   15c26:	400a      	ands	r2, r1
   15c28:	b2d4      	uxtb	r4, r2
   15c2a:	4ae7      	ldr	r2, [pc, #924]	; (15fc8 <Send_DpmConfigSetCnf+0xb48>)
   15c2c:	2168      	movs	r1, #104	; 0x68
   15c2e:	2074      	movs	r0, #116	; 0x74
   15c30:	4343      	muls	r3, r0
   15c32:	18d3      	adds	r3, r2, r3
   15c34:	185b      	adds	r3, r3, r1
   15c36:	1c22      	adds	r2, r4, #0
   15c38:	1890      	adds	r0, r2, r2
   15c3a:	791a      	ldrb	r2, [r3, #4]
   15c3c:	2101      	movs	r1, #1
   15c3e:	400a      	ands	r2, r1
   15c40:	1c11      	adds	r1, r2, #0
   15c42:	1c02      	adds	r2, r0, #0
   15c44:	430a      	orrs	r2, r1
   15c46:	711a      	strb	r2, [r3, #4]
      flag_drp = 1;
   15c48:	23aa      	movs	r3, #170	; 0xaa
   15c4a:	005b      	lsls	r3, r3, #1
   15c4c:	18fb      	adds	r3, r7, r3
   15c4e:	2201      	movs	r2, #1
   15c50:	701a      	strb	r2, [r3, #0]
   15c52:	22ab      	movs	r2, #171	; 0xab
   15c54:	0052      	lsls	r2, r2, #1
   15c56:	18bb      	adds	r3, r7, r2
   15c58:	18ba      	adds	r2, r7, r2
   15c5a:	8812      	ldrh	r2, [r2, #0]
   15c5c:	801a      	strh	r2, [r3, #0]
   15c5e:	2256      	movs	r2, #86	; 0x56
   15c60:	32ff      	adds	r2, #255	; 0xff
   15c62:	18bb      	adds	r3, r7, r2
   15c64:	18ba      	adds	r2, r7, r2
   15c66:	7812      	ldrb	r2, [r2, #0]
   15c68:	701a      	strb	r2, [r3, #0]
      break;
   15c6a:	e1e6      	b.n	1603a <Send_DpmConfigSetCnf+0xbba>
    case GUI_PARAM_DCSRC_DRP :
      dcdrp = value[0];
   15c6c:	238c      	movs	r3, #140	; 0x8c
   15c6e:	005b      	lsls	r3, r3, #1
   15c70:	18fb      	adds	r3, r7, r3
   15c72:	681b      	ldr	r3, [r3, #0]
   15c74:	781a      	ldrb	r2, [r3, #0]
   15c76:	21ab      	movs	r1, #171	; 0xab
   15c78:	0049      	lsls	r1, r1, #1
   15c7a:	187b      	adds	r3, r7, r1
   15c7c:	801a      	strh	r2, [r3, #0]
      DPM_USER_Settings[PortNum].CAD_dcSRC_DRP = dcdrp;
   15c7e:	4bd1      	ldr	r3, [pc, #836]	; (15fc4 <Send_DpmConfigSetCnf+0xb44>)
   15c80:	22ac      	movs	r2, #172	; 0xac
   15c82:	0052      	lsls	r2, r2, #1
   15c84:	4694      	mov	ip, r2
   15c86:	44bc      	add	ip, r7
   15c88:	4463      	add	r3, ip
   15c8a:	781b      	ldrb	r3, [r3, #0]
   15c8c:	187a      	adds	r2, r7, r1
   15c8e:	8812      	ldrh	r2, [r2, #0]
   15c90:	1c11      	adds	r1, r2, #0
   15c92:	227f      	movs	r2, #127	; 0x7f
   15c94:	400a      	ands	r2, r1
   15c96:	b2d2      	uxtb	r2, r2
   15c98:	49cb      	ldr	r1, [pc, #812]	; (15fc8 <Send_DpmConfigSetCnf+0xb48>)
   15c9a:	2068      	movs	r0, #104	; 0x68
   15c9c:	2474      	movs	r4, #116	; 0x74
   15c9e:	4363      	muls	r3, r4
   15ca0:	18cb      	adds	r3, r1, r3
   15ca2:	181b      	adds	r3, r3, r0
   15ca4:	217f      	movs	r1, #127	; 0x7f
   15ca6:	400a      	ands	r2, r1
   15ca8:	0010      	movs	r0, r2
   15caa:	795a      	ldrb	r2, [r3, #5]
   15cac:	217f      	movs	r1, #127	; 0x7f
   15cae:	438a      	bics	r2, r1
   15cb0:	1c11      	adds	r1, r2, #0
   15cb2:	1c02      	adds	r2, r0, #0
   15cb4:	430a      	orrs	r2, r1
   15cb6:	715a      	strb	r2, [r3, #5]
      flag_drp = 1;
   15cb8:	23aa      	movs	r3, #170	; 0xaa
   15cba:	005b      	lsls	r3, r3, #1
   15cbc:	18fb      	adds	r3, r7, r3
   15cbe:	2201      	movs	r2, #1
   15cc0:	701a      	strb	r2, [r3, #0]
   15cc2:	2256      	movs	r2, #86	; 0x56
   15cc4:	32ff      	adds	r2, #255	; 0xff
   15cc6:	18bb      	adds	r3, r7, r2
   15cc8:	18ba      	adds	r2, r7, r2
   15cca:	7812      	ldrb	r2, [r2, #0]
   15ccc:	701a      	strb	r2, [r3, #0]
   15cce:	2254      	movs	r2, #84	; 0x54
   15cd0:	32ff      	adds	r2, #255	; 0xff
   15cd2:	18bb      	adds	r3, r7, r2
   15cd4:	18ba      	adds	r2, r7, r2
   15cd6:	7812      	ldrb	r2, [r2, #0]
   15cd8:	701a      	strb	r2, [r3, #0]
      break;
   15cda:	e1ae      	b.n	1603a <Send_DpmConfigSetCnf+0xbba>
    case GUI_PARAM_RESPONDS_TO_DISCOV_SOP :
    case GUI_PARAM_ATTEMPTS_DISCOV_SOP :
      /* Parameter is a CONST. Cannot be changed */
      error = GUI_REJ_DPM_REJECT;
   15cdc:	2316      	movs	r3, #22
   15cde:	33ff      	adds	r3, #255	; 0xff
   15ce0:	18fb      	adds	r3, r7, r3
   15ce2:	2200      	movs	r2, #0
   15ce4:	701a      	strb	r2, [r3, #0]
      param_not_applicated[counter_param_not_applicated] = tag;
   15ce6:	2056      	movs	r0, #86	; 0x56
   15ce8:	30ff      	adds	r0, #255	; 0xff
   15cea:	183b      	adds	r3, r7, r0
   15cec:	781b      	ldrb	r3, [r3, #0]
   15cee:	4ab7      	ldr	r2, [pc, #732]	; (15fcc <Send_DpmConfigSetCnf+0xb4c>)
   15cf0:	21ac      	movs	r1, #172	; 0xac
   15cf2:	0049      	lsls	r1, r1, #1
   15cf4:	468c      	mov	ip, r1
   15cf6:	44bc      	add	ip, r7
   15cf8:	4462      	add	r2, ip
   15cfa:	7811      	ldrb	r1, [r2, #0]
   15cfc:	4ab4      	ldr	r2, [pc, #720]	; (15fd0 <Send_DpmConfigSetCnf+0xb50>)
   15cfe:	24ac      	movs	r4, #172	; 0xac
   15d00:	0064      	lsls	r4, r4, #1
   15d02:	46a4      	mov	ip, r4
   15d04:	44bc      	add	ip, r7
   15d06:	4462      	add	r2, ip
   15d08:	54d1      	strb	r1, [r2, r3]
      counter_param_not_applicated++;
   15d0a:	183b      	adds	r3, r7, r0
   15d0c:	781a      	ldrb	r2, [r3, #0]
   15d0e:	183b      	adds	r3, r7, r0
   15d10:	3201      	adds	r2, #1
   15d12:	701a      	strb	r2, [r3, #0]
   15d14:	22ab      	movs	r2, #171	; 0xab
   15d16:	0052      	lsls	r2, r2, #1
   15d18:	18bb      	adds	r3, r7, r2
   15d1a:	18ba      	adds	r2, r7, r2
   15d1c:	8812      	ldrh	r2, [r2, #0]
   15d1e:	801a      	strh	r2, [r3, #0]
   15d20:	22aa      	movs	r2, #170	; 0xaa
   15d22:	0052      	lsls	r2, r2, #1
   15d24:	18bb      	adds	r3, r7, r2
   15d26:	18ba      	adds	r2, r7, r2
   15d28:	7812      	ldrb	r2, [r2, #0]
   15d2a:	701a      	strb	r2, [r3, #0]
   15d2c:	2254      	movs	r2, #84	; 0x54
   15d2e:	32ff      	adds	r2, #255	; 0xff
   15d30:	18bb      	adds	r3, r7, r2
   15d32:	18ba      	adds	r2, r7, r2
   15d34:	7812      	ldrb	r2, [r2, #0]
   15d36:	701a      	strb	r2, [r3, #0]
      break;
   15d38:	e17f      	b.n	1603a <Send_DpmConfigSetCnf+0xbba>
    case GUI_PARAM_XID_SOP :
      DPM_ID_Settings[PortNum].XID       = LE32(&value[0]);
   15d3a:	208c      	movs	r0, #140	; 0x8c
   15d3c:	0040      	lsls	r0, r0, #1
   15d3e:	183b      	adds	r3, r7, r0
   15d40:	681b      	ldr	r3, [r3, #0]
   15d42:	781b      	ldrb	r3, [r3, #0]
   15d44:	001a      	movs	r2, r3
   15d46:	183b      	adds	r3, r7, r0
   15d48:	681b      	ldr	r3, [r3, #0]
   15d4a:	3301      	adds	r3, #1
   15d4c:	781b      	ldrb	r3, [r3, #0]
   15d4e:	021b      	lsls	r3, r3, #8
   15d50:	18d2      	adds	r2, r2, r3
   15d52:	183b      	adds	r3, r7, r0
   15d54:	681b      	ldr	r3, [r3, #0]
   15d56:	3302      	adds	r3, #2
   15d58:	781b      	ldrb	r3, [r3, #0]
   15d5a:	041b      	lsls	r3, r3, #16
   15d5c:	18d1      	adds	r1, r2, r3
   15d5e:	183b      	adds	r3, r7, r0
   15d60:	681b      	ldr	r3, [r3, #0]
   15d62:	3303      	adds	r3, #3
   15d64:	781b      	ldrb	r3, [r3, #0]
   15d66:	061b      	lsls	r3, r3, #24
   15d68:	4a96      	ldr	r2, [pc, #600]	; (15fc4 <Send_DpmConfigSetCnf+0xb44>)
   15d6a:	20ac      	movs	r0, #172	; 0xac
   15d6c:	0040      	lsls	r0, r0, #1
   15d6e:	4684      	mov	ip, r0
   15d70:	44bc      	add	ip, r7
   15d72:	4462      	add	r2, ip
   15d74:	7812      	ldrb	r2, [r2, #0]
   15d76:	18c9      	adds	r1, r1, r3
   15d78:	4b96      	ldr	r3, [pc, #600]	; (15fd4 <Send_DpmConfigSetCnf+0xb54>)
   15d7a:	00d2      	lsls	r2, r2, #3
   15d7c:	50d1      	str	r1, [r2, r3]
   15d7e:	22ab      	movs	r2, #171	; 0xab
   15d80:	0052      	lsls	r2, r2, #1
   15d82:	18bb      	adds	r3, r7, r2
   15d84:	18ba      	adds	r2, r7, r2
   15d86:	8812      	ldrh	r2, [r2, #0]
   15d88:	801a      	strh	r2, [r3, #0]
   15d8a:	2256      	movs	r2, #86	; 0x56
   15d8c:	32ff      	adds	r2, #255	; 0xff
   15d8e:	18bb      	adds	r3, r7, r2
   15d90:	18ba      	adds	r2, r7, r2
   15d92:	7812      	ldrb	r2, [r2, #0]
   15d94:	701a      	strb	r2, [r3, #0]
   15d96:	22aa      	movs	r2, #170	; 0xaa
   15d98:	0052      	lsls	r2, r2, #1
   15d9a:	18bb      	adds	r3, r7, r2
   15d9c:	18ba      	adds	r2, r7, r2
   15d9e:	7812      	ldrb	r2, [r2, #0]
   15da0:	701a      	strb	r2, [r3, #0]
   15da2:	2254      	movs	r2, #84	; 0x54
   15da4:	32ff      	adds	r2, #255	; 0xff
   15da6:	18bb      	adds	r3, r7, r2
   15da8:	18ba      	adds	r2, r7, r2
   15daa:	7812      	ldrb	r2, [r2, #0]
   15dac:	701a      	strb	r2, [r3, #0]
      break;
   15dae:	e144      	b.n	1603a <Send_DpmConfigSetCnf+0xbba>
    case GUI_PARAM_USB_VID_SOP :
      DPM_ID_Settings[PortNum].VID       = LE16(&value[0]);
   15db0:	228c      	movs	r2, #140	; 0x8c
   15db2:	0052      	lsls	r2, r2, #1
   15db4:	18bb      	adds	r3, r7, r2
   15db6:	681b      	ldr	r3, [r3, #0]
   15db8:	781b      	ldrb	r3, [r3, #0]
   15dba:	b299      	uxth	r1, r3
   15dbc:	18bb      	adds	r3, r7, r2
   15dbe:	681b      	ldr	r3, [r3, #0]
   15dc0:	3301      	adds	r3, #1
   15dc2:	781b      	ldrb	r3, [r3, #0]
   15dc4:	b29b      	uxth	r3, r3
   15dc6:	021b      	lsls	r3, r3, #8
   15dc8:	b29a      	uxth	r2, r3
   15dca:	4b7e      	ldr	r3, [pc, #504]	; (15fc4 <Send_DpmConfigSetCnf+0xb44>)
   15dcc:	20ac      	movs	r0, #172	; 0xac
   15dce:	0040      	lsls	r0, r0, #1
   15dd0:	4684      	mov	ip, r0
   15dd2:	44bc      	add	ip, r7
   15dd4:	4463      	add	r3, ip
   15dd6:	781b      	ldrb	r3, [r3, #0]
   15dd8:	188a      	adds	r2, r1, r2
   15dda:	b291      	uxth	r1, r2
   15ddc:	4a7d      	ldr	r2, [pc, #500]	; (15fd4 <Send_DpmConfigSetCnf+0xb54>)
   15dde:	00db      	lsls	r3, r3, #3
   15de0:	18d3      	adds	r3, r2, r3
   15de2:	3304      	adds	r3, #4
   15de4:	1c0a      	adds	r2, r1, #0
   15de6:	801a      	strh	r2, [r3, #0]
   15de8:	22ab      	movs	r2, #171	; 0xab
   15dea:	0052      	lsls	r2, r2, #1
   15dec:	18bb      	adds	r3, r7, r2
   15dee:	18ba      	adds	r2, r7, r2
   15df0:	8812      	ldrh	r2, [r2, #0]
   15df2:	801a      	strh	r2, [r3, #0]
   15df4:	2256      	movs	r2, #86	; 0x56
   15df6:	32ff      	adds	r2, #255	; 0xff
   15df8:	18bb      	adds	r3, r7, r2
   15dfa:	18ba      	adds	r2, r7, r2
   15dfc:	7812      	ldrb	r2, [r2, #0]
   15dfe:	701a      	strb	r2, [r3, #0]
   15e00:	22aa      	movs	r2, #170	; 0xaa
   15e02:	0052      	lsls	r2, r2, #1
   15e04:	18bb      	adds	r3, r7, r2
   15e06:	18ba      	adds	r2, r7, r2
   15e08:	7812      	ldrb	r2, [r2, #0]
   15e0a:	701a      	strb	r2, [r3, #0]
   15e0c:	2254      	movs	r2, #84	; 0x54
   15e0e:	32ff      	adds	r2, #255	; 0xff
   15e10:	18bb      	adds	r3, r7, r2
   15e12:	18ba      	adds	r2, r7, r2
   15e14:	7812      	ldrb	r2, [r2, #0]
   15e16:	701a      	strb	r2, [r3, #0]
      break;
   15e18:	e10f      	b.n	1603a <Send_DpmConfigSetCnf+0xbba>
    case GUI_PARAM_PID_SOP :
      DPM_ID_Settings[PortNum].PID       = LE16(&value[0]);
   15e1a:	228c      	movs	r2, #140	; 0x8c
   15e1c:	0052      	lsls	r2, r2, #1
   15e1e:	18bb      	adds	r3, r7, r2
   15e20:	681b      	ldr	r3, [r3, #0]
   15e22:	781b      	ldrb	r3, [r3, #0]
   15e24:	b299      	uxth	r1, r3
   15e26:	18bb      	adds	r3, r7, r2
   15e28:	681b      	ldr	r3, [r3, #0]
   15e2a:	3301      	adds	r3, #1
   15e2c:	781b      	ldrb	r3, [r3, #0]
   15e2e:	b29b      	uxth	r3, r3
   15e30:	021b      	lsls	r3, r3, #8
   15e32:	b29a      	uxth	r2, r3
   15e34:	4b63      	ldr	r3, [pc, #396]	; (15fc4 <Send_DpmConfigSetCnf+0xb44>)
   15e36:	20ac      	movs	r0, #172	; 0xac
   15e38:	0040      	lsls	r0, r0, #1
   15e3a:	4684      	mov	ip, r0
   15e3c:	44bc      	add	ip, r7
   15e3e:	4463      	add	r3, ip
   15e40:	781b      	ldrb	r3, [r3, #0]
   15e42:	188a      	adds	r2, r1, r2
   15e44:	b291      	uxth	r1, r2
   15e46:	4a63      	ldr	r2, [pc, #396]	; (15fd4 <Send_DpmConfigSetCnf+0xb54>)
   15e48:	00db      	lsls	r3, r3, #3
   15e4a:	18d3      	adds	r3, r2, r3
   15e4c:	3306      	adds	r3, #6
   15e4e:	1c0a      	adds	r2, r1, #0
   15e50:	801a      	strh	r2, [r3, #0]
   15e52:	22ab      	movs	r2, #171	; 0xab
   15e54:	0052      	lsls	r2, r2, #1
   15e56:	18bb      	adds	r3, r7, r2
   15e58:	18ba      	adds	r2, r7, r2
   15e5a:	8812      	ldrh	r2, [r2, #0]
   15e5c:	801a      	strh	r2, [r3, #0]
   15e5e:	2256      	movs	r2, #86	; 0x56
   15e60:	32ff      	adds	r2, #255	; 0xff
   15e62:	18bb      	adds	r3, r7, r2
   15e64:	18ba      	adds	r2, r7, r2
   15e66:	7812      	ldrb	r2, [r2, #0]
   15e68:	701a      	strb	r2, [r3, #0]
   15e6a:	22aa      	movs	r2, #170	; 0xaa
   15e6c:	0052      	lsls	r2, r2, #1
   15e6e:	18bb      	adds	r3, r7, r2
   15e70:	18ba      	adds	r2, r7, r2
   15e72:	7812      	ldrb	r2, [r2, #0]
   15e74:	701a      	strb	r2, [r3, #0]
   15e76:	2254      	movs	r2, #84	; 0x54
   15e78:	32ff      	adds	r2, #255	; 0xff
   15e7a:	18bb      	adds	r3, r7, r2
   15e7c:	18ba      	adds	r2, r7, r2
   15e7e:	7812      	ldrb	r2, [r2, #0]
   15e80:	701a      	strb	r2, [r3, #0]
      break;
   15e82:	e0da      	b.n	1603a <Send_DpmConfigSetCnf+0xbba>
      DPM_VDM_Settings[PortNum].VDM_bcdDevice_SOP     = LE16(&value[0]);
      break;
#endif /* _VDM */
    case GUI_PARAM_MEASUREREPORTING :
      /* MeasurementReporting */
      GUI_USER_Params[PortNum].u.MeasurementReporting = value[0];
   15e84:	238c      	movs	r3, #140	; 0x8c
   15e86:	005b      	lsls	r3, r3, #1
   15e88:	18fb      	adds	r3, r7, r3
   15e8a:	681b      	ldr	r3, [r3, #0]
   15e8c:	4a4d      	ldr	r2, [pc, #308]	; (15fc4 <Send_DpmConfigSetCnf+0xb44>)
   15e8e:	21ac      	movs	r1, #172	; 0xac
   15e90:	0049      	lsls	r1, r1, #1
   15e92:	468c      	mov	ip, r1
   15e94:	44bc      	add	ip, r7
   15e96:	4462      	add	r2, ip
   15e98:	7812      	ldrb	r2, [r2, #0]
   15e9a:	7818      	ldrb	r0, [r3, #0]
   15e9c:	494e      	ldr	r1, [pc, #312]	; (15fd8 <Send_DpmConfigSetCnf+0xb58>)
   15e9e:	0013      	movs	r3, r2
   15ea0:	005b      	lsls	r3, r3, #1
   15ea2:	189b      	adds	r3, r3, r2
   15ea4:	005b      	lsls	r3, r3, #1
   15ea6:	18cb      	adds	r3, r1, r3
   15ea8:	3304      	adds	r3, #4
   15eaa:	1c02      	adds	r2, r0, #0
   15eac:	701a      	strb	r2, [r3, #0]
   15eae:	22ab      	movs	r2, #171	; 0xab
   15eb0:	0052      	lsls	r2, r2, #1
   15eb2:	18bb      	adds	r3, r7, r2
   15eb4:	18ba      	adds	r2, r7, r2
   15eb6:	8812      	ldrh	r2, [r2, #0]
   15eb8:	801a      	strh	r2, [r3, #0]
   15eba:	2256      	movs	r2, #86	; 0x56
   15ebc:	32ff      	adds	r2, #255	; 0xff
   15ebe:	18bb      	adds	r3, r7, r2
   15ec0:	18ba      	adds	r2, r7, r2
   15ec2:	7812      	ldrb	r2, [r2, #0]
   15ec4:	701a      	strb	r2, [r3, #0]
   15ec6:	22aa      	movs	r2, #170	; 0xaa
   15ec8:	0052      	lsls	r2, r2, #1
   15eca:	18bb      	adds	r3, r7, r2
   15ecc:	18ba      	adds	r2, r7, r2
   15ece:	7812      	ldrb	r2, [r2, #0]
   15ed0:	701a      	strb	r2, [r3, #0]
   15ed2:	2254      	movs	r2, #84	; 0x54
   15ed4:	32ff      	adds	r2, #255	; 0xff
   15ed6:	18bb      	adds	r3, r7, r2
   15ed8:	18ba      	adds	r2, r7, r2
   15eda:	7812      	ldrb	r2, [r2, #0]
   15edc:	701a      	strb	r2, [r3, #0]
      break;
   15ede:	e0ac      	b.n	1603a <Send_DpmConfigSetCnf+0xbba>
#if defined(USBPD_REV30_SUPPORT)
#if _MANU_INFO
    case GUI_PARAM_MANUINFOPORT_VID :
      DPM_USER_Settings[PortNum].DPM_ManuInfoPort.VID = LE16(&value[0]);
   15ee0:	248c      	movs	r4, #140	; 0x8c
   15ee2:	0064      	lsls	r4, r4, #1
   15ee4:	193b      	adds	r3, r7, r4
   15ee6:	681b      	ldr	r3, [r3, #0]
   15ee8:	781b      	ldrb	r3, [r3, #0]
   15eea:	b299      	uxth	r1, r3
   15eec:	193b      	adds	r3, r7, r4
   15eee:	681b      	ldr	r3, [r3, #0]
   15ef0:	3301      	adds	r3, #1
   15ef2:	781b      	ldrb	r3, [r3, #0]
   15ef4:	b29b      	uxth	r3, r3
   15ef6:	021b      	lsls	r3, r3, #8
   15ef8:	b29a      	uxth	r2, r3
   15efa:	4b32      	ldr	r3, [pc, #200]	; (15fc4 <Send_DpmConfigSetCnf+0xb44>)
   15efc:	20ac      	movs	r0, #172	; 0xac
   15efe:	0040      	lsls	r0, r0, #1
   15f00:	4684      	mov	ip, r0
   15f02:	44bc      	add	ip, r7
   15f04:	4463      	add	r3, ip
   15f06:	781b      	ldrb	r3, [r3, #0]
   15f08:	188a      	adds	r2, r1, r2
   15f0a:	b290      	uxth	r0, r2
   15f0c:	4a2e      	ldr	r2, [pc, #184]	; (15fc8 <Send_DpmConfigSetCnf+0xb48>)
   15f0e:	2174      	movs	r1, #116	; 0x74
   15f10:	434b      	muls	r3, r1
   15f12:	18d3      	adds	r3, r2, r3
   15f14:	331c      	adds	r3, #28
   15f16:	1c02      	adds	r2, r0, #0
   15f18:	801a      	strh	r2, [r3, #0]
      DPM_USER_Settings[PortNum].DPM_ManuInfoPort.PID = LE16(&value[2]);
   15f1a:	193b      	adds	r3, r7, r4
   15f1c:	681b      	ldr	r3, [r3, #0]
   15f1e:	3302      	adds	r3, #2
   15f20:	781b      	ldrb	r3, [r3, #0]
   15f22:	b299      	uxth	r1, r3
   15f24:	193b      	adds	r3, r7, r4
   15f26:	681b      	ldr	r3, [r3, #0]
   15f28:	3303      	adds	r3, #3
   15f2a:	781b      	ldrb	r3, [r3, #0]
   15f2c:	b29b      	uxth	r3, r3
   15f2e:	021b      	lsls	r3, r3, #8
   15f30:	b29a      	uxth	r2, r3
   15f32:	4b24      	ldr	r3, [pc, #144]	; (15fc4 <Send_DpmConfigSetCnf+0xb44>)
   15f34:	20ac      	movs	r0, #172	; 0xac
   15f36:	0040      	lsls	r0, r0, #1
   15f38:	4684      	mov	ip, r0
   15f3a:	44bc      	add	ip, r7
   15f3c:	4463      	add	r3, ip
   15f3e:	781b      	ldrb	r3, [r3, #0]
   15f40:	188a      	adds	r2, r1, r2
   15f42:	b290      	uxth	r0, r2
   15f44:	4a20      	ldr	r2, [pc, #128]	; (15fc8 <Send_DpmConfigSetCnf+0xb48>)
   15f46:	2174      	movs	r1, #116	; 0x74
   15f48:	434b      	muls	r3, r1
   15f4a:	18d3      	adds	r3, r2, r3
   15f4c:	331e      	adds	r3, #30
   15f4e:	1c02      	adds	r2, r0, #0
   15f50:	801a      	strh	r2, [r3, #0]
      size -= 4;
   15f52:	258b      	movs	r5, #139	; 0x8b
   15f54:	006d      	lsls	r5, r5, #1
   15f56:	197b      	adds	r3, r7, r5
   15f58:	881b      	ldrh	r3, [r3, #0]
   15f5a:	3b04      	subs	r3, #4
   15f5c:	b29a      	uxth	r2, r3
   15f5e:	197b      	adds	r3, r7, r5
   15f60:	801a      	strh	r2, [r3, #0]
      memcpy(DPM_USER_Settings[PortNum].DPM_ManuInfoPort.ManuString, &value[4], size);
   15f62:	4b18      	ldr	r3, [pc, #96]	; (15fc4 <Send_DpmConfigSetCnf+0xb44>)
   15f64:	22ac      	movs	r2, #172	; 0xac
   15f66:	0052      	lsls	r2, r2, #1
   15f68:	4694      	mov	ip, r2
   15f6a:	44bc      	add	ip, r7
   15f6c:	4463      	add	r3, ip
   15f6e:	781b      	ldrb	r3, [r3, #0]
   15f70:	2274      	movs	r2, #116	; 0x74
   15f72:	4353      	muls	r3, r2
   15f74:	3318      	adds	r3, #24
   15f76:	001a      	movs	r2, r3
   15f78:	4b13      	ldr	r3, [pc, #76]	; (15fc8 <Send_DpmConfigSetCnf+0xb48>)
   15f7a:	18d3      	adds	r3, r2, r3
   15f7c:	3308      	adds	r3, #8
   15f7e:	0018      	movs	r0, r3
   15f80:	193b      	adds	r3, r7, r4
   15f82:	681b      	ldr	r3, [r3, #0]
   15f84:	1d19      	adds	r1, r3, #4
   15f86:	197b      	adds	r3, r7, r5
   15f88:	881b      	ldrh	r3, [r3, #0]
   15f8a:	001a      	movs	r2, r3
   15f8c:	f008 fb82 	bl	1e694 <memcpy>
   15f90:	22ab      	movs	r2, #171	; 0xab
   15f92:	0052      	lsls	r2, r2, #1
   15f94:	18bb      	adds	r3, r7, r2
   15f96:	18ba      	adds	r2, r7, r2
   15f98:	8812      	ldrh	r2, [r2, #0]
   15f9a:	801a      	strh	r2, [r3, #0]
   15f9c:	2256      	movs	r2, #86	; 0x56
   15f9e:	32ff      	adds	r2, #255	; 0xff
   15fa0:	18bb      	adds	r3, r7, r2
   15fa2:	18ba      	adds	r2, r7, r2
   15fa4:	7812      	ldrb	r2, [r2, #0]
   15fa6:	701a      	strb	r2, [r3, #0]
   15fa8:	22aa      	movs	r2, #170	; 0xaa
   15faa:	0052      	lsls	r2, r2, #1
   15fac:	18bb      	adds	r3, r7, r2
   15fae:	18ba      	adds	r2, r7, r2
   15fb0:	7812      	ldrb	r2, [r2, #0]
   15fb2:	701a      	strb	r2, [r3, #0]
   15fb4:	2254      	movs	r2, #84	; 0x54
   15fb6:	32ff      	adds	r2, #255	; 0xff
   15fb8:	18bb      	adds	r3, r7, r2
   15fba:	18ba      	adds	r2, r7, r2
   15fbc:	7812      	ldrb	r2, [r2, #0]
   15fbe:	701a      	strb	r2, [r3, #0]
      break;
   15fc0:	e03b      	b.n	1603a <Send_DpmConfigSetCnf+0xbba>
   15fc2:	46c0      	nop			; (mov r8, r8)
   15fc4:	fffffeb7 	.word	0xfffffeb7
   15fc8:	0002fedc 	.word	0x0002fedc
   15fcc:	fffffebb 	.word	0xfffffebb
   15fd0:	fffffebc 	.word	0xfffffebc
   15fd4:	0002fed4 	.word	0x0002fed4
   15fd8:	000322dc 	.word	0x000322dc
#endif /* _MANU_INFO */
#endif /*USBPD_REV30_SUPPORT*/
    default :
      error = GUI_REJ_DPM_REJECT;
   15fdc:	2316      	movs	r3, #22
   15fde:	33ff      	adds	r3, #255	; 0xff
   15fe0:	18fb      	adds	r3, r7, r3
   15fe2:	2200      	movs	r2, #0
   15fe4:	701a      	strb	r2, [r3, #0]
      param_not_applicated[counter_param_not_applicated] = tag;
   15fe6:	2056      	movs	r0, #86	; 0x56
   15fe8:	30ff      	adds	r0, #255	; 0xff
   15fea:	183b      	adds	r3, r7, r0
   15fec:	781b      	ldrb	r3, [r3, #0]
   15fee:	4aa6      	ldr	r2, [pc, #664]	; (16288 <Send_DpmConfigSetCnf+0xe08>)
   15ff0:	21ac      	movs	r1, #172	; 0xac
   15ff2:	0049      	lsls	r1, r1, #1
   15ff4:	468c      	mov	ip, r1
   15ff6:	44bc      	add	ip, r7
   15ff8:	4462      	add	r2, ip
   15ffa:	7811      	ldrb	r1, [r2, #0]
   15ffc:	4aa3      	ldr	r2, [pc, #652]	; (1628c <Send_DpmConfigSetCnf+0xe0c>)
   15ffe:	24ac      	movs	r4, #172	; 0xac
   16000:	0064      	lsls	r4, r4, #1
   16002:	46a4      	mov	ip, r4
   16004:	44bc      	add	ip, r7
   16006:	4462      	add	r2, ip
   16008:	54d1      	strb	r1, [r2, r3]
      counter_param_not_applicated++;
   1600a:	183b      	adds	r3, r7, r0
   1600c:	781a      	ldrb	r2, [r3, #0]
   1600e:	183b      	adds	r3, r7, r0
   16010:	3201      	adds	r2, #1
   16012:	701a      	strb	r2, [r3, #0]
   16014:	22ab      	movs	r2, #171	; 0xab
   16016:	0052      	lsls	r2, r2, #1
   16018:	18bb      	adds	r3, r7, r2
   1601a:	18ba      	adds	r2, r7, r2
   1601c:	8812      	ldrh	r2, [r2, #0]
   1601e:	801a      	strh	r2, [r3, #0]
   16020:	22aa      	movs	r2, #170	; 0xaa
   16022:	0052      	lsls	r2, r2, #1
   16024:	18bb      	adds	r3, r7, r2
   16026:	18ba      	adds	r2, r7, r2
   16028:	7812      	ldrb	r2, [r2, #0]
   1602a:	701a      	strb	r2, [r3, #0]
   1602c:	2254      	movs	r2, #84	; 0x54
   1602e:	32ff      	adds	r2, #255	; 0xff
   16030:	18bb      	adds	r3, r7, r2
   16032:	18ba      	adds	r2, r7, r2
   16034:	7812      	ldrb	r2, [r2, #0]
   16036:	701a      	strb	r2, [r3, #0]
      break;
   16038:	46c0      	nop			; (mov r8, r8)
  while(0xFF != TLV_get(&process_tlv, &tag, &size, &value))
   1603a:	238c      	movs	r3, #140	; 0x8c
   1603c:	005b      	lsls	r3, r3, #1
   1603e:	18fb      	adds	r3, r7, r3
   16040:	228b      	movs	r2, #139	; 0x8b
   16042:	0052      	lsls	r2, r2, #1
   16044:	18ba      	adds	r2, r7, r2
   16046:	2113      	movs	r1, #19
   16048:	1879      	adds	r1, r7, r1
   1604a:	208e      	movs	r0, #142	; 0x8e
   1604c:	0040      	lsls	r0, r0, #1
   1604e:	1838      	adds	r0, r7, r0
   16050:	f7fd f84c 	bl	130ec <TLV_get>
   16054:	0003      	movs	r3, r0
   16056:	2bff      	cmp	r3, #255	; 0xff
   16058:	d001      	beq.n	1605e <Send_DpmConfigSetCnf+0xbde>
   1605a:	f7ff fa58 	bl	1550e <Send_DpmConfigSetCnf+0x8e>
    }
  }

  /* Updtate CAD_SNKToggleTime & CAD_SRCToggleTime only if TDRP and/or DC_SRC_DRP have been received */
  if (1 == flag_drp)
   1605e:	23aa      	movs	r3, #170	; 0xaa
   16060:	005b      	lsls	r3, r3, #1
   16062:	18fb      	adds	r3, r7, r3
   16064:	781b      	ldrb	r3, [r3, #0]
   16066:	2b01      	cmp	r3, #1
   16068:	d000      	beq.n	1606c <Send_DpmConfigSetCnf+0xbec>
   1606a:	e0b2      	b.n	161d2 <Send_DpmConfigSetCnf+0xd52>
  {
    uint16_t calcul;
    if (0 == tdrp)
   1606c:	2354      	movs	r3, #84	; 0x54
   1606e:	33ff      	adds	r3, #255	; 0xff
   16070:	18fb      	adds	r3, r7, r3
   16072:	781b      	ldrb	r3, [r3, #0]
   16074:	2b00      	cmp	r3, #0
   16076:	d122      	bne.n	160be <Send_DpmConfigSetCnf+0xc3e>
    {
      tdrp = DPM_Settings[PortNum].CAD_SNKToggleTime + DPM_Settings[PortNum].CAD_SRCToggleTime;
   16078:	4b85      	ldr	r3, [pc, #532]	; (16290 <Send_DpmConfigSetCnf+0xe10>)
   1607a:	22ac      	movs	r2, #172	; 0xac
   1607c:	0052      	lsls	r2, r2, #1
   1607e:	4694      	mov	ip, r2
   16080:	44bc      	add	ip, r7
   16082:	4463      	add	r3, ip
   16084:	781a      	ldrb	r2, [r3, #0]
   16086:	4983      	ldr	r1, [pc, #524]	; (16294 <Send_DpmConfigSetCnf+0xe14>)
   16088:	0013      	movs	r3, r2
   1608a:	005b      	lsls	r3, r3, #1
   1608c:	189b      	adds	r3, r3, r2
   1608e:	009b      	lsls	r3, r3, #2
   16090:	18cb      	adds	r3, r1, r3
   16092:	3306      	adds	r3, #6
   16094:	7819      	ldrb	r1, [r3, #0]
   16096:	4b7e      	ldr	r3, [pc, #504]	; (16290 <Send_DpmConfigSetCnf+0xe10>)
   16098:	22ac      	movs	r2, #172	; 0xac
   1609a:	0052      	lsls	r2, r2, #1
   1609c:	4694      	mov	ip, r2
   1609e:	44bc      	add	ip, r7
   160a0:	4463      	add	r3, ip
   160a2:	781a      	ldrb	r2, [r3, #0]
   160a4:	487b      	ldr	r0, [pc, #492]	; (16294 <Send_DpmConfigSetCnf+0xe14>)
   160a6:	0013      	movs	r3, r2
   160a8:	005b      	lsls	r3, r3, #1
   160aa:	189b      	adds	r3, r3, r2
   160ac:	009b      	lsls	r3, r3, #2
   160ae:	18c3      	adds	r3, r0, r3
   160b0:	3307      	adds	r3, #7
   160b2:	781a      	ldrb	r2, [r3, #0]
   160b4:	2354      	movs	r3, #84	; 0x54
   160b6:	33ff      	adds	r3, #255	; 0xff
   160b8:	18fb      	adds	r3, r7, r3
   160ba:	188a      	adds	r2, r1, r2
   160bc:	701a      	strb	r2, [r3, #0]
    }
    if (0 == dcdrp)
   160be:	23ab      	movs	r3, #171	; 0xab
   160c0:	005b      	lsls	r3, r3, #1
   160c2:	18fb      	adds	r3, r7, r3
   160c4:	881b      	ldrh	r3, [r3, #0]
   160c6:	2b00      	cmp	r3, #0
   160c8:	d13b      	bne.n	16142 <Send_DpmConfigSetCnf+0xcc2>
    {
      dcdrp = (DPM_Settings[PortNum].CAD_SRCToggleTime * 100) / (DPM_Settings[PortNum].CAD_SNKToggleTime + DPM_Settings[PortNum].CAD_SRCToggleTime);
   160ca:	4b71      	ldr	r3, [pc, #452]	; (16290 <Send_DpmConfigSetCnf+0xe10>)
   160cc:	22ac      	movs	r2, #172	; 0xac
   160ce:	0052      	lsls	r2, r2, #1
   160d0:	4694      	mov	ip, r2
   160d2:	44bc      	add	ip, r7
   160d4:	4463      	add	r3, ip
   160d6:	781a      	ldrb	r2, [r3, #0]
   160d8:	496e      	ldr	r1, [pc, #440]	; (16294 <Send_DpmConfigSetCnf+0xe14>)
   160da:	0013      	movs	r3, r2
   160dc:	005b      	lsls	r3, r3, #1
   160de:	189b      	adds	r3, r3, r2
   160e0:	009b      	lsls	r3, r3, #2
   160e2:	18cb      	adds	r3, r1, r3
   160e4:	3307      	adds	r3, #7
   160e6:	781b      	ldrb	r3, [r3, #0]
   160e8:	001a      	movs	r2, r3
   160ea:	2364      	movs	r3, #100	; 0x64
   160ec:	4353      	muls	r3, r2
   160ee:	0018      	movs	r0, r3
   160f0:	4b67      	ldr	r3, [pc, #412]	; (16290 <Send_DpmConfigSetCnf+0xe10>)
   160f2:	22ac      	movs	r2, #172	; 0xac
   160f4:	0052      	lsls	r2, r2, #1
   160f6:	4694      	mov	ip, r2
   160f8:	44bc      	add	ip, r7
   160fa:	4463      	add	r3, ip
   160fc:	781a      	ldrb	r2, [r3, #0]
   160fe:	4965      	ldr	r1, [pc, #404]	; (16294 <Send_DpmConfigSetCnf+0xe14>)
   16100:	0013      	movs	r3, r2
   16102:	005b      	lsls	r3, r3, #1
   16104:	189b      	adds	r3, r3, r2
   16106:	009b      	lsls	r3, r3, #2
   16108:	18cb      	adds	r3, r1, r3
   1610a:	3306      	adds	r3, #6
   1610c:	781b      	ldrb	r3, [r3, #0]
   1610e:	001c      	movs	r4, r3
   16110:	4b5f      	ldr	r3, [pc, #380]	; (16290 <Send_DpmConfigSetCnf+0xe10>)
   16112:	22ac      	movs	r2, #172	; 0xac
   16114:	0052      	lsls	r2, r2, #1
   16116:	4694      	mov	ip, r2
   16118:	44bc      	add	ip, r7
   1611a:	4463      	add	r3, ip
   1611c:	781a      	ldrb	r2, [r3, #0]
   1611e:	495d      	ldr	r1, [pc, #372]	; (16294 <Send_DpmConfigSetCnf+0xe14>)
   16120:	0013      	movs	r3, r2
   16122:	005b      	lsls	r3, r3, #1
   16124:	189b      	adds	r3, r3, r2
   16126:	009b      	lsls	r3, r3, #2
   16128:	18cb      	adds	r3, r1, r3
   1612a:	3307      	adds	r3, #7
   1612c:	781b      	ldrb	r3, [r3, #0]
   1612e:	18e3      	adds	r3, r4, r3
   16130:	0019      	movs	r1, r3
   16132:	f008 ff51 	bl	1efd8 <__divsi3>
   16136:	0003      	movs	r3, r0
   16138:	001a      	movs	r2, r3
   1613a:	23ab      	movs	r3, #171	; 0xab
   1613c:	005b      	lsls	r3, r3, #1
   1613e:	18fb      	adds	r3, r7, r3
   16140:	801a      	strh	r2, [r3, #0]
    }
    calcul = (tdrp * dcdrp) / 100;
   16142:	2554      	movs	r5, #84	; 0x54
   16144:	35ff      	adds	r5, #255	; 0xff
   16146:	197b      	adds	r3, r7, r5
   16148:	781b      	ldrb	r3, [r3, #0]
   1614a:	26ab      	movs	r6, #171	; 0xab
   1614c:	0076      	lsls	r6, r6, #1
   1614e:	19ba      	adds	r2, r7, r6
   16150:	8812      	ldrh	r2, [r2, #0]
   16152:	4353      	muls	r3, r2
   16154:	2164      	movs	r1, #100	; 0x64
   16156:	0018      	movs	r0, r3
   16158:	f008 ff3e 	bl	1efd8 <__divsi3>
   1615c:	0003      	movs	r3, r0
   1615e:	001a      	movs	r2, r3
   16160:	249d      	movs	r4, #157	; 0x9d
   16162:	0064      	lsls	r4, r4, #1
   16164:	193b      	adds	r3, r7, r4
   16166:	801a      	strh	r2, [r3, #0]
    DPM_Settings[PortNum].CAD_SRCToggleTime = (uint8_t)calcul;
   16168:	4b49      	ldr	r3, [pc, #292]	; (16290 <Send_DpmConfigSetCnf+0xe10>)
   1616a:	22ac      	movs	r2, #172	; 0xac
   1616c:	0052      	lsls	r2, r2, #1
   1616e:	4694      	mov	ip, r2
   16170:	44bc      	add	ip, r7
   16172:	4463      	add	r3, ip
   16174:	781a      	ldrb	r2, [r3, #0]
   16176:	193b      	adds	r3, r7, r4
   16178:	881b      	ldrh	r3, [r3, #0]
   1617a:	b2d8      	uxtb	r0, r3
   1617c:	4945      	ldr	r1, [pc, #276]	; (16294 <Send_DpmConfigSetCnf+0xe14>)
   1617e:	0013      	movs	r3, r2
   16180:	005b      	lsls	r3, r3, #1
   16182:	189b      	adds	r3, r3, r2
   16184:	009b      	lsls	r3, r3, #2
   16186:	18cb      	adds	r3, r1, r3
   16188:	3307      	adds	r3, #7
   1618a:	1c02      	adds	r2, r0, #0
   1618c:	701a      	strb	r2, [r3, #0]
    calcul = tdrp * (100 - dcdrp) / 100;
   1618e:	197b      	adds	r3, r7, r5
   16190:	781b      	ldrb	r3, [r3, #0]
   16192:	19ba      	adds	r2, r7, r6
   16194:	8812      	ldrh	r2, [r2, #0]
   16196:	2164      	movs	r1, #100	; 0x64
   16198:	1a8a      	subs	r2, r1, r2
   1619a:	4353      	muls	r3, r2
   1619c:	2164      	movs	r1, #100	; 0x64
   1619e:	0018      	movs	r0, r3
   161a0:	f008 ff1a 	bl	1efd8 <__divsi3>
   161a4:	0003      	movs	r3, r0
   161a6:	001a      	movs	r2, r3
   161a8:	193b      	adds	r3, r7, r4
   161aa:	801a      	strh	r2, [r3, #0]
    DPM_Settings[PortNum].CAD_SNKToggleTime = (uint8_t)calcul;
   161ac:	4b38      	ldr	r3, [pc, #224]	; (16290 <Send_DpmConfigSetCnf+0xe10>)
   161ae:	22ac      	movs	r2, #172	; 0xac
   161b0:	0052      	lsls	r2, r2, #1
   161b2:	4694      	mov	ip, r2
   161b4:	44bc      	add	ip, r7
   161b6:	4463      	add	r3, ip
   161b8:	781a      	ldrb	r2, [r3, #0]
   161ba:	193b      	adds	r3, r7, r4
   161bc:	881b      	ldrh	r3, [r3, #0]
   161be:	b2d8      	uxtb	r0, r3
   161c0:	4934      	ldr	r1, [pc, #208]	; (16294 <Send_DpmConfigSetCnf+0xe14>)
   161c2:	0013      	movs	r3, r2
   161c4:	005b      	lsls	r3, r3, #1
   161c6:	189b      	adds	r3, r3, r2
   161c8:	009b      	lsls	r3, r3, #2
   161ca:	18cb      	adds	r3, r1, r3
   161cc:	3306      	adds	r3, #6
   161ce:	1c02      	adds	r2, r0, #0
   161d0:	701a      	strb	r2, [r3, #0]
  }

  /* Only applies if an error was specified. Will send a DPM_CONFIG_REJ instead of DPM_CONFIG_SET_CNF*/
  if(error != 0xFF)
   161d2:	2316      	movs	r3, #22
   161d4:	33ff      	adds	r3, #255	; 0xff
   161d6:	18fb      	adds	r3, r7, r3
   161d8:	781b      	ldrb	r3, [r3, #0]
   161da:	2bff      	cmp	r3, #255	; 0xff
   161dc:	d04f      	beq.n	1627e <Send_DpmConfigSetCnf+0xdfe>
  {
    TLV_deinit_encode(&send_tlv);
   161de:	2592      	movs	r5, #146	; 0x92
   161e0:	006d      	lsls	r5, r5, #1
   161e2:	197b      	adds	r3, r7, r5
   161e4:	0018      	movs	r0, r3
   161e6:	f7fc ff43 	bl	13070 <TLV_deinit_encode>
    TLV_init_encode(&send_tlv, __GUI_SET_TAG_ID((PortNum + 1), DPM_CONFIG_REJ), TLV_SIZE_MAX, pEncodedMsg);
   161ea:	4b29      	ldr	r3, [pc, #164]	; (16290 <Send_DpmConfigSetCnf+0xe10>)
   161ec:	22ac      	movs	r2, #172	; 0xac
   161ee:	0052      	lsls	r2, r2, #1
   161f0:	4694      	mov	ip, r2
   161f2:	44bc      	add	ip, r7
   161f4:	4463      	add	r3, ip
   161f6:	781b      	ldrb	r3, [r3, #0]
   161f8:	3301      	adds	r3, #1
   161fa:	015b      	lsls	r3, r3, #5
   161fc:	b25b      	sxtb	r3, r3
   161fe:	2208      	movs	r2, #8
   16200:	4313      	orrs	r3, r2
   16202:	b25b      	sxtb	r3, r3
   16204:	b2d9      	uxtb	r1, r3
   16206:	687c      	ldr	r4, [r7, #4]
   16208:	2380      	movs	r3, #128	; 0x80
   1620a:	005a      	lsls	r2, r3, #1
   1620c:	1978      	adds	r0, r7, r5
   1620e:	0023      	movs	r3, r4
   16210:	f7fc fd68 	bl	12ce4 <TLV_init_encode>
    TLV_addValue(&send_tlv, &error, 1);
   16214:	2416      	movs	r4, #22
   16216:	34ff      	adds	r4, #255	; 0xff
   16218:	1939      	adds	r1, r7, r4
   1621a:	197b      	adds	r3, r7, r5
   1621c:	2201      	movs	r2, #1
   1621e:	0018      	movs	r0, r3
   16220:	f7fc fe92 	bl	12f48 <TLV_addValue>

    /* If the cause of error is DPM_REJECT, we have to list the tag of parameters which didn't pass */
    if(!error)
   16224:	193b      	adds	r3, r7, r4
   16226:	781b      	ldrb	r3, [r3, #0]
   16228:	2b00      	cmp	r3, #0
   1622a:	d122      	bne.n	16272 <Send_DpmConfigSetCnf+0xdf2>
    {
      uint32_t index;
      for(index = 0; index < counter_param_not_applicated; index++)
   1622c:	2300      	movs	r3, #0
   1622e:	229e      	movs	r2, #158	; 0x9e
   16230:	0052      	lsls	r2, r2, #1
   16232:	18ba      	adds	r2, r7, r2
   16234:	6013      	str	r3, [r2, #0]
   16236:	e012      	b.n	1625e <Send_DpmConfigSetCnf+0xdde>
      {
        TLV_addValue(&send_tlv, &param_not_applicated[index], 1);
   16238:	2314      	movs	r3, #20
   1623a:	18fa      	adds	r2, r7, r3
   1623c:	249e      	movs	r4, #158	; 0x9e
   1623e:	0064      	lsls	r4, r4, #1
   16240:	193b      	adds	r3, r7, r4
   16242:	681b      	ldr	r3, [r3, #0]
   16244:	18d1      	adds	r1, r2, r3
   16246:	2392      	movs	r3, #146	; 0x92
   16248:	005b      	lsls	r3, r3, #1
   1624a:	18fb      	adds	r3, r7, r3
   1624c:	2201      	movs	r2, #1
   1624e:	0018      	movs	r0, r3
   16250:	f7fc fe7a 	bl	12f48 <TLV_addValue>
      for(index = 0; index < counter_param_not_applicated; index++)
   16254:	193b      	adds	r3, r7, r4
   16256:	681b      	ldr	r3, [r3, #0]
   16258:	3301      	adds	r3, #1
   1625a:	193a      	adds	r2, r7, r4
   1625c:	6013      	str	r3, [r2, #0]
   1625e:	2356      	movs	r3, #86	; 0x56
   16260:	33ff      	adds	r3, #255	; 0xff
   16262:	18fb      	adds	r3, r7, r3
   16264:	781b      	ldrb	r3, [r3, #0]
   16266:	229e      	movs	r2, #158	; 0x9e
   16268:	0052      	lsls	r2, r2, #1
   1626a:	18ba      	adds	r2, r7, r2
   1626c:	6812      	ldr	r2, [r2, #0]
   1626e:	429a      	cmp	r2, r3
   16270:	d3e2      	bcc.n	16238 <Send_DpmConfigSetCnf+0xdb8>
      }
    }
    TLV_deinit_encode(&send_tlv);
   16272:	2392      	movs	r3, #146	; 0x92
   16274:	005b      	lsls	r3, r3, #1
   16276:	18fb      	adds	r3, r7, r3
   16278:	0018      	movs	r0, r3
   1627a:	f7fc fef9 	bl	13070 <TLV_deinit_encode>
  }
}
   1627e:	46c0      	nop			; (mov r8, r8)
   16280:	46bd      	mov	sp, r7
   16282:	b057      	add	sp, #348	; 0x15c
   16284:	bdf0      	pop	{r4, r5, r6, r7, pc}
   16286:	46c0      	nop			; (mov r8, r8)
   16288:	fffffebb 	.word	0xfffffebb
   1628c:	fffffebc 	.word	0xfffffebc
   16290:	fffffeb7 	.word	0xfffffeb7
   16294:	0002fec8 	.word	0x0002fec8

00016298 <Send_DpmConfigGetCnf>:

static void Send_DpmConfigGetCnf(uint8_t PortNum, uint8_t* instruction, uint8_t *pEncodedMsg)
{
   16298:	b590      	push	{r4, r7, lr}
   1629a:	b095      	sub	sp, #84	; 0x54
   1629c:	af00      	add	r7, sp, #0
   1629e:	60b9      	str	r1, [r7, #8]
   162a0:	607a      	str	r2, [r7, #4]
   162a2:	210f      	movs	r1, #15
   162a4:	187b      	adds	r3, r7, r1
   162a6:	1c02      	adds	r2, r0, #0
   162a8:	701a      	strb	r2, [r3, #0]
  TLV_ToSend_Data send_tlv;
  TLV_init_encode(&send_tlv, __GUI_SET_TAG_ID((PortNum + 1), DPM_CONFIG_GET_CNF), TLV_SIZE_MAX, pEncodedMsg);
   162aa:	187b      	adds	r3, r7, r1
   162ac:	781b      	ldrb	r3, [r3, #0]
   162ae:	3301      	adds	r3, #1
   162b0:	015b      	lsls	r3, r3, #5
   162b2:	b25b      	sxtb	r3, r3
   162b4:	2205      	movs	r2, #5
   162b6:	4313      	orrs	r3, r2
   162b8:	b25b      	sxtb	r3, r3
   162ba:	b2d9      	uxtb	r1, r3
   162bc:	687c      	ldr	r4, [r7, #4]
   162be:	2380      	movs	r3, #128	; 0x80
   162c0:	005a      	lsls	r2, r3, #1
   162c2:	232c      	movs	r3, #44	; 0x2c
   162c4:	18f8      	adds	r0, r7, r3
   162c6:	0023      	movs	r3, r4
   162c8:	f7fc fd0c 	bl	12ce4 <TLV_init_encode>
  uint16_t length = TLV_get_string_length(instruction) - TLV_HEADER_SIZE;
   162cc:	68bb      	ldr	r3, [r7, #8]
   162ce:	0018      	movs	r0, r3
   162d0:	f7fc ff74 	bl	131bc <TLV_get_string_length>
   162d4:	0003      	movs	r3, r0
   162d6:	001a      	movs	r2, r3
   162d8:	234c      	movs	r3, #76	; 0x4c
   162da:	18fb      	adds	r3, r7, r3
   162dc:	3a03      	subs	r2, #3
   162de:	801a      	strh	r2, [r3, #0]
  uint8_t index = 0;
   162e0:	234f      	movs	r3, #79	; 0x4f
   162e2:	18fb      	adds	r3, r7, r3
   162e4:	2200      	movs	r2, #0
   162e6:	701a      	strb	r2, [r3, #0]

  /* This is a state machine. */
  do
  {
    /* If there is no parameters, we go through each case of the state machine in one pass. (conditionnal breaks) */
    if(0 == length)
   162e8:	234c      	movs	r3, #76	; 0x4c
   162ea:	18fb      	adds	r3, r7, r3
   162ec:	881b      	ldrh	r3, [r3, #0]
   162ee:	2b00      	cmp	r3, #0
   162f0:	d104      	bne.n	162fc <Send_DpmConfigGetCnf+0x64>
    {
      param = GUI_PARAM_ALL;
   162f2:	234e      	movs	r3, #78	; 0x4e
   162f4:	18fb      	adds	r3, r7, r3
   162f6:	22ff      	movs	r2, #255	; 0xff
   162f8:	701a      	strb	r2, [r3, #0]
   162fa:	e009      	b.n	16310 <Send_DpmConfigGetCnf+0x78>
    }
    else
    {
      /* If there are, we loop the state machine and go through one case each time. */
      param = instruction[TLV_VALUE_POSITION + index];
   162fc:	234f      	movs	r3, #79	; 0x4f
   162fe:	18fb      	adds	r3, r7, r3
   16300:	781b      	ldrb	r3, [r3, #0]
   16302:	3307      	adds	r3, #7
   16304:	68ba      	ldr	r2, [r7, #8]
   16306:	18d2      	adds	r2, r2, r3
   16308:	234e      	movs	r3, #78	; 0x4e
   1630a:	18fb      	adds	r3, r7, r3
   1630c:	7812      	ldrb	r2, [r2, #0]
   1630e:	701a      	strb	r2, [r3, #0]

    /*
    Each case should simply use the TLV_add function to insert his corresponding data,
    as suggested in comment. Manual cast to (uint8_t *) may be required.
    */
    switch((USBPD_GUI_Tag_Param)param)
   16310:	234e      	movs	r3, #78	; 0x4e
   16312:	18fb      	adds	r3, r7, r3
   16314:	781b      	ldrb	r3, [r3, #0]
   16316:	2b0d      	cmp	r3, #13
   16318:	d100      	bne.n	1631c <Send_DpmConfigGetCnf+0x84>
   1631a:	e1a1      	b.n	16660 <Send_DpmConfigGetCnf+0x3c8>
   1631c:	dc26      	bgt.n	1636c <Send_DpmConfigGetCnf+0xd4>
   1631e:	2b06      	cmp	r3, #6
   16320:	d100      	bne.n	16324 <Send_DpmConfigGetCnf+0x8c>
   16322:	e0f5      	b.n	16510 <Send_DpmConfigGetCnf+0x278>
   16324:	dc10      	bgt.n	16348 <Send_DpmConfigGetCnf+0xb0>
   16326:	2b03      	cmp	r3, #3
   16328:	d100      	bne.n	1632c <Send_DpmConfigGetCnf+0x94>
   1632a:	e07f      	b.n	1642c <Send_DpmConfigGetCnf+0x194>
   1632c:	dc05      	bgt.n	1633a <Send_DpmConfigGetCnf+0xa2>
   1632e:	2b00      	cmp	r3, #0
   16330:	d042      	beq.n	163b8 <Send_DpmConfigGetCnf+0x120>
   16332:	2b02      	cmp	r3, #2
   16334:	d100      	bne.n	16338 <Send_DpmConfigGetCnf+0xa0>
   16336:	e059      	b.n	163ec <Send_DpmConfigGetCnf+0x154>
   16338:	e2a9      	b.n	1688e <Send_DpmConfigGetCnf+0x5f6>
   1633a:	2b04      	cmp	r3, #4
   1633c:	d100      	bne.n	16340 <Send_DpmConfigGetCnf+0xa8>
   1633e:	e0ab      	b.n	16498 <Send_DpmConfigGetCnf+0x200>
   16340:	2b05      	cmp	r3, #5
   16342:	d100      	bne.n	16346 <Send_DpmConfigGetCnf+0xae>
   16344:	e0c6      	b.n	164d4 <Send_DpmConfigGetCnf+0x23c>
   16346:	e2a2      	b.n	1688e <Send_DpmConfigGetCnf+0x5f6>
   16348:	2b0a      	cmp	r3, #10
   1634a:	d100      	bne.n	1634e <Send_DpmConfigGetCnf+0xb6>
   1634c:	e137      	b.n	165be <Send_DpmConfigGetCnf+0x326>
   1634e:	dc06      	bgt.n	1635e <Send_DpmConfigGetCnf+0xc6>
   16350:	2b07      	cmp	r3, #7
   16352:	d100      	bne.n	16356 <Send_DpmConfigGetCnf+0xbe>
   16354:	e0fa      	b.n	1654c <Send_DpmConfigGetCnf+0x2b4>
   16356:	2b08      	cmp	r3, #8
   16358:	d100      	bne.n	1635c <Send_DpmConfigGetCnf+0xc4>
   1635a:	e115      	b.n	16588 <Send_DpmConfigGetCnf+0x2f0>
   1635c:	e297      	b.n	1688e <Send_DpmConfigGetCnf+0x5f6>
   1635e:	2b0b      	cmp	r3, #11
   16360:	d100      	bne.n	16364 <Send_DpmConfigGetCnf+0xcc>
   16362:	e14a      	b.n	165fa <Send_DpmConfigGetCnf+0x362>
   16364:	2b0c      	cmp	r3, #12
   16366:	d100      	bne.n	1636a <Send_DpmConfigGetCnf+0xd2>
   16368:	e162      	b.n	16630 <Send_DpmConfigGetCnf+0x398>
   1636a:	e290      	b.n	1688e <Send_DpmConfigGetCnf+0x5f6>
   1636c:	2b17      	cmp	r3, #23
   1636e:	d100      	bne.n	16372 <Send_DpmConfigGetCnf+0xda>
   16370:	e227      	b.n	167c2 <Send_DpmConfigGetCnf+0x52a>
   16372:	dc11      	bgt.n	16398 <Send_DpmConfigGetCnf+0x100>
   16374:	2b10      	cmp	r3, #16
   16376:	d100      	bne.n	1637a <Send_DpmConfigGetCnf+0xe2>
   16378:	e1c6      	b.n	16708 <Send_DpmConfigGetCnf+0x470>
   1637a:	dc06      	bgt.n	1638a <Send_DpmConfigGetCnf+0xf2>
   1637c:	2b0e      	cmp	r3, #14
   1637e:	d100      	bne.n	16382 <Send_DpmConfigGetCnf+0xea>
   16380:	e186      	b.n	16690 <Send_DpmConfigGetCnf+0x3f8>
   16382:	2b0f      	cmp	r3, #15
   16384:	d100      	bne.n	16388 <Send_DpmConfigGetCnf+0xf0>
   16386:	e1a1      	b.n	166cc <Send_DpmConfigGetCnf+0x434>
   16388:	e281      	b.n	1688e <Send_DpmConfigGetCnf+0x5f6>
   1638a:	2b11      	cmp	r3, #17
   1638c:	d100      	bne.n	16390 <Send_DpmConfigGetCnf+0xf8>
   1638e:	e1d9      	b.n	16744 <Send_DpmConfigGetCnf+0x4ac>
   16390:	2b12      	cmp	r3, #18
   16392:	d100      	bne.n	16396 <Send_DpmConfigGetCnf+0xfe>
   16394:	e200      	b.n	16798 <Send_DpmConfigGetCnf+0x500>
   16396:	e27a      	b.n	1688e <Send_DpmConfigGetCnf+0x5f6>
   16398:	2b1b      	cmp	r3, #27
   1639a:	d100      	bne.n	1639e <Send_DpmConfigGetCnf+0x106>
   1639c:	e25b      	b.n	16856 <Send_DpmConfigGetCnf+0x5be>
   1639e:	dc06      	bgt.n	163ae <Send_DpmConfigGetCnf+0x116>
   163a0:	2b18      	cmp	r3, #24
   163a2:	d100      	bne.n	163a6 <Send_DpmConfigGetCnf+0x10e>
   163a4:	e225      	b.n	167f2 <Send_DpmConfigGetCnf+0x55a>
   163a6:	2b1a      	cmp	r3, #26
   163a8:	d100      	bne.n	163ac <Send_DpmConfigGetCnf+0x114>
   163aa:	e23a      	b.n	16822 <Send_DpmConfigGetCnf+0x58a>
   163ac:	e26f      	b.n	1688e <Send_DpmConfigGetCnf+0x5f6>
   163ae:	2b1c      	cmp	r3, #28
   163b0:	d057      	beq.n	16462 <Send_DpmConfigGetCnf+0x1ca>
   163b2:	2bff      	cmp	r3, #255	; 0xff
   163b4:	d000      	beq.n	163b8 <Send_DpmConfigGetCnf+0x120>
   163b6:	e26a      	b.n	1688e <Send_DpmConfigGetCnf+0x5f6>
    case GUI_PARAM_ALL :
    case GUI_PARAM_SOP :
      {
        /* SOP & SOP1 & SOP2 */
        /* SOP1_Debug & SOP2_Debug not implemented */
        uint8_t settings = DPM_Settings[PortNum].PE_SupportedSOP;
   163b8:	230f      	movs	r3, #15
   163ba:	18fb      	adds	r3, r7, r3
   163bc:	781a      	ldrb	r2, [r3, #0]
   163be:	49ee      	ldr	r1, [pc, #952]	; (16778 <Send_DpmConfigGetCnf+0x4e0>)
   163c0:	0013      	movs	r3, r2
   163c2:	005b      	lsls	r3, r3, #1
   163c4:	189b      	adds	r3, r3, r2
   163c6:	009b      	lsls	r3, r3, #2
   163c8:	585b      	ldr	r3, [r3, r1]
   163ca:	b2da      	uxtb	r2, r3
   163cc:	212b      	movs	r1, #43	; 0x2b
   163ce:	187b      	adds	r3, r7, r1
   163d0:	701a      	strb	r2, [r3, #0]
        TLV_add(&send_tlv, GUI_PARAM_SOP, 1, &settings);
   163d2:	187b      	adds	r3, r7, r1
   163d4:	222c      	movs	r2, #44	; 0x2c
   163d6:	18b8      	adds	r0, r7, r2
   163d8:	2201      	movs	r2, #1
   163da:	2100      	movs	r1, #0
   163dc:	f7fc fce6 	bl	12dac <TLV_add>
        if(0 != length)
   163e0:	234c      	movs	r3, #76	; 0x4c
   163e2:	18fb      	adds	r3, r7, r3
   163e4:	881b      	ldrh	r3, [r3, #0]
   163e6:	2b00      	cmp	r3, #0
   163e8:	d000      	beq.n	163ec <Send_DpmConfigGetCnf+0x154>
   163ea:	e263      	b.n	168b4 <Send_DpmConfigGetCnf+0x61c>
      }
#if defined(USBPD_REV30_SUPPORT)
    case GUI_PARAM_FASTROLESWAP :
      {
        /*FastRoleSwap*/
        uint8_t settings = DPM_Settings[PortNum].PE_PD3_Support.d.PE_FastRoleSwapSupport;
   163ec:	230f      	movs	r3, #15
   163ee:	18fb      	adds	r3, r7, r3
   163f0:	781a      	ldrb	r2, [r3, #0]
   163f2:	49e1      	ldr	r1, [pc, #900]	; (16778 <Send_DpmConfigGetCnf+0x4e0>)
   163f4:	2008      	movs	r0, #8
   163f6:	0013      	movs	r3, r2
   163f8:	005b      	lsls	r3, r3, #1
   163fa:	189b      	adds	r3, r3, r2
   163fc:	009b      	lsls	r3, r3, #2
   163fe:	18cb      	adds	r3, r1, r3
   16400:	181b      	adds	r3, r3, r0
   16402:	781b      	ldrb	r3, [r3, #0]
   16404:	079b      	lsls	r3, r3, #30
   16406:	0fdb      	lsrs	r3, r3, #31
   16408:	b2db      	uxtb	r3, r3
   1640a:	001a      	movs	r2, r3
   1640c:	212a      	movs	r1, #42	; 0x2a
   1640e:	187b      	adds	r3, r7, r1
   16410:	701a      	strb	r2, [r3, #0]
        TLV_add(&send_tlv, GUI_PARAM_FASTROLESWAP, 1, &settings);
   16412:	187b      	adds	r3, r7, r1
   16414:	222c      	movs	r2, #44	; 0x2c
   16416:	18b8      	adds	r0, r7, r2
   16418:	2201      	movs	r2, #1
   1641a:	2102      	movs	r1, #2
   1641c:	f7fc fcc6 	bl	12dac <TLV_add>
        if(0 != length)
   16420:	234c      	movs	r3, #76	; 0x4c
   16422:	18fb      	adds	r3, r7, r3
   16424:	881b      	ldrh	r3, [r3, #0]
   16426:	2b00      	cmp	r3, #0
   16428:	d000      	beq.n	1642c <Send_DpmConfigGetCnf+0x194>
   1642a:	e245      	b.n	168b8 <Send_DpmConfigGetCnf+0x620>
      }
#endif /*USBPD_REV30_SUPPORT*/
    case GUI_PARAM_DATAROLESWAP_TO_UFP :
      {
        /* DataRoleSwap to UFP */
        uint8_t settings = DPM_USER_Settings[PortNum].PE_DR_Swap_To_UFP;
   1642c:	230f      	movs	r3, #15
   1642e:	18fb      	adds	r3, r7, r3
   16430:	781a      	ldrb	r2, [r3, #0]
   16432:	4bd2      	ldr	r3, [pc, #840]	; (1677c <Send_DpmConfigGetCnf+0x4e4>)
   16434:	2174      	movs	r1, #116	; 0x74
   16436:	434a      	muls	r2, r1
   16438:	5cd3      	ldrb	r3, [r2, r3]
   1643a:	071b      	lsls	r3, r3, #28
   1643c:	0fdb      	lsrs	r3, r3, #31
   1643e:	b2db      	uxtb	r3, r3
   16440:	001a      	movs	r2, r3
   16442:	2129      	movs	r1, #41	; 0x29
   16444:	187b      	adds	r3, r7, r1
   16446:	701a      	strb	r2, [r3, #0]
        TLV_add(&send_tlv, GUI_PARAM_DATAROLESWAP_TO_UFP, 1, &settings);
   16448:	187b      	adds	r3, r7, r1
   1644a:	222c      	movs	r2, #44	; 0x2c
   1644c:	18b8      	adds	r0, r7, r2
   1644e:	2201      	movs	r2, #1
   16450:	2103      	movs	r1, #3
   16452:	f7fc fcab 	bl	12dac <TLV_add>
        if(0 != length)
   16456:	234c      	movs	r3, #76	; 0x4c
   16458:	18fb      	adds	r3, r7, r3
   1645a:	881b      	ldrh	r3, [r3, #0]
   1645c:	2b00      	cmp	r3, #0
   1645e:	d000      	beq.n	16462 <Send_DpmConfigGetCnf+0x1ca>
   16460:	e22c      	b.n	168bc <Send_DpmConfigGetCnf+0x624>
        }
      }
    case GUI_PARAM_DATAROLESWAP_TO_DFP :
      {
        /* DataRoleSwap to DFP */
        uint8_t settings = DPM_USER_Settings[PortNum].PE_DR_Swap_To_DFP;
   16462:	230f      	movs	r3, #15
   16464:	18fb      	adds	r3, r7, r3
   16466:	781a      	ldrb	r2, [r3, #0]
   16468:	4bc4      	ldr	r3, [pc, #784]	; (1677c <Send_DpmConfigGetCnf+0x4e4>)
   1646a:	2174      	movs	r1, #116	; 0x74
   1646c:	434a      	muls	r2, r1
   1646e:	5cd3      	ldrb	r3, [r2, r3]
   16470:	075b      	lsls	r3, r3, #29
   16472:	0fdb      	lsrs	r3, r3, #31
   16474:	b2db      	uxtb	r3, r3
   16476:	001a      	movs	r2, r3
   16478:	2128      	movs	r1, #40	; 0x28
   1647a:	187b      	adds	r3, r7, r1
   1647c:	701a      	strb	r2, [r3, #0]
        TLV_add(&send_tlv, GUI_PARAM_DATAROLESWAP_TO_DFP, 1, &settings);
   1647e:	187b      	adds	r3, r7, r1
   16480:	222c      	movs	r2, #44	; 0x2c
   16482:	18b8      	adds	r0, r7, r2
   16484:	2201      	movs	r2, #1
   16486:	211c      	movs	r1, #28
   16488:	f7fc fc90 	bl	12dac <TLV_add>
        if(0 != length)
   1648c:	234c      	movs	r3, #76	; 0x4c
   1648e:	18fb      	adds	r3, r7, r3
   16490:	881b      	ldrh	r3, [r3, #0]
   16492:	2b00      	cmp	r3, #0
   16494:	d000      	beq.n	16498 <Send_DpmConfigGetCnf+0x200>
   16496:	e213      	b.n	168c0 <Send_DpmConfigGetCnf+0x628>
        }
      }
    case GUI_PARAM_DEFAULTPOWERROLE :
      {
        /*DefaultPowerRole*/
        uint8_t settings = DPM_Settings[PortNum].PE_DefaultRole;
   16498:	230f      	movs	r3, #15
   1649a:	18fb      	adds	r3, r7, r3
   1649c:	781a      	ldrb	r2, [r3, #0]
   1649e:	49b6      	ldr	r1, [pc, #728]	; (16778 <Send_DpmConfigGetCnf+0x4e0>)
   164a0:	0013      	movs	r3, r2
   164a2:	005b      	lsls	r3, r3, #1
   164a4:	189b      	adds	r3, r3, r2
   164a6:	009b      	lsls	r3, r3, #2
   164a8:	18cb      	adds	r3, r1, r3
   164aa:	791b      	ldrb	r3, [r3, #4]
   164ac:	075b      	lsls	r3, r3, #29
   164ae:	0fdb      	lsrs	r3, r3, #31
   164b0:	b2db      	uxtb	r3, r3
   164b2:	001a      	movs	r2, r3
   164b4:	2127      	movs	r1, #39	; 0x27
   164b6:	187b      	adds	r3, r7, r1
   164b8:	701a      	strb	r2, [r3, #0]
        TLV_add(&send_tlv, GUI_PARAM_DEFAULTPOWERROLE, 1, &settings);
   164ba:	187b      	adds	r3, r7, r1
   164bc:	222c      	movs	r2, #44	; 0x2c
   164be:	18b8      	adds	r0, r7, r2
   164c0:	2201      	movs	r2, #1
   164c2:	2104      	movs	r1, #4
   164c4:	f7fc fc72 	bl	12dac <TLV_add>
        if(0 != length)
   164c8:	234c      	movs	r3, #76	; 0x4c
   164ca:	18fb      	adds	r3, r7, r3
   164cc:	881b      	ldrh	r3, [r3, #0]
   164ce:	2b00      	cmp	r3, #0
   164d0:	d000      	beq.n	164d4 <Send_DpmConfigGetCnf+0x23c>
   164d2:	e1f7      	b.n	168c4 <Send_DpmConfigGetCnf+0x62c>
        }
      }
    case GUI_PARAM_DRP_SUPPORT :
      {
        /*DRP_Support*/
        uint8_t settings = DPM_Settings[PortNum].PE_RoleSwap;
   164d4:	230f      	movs	r3, #15
   164d6:	18fb      	adds	r3, r7, r3
   164d8:	781a      	ldrb	r2, [r3, #0]
   164da:	49a7      	ldr	r1, [pc, #668]	; (16778 <Send_DpmConfigGetCnf+0x4e0>)
   164dc:	0013      	movs	r3, r2
   164de:	005b      	lsls	r3, r3, #1
   164e0:	189b      	adds	r3, r3, r2
   164e2:	009b      	lsls	r3, r3, #2
   164e4:	18cb      	adds	r3, r1, r3
   164e6:	791b      	ldrb	r3, [r3, #4]
   164e8:	071b      	lsls	r3, r3, #28
   164ea:	0fdb      	lsrs	r3, r3, #31
   164ec:	b2db      	uxtb	r3, r3
   164ee:	001a      	movs	r2, r3
   164f0:	2126      	movs	r1, #38	; 0x26
   164f2:	187b      	adds	r3, r7, r1
   164f4:	701a      	strb	r2, [r3, #0]
        TLV_add(&send_tlv, GUI_PARAM_DRP_SUPPORT, 1, &settings);
   164f6:	187b      	adds	r3, r7, r1
   164f8:	222c      	movs	r2, #44	; 0x2c
   164fa:	18b8      	adds	r0, r7, r2
   164fc:	2201      	movs	r2, #1
   164fe:	2105      	movs	r1, #5
   16500:	f7fc fc54 	bl	12dac <TLV_add>
        if(0 != length)
   16504:	234c      	movs	r3, #76	; 0x4c
   16506:	18fb      	adds	r3, r7, r3
   16508:	881b      	ldrh	r3, [r3, #0]
   1650a:	2b00      	cmp	r3, #0
   1650c:	d000      	beq.n	16510 <Send_DpmConfigGetCnf+0x278>
   1650e:	e1db      	b.n	168c8 <Send_DpmConfigGetCnf+0x630>
        }
      }
    case GUI_PARAM_CADROLETOGGLE :
      {
        /*CADRoleToggle*/
        uint8_t settings = DPM_Settings[PortNum].CAD_RoleToggle;
   16510:	230f      	movs	r3, #15
   16512:	18fb      	adds	r3, r7, r3
   16514:	781a      	ldrb	r2, [r3, #0]
   16516:	4998      	ldr	r1, [pc, #608]	; (16778 <Send_DpmConfigGetCnf+0x4e0>)
   16518:	0013      	movs	r3, r2
   1651a:	005b      	lsls	r3, r3, #1
   1651c:	189b      	adds	r3, r3, r2
   1651e:	009b      	lsls	r3, r3, #2
   16520:	18cb      	adds	r3, r1, r3
   16522:	795b      	ldrb	r3, [r3, #5]
   16524:	069b      	lsls	r3, r3, #26
   16526:	0fdb      	lsrs	r3, r3, #31
   16528:	b2db      	uxtb	r3, r3
   1652a:	001a      	movs	r2, r3
   1652c:	2125      	movs	r1, #37	; 0x25
   1652e:	187b      	adds	r3, r7, r1
   16530:	701a      	strb	r2, [r3, #0]
        TLV_add(&send_tlv, GUI_PARAM_CADROLETOGGLE, 1, &settings);
   16532:	187b      	adds	r3, r7, r1
   16534:	222c      	movs	r2, #44	; 0x2c
   16536:	18b8      	adds	r0, r7, r2
   16538:	2201      	movs	r2, #1
   1653a:	2106      	movs	r1, #6
   1653c:	f7fc fc36 	bl	12dac <TLV_add>
        if(0 != length)
   16540:	234c      	movs	r3, #76	; 0x4c
   16542:	18fb      	adds	r3, r7, r3
   16544:	881b      	ldrh	r3, [r3, #0]
   16546:	2b00      	cmp	r3, #0
   16548:	d000      	beq.n	1654c <Send_DpmConfigGetCnf+0x2b4>
   1654a:	e1bf      	b.n	168cc <Send_DpmConfigGetCnf+0x634>
        }
      }
    case GUI_PARAM_PE_SCAP_HR :
      {
        /*PE_SCAP_HR*/
        uint8_t settings = DPM_Settings[PortNum].PE_CapscounterSupport;
   1654c:	230f      	movs	r3, #15
   1654e:	18fb      	adds	r3, r7, r3
   16550:	781a      	ldrb	r2, [r3, #0]
   16552:	4989      	ldr	r1, [pc, #548]	; (16778 <Send_DpmConfigGetCnf+0x4e0>)
   16554:	0013      	movs	r3, r2
   16556:	005b      	lsls	r3, r3, #1
   16558:	189b      	adds	r3, r3, r2
   1655a:	009b      	lsls	r3, r3, #2
   1655c:	18cb      	adds	r3, r1, r3
   1655e:	791b      	ldrb	r3, [r3, #4]
   16560:	061b      	lsls	r3, r3, #24
   16562:	0fdb      	lsrs	r3, r3, #31
   16564:	b2db      	uxtb	r3, r3
   16566:	001a      	movs	r2, r3
   16568:	2124      	movs	r1, #36	; 0x24
   1656a:	187b      	adds	r3, r7, r1
   1656c:	701a      	strb	r2, [r3, #0]
        TLV_add(&send_tlv, GUI_PARAM_PE_SCAP_HR,  1, &settings);
   1656e:	187b      	adds	r3, r7, r1
   16570:	222c      	movs	r2, #44	; 0x2c
   16572:	18b8      	adds	r0, r7, r2
   16574:	2201      	movs	r2, #1
   16576:	2107      	movs	r1, #7
   16578:	f7fc fc18 	bl	12dac <TLV_add>
        if(0 != length)
   1657c:	234c      	movs	r3, #76	; 0x4c
   1657e:	18fb      	adds	r3, r7, r3
   16580:	881b      	ldrh	r3, [r3, #0]
   16582:	2b00      	cmp	r3, #0
   16584:	d000      	beq.n	16588 <Send_DpmConfigGetCnf+0x2f0>
   16586:	e1a3      	b.n	168d0 <Send_DpmConfigGetCnf+0x638>
        }
      }
    case GUI_PARAM_VCONNSWAP :
      {
        /*VConnSwap*/
        uint8_t settings = DPM_USER_Settings[PortNum].PE_VconnSwap;
   16588:	230f      	movs	r3, #15
   1658a:	18fb      	adds	r3, r7, r3
   1658c:	781a      	ldrb	r2, [r3, #0]
   1658e:	4b7b      	ldr	r3, [pc, #492]	; (1677c <Send_DpmConfigGetCnf+0x4e4>)
   16590:	2174      	movs	r1, #116	; 0x74
   16592:	434a      	muls	r2, r1
   16594:	5cd3      	ldrb	r3, [r2, r3]
   16596:	079b      	lsls	r3, r3, #30
   16598:	0fdb      	lsrs	r3, r3, #31
   1659a:	b2db      	uxtb	r3, r3
   1659c:	001a      	movs	r2, r3
   1659e:	2123      	movs	r1, #35	; 0x23
   165a0:	187b      	adds	r3, r7, r1
   165a2:	701a      	strb	r2, [r3, #0]
        TLV_add(&send_tlv, GUI_PARAM_VCONNSWAP, 1, &settings);
   165a4:	187b      	adds	r3, r7, r1
   165a6:	222c      	movs	r2, #44	; 0x2c
   165a8:	18b8      	adds	r0, r7, r2
   165aa:	2201      	movs	r2, #1
   165ac:	2108      	movs	r1, #8
   165ae:	f7fc fbfd 	bl	12dac <TLV_add>
        if(0 != length)
   165b2:	234c      	movs	r3, #76	; 0x4c
   165b4:	18fb      	adds	r3, r7, r3
   165b6:	881b      	ldrh	r3, [r3, #0]
   165b8:	2b00      	cmp	r3, #0
   165ba:	d000      	beq.n	165be <Send_DpmConfigGetCnf+0x326>
   165bc:	e18a      	b.n	168d4 <Send_DpmConfigGetCnf+0x63c>
      }
#endif /*_VDM*/
    case GUI_PARAM_PING_SUPPORT :
      {
        /* Ping Support */
        uint8_t settings = DPM_Settings[PortNum].PE_PingSupport;
   165be:	230f      	movs	r3, #15
   165c0:	18fb      	adds	r3, r7, r3
   165c2:	781a      	ldrb	r2, [r3, #0]
   165c4:	496c      	ldr	r1, [pc, #432]	; (16778 <Send_DpmConfigGetCnf+0x4e0>)
   165c6:	0013      	movs	r3, r2
   165c8:	005b      	lsls	r3, r3, #1
   165ca:	189b      	adds	r3, r3, r2
   165cc:	009b      	lsls	r3, r3, #2
   165ce:	18cb      	adds	r3, r1, r3
   165d0:	791b      	ldrb	r3, [r3, #4]
   165d2:	065b      	lsls	r3, r3, #25
   165d4:	0fdb      	lsrs	r3, r3, #31
   165d6:	b2db      	uxtb	r3, r3
   165d8:	001a      	movs	r2, r3
   165da:	2122      	movs	r1, #34	; 0x22
   165dc:	187b      	adds	r3, r7, r1
   165de:	701a      	strb	r2, [r3, #0]
        TLV_add(&send_tlv, GUI_PARAM_PING_SUPPORT, 1, &settings);
   165e0:	187b      	adds	r3, r7, r1
   165e2:	222c      	movs	r2, #44	; 0x2c
   165e4:	18b8      	adds	r0, r7, r2
   165e6:	2201      	movs	r2, #1
   165e8:	210a      	movs	r1, #10
   165ea:	f7fc fbdf 	bl	12dac <TLV_add>
        if(0 != length)
   165ee:	234c      	movs	r3, #76	; 0x4c
   165f0:	18fb      	adds	r3, r7, r3
   165f2:	881b      	ldrh	r3, [r3, #0]
   165f4:	2b00      	cmp	r3, #0
   165f6:	d000      	beq.n	165fa <Send_DpmConfigGetCnf+0x362>
   165f8:	e16e      	b.n	168d8 <Send_DpmConfigGetCnf+0x640>
      }
#if defined(USBPD_REV30_SUPPORT)
    case GUI_PARAM_PPS_SUPPORT :
      {
        /* PD3 Support */
        uint16_t settings = DPM_Settings[PortNum].PE_PD3_Support.PD3_Support;
   165fa:	230f      	movs	r3, #15
   165fc:	18fb      	adds	r3, r7, r3
   165fe:	781a      	ldrb	r2, [r3, #0]
   16600:	495d      	ldr	r1, [pc, #372]	; (16778 <Send_DpmConfigGetCnf+0x4e0>)
   16602:	0013      	movs	r3, r2
   16604:	005b      	lsls	r3, r3, #1
   16606:	189b      	adds	r3, r3, r2
   16608:	009b      	lsls	r3, r3, #2
   1660a:	18cb      	adds	r3, r1, r3
   1660c:	3308      	adds	r3, #8
   1660e:	881a      	ldrh	r2, [r3, #0]
   16610:	2120      	movs	r1, #32
   16612:	187b      	adds	r3, r7, r1
   16614:	801a      	strh	r2, [r3, #0]
        TLV_add(&send_tlv, GUI_PARAM_PPS_SUPPORT, 2, (uint8_t*)&settings);
   16616:	187b      	adds	r3, r7, r1
   16618:	222c      	movs	r2, #44	; 0x2c
   1661a:	18b8      	adds	r0, r7, r2
   1661c:	2202      	movs	r2, #2
   1661e:	210b      	movs	r1, #11
   16620:	f7fc fbc4 	bl	12dac <TLV_add>
        if(0 != length)
   16624:	234c      	movs	r3, #76	; 0x4c
   16626:	18fb      	adds	r3, r7, r3
   16628:	881b      	ldrh	r3, [r3, #0]
   1662a:	2b00      	cmp	r3, #0
   1662c:	d000      	beq.n	16630 <Send_DpmConfigGetCnf+0x398>
   1662e:	e155      	b.n	168dc <Send_DpmConfigGetCnf+0x644>
        uint8_t nb_pdo;
#if USBPD_PORT_COUNT==2
        if (USBPD_PORT_0 == PortNum)
#endif /* USBPD_PORT_COUNT==2 */
        {
          nb_pdo    =  USBPD_NbPDO[0];
   16630:	214b      	movs	r1, #75	; 0x4b
   16632:	187b      	adds	r3, r7, r1
   16634:	4a52      	ldr	r2, [pc, #328]	; (16780 <Send_DpmConfigGetCnf+0x4e8>)
   16636:	7812      	ldrb	r2, [r2, #0]
   16638:	701a      	strb	r2, [r3, #0]
          list_pdo  = (uint8_t*)PORT0_PDO_ListSNK;
   1663a:	4b52      	ldr	r3, [pc, #328]	; (16784 <Send_DpmConfigGetCnf+0x4ec>)
   1663c:	647b      	str	r3, [r7, #68]	; 0x44
        {
          nb_pdo    =  USBPD_NbPDO[2];
          list_pdo  = (uint8_t*)PORT1_PDO_ListSNK;
        }
#endif /* USBPD_PORT_COUNT==2 */
        TLV_add(&send_tlv, GUI_PARAM_SNK_PDO, nb_pdo * 4, list_pdo);
   1663e:	187b      	adds	r3, r7, r1
   16640:	781b      	ldrb	r3, [r3, #0]
   16642:	b29b      	uxth	r3, r3
   16644:	009b      	lsls	r3, r3, #2
   16646:	b29a      	uxth	r2, r3
   16648:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   1664a:	212c      	movs	r1, #44	; 0x2c
   1664c:	1878      	adds	r0, r7, r1
   1664e:	210c      	movs	r1, #12
   16650:	f7fc fbac 	bl	12dac <TLV_add>
      }
      if(0 != length)
   16654:	234c      	movs	r3, #76	; 0x4c
   16656:	18fb      	adds	r3, r7, r3
   16658:	881b      	ldrh	r3, [r3, #0]
   1665a:	2b00      	cmp	r3, #0
   1665c:	d000      	beq.n	16660 <Send_DpmConfigGetCnf+0x3c8>
   1665e:	e13f      	b.n	168e0 <Send_DpmConfigGetCnf+0x648>
        uint8_t nb_pdo;
#if USBPD_PORT_COUNT==2
        if (USBPD_PORT_0 == PortNum)
#endif /* USBPD_PORT_COUNT==2 */
        {
          nb_pdo    =  USBPD_NbPDO[1];
   16660:	2143      	movs	r1, #67	; 0x43
   16662:	187b      	adds	r3, r7, r1
   16664:	4a46      	ldr	r2, [pc, #280]	; (16780 <Send_DpmConfigGetCnf+0x4e8>)
   16666:	7852      	ldrb	r2, [r2, #1]
   16668:	701a      	strb	r2, [r3, #0]
          list_pdo  = (uint8_t*)PORT0_PDO_ListSRC;
   1666a:	4b47      	ldr	r3, [pc, #284]	; (16788 <Send_DpmConfigGetCnf+0x4f0>)
   1666c:	63fb      	str	r3, [r7, #60]	; 0x3c
        {
          nb_pdo    =  USBPD_NbPDO[3];
          list_pdo  = (uint8_t*)PORT1_PDO_ListSRC;
        }
#endif /* USBPD_PORT_COUNT==2 */
        TLV_add(&send_tlv, GUI_PARAM_SRC_PDO, nb_pdo * 4, list_pdo);
   1666e:	187b      	adds	r3, r7, r1
   16670:	781b      	ldrb	r3, [r3, #0]
   16672:	b29b      	uxth	r3, r3
   16674:	009b      	lsls	r3, r3, #2
   16676:	b29a      	uxth	r2, r3
   16678:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   1667a:	212c      	movs	r1, #44	; 0x2c
   1667c:	1878      	adds	r0, r7, r1
   1667e:	210d      	movs	r1, #13
   16680:	f7fc fb94 	bl	12dac <TLV_add>
      }
      if(0 != length)
   16684:	234c      	movs	r3, #76	; 0x4c
   16686:	18fb      	adds	r3, r7, r3
   16688:	881b      	ldrh	r3, [r3, #0]
   1668a:	2b00      	cmp	r3, #0
   1668c:	d000      	beq.n	16690 <Send_DpmConfigGetCnf+0x3f8>
   1668e:	e129      	b.n	168e4 <Send_DpmConfigGetCnf+0x64c>
      }
#endif /* _SRC || _DRP */
    case GUI_PARAM_TDRP :
      {
        /* Calculate the current value of tDRP (value between 50ms and 100ms) */
        uint8_t value = DPM_USER_Settings[PortNum].CAD_tDRP;
   16690:	230f      	movs	r3, #15
   16692:	18fb      	adds	r3, r7, r3
   16694:	781b      	ldrb	r3, [r3, #0]
   16696:	4a39      	ldr	r2, [pc, #228]	; (1677c <Send_DpmConfigGetCnf+0x4e4>)
   16698:	2168      	movs	r1, #104	; 0x68
   1669a:	2074      	movs	r0, #116	; 0x74
   1669c:	4343      	muls	r3, r0
   1669e:	18d3      	adds	r3, r2, r3
   166a0:	185b      	adds	r3, r3, r1
   166a2:	791b      	ldrb	r3, [r3, #4]
   166a4:	061b      	lsls	r3, r3, #24
   166a6:	0e5b      	lsrs	r3, r3, #25
   166a8:	b2db      	uxtb	r3, r3
   166aa:	001a      	movs	r2, r3
   166ac:	211f      	movs	r1, #31
   166ae:	187b      	adds	r3, r7, r1
   166b0:	701a      	strb	r2, [r3, #0]
        TLV_add(&send_tlv, GUI_PARAM_TDRP, 1, &value);
   166b2:	187b      	adds	r3, r7, r1
   166b4:	222c      	movs	r2, #44	; 0x2c
   166b6:	18b8      	adds	r0, r7, r2
   166b8:	2201      	movs	r2, #1
   166ba:	210e      	movs	r1, #14
   166bc:	f7fc fb76 	bl	12dac <TLV_add>
      }
      if(0 != length)
   166c0:	234c      	movs	r3, #76	; 0x4c
   166c2:	18fb      	adds	r3, r7, r3
   166c4:	881b      	ldrh	r3, [r3, #0]
   166c6:	2b00      	cmp	r3, #0
   166c8:	d000      	beq.n	166cc <Send_DpmConfigGetCnf+0x434>
   166ca:	e10d      	b.n	168e8 <Send_DpmConfigGetCnf+0x650>
        break;
      }
    case GUI_PARAM_DCSRC_DRP :
      {
        /* Calculate the current value of tDRP (value between 50ms and 100ms) */
        uint8_t value = DPM_USER_Settings[PortNum].CAD_dcSRC_DRP;
   166cc:	230f      	movs	r3, #15
   166ce:	18fb      	adds	r3, r7, r3
   166d0:	781b      	ldrb	r3, [r3, #0]
   166d2:	4a2a      	ldr	r2, [pc, #168]	; (1677c <Send_DpmConfigGetCnf+0x4e4>)
   166d4:	2168      	movs	r1, #104	; 0x68
   166d6:	2074      	movs	r0, #116	; 0x74
   166d8:	4343      	muls	r3, r0
   166da:	18d3      	adds	r3, r2, r3
   166dc:	185b      	adds	r3, r3, r1
   166de:	795b      	ldrb	r3, [r3, #5]
   166e0:	065b      	lsls	r3, r3, #25
   166e2:	0e5b      	lsrs	r3, r3, #25
   166e4:	b2db      	uxtb	r3, r3
   166e6:	001a      	movs	r2, r3
   166e8:	211e      	movs	r1, #30
   166ea:	187b      	adds	r3, r7, r1
   166ec:	701a      	strb	r2, [r3, #0]
        TLV_add(&send_tlv, GUI_PARAM_DCSRC_DRP, 1, &value);
   166ee:	187b      	adds	r3, r7, r1
   166f0:	222c      	movs	r2, #44	; 0x2c
   166f2:	18b8      	adds	r0, r7, r2
   166f4:	2201      	movs	r2, #1
   166f6:	210f      	movs	r1, #15
   166f8:	f7fc fb58 	bl	12dac <TLV_add>
      }
      if(0 != length)
   166fc:	234c      	movs	r3, #76	; 0x4c
   166fe:	18fb      	adds	r3, r7, r3
   16700:	881b      	ldrh	r3, [r3, #0]
   16702:	2b00      	cmp	r3, #0
   16704:	d000      	beq.n	16708 <Send_DpmConfigGetCnf+0x470>
   16706:	e0f1      	b.n	168ec <Send_DpmConfigGetCnf+0x654>
      {
        break;
      }
    case GUI_PARAM_RESPONDS_TO_DISCOV_SOP :
      {
        uint8_t settings = DPM_Settings[PortNum].PE_RespondsToDiscovSOP;
   16708:	230f      	movs	r3, #15
   1670a:	18fb      	adds	r3, r7, r3
   1670c:	781a      	ldrb	r2, [r3, #0]
   1670e:	491a      	ldr	r1, [pc, #104]	; (16778 <Send_DpmConfigGetCnf+0x4e0>)
   16710:	0013      	movs	r3, r2
   16712:	005b      	lsls	r3, r3, #1
   16714:	189b      	adds	r3, r3, r2
   16716:	009b      	lsls	r3, r3, #2
   16718:	18cb      	adds	r3, r1, r3
   1671a:	795b      	ldrb	r3, [r3, #5]
   1671c:	07db      	lsls	r3, r3, #31
   1671e:	0fdb      	lsrs	r3, r3, #31
   16720:	b2db      	uxtb	r3, r3
   16722:	001a      	movs	r2, r3
   16724:	211d      	movs	r1, #29
   16726:	187b      	adds	r3, r7, r1
   16728:	701a      	strb	r2, [r3, #0]
        TLV_add(&send_tlv, GUI_PARAM_RESPONDS_TO_DISCOV_SOP, 1, &settings);
   1672a:	187b      	adds	r3, r7, r1
   1672c:	222c      	movs	r2, #44	; 0x2c
   1672e:	18b8      	adds	r0, r7, r2
   16730:	2201      	movs	r2, #1
   16732:	2110      	movs	r1, #16
   16734:	f7fc fb3a 	bl	12dac <TLV_add>
      }
      if(0 != length)
   16738:	234c      	movs	r3, #76	; 0x4c
   1673a:	18fb      	adds	r3, r7, r3
   1673c:	881b      	ldrh	r3, [r3, #0]
   1673e:	2b00      	cmp	r3, #0
   16740:	d000      	beq.n	16744 <Send_DpmConfigGetCnf+0x4ac>
   16742:	e0d5      	b.n	168f0 <Send_DpmConfigGetCnf+0x658>
      {
        break;
      }
    case GUI_PARAM_ATTEMPTS_DISCOV_SOP :
      {
        uint8_t settings = DPM_Settings[PortNum].PE_AttemptsDiscovSOP;
   16744:	230f      	movs	r3, #15
   16746:	18fb      	adds	r3, r7, r3
   16748:	781a      	ldrb	r2, [r3, #0]
   1674a:	490b      	ldr	r1, [pc, #44]	; (16778 <Send_DpmConfigGetCnf+0x4e0>)
   1674c:	0013      	movs	r3, r2
   1674e:	005b      	lsls	r3, r3, #1
   16750:	189b      	adds	r3, r3, r2
   16752:	009b      	lsls	r3, r3, #2
   16754:	18cb      	adds	r3, r1, r3
   16756:	795b      	ldrb	r3, [r3, #5]
   16758:	079b      	lsls	r3, r3, #30
   1675a:	0fdb      	lsrs	r3, r3, #31
   1675c:	b2db      	uxtb	r3, r3
   1675e:	001a      	movs	r2, r3
   16760:	211c      	movs	r1, #28
   16762:	187b      	adds	r3, r7, r1
   16764:	701a      	strb	r2, [r3, #0]
        TLV_add(&send_tlv, GUI_PARAM_ATTEMPTS_DISCOV_SOP, 1, &settings);
   16766:	187b      	adds	r3, r7, r1
   16768:	222c      	movs	r2, #44	; 0x2c
   1676a:	18b8      	adds	r0, r7, r2
   1676c:	2201      	movs	r2, #1
   1676e:	2111      	movs	r1, #17
   16770:	f7fc fb1c 	bl	12dac <TLV_add>
   16774:	e00a      	b.n	1678c <Send_DpmConfigGetCnf+0x4f4>
   16776:	46c0      	nop			; (mov r8, r8)
   16778:	0002fec8 	.word	0x0002fec8
   1677c:	0002fedc 	.word	0x0002fedc
   16780:	0002fe20 	.word	0x0002fe20
   16784:	0002fe40 	.word	0x0002fe40
   16788:	0002fe24 	.word	0x0002fe24
      }
      if(0 != length)
   1678c:	234c      	movs	r3, #76	; 0x4c
   1678e:	18fb      	adds	r3, r7, r3
   16790:	881b      	ldrh	r3, [r3, #0]
   16792:	2b00      	cmp	r3, #0
   16794:	d000      	beq.n	16798 <Send_DpmConfigGetCnf+0x500>
   16796:	e0ad      	b.n	168f4 <Send_DpmConfigGetCnf+0x65c>
      {
        break;
      }
    case GUI_PARAM_XID_SOP :
      {
        uint32_t value = DPM_ID_Settings[PortNum].XID;
   16798:	230f      	movs	r3, #15
   1679a:	18fb      	adds	r3, r7, r3
   1679c:	781a      	ldrb	r2, [r3, #0]
   1679e:	4b68      	ldr	r3, [pc, #416]	; (16940 <Send_DpmConfigGetCnf+0x6a8>)
   167a0:	00d2      	lsls	r2, r2, #3
   167a2:	58d3      	ldr	r3, [r2, r3]
   167a4:	61bb      	str	r3, [r7, #24]
        TLV_add(&send_tlv, GUI_PARAM_XID_SOP, 4, (uint8_t*)&value);
   167a6:	2318      	movs	r3, #24
   167a8:	18fb      	adds	r3, r7, r3
   167aa:	222c      	movs	r2, #44	; 0x2c
   167ac:	18b8      	adds	r0, r7, r2
   167ae:	2204      	movs	r2, #4
   167b0:	2112      	movs	r1, #18
   167b2:	f7fc fafb 	bl	12dac <TLV_add>
      }
      if(0 != length)
   167b6:	234c      	movs	r3, #76	; 0x4c
   167b8:	18fb      	adds	r3, r7, r3
   167ba:	881b      	ldrh	r3, [r3, #0]
   167bc:	2b00      	cmp	r3, #0
   167be:	d000      	beq.n	167c2 <Send_DpmConfigGetCnf+0x52a>
   167c0:	e09a      	b.n	168f8 <Send_DpmConfigGetCnf+0x660>
      {
        break;
      }
    case GUI_PARAM_USB_VID_SOP :
      {
        uint16_t value = DPM_ID_Settings[PortNum].VID;
   167c2:	230f      	movs	r3, #15
   167c4:	18fb      	adds	r3, r7, r3
   167c6:	781b      	ldrb	r3, [r3, #0]
   167c8:	4a5d      	ldr	r2, [pc, #372]	; (16940 <Send_DpmConfigGetCnf+0x6a8>)
   167ca:	00db      	lsls	r3, r3, #3
   167cc:	18d3      	adds	r3, r2, r3
   167ce:	3304      	adds	r3, #4
   167d0:	881a      	ldrh	r2, [r3, #0]
   167d2:	2116      	movs	r1, #22
   167d4:	187b      	adds	r3, r7, r1
   167d6:	801a      	strh	r2, [r3, #0]
        TLV_add(&send_tlv, GUI_PARAM_USB_VID_SOP, 2, (uint8_t*)&value);
   167d8:	187b      	adds	r3, r7, r1
   167da:	222c      	movs	r2, #44	; 0x2c
   167dc:	18b8      	adds	r0, r7, r2
   167de:	2202      	movs	r2, #2
   167e0:	2117      	movs	r1, #23
   167e2:	f7fc fae3 	bl	12dac <TLV_add>
      }
      if(0 != length)
   167e6:	234c      	movs	r3, #76	; 0x4c
   167e8:	18fb      	adds	r3, r7, r3
   167ea:	881b      	ldrh	r3, [r3, #0]
   167ec:	2b00      	cmp	r3, #0
   167ee:	d000      	beq.n	167f2 <Send_DpmConfigGetCnf+0x55a>
   167f0:	e084      	b.n	168fc <Send_DpmConfigGetCnf+0x664>
      {
        break;
      }
    case GUI_PARAM_PID_SOP :
      {
        uint16_t value = DPM_ID_Settings[PortNum].PID;
   167f2:	230f      	movs	r3, #15
   167f4:	18fb      	adds	r3, r7, r3
   167f6:	781b      	ldrb	r3, [r3, #0]
   167f8:	4a51      	ldr	r2, [pc, #324]	; (16940 <Send_DpmConfigGetCnf+0x6a8>)
   167fa:	00db      	lsls	r3, r3, #3
   167fc:	18d3      	adds	r3, r2, r3
   167fe:	3306      	adds	r3, #6
   16800:	881a      	ldrh	r2, [r3, #0]
   16802:	2114      	movs	r1, #20
   16804:	187b      	adds	r3, r7, r1
   16806:	801a      	strh	r2, [r3, #0]
        TLV_add(&send_tlv, GUI_PARAM_PID_SOP, 2, (uint8_t*)&value);
   16808:	187b      	adds	r3, r7, r1
   1680a:	222c      	movs	r2, #44	; 0x2c
   1680c:	18b8      	adds	r0, r7, r2
   1680e:	2202      	movs	r2, #2
   16810:	2118      	movs	r1, #24
   16812:	f7fc facb 	bl	12dac <TLV_add>
      }
      if(0 != length)
   16816:	234c      	movs	r3, #76	; 0x4c
   16818:	18fb      	adds	r3, r7, r3
   1681a:	881b      	ldrh	r3, [r3, #0]
   1681c:	2b00      	cmp	r3, #0
   1681e:	d000      	beq.n	16822 <Send_DpmConfigGetCnf+0x58a>
   16820:	e06e      	b.n	16900 <Send_DpmConfigGetCnf+0x668>
        break;
      }
#endif /* _VDM */
    case GUI_PARAM_MEASUREREPORTING :
      {
        uint8_t settings = GUI_USER_Params[PortNum].u.MeasurementReporting;
   16822:	230f      	movs	r3, #15
   16824:	18fb      	adds	r3, r7, r3
   16826:	781a      	ldrb	r2, [r3, #0]
   16828:	4946      	ldr	r1, [pc, #280]	; (16944 <Send_DpmConfigGetCnf+0x6ac>)
   1682a:	0013      	movs	r3, r2
   1682c:	005b      	lsls	r3, r3, #1
   1682e:	189b      	adds	r3, r3, r2
   16830:	005b      	lsls	r3, r3, #1
   16832:	18cb      	adds	r3, r1, r3
   16834:	3304      	adds	r3, #4
   16836:	781a      	ldrb	r2, [r3, #0]
   16838:	2113      	movs	r1, #19
   1683a:	187b      	adds	r3, r7, r1
   1683c:	701a      	strb	r2, [r3, #0]
        TLV_add(&send_tlv, GUI_PARAM_MEASUREREPORTING, 1, &settings);
   1683e:	187b      	adds	r3, r7, r1
   16840:	222c      	movs	r2, #44	; 0x2c
   16842:	18b8      	adds	r0, r7, r2
   16844:	2201      	movs	r2, #1
   16846:	211a      	movs	r1, #26
   16848:	f7fc fab0 	bl	12dac <TLV_add>
      }
      if(0 != length)
   1684c:	234c      	movs	r3, #76	; 0x4c
   1684e:	18fb      	adds	r3, r7, r3
   16850:	881b      	ldrh	r3, [r3, #0]
   16852:	2b00      	cmp	r3, #0
   16854:	d156      	bne.n	16904 <Send_DpmConfigGetCnf+0x66c>
      }
#if defined(USBPD_REV30_SUPPORT)
#if _MANU_INFO
    case GUI_PARAM_MANUINFOPORT_VID :
      {
        uint8_t size = sizeof(DPM_USER_Settings[PortNum].DPM_ManuInfoPort.ManuString) + 4;
   16856:	213b      	movs	r1, #59	; 0x3b
   16858:	187b      	adds	r3, r7, r1
   1685a:	221a      	movs	r2, #26
   1685c:	701a      	strb	r2, [r3, #0]
        TLV_add(&send_tlv, GUI_PARAM_MANUINFOPORT_VID, size, (uint8_t*)&DPM_USER_Settings[PortNum].DPM_ManuInfoPort);
   1685e:	187b      	adds	r3, r7, r1
   16860:	781b      	ldrb	r3, [r3, #0]
   16862:	b299      	uxth	r1, r3
   16864:	230f      	movs	r3, #15
   16866:	18fb      	adds	r3, r7, r3
   16868:	781b      	ldrb	r3, [r3, #0]
   1686a:	2274      	movs	r2, #116	; 0x74
   1686c:	4353      	muls	r3, r2
   1686e:	3318      	adds	r3, #24
   16870:	001a      	movs	r2, r3
   16872:	4b35      	ldr	r3, [pc, #212]	; (16948 <Send_DpmConfigGetCnf+0x6b0>)
   16874:	18d3      	adds	r3, r2, r3
   16876:	3304      	adds	r3, #4
   16878:	222c      	movs	r2, #44	; 0x2c
   1687a:	18b8      	adds	r0, r7, r2
   1687c:	000a      	movs	r2, r1
   1687e:	211b      	movs	r1, #27
   16880:	f7fc fa94 	bl	12dac <TLV_add>
      }
      if(0 != length)
   16884:	234c      	movs	r3, #76	; 0x4c
   16886:	18fb      	adds	r3, r7, r3
   16888:	881b      	ldrh	r3, [r3, #0]
   1688a:	2b00      	cmp	r3, #0
   1688c:	d13c      	bne.n	16908 <Send_DpmConfigGetCnf+0x670>
        break;
      }
#endif /* _MANU_INFO */
#endif /*USBPD_REV30_SUPPORT*/
    default:
      if(0 != length)
   1688e:	234c      	movs	r3, #76	; 0x4c
   16890:	18fb      	adds	r3, r7, r3
   16892:	881b      	ldrh	r3, [r3, #0]
   16894:	2b00      	cmp	r3, #0
   16896:	d039      	beq.n	1690c <Send_DpmConfigGetCnf+0x674>
      {
        /* At least 1 parameter does not exist */
        TLV_deinit_encode(&send_tlv);
   16898:	232c      	movs	r3, #44	; 0x2c
   1689a:	18fb      	adds	r3, r7, r3
   1689c:	0018      	movs	r0, r3
   1689e:	f7fc fbe7 	bl	13070 <TLV_deinit_encode>
        Send_DpmConfigGetRej(PortNum, pEncodedMsg, GUI_REJ_DPM_INVALID_MESSAGE);
   168a2:	6879      	ldr	r1, [r7, #4]
   168a4:	230f      	movs	r3, #15
   168a6:	18fb      	adds	r3, r7, r3
   168a8:	781b      	ldrb	r3, [r3, #0]
   168aa:	2203      	movs	r2, #3
   168ac:	0018      	movs	r0, r3
   168ae:	f000 f84d 	bl	1694c <Send_DpmConfigGetRej>
        goto __end;
   168b2:	e03c      	b.n	1692e <Send_DpmConfigGetCnf+0x696>
          break;
   168b4:	46c0      	nop			; (mov r8, r8)
   168b6:	e02a      	b.n	1690e <Send_DpmConfigGetCnf+0x676>
          break;
   168b8:	46c0      	nop			; (mov r8, r8)
   168ba:	e028      	b.n	1690e <Send_DpmConfigGetCnf+0x676>
          break;
   168bc:	46c0      	nop			; (mov r8, r8)
   168be:	e026      	b.n	1690e <Send_DpmConfigGetCnf+0x676>
          break;
   168c0:	46c0      	nop			; (mov r8, r8)
   168c2:	e024      	b.n	1690e <Send_DpmConfigGetCnf+0x676>
          break;
   168c4:	46c0      	nop			; (mov r8, r8)
   168c6:	e022      	b.n	1690e <Send_DpmConfigGetCnf+0x676>
          break;
   168c8:	46c0      	nop			; (mov r8, r8)
   168ca:	e020      	b.n	1690e <Send_DpmConfigGetCnf+0x676>
          break;
   168cc:	46c0      	nop			; (mov r8, r8)
   168ce:	e01e      	b.n	1690e <Send_DpmConfigGetCnf+0x676>
          break;
   168d0:	46c0      	nop			; (mov r8, r8)
   168d2:	e01c      	b.n	1690e <Send_DpmConfigGetCnf+0x676>
          break;
   168d4:	46c0      	nop			; (mov r8, r8)
   168d6:	e01a      	b.n	1690e <Send_DpmConfigGetCnf+0x676>
          break;
   168d8:	46c0      	nop			; (mov r8, r8)
   168da:	e018      	b.n	1690e <Send_DpmConfigGetCnf+0x676>
          break;
   168dc:	46c0      	nop			; (mov r8, r8)
   168de:	e016      	b.n	1690e <Send_DpmConfigGetCnf+0x676>
        break;
   168e0:	46c0      	nop			; (mov r8, r8)
   168e2:	e014      	b.n	1690e <Send_DpmConfigGetCnf+0x676>
        break;
   168e4:	46c0      	nop			; (mov r8, r8)
   168e6:	e012      	b.n	1690e <Send_DpmConfigGetCnf+0x676>
        break;
   168e8:	46c0      	nop			; (mov r8, r8)
   168ea:	e010      	b.n	1690e <Send_DpmConfigGetCnf+0x676>
        break;
   168ec:	46c0      	nop			; (mov r8, r8)
   168ee:	e00e      	b.n	1690e <Send_DpmConfigGetCnf+0x676>
        break;
   168f0:	46c0      	nop			; (mov r8, r8)
   168f2:	e00c      	b.n	1690e <Send_DpmConfigGetCnf+0x676>
        break;
   168f4:	46c0      	nop			; (mov r8, r8)
   168f6:	e00a      	b.n	1690e <Send_DpmConfigGetCnf+0x676>
        break;
   168f8:	46c0      	nop			; (mov r8, r8)
   168fa:	e008      	b.n	1690e <Send_DpmConfigGetCnf+0x676>
        break;
   168fc:	46c0      	nop			; (mov r8, r8)
   168fe:	e006      	b.n	1690e <Send_DpmConfigGetCnf+0x676>
        break;
   16900:	46c0      	nop			; (mov r8, r8)
   16902:	e004      	b.n	1690e <Send_DpmConfigGetCnf+0x676>
        break;
   16904:	46c0      	nop			; (mov r8, r8)
   16906:	e002      	b.n	1690e <Send_DpmConfigGetCnf+0x676>
        break;
   16908:	46c0      	nop			; (mov r8, r8)
   1690a:	e000      	b.n	1690e <Send_DpmConfigGetCnf+0x676>
      }
      break;
   1690c:	46c0      	nop			; (mov r8, r8)
    }
    index++;
   1690e:	214f      	movs	r1, #79	; 0x4f
   16910:	187b      	adds	r3, r7, r1
   16912:	781a      	ldrb	r2, [r3, #0]
   16914:	187b      	adds	r3, r7, r1
   16916:	3201      	adds	r2, #1
   16918:	701a      	strb	r2, [r3, #0]
    /*
    Loop until we haven't processed each specified parameter.
    If there weren't any (length = 0), we exit the loop after one execution.
    */
  } while(index < length);
   1691a:	187b      	adds	r3, r7, r1
   1691c:	781b      	ldrb	r3, [r3, #0]
   1691e:	b29b      	uxth	r3, r3
   16920:	224c      	movs	r2, #76	; 0x4c
   16922:	18ba      	adds	r2, r7, r2
   16924:	8812      	ldrh	r2, [r2, #0]
   16926:	429a      	cmp	r2, r3
   16928:	d900      	bls.n	1692c <Send_DpmConfigGetCnf+0x694>
   1692a:	e4dd      	b.n	162e8 <Send_DpmConfigGetCnf+0x50>

__end:
   1692c:	46c0      	nop			; (mov r8, r8)
  TLV_deinit_encode(&send_tlv);
   1692e:	232c      	movs	r3, #44	; 0x2c
   16930:	18fb      	adds	r3, r7, r3
   16932:	0018      	movs	r0, r3
   16934:	f7fc fb9c 	bl	13070 <TLV_deinit_encode>
}
   16938:	46c0      	nop			; (mov r8, r8)
   1693a:	46bd      	mov	sp, r7
   1693c:	b015      	add	sp, #84	; 0x54
   1693e:	bd90      	pop	{r4, r7, pc}
   16940:	0002fed4 	.word	0x0002fed4
   16944:	000322dc 	.word	0x000322dc
   16948:	0002fedc 	.word	0x0002fedc

0001694c <Send_DpmConfigGetRej>:

static void Send_DpmConfigGetRej(uint8_t PortNum, uint8_t *pEncodedMsg, USBPD_GUI_Reject_Reason RejectReason)
{
   1694c:	b590      	push	{r4, r7, lr}
   1694e:	b087      	sub	sp, #28
   16950:	af00      	add	r7, sp, #0
   16952:	6039      	str	r1, [r7, #0]
   16954:	0011      	movs	r1, r2
   16956:	1dfb      	adds	r3, r7, #7
   16958:	1c02      	adds	r2, r0, #0
   1695a:	701a      	strb	r2, [r3, #0]
   1695c:	1dbb      	adds	r3, r7, #6
   1695e:	1c0a      	adds	r2, r1, #0
   16960:	701a      	strb	r2, [r3, #0]
  TLV_ToSend_Data send_tlv;
  TLV_init_encode(&send_tlv, DPM_CONFIG_REJ, TLV_SIZE_MAX, pEncodedMsg);
   16962:	6839      	ldr	r1, [r7, #0]
   16964:	2380      	movs	r3, #128	; 0x80
   16966:	005a      	lsls	r2, r3, #1
   16968:	240c      	movs	r4, #12
   1696a:	1938      	adds	r0, r7, r4
   1696c:	000b      	movs	r3, r1
   1696e:	2108      	movs	r1, #8
   16970:	f7fc f9b8 	bl	12ce4 <TLV_init_encode>
  TLV_add(&send_tlv, RejectReason, 0, NULL);
   16974:	1dbb      	adds	r3, r7, #6
   16976:	7819      	ldrb	r1, [r3, #0]
   16978:	1938      	adds	r0, r7, r4
   1697a:	2300      	movs	r3, #0
   1697c:	2200      	movs	r2, #0
   1697e:	f7fc fa15 	bl	12dac <TLV_add>
  TLV_deinit_encode(&send_tlv);
   16982:	193b      	adds	r3, r7, r4
   16984:	0018      	movs	r0, r3
   16986:	f7fc fb73 	bl	13070 <TLV_deinit_encode>
}
   1698a:	46c0      	nop			; (mov r8, r8)
   1698c:	46bd      	mov	sp, r7
   1698e:	b007      	add	sp, #28
   16990:	bd90      	pop	{r4, r7, pc}

00016992 <Send_DpmMessageRej>:

static void Send_DpmMessageRej(uint8_t PortNum, uint8_t *pEncodedMsg, USBPD_GUI_Reject_Reason RejectReason)
{
   16992:	b590      	push	{r4, r7, lr}
   16994:	b087      	sub	sp, #28
   16996:	af00      	add	r7, sp, #0
   16998:	6039      	str	r1, [r7, #0]
   1699a:	0011      	movs	r1, r2
   1699c:	1dfb      	adds	r3, r7, #7
   1699e:	1c02      	adds	r2, r0, #0
   169a0:	701a      	strb	r2, [r3, #0]
   169a2:	1dbb      	adds	r3, r7, #6
   169a4:	1c0a      	adds	r2, r1, #0
   169a6:	701a      	strb	r2, [r3, #0]
  TLV_ToSend_Data send_tlv;
  TLV_init_encode(&send_tlv, DPM_MESSAGE_REJ, TLV_SIZE_MAX, pEncodedMsg);
   169a8:	6839      	ldr	r1, [r7, #0]
   169aa:	2380      	movs	r3, #128	; 0x80
   169ac:	005a      	lsls	r2, r3, #1
   169ae:	240c      	movs	r4, #12
   169b0:	1938      	adds	r0, r7, r4
   169b2:	000b      	movs	r3, r1
   169b4:	210b      	movs	r1, #11
   169b6:	f7fc f995 	bl	12ce4 <TLV_init_encode>
  TLV_add(&send_tlv, RejectReason, 0, NULL);
   169ba:	1dbb      	adds	r3, r7, #6
   169bc:	7819      	ldrb	r1, [r3, #0]
   169be:	1938      	adds	r0, r7, r4
   169c0:	2300      	movs	r3, #0
   169c2:	2200      	movs	r2, #0
   169c4:	f7fc f9f2 	bl	12dac <TLV_add>
  TLV_deinit_encode(&send_tlv);
   169c8:	193b      	adds	r3, r7, r4
   169ca:	0018      	movs	r0, r3
   169cc:	f7fc fb50 	bl	13070 <TLV_deinit_encode>
}
   169d0:	46c0      	nop			; (mov r8, r8)
   169d2:	46bd      	mov	sp, r7
   169d4:	b007      	add	sp, #28
   169d6:	bd90      	pop	{r4, r7, pc}

000169d8 <Send_DpmRegisterReadCnf>:

static void Send_DpmRegisterReadCnf(uint8_t PortNum, uint8_t *pEncodedMsg, uint8_t param)
{
   169d8:	b590      	push	{r4, r7, lr}
   169da:	b091      	sub	sp, #68	; 0x44
   169dc:	af00      	add	r7, sp, #0
   169de:	6039      	str	r1, [r7, #0]
   169e0:	0011      	movs	r1, r2
   169e2:	1dfb      	adds	r3, r7, #7
   169e4:	1c02      	adds	r2, r0, #0
   169e6:	701a      	strb	r2, [r3, #0]
   169e8:	1dbb      	adds	r3, r7, #6
   169ea:	1c0a      	adds	r2, r1, #0
   169ec:	701a      	strb	r2, [r3, #0]
  TLV_ToSend_Data ToSendTLV;
  TLV_init_encode(&ToSendTLV, __GUI_SET_TAG_ID((PortNum +1), DPM_REGISTER_READ_CNF), TLV_SIZE_MAX, pEncodedMsg);
   169ee:	1dfb      	adds	r3, r7, #7
   169f0:	781b      	ldrb	r3, [r3, #0]
   169f2:	3301      	adds	r3, #1
   169f4:	015b      	lsls	r3, r3, #5
   169f6:	b25b      	sxtb	r3, r3
   169f8:	220f      	movs	r2, #15
   169fa:	4313      	orrs	r3, r2
   169fc:	b25b      	sxtb	r3, r3
   169fe:	b2d9      	uxtb	r1, r3
   16a00:	683c      	ldr	r4, [r7, #0]
   16a02:	2380      	movs	r3, #128	; 0x80
   16a04:	005a      	lsls	r2, r3, #1
   16a06:	2330      	movs	r3, #48	; 0x30
   16a08:	18f8      	adds	r0, r7, r3
   16a0a:	0023      	movs	r3, r4
   16a0c:	f7fc f96a 	bl	12ce4 <TLV_init_encode>

  uint8_t stateMachineArray[GUI_REG_NUMBER_OF_REGISTERS] = {
   16a10:	2308      	movs	r3, #8
   16a12:	18fb      	adds	r3, r7, r3
   16a14:	4a1e      	ldr	r2, [pc, #120]	; (16a90 <Send_DpmRegisterReadCnf+0xb8>)
   16a16:	ca13      	ldmia	r2!, {r0, r1, r4}
   16a18:	c313      	stmia	r3!, {r0, r1, r4}
   16a1a:	ca13      	ldmia	r2!, {r0, r1, r4}
   16a1c:	c313      	stmia	r3!, {r0, r1, r4}
   16a1e:	ca13      	ldmia	r2!, {r0, r1, r4}
   16a20:	c313      	stmia	r3!, {r0, r1, r4}
   16a22:	8811      	ldrh	r1, [r2, #0]
   16a24:	8019      	strh	r1, [r3, #0]
   16a26:	7892      	ldrb	r2, [r2, #2]
   16a28:	709a      	strb	r2, [r3, #2]
    GUI_REG_RX_DETECT, GUI_REG_RX_BYTE_COUNT, GUI_REG_RX_BUFFER_FRAME_TYPE, GUI_REG_RX_HEADER,
    GUI_REG_RX_DATA, GUI_REG_TRANSMIT, GUI_REG_TX_BYTE_COUNT, GUI_REG_TX_HEADER, GUI_REG_TX_DATA,
    GUI_REG_VBUS_VOLTAGE, GUI_REG_VBUS_SINK_DISCONNECT_THRESHOLD, GUI_REG_VBUS_STOP_DISCHARGE_THRESHOLD,
    GUI_REG_VBUS_VOLTAGE_ALARM_HI_CFG, GUI_REG_VBUS_VOLTAGE_ALARM_LO_CFG, GUI_REG_VENDOR_DATA
  };
  uint8_t counter = 0;
   16a2a:	233f      	movs	r3, #63	; 0x3f
   16a2c:	18fb      	adds	r3, r7, r3
   16a2e:	2200      	movs	r2, #0
   16a30:	701a      	strb	r2, [r3, #0]

  /*  If param is not at 0xFF, then it means we only want one parameter.
      We then have to get out of the state machine after the first state */
  if(param != 0xFF)
   16a32:	1dbb      	adds	r3, r7, #6
   16a34:	781b      	ldrb	r3, [r3, #0]
   16a36:	2bff      	cmp	r3, #255	; 0xff
   16a38:	d004      	beq.n	16a44 <Send_DpmRegisterReadCnf+0x6c>
  {
    *stateMachineArray = param;
   16a3a:	2308      	movs	r3, #8
   16a3c:	18fb      	adds	r3, r7, r3
   16a3e:	1dba      	adds	r2, r7, #6
   16a40:	7812      	ldrb	r2, [r2, #0]
   16a42:	701a      	strb	r2, [r3, #0]
  }

  do
  {
    switch(stateMachineArray[counter])
   16a44:	233f      	movs	r3, #63	; 0x3f
   16a46:	18fb      	adds	r3, r7, r3
   16a48:	781b      	ldrb	r3, [r3, #0]
   16a4a:	2208      	movs	r2, #8
   16a4c:	18ba      	adds	r2, r7, r2
   16a4e:	5cd3      	ldrb	r3, [r2, r3]
   16a50:	2b80      	cmp	r3, #128	; 0x80
   16a52:	d804      	bhi.n	16a5e <Send_DpmRegisterReadCnf+0x86>
   16a54:	009a      	lsls	r2, r3, #2
   16a56:	4b0f      	ldr	r3, [pc, #60]	; (16a94 <Send_DpmRegisterReadCnf+0xbc>)
   16a58:	18d3      	adds	r3, r2, r3
   16a5a:	681b      	ldr	r3, [r3, #0]
   16a5c:	469f      	mov	pc, r3
              break;
      case GUI_REG_VENDOR_DATA :

              break;
      default :
              break;
   16a5e:	46c0      	nop			; (mov r8, r8)
    }
    counter++;
   16a60:	213f      	movs	r1, #63	; 0x3f
   16a62:	187b      	adds	r3, r7, r1
   16a64:	781a      	ldrb	r2, [r3, #0]
   16a66:	187b      	adds	r3, r7, r1
   16a68:	3201      	adds	r2, #1
   16a6a:	701a      	strb	r2, [r3, #0]
  } while(counter < GUI_REG_NUMBER_OF_REGISTERS && param != 0xFF);
   16a6c:	187b      	adds	r3, r7, r1
   16a6e:	781b      	ldrb	r3, [r3, #0]
   16a70:	2b26      	cmp	r3, #38	; 0x26
   16a72:	d803      	bhi.n	16a7c <Send_DpmRegisterReadCnf+0xa4>
   16a74:	1dbb      	adds	r3, r7, #6
   16a76:	781b      	ldrb	r3, [r3, #0]
   16a78:	2bff      	cmp	r3, #255	; 0xff
   16a7a:	d1e3      	bne.n	16a44 <Send_DpmRegisterReadCnf+0x6c>

  TLV_deinit_encode(&ToSendTLV);
   16a7c:	2330      	movs	r3, #48	; 0x30
   16a7e:	18fb      	adds	r3, r7, r3
   16a80:	0018      	movs	r0, r3
   16a82:	f7fc faf5 	bl	13070 <TLV_deinit_encode>
}
   16a86:	46c0      	nop			; (mov r8, r8)
   16a88:	46bd      	mov	sp, r7
   16a8a:	b011      	add	sp, #68	; 0x44
   16a8c:	bd90      	pop	{r4, r7, pc}
   16a8e:	46c0      	nop			; (mov r8, r8)
   16a90:	0001f67c 	.word	0x0001f67c
   16a94:	0001f9c4 	.word	0x0001f9c4

00016a98 <Send_DpmRegisterWriteCnf>:

static void Send_DpmRegisterWriteCnf(uint8_t PortNum, uint8_t *pEncodedMsg, uint8_t *toProcess)
{
   16a98:	b5b0      	push	{r4, r5, r7, lr}
   16a9a:	b08c      	sub	sp, #48	; 0x30
   16a9c:	af00      	add	r7, sp, #0
   16a9e:	60b9      	str	r1, [r7, #8]
   16aa0:	607a      	str	r2, [r7, #4]
   16aa2:	230f      	movs	r3, #15
   16aa4:	18fb      	adds	r3, r7, r3
   16aa6:	1c02      	adds	r2, r0, #0
   16aa8:	701a      	strb	r2, [r3, #0]
  TLV_Received_Data ToProcessTLV;
  TLV_init_decode(&ToProcessTLV, toProcess);
   16aaa:	687a      	ldr	r2, [r7, #4]
   16aac:	2428      	movs	r4, #40	; 0x28
   16aae:	193b      	adds	r3, r7, r4
   16ab0:	0011      	movs	r1, r2
   16ab2:	0018      	movs	r0, r3
   16ab4:	f7fc faee 	bl	13094 <TLV_init_decode>

  uint8_t registerName;
  uint16_t registerSize;
  uint8_t *registerValue;

  TLV_get(&ToProcessTLV, &registerName, &registerSize, &registerValue);
   16ab8:	2320      	movs	r3, #32
   16aba:	18fb      	adds	r3, r7, r3
   16abc:	2224      	movs	r2, #36	; 0x24
   16abe:	18ba      	adds	r2, r7, r2
   16ac0:	2527      	movs	r5, #39	; 0x27
   16ac2:	1979      	adds	r1, r7, r5
   16ac4:	1938      	adds	r0, r7, r4
   16ac6:	f7fc fb11 	bl	130ec <TLV_get>

  switch(registerName)
   16aca:	197b      	adds	r3, r7, r5
   16acc:	781b      	ldrb	r3, [r3, #0]
   16ace:	2b80      	cmp	r3, #128	; 0x80
   16ad0:	d804      	bhi.n	16adc <Send_DpmRegisterWriteCnf+0x44>
   16ad2:	009a      	lsls	r2, r3, #2
   16ad4:	4b10      	ldr	r3, [pc, #64]	; (16b18 <Send_DpmRegisterWriteCnf+0x80>)
   16ad6:	18d3      	adds	r3, r2, r3
   16ad8:	681b      	ldr	r3, [r3, #0]
   16ada:	469f      	mov	pc, r3
              break;
      case GUI_REG_VENDOR_DATA :

              break;
      default :
              break;
   16adc:	46c0      	nop			; (mov r8, r8)
  }
  TLV_deinit_decode(&ToProcessTLV);
   16ade:	2328      	movs	r3, #40	; 0x28
   16ae0:	18fb      	adds	r3, r7, r3
   16ae2:	0018      	movs	r0, r3
   16ae4:	f7fc fb5c 	bl	131a0 <TLV_deinit_decode>

  TLV_ToSend_Data ToSendTLV;
  /* Generation of the empty response, as it should be done*/
  TLV_init_encode(&ToSendTLV, __GUI_SET_TAG_ID((PortNum + 1), DPM_REGISTER_WRITE_CNF), 12, pEncodedMsg);
   16ae8:	230f      	movs	r3, #15
   16aea:	18fb      	adds	r3, r7, r3
   16aec:	781b      	ldrb	r3, [r3, #0]
   16aee:	3301      	adds	r3, #1
   16af0:	015b      	lsls	r3, r3, #5
   16af2:	b25b      	sxtb	r3, r3
   16af4:	2211      	movs	r2, #17
   16af6:	4313      	orrs	r3, r2
   16af8:	b25b      	sxtb	r3, r3
   16afa:	b2d9      	uxtb	r1, r3
   16afc:	68bb      	ldr	r3, [r7, #8]
   16afe:	2414      	movs	r4, #20
   16b00:	1938      	adds	r0, r7, r4
   16b02:	220c      	movs	r2, #12
   16b04:	f7fc f8ee 	bl	12ce4 <TLV_init_encode>
  TLV_deinit_encode(&ToSendTLV);
   16b08:	193b      	adds	r3, r7, r4
   16b0a:	0018      	movs	r0, r3
   16b0c:	f7fc fab0 	bl	13070 <TLV_deinit_encode>
}
   16b10:	46c0      	nop			; (mov r8, r8)
   16b12:	46bd      	mov	sp, r7
   16b14:	b00c      	add	sp, #48	; 0x30
   16b16:	bdb0      	pop	{r4, r5, r7, pc}
   16b18:	0001fbc8 	.word	0x0001fbc8

00016b1c <Manage_FreeText>:
  * @param  pPayload    Pointer of the text to manage
  * @param  Size        Size of the text
  * @retval USBPD Status
  */
static USBPD_StatusTypeDef Manage_FreeText(uint8_t PortNum, uint8_t *pPayload, uint16_t Size)
{
   16b1c:	b580      	push	{r7, lr}
   16b1e:	b084      	sub	sp, #16
   16b20:	af02      	add	r7, sp, #8
   16b22:	6039      	str	r1, [r7, #0]
   16b24:	0011      	movs	r1, r2
   16b26:	1dfb      	adds	r3, r7, #7
   16b28:	1c02      	adds	r2, r0, #0
   16b2a:	701a      	strb	r2, [r3, #0]
   16b2c:	1d3b      	adds	r3, r7, #4
   16b2e:	1c0a      	adds	r2, r1, #0
   16b30:	801a      	strh	r2, [r3, #0]
  USBPD_TRACE_Add(USBPD_TRACE_DEBUG, PortNum, 0, pPayload, Size);
   16b32:	1d3b      	adds	r3, r7, #4
   16b34:	881b      	ldrh	r3, [r3, #0]
   16b36:	6838      	ldr	r0, [r7, #0]
   16b38:	1dfa      	adds	r2, r7, #7
   16b3a:	7811      	ldrb	r1, [r2, #0]
   16b3c:	9300      	str	r3, [sp, #0]
   16b3e:	0003      	movs	r3, r0
   16b40:	2200      	movs	r2, #0
   16b42:	2006      	movs	r0, #6
   16b44:	f7f9 fd0e 	bl	10564 <USBPD_TRACE_Add>
  return USBPD_OK;
   16b48:	2300      	movs	r3, #0
}
   16b4a:	0018      	movs	r0, r3
   16b4c:	46bd      	mov	sp, r7
   16b4e:	b002      	add	sp, #8
   16b50:	bd80      	pop	{r7, pc}

00016b52 <TRACER_EMB_WakeUpProcess>:
/**
  * @brief  function to wakeup TX process when sending a message.
  * @retval Timing
  */
void TRACER_EMB_WakeUpProcess(void)
{
   16b52:	b580      	push	{r7, lr}
   16b54:	af00      	add	r7, sp, #0
  USBPD_DPM_TraceWakeUp();
   16b56:	f7f9 fbd7 	bl	10308 <USBPD_DPM_TraceWakeUp>
}
   16b5a:	46c0      	nop			; (mov r8, r8)
   16b5c:	46bd      	mov	sp, r7
   16b5e:	bd80      	pop	{r7, pc}

00016b60 <UpdateSNKPowerPort0>:
/**
  * @brief  Function to update SNK PDO and power user settings on Port0
  * @retval None
  */
static void UpdateSNKPowerPort0(void)
{
   16b60:	b580      	push	{r7, lr}
   16b62:	b088      	sub	sp, #32
   16b64:	af00      	add	r7, sp, #0
  USBPD_PDO_TypeDef pdo;
  uint32_t _max_power = 0;
   16b66:	2300      	movs	r3, #0
   16b68:	61fb      	str	r3, [r7, #28]
  uint16_t _voltage = 0, _current = 0, _power = 0;
   16b6a:	230e      	movs	r3, #14
   16b6c:	18fb      	adds	r3, r7, r3
   16b6e:	2200      	movs	r2, #0
   16b70:	801a      	strh	r2, [r3, #0]
   16b72:	230c      	movs	r3, #12
   16b74:	18fb      	adds	r3, r7, r3
   16b76:	2200      	movs	r2, #0
   16b78:	801a      	strh	r2, [r3, #0]
   16b7a:	230a      	movs	r3, #10
   16b7c:	18fb      	adds	r3, r7, r3
   16b7e:	2200      	movs	r2, #0
   16b80:	801a      	strh	r2, [r3, #0]
  uint16_t _min_voltage = 0xFFFF, _max_voltage = 0, _max_current = 0;
   16b82:	231a      	movs	r3, #26
   16b84:	18fb      	adds	r3, r7, r3
   16b86:	2201      	movs	r2, #1
   16b88:	4252      	negs	r2, r2
   16b8a:	801a      	strh	r2, [r3, #0]
   16b8c:	2318      	movs	r3, #24
   16b8e:	18fb      	adds	r3, r7, r3
   16b90:	2200      	movs	r2, #0
   16b92:	801a      	strh	r2, [r3, #0]
   16b94:	2316      	movs	r3, #22
   16b96:	18fb      	adds	r3, r7, r3
   16b98:	2200      	movs	r2, #0
   16b9a:	801a      	strh	r2, [r3, #0]

  for (uint32_t _index = 0; _index < USBPD_NbPDO[0]; _index++)
   16b9c:	2300      	movs	r3, #0
   16b9e:	613b      	str	r3, [r7, #16]
   16ba0:	e0e6      	b.n	16d70 <UpdateSNKPowerPort0+0x210>
  {
    pdo.d32 = PORT0_PDO_ListSNK[_index];
   16ba2:	4b88      	ldr	r3, [pc, #544]	; (16dc4 <UpdateSNKPowerPort0+0x264>)
   16ba4:	693a      	ldr	r2, [r7, #16]
   16ba6:	0092      	lsls	r2, r2, #2
   16ba8:	58d3      	ldr	r3, [r2, r3]
   16baa:	607b      	str	r3, [r7, #4]
    switch (pdo.GenericPDO.PowerObject)
   16bac:	1dfb      	adds	r3, r7, #7
   16bae:	781b      	ldrb	r3, [r3, #0]
   16bb0:	061b      	lsls	r3, r3, #24
   16bb2:	0f9b      	lsrs	r3, r3, #30
   16bb4:	b2db      	uxtb	r3, r3
   16bb6:	2b01      	cmp	r3, #1
   16bb8:	d045      	beq.n	16c46 <UpdateSNKPowerPort0+0xe6>
   16bba:	2b02      	cmp	r3, #2
   16bbc:	d100      	bne.n	16bc0 <UpdateSNKPowerPort0+0x60>
   16bbe:	e086      	b.n	16cce <UpdateSNKPowerPort0+0x16e>
   16bc0:	2b00      	cmp	r3, #0
   16bc2:	d000      	beq.n	16bc6 <UpdateSNKPowerPort0+0x66>
        _current = GUI_DECODE_50MA(pdo.SRCSNKAPDO.MaxCurrentIn50mAunits);
        GUI_UPDATE_CURRENT_MAX(_current, _max_current);
        break;
#endif /*_USBPD_REV30_SUPPORT && PPS*/
      default:
        break;
   16bc4:	e0d1      	b.n	16d6a <UpdateSNKPowerPort0+0x20a>
        _voltage = GUI_DECODE_50MV(pdo.SNKFixedPDO.VoltageIn50mVunits);
   16bc6:	687b      	ldr	r3, [r7, #4]
   16bc8:	031b      	lsls	r3, r3, #12
   16bca:	0d9b      	lsrs	r3, r3, #22
   16bcc:	b29b      	uxth	r3, r3
   16bce:	0019      	movs	r1, r3
   16bd0:	200e      	movs	r0, #14
   16bd2:	183b      	adds	r3, r7, r0
   16bd4:	2232      	movs	r2, #50	; 0x32
   16bd6:	434a      	muls	r2, r1
   16bd8:	801a      	strh	r2, [r3, #0]
        GUI_UPDATE_VOLTAGE_MIN(_voltage, _min_voltage);
   16bda:	183a      	adds	r2, r7, r0
   16bdc:	231a      	movs	r3, #26
   16bde:	18fb      	adds	r3, r7, r3
   16be0:	8812      	ldrh	r2, [r2, #0]
   16be2:	881b      	ldrh	r3, [r3, #0]
   16be4:	429a      	cmp	r2, r3
   16be6:	d205      	bcs.n	16bf4 <UpdateSNKPowerPort0+0x94>
   16be8:	231a      	movs	r3, #26
   16bea:	18fb      	adds	r3, r7, r3
   16bec:	220e      	movs	r2, #14
   16bee:	18ba      	adds	r2, r7, r2
   16bf0:	8812      	ldrh	r2, [r2, #0]
   16bf2:	801a      	strh	r2, [r3, #0]
        GUI_UPDATE_VOLTAGE_MAX(_voltage, _max_voltage);
   16bf4:	230e      	movs	r3, #14
   16bf6:	18fa      	adds	r2, r7, r3
   16bf8:	2318      	movs	r3, #24
   16bfa:	18fb      	adds	r3, r7, r3
   16bfc:	8812      	ldrh	r2, [r2, #0]
   16bfe:	881b      	ldrh	r3, [r3, #0]
   16c00:	429a      	cmp	r2, r3
   16c02:	d905      	bls.n	16c10 <UpdateSNKPowerPort0+0xb0>
   16c04:	2318      	movs	r3, #24
   16c06:	18fb      	adds	r3, r7, r3
   16c08:	220e      	movs	r2, #14
   16c0a:	18ba      	adds	r2, r7, r2
   16c0c:	8812      	ldrh	r2, [r2, #0]
   16c0e:	801a      	strh	r2, [r3, #0]
        _current = GUI_DECODE_10MA(pdo.SNKFixedPDO.OperationalCurrentIn10mAunits);
   16c10:	1d3b      	adds	r3, r7, #4
   16c12:	881b      	ldrh	r3, [r3, #0]
   16c14:	059b      	lsls	r3, r3, #22
   16c16:	0d9b      	lsrs	r3, r3, #22
   16c18:	b29b      	uxth	r3, r3
   16c1a:	200c      	movs	r0, #12
   16c1c:	183a      	adds	r2, r7, r0
   16c1e:	1c19      	adds	r1, r3, #0
   16c20:	0089      	lsls	r1, r1, #2
   16c22:	18cb      	adds	r3, r1, r3
   16c24:	18db      	adds	r3, r3, r3
   16c26:	8013      	strh	r3, [r2, #0]
        GUI_UPDATE_CURRENT_MAX(_current, _max_current);
   16c28:	183a      	adds	r2, r7, r0
   16c2a:	2316      	movs	r3, #22
   16c2c:	18fb      	adds	r3, r7, r3
   16c2e:	8812      	ldrh	r2, [r2, #0]
   16c30:	881b      	ldrh	r3, [r3, #0]
   16c32:	429a      	cmp	r2, r3
   16c34:	d800      	bhi.n	16c38 <UpdateSNKPowerPort0+0xd8>
   16c36:	e093      	b.n	16d60 <UpdateSNKPowerPort0+0x200>
   16c38:	2316      	movs	r3, #22
   16c3a:	18fb      	adds	r3, r7, r3
   16c3c:	220c      	movs	r2, #12
   16c3e:	18ba      	adds	r2, r7, r2
   16c40:	8812      	ldrh	r2, [r2, #0]
   16c42:	801a      	strh	r2, [r3, #0]
        break;
   16c44:	e08c      	b.n	16d60 <UpdateSNKPowerPort0+0x200>
        _voltage = GUI_DECODE_50MV(pdo.SNKBatteryPDO.MinVoltageIn50mVunits);
   16c46:	687b      	ldr	r3, [r7, #4]
   16c48:	031b      	lsls	r3, r3, #12
   16c4a:	0d9b      	lsrs	r3, r3, #22
   16c4c:	b29b      	uxth	r3, r3
   16c4e:	0019      	movs	r1, r3
   16c50:	200e      	movs	r0, #14
   16c52:	183b      	adds	r3, r7, r0
   16c54:	2232      	movs	r2, #50	; 0x32
   16c56:	434a      	muls	r2, r1
   16c58:	801a      	strh	r2, [r3, #0]
        GUI_UPDATE_VOLTAGE_MIN(_voltage, _min_voltage);
   16c5a:	183a      	adds	r2, r7, r0
   16c5c:	231a      	movs	r3, #26
   16c5e:	18fb      	adds	r3, r7, r3
   16c60:	8812      	ldrh	r2, [r2, #0]
   16c62:	881b      	ldrh	r3, [r3, #0]
   16c64:	429a      	cmp	r2, r3
   16c66:	d205      	bcs.n	16c74 <UpdateSNKPowerPort0+0x114>
   16c68:	231a      	movs	r3, #26
   16c6a:	18fb      	adds	r3, r7, r3
   16c6c:	220e      	movs	r2, #14
   16c6e:	18ba      	adds	r2, r7, r2
   16c70:	8812      	ldrh	r2, [r2, #0]
   16c72:	801a      	strh	r2, [r3, #0]
        _voltage = GUI_DECODE_50MV(pdo.SNKBatteryPDO.MaxVoltageIn50mVunits);
   16c74:	1dbb      	adds	r3, r7, #6
   16c76:	881b      	ldrh	r3, [r3, #0]
   16c78:	049b      	lsls	r3, r3, #18
   16c7a:	0d9b      	lsrs	r3, r3, #22
   16c7c:	b29b      	uxth	r3, r3
   16c7e:	0019      	movs	r1, r3
   16c80:	200e      	movs	r0, #14
   16c82:	183b      	adds	r3, r7, r0
   16c84:	2232      	movs	r2, #50	; 0x32
   16c86:	434a      	muls	r2, r1
   16c88:	801a      	strh	r2, [r3, #0]
        GUI_UPDATE_VOLTAGE_MAX(_voltage, _max_voltage);
   16c8a:	183a      	adds	r2, r7, r0
   16c8c:	2318      	movs	r3, #24
   16c8e:	18fb      	adds	r3, r7, r3
   16c90:	8812      	ldrh	r2, [r2, #0]
   16c92:	881b      	ldrh	r3, [r3, #0]
   16c94:	429a      	cmp	r2, r3
   16c96:	d905      	bls.n	16ca4 <UpdateSNKPowerPort0+0x144>
   16c98:	2318      	movs	r3, #24
   16c9a:	18fb      	adds	r3, r7, r3
   16c9c:	220e      	movs	r2, #14
   16c9e:	18ba      	adds	r2, r7, r2
   16ca0:	8812      	ldrh	r2, [r2, #0]
   16ca2:	801a      	strh	r2, [r3, #0]
        _power = GUI_DECODE_MW(pdo.SNKBatteryPDO.OperationalPowerIn250mWunits);
   16ca4:	1d3b      	adds	r3, r7, #4
   16ca6:	881b      	ldrh	r3, [r3, #0]
   16ca8:	059b      	lsls	r3, r3, #22
   16caa:	0d9b      	lsrs	r3, r3, #22
   16cac:	b29b      	uxth	r3, r3
   16cae:	0019      	movs	r1, r3
   16cb0:	200a      	movs	r0, #10
   16cb2:	183b      	adds	r3, r7, r0
   16cb4:	22fa      	movs	r2, #250	; 0xfa
   16cb6:	434a      	muls	r2, r1
   16cb8:	801a      	strh	r2, [r3, #0]
        GUI_UPDATE_POWER_MAX(_power, _max_power);
   16cba:	183b      	adds	r3, r7, r0
   16cbc:	881b      	ldrh	r3, [r3, #0]
   16cbe:	69fa      	ldr	r2, [r7, #28]
   16cc0:	429a      	cmp	r2, r3
   16cc2:	d24f      	bcs.n	16d64 <UpdateSNKPowerPort0+0x204>
   16cc4:	230a      	movs	r3, #10
   16cc6:	18fb      	adds	r3, r7, r3
   16cc8:	881b      	ldrh	r3, [r3, #0]
   16cca:	61fb      	str	r3, [r7, #28]
        break;
   16ccc:	e04a      	b.n	16d64 <UpdateSNKPowerPort0+0x204>
        _voltage = GUI_DECODE_50MV(pdo.SNKVariablePDO.MinVoltageIn50mVunits);
   16cce:	687b      	ldr	r3, [r7, #4]
   16cd0:	031b      	lsls	r3, r3, #12
   16cd2:	0d9b      	lsrs	r3, r3, #22
   16cd4:	b29b      	uxth	r3, r3
   16cd6:	0019      	movs	r1, r3
   16cd8:	200e      	movs	r0, #14
   16cda:	183b      	adds	r3, r7, r0
   16cdc:	2232      	movs	r2, #50	; 0x32
   16cde:	434a      	muls	r2, r1
   16ce0:	801a      	strh	r2, [r3, #0]
        GUI_UPDATE_VOLTAGE_MIN(_voltage, _min_voltage);
   16ce2:	183a      	adds	r2, r7, r0
   16ce4:	231a      	movs	r3, #26
   16ce6:	18fb      	adds	r3, r7, r3
   16ce8:	8812      	ldrh	r2, [r2, #0]
   16cea:	881b      	ldrh	r3, [r3, #0]
   16cec:	429a      	cmp	r2, r3
   16cee:	d205      	bcs.n	16cfc <UpdateSNKPowerPort0+0x19c>
   16cf0:	231a      	movs	r3, #26
   16cf2:	18fb      	adds	r3, r7, r3
   16cf4:	220e      	movs	r2, #14
   16cf6:	18ba      	adds	r2, r7, r2
   16cf8:	8812      	ldrh	r2, [r2, #0]
   16cfa:	801a      	strh	r2, [r3, #0]
        _voltage = GUI_DECODE_50MV(pdo.SNKVariablePDO.MaxVoltageIn50mVunits);
   16cfc:	1dbb      	adds	r3, r7, #6
   16cfe:	881b      	ldrh	r3, [r3, #0]
   16d00:	049b      	lsls	r3, r3, #18
   16d02:	0d9b      	lsrs	r3, r3, #22
   16d04:	b29b      	uxth	r3, r3
   16d06:	0019      	movs	r1, r3
   16d08:	200e      	movs	r0, #14
   16d0a:	183b      	adds	r3, r7, r0
   16d0c:	2232      	movs	r2, #50	; 0x32
   16d0e:	434a      	muls	r2, r1
   16d10:	801a      	strh	r2, [r3, #0]
        GUI_UPDATE_VOLTAGE_MAX(_voltage, _max_voltage);
   16d12:	183a      	adds	r2, r7, r0
   16d14:	2318      	movs	r3, #24
   16d16:	18fb      	adds	r3, r7, r3
   16d18:	8812      	ldrh	r2, [r2, #0]
   16d1a:	881b      	ldrh	r3, [r3, #0]
   16d1c:	429a      	cmp	r2, r3
   16d1e:	d905      	bls.n	16d2c <UpdateSNKPowerPort0+0x1cc>
   16d20:	2318      	movs	r3, #24
   16d22:	18fb      	adds	r3, r7, r3
   16d24:	220e      	movs	r2, #14
   16d26:	18ba      	adds	r2, r7, r2
   16d28:	8812      	ldrh	r2, [r2, #0]
   16d2a:	801a      	strh	r2, [r3, #0]
        _current = GUI_DECODE_10MA(pdo.SNKVariablePDO.OperationalCurrentIn10mAunits);
   16d2c:	1d3b      	adds	r3, r7, #4
   16d2e:	881b      	ldrh	r3, [r3, #0]
   16d30:	059b      	lsls	r3, r3, #22
   16d32:	0d9b      	lsrs	r3, r3, #22
   16d34:	b29b      	uxth	r3, r3
   16d36:	200c      	movs	r0, #12
   16d38:	183a      	adds	r2, r7, r0
   16d3a:	1c19      	adds	r1, r3, #0
   16d3c:	0089      	lsls	r1, r1, #2
   16d3e:	18cb      	adds	r3, r1, r3
   16d40:	18db      	adds	r3, r3, r3
   16d42:	8013      	strh	r3, [r2, #0]
        GUI_UPDATE_CURRENT_MAX(_current, _max_current);
   16d44:	183a      	adds	r2, r7, r0
   16d46:	2316      	movs	r3, #22
   16d48:	18fb      	adds	r3, r7, r3
   16d4a:	8812      	ldrh	r2, [r2, #0]
   16d4c:	881b      	ldrh	r3, [r3, #0]
   16d4e:	429a      	cmp	r2, r3
   16d50:	d90a      	bls.n	16d68 <UpdateSNKPowerPort0+0x208>
   16d52:	2316      	movs	r3, #22
   16d54:	18fb      	adds	r3, r7, r3
   16d56:	220c      	movs	r2, #12
   16d58:	18ba      	adds	r2, r7, r2
   16d5a:	8812      	ldrh	r2, [r2, #0]
   16d5c:	801a      	strh	r2, [r3, #0]
        break;
   16d5e:	e003      	b.n	16d68 <UpdateSNKPowerPort0+0x208>
        break;
   16d60:	46c0      	nop			; (mov r8, r8)
   16d62:	e002      	b.n	16d6a <UpdateSNKPowerPort0+0x20a>
        break;
   16d64:	46c0      	nop			; (mov r8, r8)
   16d66:	e000      	b.n	16d6a <UpdateSNKPowerPort0+0x20a>
        break;
   16d68:	46c0      	nop			; (mov r8, r8)
  for (uint32_t _index = 0; _index < USBPD_NbPDO[0]; _index++)
   16d6a:	693b      	ldr	r3, [r7, #16]
   16d6c:	3301      	adds	r3, #1
   16d6e:	613b      	str	r3, [r7, #16]
   16d70:	4b15      	ldr	r3, [pc, #84]	; (16dc8 <UpdateSNKPowerPort0+0x268>)
   16d72:	781b      	ldrb	r3, [r3, #0]
   16d74:	001a      	movs	r2, r3
   16d76:	693b      	ldr	r3, [r7, #16]
   16d78:	4293      	cmp	r3, r2
   16d7a:	d200      	bcs.n	16d7e <UpdateSNKPowerPort0+0x21e>
   16d7c:	e711      	b.n	16ba2 <UpdateSNKPowerPort0+0x42>
    }
  }

  GUI_CHECK_VOLTAGE_MIN(_min_voltage, DPM_USER_Settings[USBPD_PORT_0].DPM_SNKRequestedPower.MinOperatingVoltageInmVunits);
   16d7e:	231a      	movs	r3, #26
   16d80:	18fb      	adds	r3, r7, r3
   16d82:	881a      	ldrh	r2, [r3, #0]
   16d84:	4b11      	ldr	r3, [pc, #68]	; (16dcc <UpdateSNKPowerPort0+0x26c>)
   16d86:	611a      	str	r2, [r3, #16]
  GUI_CHECK_VOLTAGE_MAX(_max_voltage, DPM_USER_Settings[USBPD_PORT_0].DPM_SNKRequestedPower.MaxOperatingVoltageInmVunits);
   16d88:	2118      	movs	r1, #24
   16d8a:	187b      	adds	r3, r7, r1
   16d8c:	881a      	ldrh	r2, [r3, #0]
   16d8e:	4b0f      	ldr	r3, [pc, #60]	; (16dcc <UpdateSNKPowerPort0+0x26c>)
   16d90:	60da      	str	r2, [r3, #12]
  GUI_CHECK_CURRENT_MAX(_max_current, DPM_USER_Settings[USBPD_PORT_0].DPM_SNKRequestedPower.MaxOperatingCurrentInmAunits);
   16d92:	2016      	movs	r0, #22
   16d94:	183b      	adds	r3, r7, r0
   16d96:	881a      	ldrh	r2, [r3, #0]
   16d98:	4b0c      	ldr	r3, [pc, #48]	; (16dcc <UpdateSNKPowerPort0+0x26c>)
   16d9a:	605a      	str	r2, [r3, #4]
  _max_power = (_max_voltage * _max_current) / 1000;
   16d9c:	187b      	adds	r3, r7, r1
   16d9e:	881b      	ldrh	r3, [r3, #0]
   16da0:	183a      	adds	r2, r7, r0
   16da2:	8812      	ldrh	r2, [r2, #0]
   16da4:	435a      	muls	r2, r3
   16da6:	23fa      	movs	r3, #250	; 0xfa
   16da8:	0099      	lsls	r1, r3, #2
   16daa:	0010      	movs	r0, r2
   16dac:	f008 f914 	bl	1efd8 <__divsi3>
   16db0:	0003      	movs	r3, r0
   16db2:	61fb      	str	r3, [r7, #28]
  GUI_CHECK_POWER_MAX(_max_power, DPM_USER_Settings[USBPD_PORT_0].DPM_SNKRequestedPower.MaxOperatingPowerInmWunits);
   16db4:	4b05      	ldr	r3, [pc, #20]	; (16dcc <UpdateSNKPowerPort0+0x26c>)
   16db6:	69fa      	ldr	r2, [r7, #28]
   16db8:	619a      	str	r2, [r3, #24]
}
   16dba:	46c0      	nop			; (mov r8, r8)
   16dbc:	46bd      	mov	sp, r7
   16dbe:	b008      	add	sp, #32
   16dc0:	bd80      	pop	{r7, pc}
   16dc2:	46c0      	nop			; (mov r8, r8)
   16dc4:	0002fe40 	.word	0x0002fe40
   16dc8:	0002fe20 	.word	0x0002fe20
   16dcc:	0002fedc 	.word	0x0002fedc

00016dd0 <TRACER_EMB_Init>:

/** @addtogroup USBPD_CORE_TRACER_EMB_Exported_Functions
  * @{
  */
void TRACER_EMB_Init(void)
{
   16dd0:	b580      	push	{r7, lr}
   16dd2:	af00      	add	r7, sp, #0
  /* initialize the Ptr for Read/Write */
  PtrTx_Read = 0u;
   16dd4:	4b06      	ldr	r3, [pc, #24]	; (16df0 <TRACER_EMB_Init+0x20>)
   16dd6:	2200      	movs	r2, #0
   16dd8:	601a      	str	r2, [r3, #0]
  PtrTx_Write = 0u;
   16dda:	4b06      	ldr	r3, [pc, #24]	; (16df4 <TRACER_EMB_Init+0x24>)
   16ddc:	2200      	movs	r2, #0
   16dde:	601a      	str	r2, [r3, #0]
  /* Initialize trace BUS */
  HW_TRACER_EMB_Init();
   16de0:	f000 fc04 	bl	175ec <HW_TRACER_EMB_Init>
  
  /* Initialize the lowpower aspect */
  TRACER_EMB_LowPowerInit();
   16de4:	f000 f952 	bl	1708c <TRACER_EMB_LowPowerInit>
}
   16de8:	46c0      	nop			; (mov r8, r8)
   16dea:	46bd      	mov	sp, r7
   16dec:	bd80      	pop	{r7, pc}
   16dee:	46c0      	nop			; (mov r8, r8)
   16df0:	000320d8 	.word	0x000320d8
   16df4:	000320dc 	.word	0x000320dc

00016df8 <TRACER_EMB_Add>:

void TRACER_EMB_Add(uint8_t *Ptr, uint32_t Size)
{
   16df8:	b580      	push	{r7, lr}
   16dfa:	b086      	sub	sp, #24
   16dfc:	af00      	add	r7, sp, #0
   16dfe:	6078      	str	r0, [r7, #4]
   16e00:	6039      	str	r1, [r7, #0]
  int32_t _writepos;
  uint8_t *data_to_write = Ptr;
   16e02:	687b      	ldr	r3, [r7, #4]
   16e04:	60fb      	str	r3, [r7, #12]
  uint32_t index;

  TRACER_EMB_Lock();
   16e06:	f000 f88f 	bl	16f28 <TRACER_EMB_Lock>

  _writepos = TRACER_EMB_AllocateBufer(Size);
   16e0a:	683b      	ldr	r3, [r7, #0]
   16e0c:	0018      	movs	r0, r3
   16e0e:	f000 f8f1 	bl	16ff4 <TRACER_EMB_AllocateBufer>
   16e12:	0003      	movs	r3, r0
   16e14:	617b      	str	r3, [r7, #20]

  /* if allocation is ok, write data into the bufffer */
  if (_writepos  != -1)
   16e16:	697b      	ldr	r3, [r7, #20]
   16e18:	3301      	adds	r3, #1
   16e1a:	d018      	beq.n	16e4e <TRACER_EMB_Add+0x56>
  {
    /* initialize the Ptr for Read/Write */
    for (index = 0u; index < Size; index++)
   16e1c:	2300      	movs	r3, #0
   16e1e:	613b      	str	r3, [r7, #16]
   16e20:	e010      	b.n	16e44 <TRACER_EMB_Add+0x4c>
    {
      TRACER_WRITE_DATA(_writepos, data_to_write[index]);
   16e22:	68fa      	ldr	r2, [r7, #12]
   16e24:	693b      	ldr	r3, [r7, #16]
   16e26:	18d2      	adds	r2, r2, r3
   16e28:	697b      	ldr	r3, [r7, #20]
   16e2a:	059b      	lsls	r3, r3, #22
   16e2c:	0d9b      	lsrs	r3, r3, #22
   16e2e:	7811      	ldrb	r1, [r2, #0]
   16e30:	4a0b      	ldr	r2, [pc, #44]	; (16e60 <TRACER_EMB_Add+0x68>)
   16e32:	54d1      	strb	r1, [r2, r3]
   16e34:	697b      	ldr	r3, [r7, #20]
   16e36:	3301      	adds	r3, #1
   16e38:	059b      	lsls	r3, r3, #22
   16e3a:	0d9b      	lsrs	r3, r3, #22
   16e3c:	617b      	str	r3, [r7, #20]
    for (index = 0u; index < Size; index++)
   16e3e:	693b      	ldr	r3, [r7, #16]
   16e40:	3301      	adds	r3, #1
   16e42:	613b      	str	r3, [r7, #16]
   16e44:	693a      	ldr	r2, [r7, #16]
   16e46:	683b      	ldr	r3, [r7, #0]
   16e48:	429a      	cmp	r2, r3
   16e4a:	d3ea      	bcc.n	16e22 <TRACER_EMB_Add+0x2a>
   16e4c:	e000      	b.n	16e50 <TRACER_EMB_Add+0x58>
    }
  }
  else
    __NOP();
   16e4e:	46c0      	nop			; (mov r8, r8)
  TRACER_EMB_UnLock();
   16e50:	f000 f884 	bl	16f5c <TRACER_EMB_UnLock>

  /* Wakeup the trace system */
  TRACER_EMB_WakeUpProcess();
   16e54:	f7ff fe7d 	bl	16b52 <TRACER_EMB_WakeUpProcess>
}
   16e58:	46c0      	nop			; (mov r8, r8)
   16e5a:	46bd      	mov	sp, r7
   16e5c:	b006      	add	sp, #24
   16e5e:	bd80      	pop	{r7, pc}
   16e60:	00031cd8 	.word	0x00031cd8

00016e64 <TRACER_EMB_TX_Process>:
{
  HW_TRACER_EMB_IRQHandlerUSART();
}

uint32_t TRACER_EMB_TX_Process(void)
{
   16e64:	b580      	push	{r7, lr}
   16e66:	b084      	sub	sp, #16
   16e68:	af00      	add	r7, sp, #0
  uint32_t _timing = 2u;
   16e6a:	2302      	movs	r3, #2
   16e6c:	60fb      	str	r3, [r7, #12]
  uint32_t _begin, _end;

  if (TRACER_OK == TRACER_CheckLook(&_begin, &_end))
   16e6e:	1d3a      	adds	r2, r7, #4
   16e70:	2308      	movs	r3, #8
   16e72:	18fb      	adds	r3, r7, r3
   16e74:	0011      	movs	r1, r2
   16e76:	0018      	movs	r0, r3
   16e78:	f000 f88a 	bl	16f90 <TRACER_CheckLook>
   16e7c:	1e03      	subs	r3, r0, #0
   16e7e:	d124      	bne.n	16eca <TRACER_EMB_TX_Process+0x66>
  {
    if (_begin == _end)
   16e80:	68ba      	ldr	r2, [r7, #8]
   16e82:	687b      	ldr	r3, [r7, #4]
   16e84:	429a      	cmp	r2, r3
   16e86:	d103      	bne.n	16e90 <TRACER_EMB_TX_Process+0x2c>
    {
      /* nothing to do */
      _timing = 0xFFFFFFFFu;
   16e88:	2301      	movs	r3, #1
   16e8a:	425b      	negs	r3, r3
   16e8c:	60fb      	str	r3, [r7, #12]
   16e8e:	e01c      	b.n	16eca <TRACER_EMB_TX_Process+0x66>
    }
    else
    {
      TRACER_EMB_Lock();
   16e90:	f000 f84a 	bl	16f28 <TRACER_EMB_Lock>
      /*  */
      if (_end > _begin)
   16e94:	687a      	ldr	r2, [r7, #4]
   16e96:	68bb      	ldr	r3, [r7, #8]
   16e98:	429a      	cmp	r2, r3
   16e9a:	d905      	bls.n	16ea8 <TRACER_EMB_TX_Process+0x44>
      {
        SizeSent = _end - _begin;
   16e9c:	687a      	ldr	r2, [r7, #4]
   16e9e:	68bb      	ldr	r3, [r7, #8]
   16ea0:	1ad2      	subs	r2, r2, r3
   16ea2:	4b0c      	ldr	r3, [pc, #48]	; (16ed4 <TRACER_EMB_TX_Process+0x70>)
   16ea4:	601a      	str	r2, [r3, #0]
   16ea6:	e005      	b.n	16eb4 <TRACER_EMB_TX_Process+0x50>
      }
      else  /* _begin > _end */
      {
        SizeSent = TRACER_EMB_BUFFER_SIZE - _begin;
   16ea8:	68bb      	ldr	r3, [r7, #8]
   16eaa:	2280      	movs	r2, #128	; 0x80
   16eac:	00d2      	lsls	r2, r2, #3
   16eae:	1ad2      	subs	r2, r2, r3
   16eb0:	4b08      	ldr	r3, [pc, #32]	; (16ed4 <TRACER_EMB_TX_Process+0x70>)
   16eb2:	601a      	str	r2, [r3, #0]
      }
      TRACER_EMB_LowPowerSendData();
   16eb4:	f000 f8ef 	bl	17096 <TRACER_EMB_LowPowerSendData>
      HW_TRACER_EMB_SendData(&PtrDataTx[_begin], SizeSent);
   16eb8:	68ba      	ldr	r2, [r7, #8]
   16eba:	4b07      	ldr	r3, [pc, #28]	; (16ed8 <TRACER_EMB_TX_Process+0x74>)
   16ebc:	18d2      	adds	r2, r2, r3
   16ebe:	4b05      	ldr	r3, [pc, #20]	; (16ed4 <TRACER_EMB_TX_Process+0x70>)
   16ec0:	681b      	ldr	r3, [r3, #0]
   16ec2:	0019      	movs	r1, r3
   16ec4:	0010      	movs	r0, r2
   16ec6:	f000 fc7b 	bl	177c0 <HW_TRACER_EMB_SendData>
    }
  }
  return _timing;
   16eca:	68fb      	ldr	r3, [r7, #12]
}
   16ecc:	0018      	movs	r0, r3
   16ece:	46bd      	mov	sp, r7
   16ed0:	b004      	add	sp, #16
   16ed2:	bd80      	pop	{r7, pc}
   16ed4:	000320e4 	.word	0x000320e4
   16ed8:	00031cd8 	.word	0x00031cd8

00016edc <TRACER_EMB_WriteData>:

void TRACER_EMB_WriteData(uint16_t pos, uint8_t data)
{
   16edc:	b580      	push	{r7, lr}
   16ede:	b082      	sub	sp, #8
   16ee0:	af00      	add	r7, sp, #0
   16ee2:	0002      	movs	r2, r0
   16ee4:	1dbb      	adds	r3, r7, #6
   16ee6:	801a      	strh	r2, [r3, #0]
   16ee8:	1d7b      	adds	r3, r7, #5
   16eea:	1c0a      	adds	r2, r1, #0
   16eec:	701a      	strb	r2, [r3, #0]
  PtrDataTx[pos % TRACER_EMB_BUFFER_SIZE] = data;
   16eee:	1dbb      	adds	r3, r7, #6
   16ef0:	881b      	ldrh	r3, [r3, #0]
   16ef2:	059b      	lsls	r3, r3, #22
   16ef4:	0d9b      	lsrs	r3, r3, #22
   16ef6:	4a04      	ldr	r2, [pc, #16]	; (16f08 <TRACER_EMB_WriteData+0x2c>)
   16ef8:	1d79      	adds	r1, r7, #5
   16efa:	7809      	ldrb	r1, [r1, #0]
   16efc:	54d1      	strb	r1, [r2, r3]
}
   16efe:	46c0      	nop			; (mov r8, r8)
   16f00:	46bd      	mov	sp, r7
   16f02:	b002      	add	sp, #8
   16f04:	bd80      	pop	{r7, pc}
   16f06:	46c0      	nop			; (mov r8, r8)
   16f08:	00031cd8 	.word	0x00031cd8

00016f0c <TRACER_EMB_StartRX>:

void TRACER_EMB_StartRX(void (*callbackRX)(uint8_t, uint8_t))
{
   16f0c:	b580      	push	{r7, lr}
   16f0e:	b082      	sub	sp, #8
   16f10:	af00      	add	r7, sp, #0
   16f12:	6078      	str	r0, [r7, #4]
  HW_TRACER_EMB_RegisterRxCallback(callbackRX);
   16f14:	687b      	ldr	r3, [r7, #4]
   16f16:	0018      	movs	r0, r3
   16f18:	f000 fc26 	bl	17768 <HW_TRACER_EMB_RegisterRxCallback>
  HW_TRACER_EMB_StartRX();
   16f1c:	f000 fc36 	bl	1778c <HW_TRACER_EMB_StartRX>
}
   16f20:	46c0      	nop			; (mov r8, r8)
   16f22:	46bd      	mov	sp, r7
   16f24:	b002      	add	sp, #8
   16f26:	bd80      	pop	{r7, pc}

00016f28 <TRACER_EMB_Lock>:
  * @brief  Lock the trace buffer.
  * @param  None.
  * @retval None.
  */
void TRACER_EMB_Lock(void)
{
   16f28:	b580      	push	{r7, lr}
   16f2a:	b084      	sub	sp, #16
   16f2c:	af00      	add	r7, sp, #0
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
   16f2e:	f3ef 8310 	mrs	r3, PRIMASK
   16f32:	607b      	str	r3, [r7, #4]
  return(result);
   16f34:	687b      	ldr	r3, [r7, #4]
  TRACER_ENTER_CRITICAL_SECTION();
   16f36:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("cpsid i" : : : "memory");
   16f38:	b672      	cpsid	i
  Counter++;
   16f3a:	4b07      	ldr	r3, [pc, #28]	; (16f58 <TRACER_EMB_Lock+0x30>)
   16f3c:	681b      	ldr	r3, [r3, #0]
   16f3e:	1c5a      	adds	r2, r3, #1
   16f40:	4b05      	ldr	r3, [pc, #20]	; (16f58 <TRACER_EMB_Lock+0x30>)
   16f42:	601a      	str	r2, [r3, #0]
   16f44:	68fb      	ldr	r3, [r7, #12]
   16f46:	60bb      	str	r3, [r7, #8]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
   16f48:	68bb      	ldr	r3, [r7, #8]
   16f4a:	f383 8810 	msr	PRIMASK, r3
  TRACER_LEAVE_CRITICAL_SECTION();
}
   16f4e:	46c0      	nop			; (mov r8, r8)
   16f50:	46bd      	mov	sp, r7
   16f52:	b004      	add	sp, #16
   16f54:	bd80      	pop	{r7, pc}
   16f56:	46c0      	nop			; (mov r8, r8)
   16f58:	000320e0 	.word	0x000320e0

00016f5c <TRACER_EMB_UnLock>:
  * @brief  UnLock the trace buffer.
  * @param  None.
  * @retval None.
  */
void TRACER_EMB_UnLock(void)
{
   16f5c:	b580      	push	{r7, lr}
   16f5e:	b084      	sub	sp, #16
   16f60:	af00      	add	r7, sp, #0
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
   16f62:	f3ef 8310 	mrs	r3, PRIMASK
   16f66:	607b      	str	r3, [r7, #4]
  return(result);
   16f68:	687b      	ldr	r3, [r7, #4]
  TRACER_ENTER_CRITICAL_SECTION();
   16f6a:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("cpsid i" : : : "memory");
   16f6c:	b672      	cpsid	i
  Counter--;
   16f6e:	4b07      	ldr	r3, [pc, #28]	; (16f8c <TRACER_EMB_UnLock+0x30>)
   16f70:	681b      	ldr	r3, [r3, #0]
   16f72:	1e5a      	subs	r2, r3, #1
   16f74:	4b05      	ldr	r3, [pc, #20]	; (16f8c <TRACER_EMB_UnLock+0x30>)
   16f76:	601a      	str	r2, [r3, #0]
   16f78:	68fb      	ldr	r3, [r7, #12]
   16f7a:	60bb      	str	r3, [r7, #8]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
   16f7c:	68bb      	ldr	r3, [r7, #8]
   16f7e:	f383 8810 	msr	PRIMASK, r3
  TRACER_LEAVE_CRITICAL_SECTION();
}
   16f82:	46c0      	nop			; (mov r8, r8)
   16f84:	46bd      	mov	sp, r7
   16f86:	b004      	add	sp, #16
   16f88:	bd80      	pop	{r7, pc}
   16f8a:	46c0      	nop			; (mov r8, r8)
   16f8c:	000320e0 	.word	0x000320e0

00016f90 <TRACER_CheckLook>:
  * @param  address begin of the data
  * @param  address end of the data
  * @retval USBPD_TRUE if a transfer can be execute else USBPD_FALSE.
  */
static TRACER_StatusTypedef TRACER_CheckLook(uint32_t *Begin, uint32_t *End)
{
   16f90:	b580      	push	{r7, lr}
   16f92:	b086      	sub	sp, #24
   16f94:	af00      	add	r7, sp, #0
   16f96:	6078      	str	r0, [r7, #4]
   16f98:	6039      	str	r1, [r7, #0]
  TRACER_StatusTypedef _status = TRACER_KO;
   16f9a:	2317      	movs	r3, #23
   16f9c:	18fb      	adds	r3, r7, r3
   16f9e:	2201      	movs	r2, #1
   16fa0:	701a      	strb	r2, [r3, #0]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
   16fa2:	f3ef 8310 	mrs	r3, PRIMASK
   16fa6:	60fb      	str	r3, [r7, #12]
  return(result);
   16fa8:	68fb      	ldr	r3, [r7, #12]
  TRACER_ENTER_CRITICAL_SECTION();
   16faa:	613b      	str	r3, [r7, #16]
  __ASM volatile ("cpsid i" : : : "memory");
   16fac:	b672      	cpsid	i

  if (0u == Counter)
   16fae:	4b0e      	ldr	r3, [pc, #56]	; (16fe8 <TRACER_CheckLook+0x58>)
   16fb0:	681b      	ldr	r3, [r3, #0]
   16fb2:	2b00      	cmp	r3, #0
   16fb4:	d10b      	bne.n	16fce <TRACER_CheckLook+0x3e>
  {
    *Begin = PtrTx_Read;
   16fb6:	4b0d      	ldr	r3, [pc, #52]	; (16fec <TRACER_CheckLook+0x5c>)
   16fb8:	681a      	ldr	r2, [r3, #0]
   16fba:	687b      	ldr	r3, [r7, #4]
   16fbc:	601a      	str	r2, [r3, #0]
    *End = PtrTx_Write;
   16fbe:	4b0c      	ldr	r3, [pc, #48]	; (16ff0 <TRACER_CheckLook+0x60>)
   16fc0:	681a      	ldr	r2, [r3, #0]
   16fc2:	683b      	ldr	r3, [r7, #0]
   16fc4:	601a      	str	r2, [r3, #0]
    _status = TRACER_OK;
   16fc6:	2317      	movs	r3, #23
   16fc8:	18fb      	adds	r3, r7, r3
   16fca:	2200      	movs	r2, #0
   16fcc:	701a      	strb	r2, [r3, #0]
   16fce:	693b      	ldr	r3, [r7, #16]
   16fd0:	60bb      	str	r3, [r7, #8]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
   16fd2:	68bb      	ldr	r3, [r7, #8]
   16fd4:	f383 8810 	msr	PRIMASK, r3
  }

  TRACER_LEAVE_CRITICAL_SECTION();
  return _status;
   16fd8:	2317      	movs	r3, #23
   16fda:	18fb      	adds	r3, r7, r3
   16fdc:	781b      	ldrb	r3, [r3, #0]
}
   16fde:	0018      	movs	r0, r3
   16fe0:	46bd      	mov	sp, r7
   16fe2:	b006      	add	sp, #24
   16fe4:	bd80      	pop	{r7, pc}
   16fe6:	46c0      	nop			; (mov r8, r8)
   16fe8:	000320e0 	.word	0x000320e0
   16fec:	000320d8 	.word	0x000320d8
   16ff0:	000320dc 	.word	0x000320dc

00016ff4 <TRACER_EMB_AllocateBufer>:
  * @brief  allocate space inside the buffer to push data
  * @param  data size
  * @retval write position inside the buffer is -1 no space available.
  */
int32_t TRACER_EMB_AllocateBufer(uint32_t Size)
{
   16ff4:	b580      	push	{r7, lr}
   16ff6:	b088      	sub	sp, #32
   16ff8:	af00      	add	r7, sp, #0
   16ffa:	6078      	str	r0, [r7, #4]
  uint32_t _freesize;
  int32_t _pos = -1;
   16ffc:	2301      	movs	r3, #1
   16ffe:	425b      	negs	r3, r3
   17000:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
   17002:	f3ef 8310 	mrs	r3, PRIMASK
   17006:	613b      	str	r3, [r7, #16]
  return(result);
   17008:	693b      	ldr	r3, [r7, #16]

  TRACER_ENTER_CRITICAL_SECTION();
   1700a:	617b      	str	r3, [r7, #20]
  __ASM volatile ("cpsid i" : : : "memory");
   1700c:	b672      	cpsid	i

  if (PtrTx_Write == PtrTx_Read)
   1700e:	4b1d      	ldr	r3, [pc, #116]	; (17084 <TRACER_EMB_AllocateBufer+0x90>)
   17010:	681a      	ldr	r2, [r3, #0]
   17012:	4b1d      	ldr	r3, [pc, #116]	; (17088 <TRACER_EMB_AllocateBufer+0x94>)
   17014:	681b      	ldr	r3, [r3, #0]
   17016:	429a      	cmp	r2, r3
   17018:	d103      	bne.n	17022 <TRACER_EMB_AllocateBufer+0x2e>
  {
    // need to add buffer full managment
    _freesize = TRACER_EMB_BUFFER_SIZE;
   1701a:	2380      	movs	r3, #128	; 0x80
   1701c:	00db      	lsls	r3, r3, #3
   1701e:	61fb      	str	r3, [r7, #28]
   17020:	e016      	b.n	17050 <TRACER_EMB_AllocateBufer+0x5c>
  }
  else
  {
    if (PtrTx_Write > PtrTx_Read)
   17022:	4b18      	ldr	r3, [pc, #96]	; (17084 <TRACER_EMB_AllocateBufer+0x90>)
   17024:	681a      	ldr	r2, [r3, #0]
   17026:	4b18      	ldr	r3, [pc, #96]	; (17088 <TRACER_EMB_AllocateBufer+0x94>)
   17028:	681b      	ldr	r3, [r3, #0]
   1702a:	429a      	cmp	r2, r3
   1702c:	d90a      	bls.n	17044 <TRACER_EMB_AllocateBufer+0x50>
    {
      _freesize = TRACER_EMB_BUFFER_SIZE - PtrTx_Write + PtrTx_Read;
   1702e:	4b16      	ldr	r3, [pc, #88]	; (17088 <TRACER_EMB_AllocateBufer+0x94>)
   17030:	681a      	ldr	r2, [r3, #0]
   17032:	4b14      	ldr	r3, [pc, #80]	; (17084 <TRACER_EMB_AllocateBufer+0x90>)
   17034:	681b      	ldr	r3, [r3, #0]
   17036:	1ad3      	subs	r3, r2, r3
   17038:	2280      	movs	r2, #128	; 0x80
   1703a:	00d2      	lsls	r2, r2, #3
   1703c:	4694      	mov	ip, r2
   1703e:	4463      	add	r3, ip
   17040:	61fb      	str	r3, [r7, #28]
   17042:	e005      	b.n	17050 <TRACER_EMB_AllocateBufer+0x5c>
    }
    else
    {
      _freesize = PtrTx_Read - PtrTx_Write;
   17044:	4b10      	ldr	r3, [pc, #64]	; (17088 <TRACER_EMB_AllocateBufer+0x94>)
   17046:	681a      	ldr	r2, [r3, #0]
   17048:	4b0e      	ldr	r3, [pc, #56]	; (17084 <TRACER_EMB_AllocateBufer+0x90>)
   1704a:	681b      	ldr	r3, [r3, #0]
   1704c:	1ad3      	subs	r3, r2, r3
   1704e:	61fb      	str	r3, [r7, #28]
    }
  }

  if (_freesize > Size)
   17050:	69fa      	ldr	r2, [r7, #28]
   17052:	687b      	ldr	r3, [r7, #4]
   17054:	429a      	cmp	r2, r3
   17056:	d90a      	bls.n	1706e <TRACER_EMB_AllocateBufer+0x7a>
  {
    _pos = (int32_t)PtrTx_Write;
   17058:	4b0a      	ldr	r3, [pc, #40]	; (17084 <TRACER_EMB_AllocateBufer+0x90>)
   1705a:	681b      	ldr	r3, [r3, #0]
   1705c:	61bb      	str	r3, [r7, #24]
    PtrTx_Write = (PtrTx_Write + Size) % TRACER_EMB_BUFFER_SIZE;
   1705e:	4b09      	ldr	r3, [pc, #36]	; (17084 <TRACER_EMB_AllocateBufer+0x90>)
   17060:	681a      	ldr	r2, [r3, #0]
   17062:	687b      	ldr	r3, [r7, #4]
   17064:	18d3      	adds	r3, r2, r3
   17066:	059b      	lsls	r3, r3, #22
   17068:	0d9a      	lsrs	r2, r3, #22
   1706a:	4b06      	ldr	r3, [pc, #24]	; (17084 <TRACER_EMB_AllocateBufer+0x90>)
   1706c:	601a      	str	r2, [r3, #0]
   1706e:	697b      	ldr	r3, [r7, #20]
   17070:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
   17072:	68fb      	ldr	r3, [r7, #12]
   17074:	f383 8810 	msr	PRIMASK, r3
  }

  TRACER_LEAVE_CRITICAL_SECTION();
  return _pos;
   17078:	69bb      	ldr	r3, [r7, #24]
}
   1707a:	0018      	movs	r0, r3
   1707c:	46bd      	mov	sp, r7
   1707e:	b008      	add	sp, #32
   17080:	bd80      	pop	{r7, pc}
   17082:	46c0      	nop			; (mov r8, r8)
   17084:	000320dc 	.word	0x000320dc
   17088:	000320d8 	.word	0x000320d8

0001708c <TRACER_EMB_LowPowerInit>:

__weak void TRACER_EMB_LowPowerInit(void)
{
   1708c:	b580      	push	{r7, lr}
   1708e:	af00      	add	r7, sp, #0
}
   17090:	46c0      	nop			; (mov r8, r8)
   17092:	46bd      	mov	sp, r7
   17094:	bd80      	pop	{r7, pc}

00017096 <TRACER_EMB_LowPowerSendData>:

__weak void TRACER_EMB_LowPowerSendData(void)
{
   17096:	b580      	push	{r7, lr}
   17098:	af00      	add	r7, sp, #0
}
   1709a:	46c0      	nop			; (mov r8, r8)
   1709c:	46bd      	mov	sp, r7
   1709e:	bd80      	pop	{r7, pc}

000170a0 <__NVIC_EnableIRQ>:
{
   170a0:	b580      	push	{r7, lr}
   170a2:	b082      	sub	sp, #8
   170a4:	af00      	add	r7, sp, #0
   170a6:	0002      	movs	r2, r0
   170a8:	1dfb      	adds	r3, r7, #7
   170aa:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
   170ac:	1dfb      	adds	r3, r7, #7
   170ae:	781b      	ldrb	r3, [r3, #0]
   170b0:	2b7f      	cmp	r3, #127	; 0x7f
   170b2:	d809      	bhi.n	170c8 <__NVIC_EnableIRQ+0x28>
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   170b4:	1dfb      	adds	r3, r7, #7
   170b6:	781b      	ldrb	r3, [r3, #0]
   170b8:	001a      	movs	r2, r3
   170ba:	231f      	movs	r3, #31
   170bc:	401a      	ands	r2, r3
   170be:	4b04      	ldr	r3, [pc, #16]	; (170d0 <__NVIC_EnableIRQ+0x30>)
   170c0:	2101      	movs	r1, #1
   170c2:	4091      	lsls	r1, r2
   170c4:	000a      	movs	r2, r1
   170c6:	601a      	str	r2, [r3, #0]
}
   170c8:	46c0      	nop			; (mov r8, r8)
   170ca:	46bd      	mov	sp, r7
   170cc:	b002      	add	sp, #8
   170ce:	bd80      	pop	{r7, pc}
   170d0:	e000e100 	.word	0xe000e100

000170d4 <__NVIC_SetPriority>:
{
   170d4:	b590      	push	{r4, r7, lr}
   170d6:	b083      	sub	sp, #12
   170d8:	af00      	add	r7, sp, #0
   170da:	0002      	movs	r2, r0
   170dc:	6039      	str	r1, [r7, #0]
   170de:	1dfb      	adds	r3, r7, #7
   170e0:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
   170e2:	1dfb      	adds	r3, r7, #7
   170e4:	781b      	ldrb	r3, [r3, #0]
   170e6:	2b7f      	cmp	r3, #127	; 0x7f
   170e8:	d828      	bhi.n	1713c <__NVIC_SetPriority+0x68>
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
   170ea:	4a2f      	ldr	r2, [pc, #188]	; (171a8 <__NVIC_SetPriority+0xd4>)
   170ec:	1dfb      	adds	r3, r7, #7
   170ee:	781b      	ldrb	r3, [r3, #0]
   170f0:	b25b      	sxtb	r3, r3
   170f2:	089b      	lsrs	r3, r3, #2
   170f4:	33c0      	adds	r3, #192	; 0xc0
   170f6:	009b      	lsls	r3, r3, #2
   170f8:	589b      	ldr	r3, [r3, r2]
   170fa:	1dfa      	adds	r2, r7, #7
   170fc:	7812      	ldrb	r2, [r2, #0]
   170fe:	0011      	movs	r1, r2
   17100:	2203      	movs	r2, #3
   17102:	400a      	ands	r2, r1
   17104:	00d2      	lsls	r2, r2, #3
   17106:	21ff      	movs	r1, #255	; 0xff
   17108:	4091      	lsls	r1, r2
   1710a:	000a      	movs	r2, r1
   1710c:	43d2      	mvns	r2, r2
   1710e:	401a      	ands	r2, r3
   17110:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
   17112:	683b      	ldr	r3, [r7, #0]
   17114:	019b      	lsls	r3, r3, #6
   17116:	22ff      	movs	r2, #255	; 0xff
   17118:	401a      	ands	r2, r3
   1711a:	1dfb      	adds	r3, r7, #7
   1711c:	781b      	ldrb	r3, [r3, #0]
   1711e:	0018      	movs	r0, r3
   17120:	2303      	movs	r3, #3
   17122:	4003      	ands	r3, r0
   17124:	00db      	lsls	r3, r3, #3
   17126:	409a      	lsls	r2, r3
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
   17128:	481f      	ldr	r0, [pc, #124]	; (171a8 <__NVIC_SetPriority+0xd4>)
   1712a:	1dfb      	adds	r3, r7, #7
   1712c:	781b      	ldrb	r3, [r3, #0]
   1712e:	b25b      	sxtb	r3, r3
   17130:	089b      	lsrs	r3, r3, #2
   17132:	430a      	orrs	r2, r1
   17134:	33c0      	adds	r3, #192	; 0xc0
   17136:	009b      	lsls	r3, r3, #2
   17138:	501a      	str	r2, [r3, r0]
}
   1713a:	e031      	b.n	171a0 <__NVIC_SetPriority+0xcc>
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
   1713c:	4a1b      	ldr	r2, [pc, #108]	; (171ac <__NVIC_SetPriority+0xd8>)
   1713e:	1dfb      	adds	r3, r7, #7
   17140:	781b      	ldrb	r3, [r3, #0]
   17142:	0019      	movs	r1, r3
   17144:	230f      	movs	r3, #15
   17146:	400b      	ands	r3, r1
   17148:	3b08      	subs	r3, #8
   1714a:	089b      	lsrs	r3, r3, #2
   1714c:	3306      	adds	r3, #6
   1714e:	009b      	lsls	r3, r3, #2
   17150:	18d3      	adds	r3, r2, r3
   17152:	3304      	adds	r3, #4
   17154:	681b      	ldr	r3, [r3, #0]
   17156:	1dfa      	adds	r2, r7, #7
   17158:	7812      	ldrb	r2, [r2, #0]
   1715a:	0011      	movs	r1, r2
   1715c:	2203      	movs	r2, #3
   1715e:	400a      	ands	r2, r1
   17160:	00d2      	lsls	r2, r2, #3
   17162:	21ff      	movs	r1, #255	; 0xff
   17164:	4091      	lsls	r1, r2
   17166:	000a      	movs	r2, r1
   17168:	43d2      	mvns	r2, r2
   1716a:	401a      	ands	r2, r3
   1716c:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
   1716e:	683b      	ldr	r3, [r7, #0]
   17170:	019b      	lsls	r3, r3, #6
   17172:	22ff      	movs	r2, #255	; 0xff
   17174:	401a      	ands	r2, r3
   17176:	1dfb      	adds	r3, r7, #7
   17178:	781b      	ldrb	r3, [r3, #0]
   1717a:	0018      	movs	r0, r3
   1717c:	2303      	movs	r3, #3
   1717e:	4003      	ands	r3, r0
   17180:	00db      	lsls	r3, r3, #3
   17182:	409a      	lsls	r2, r3
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
   17184:	4809      	ldr	r0, [pc, #36]	; (171ac <__NVIC_SetPriority+0xd8>)
   17186:	1dfb      	adds	r3, r7, #7
   17188:	781b      	ldrb	r3, [r3, #0]
   1718a:	001c      	movs	r4, r3
   1718c:	230f      	movs	r3, #15
   1718e:	4023      	ands	r3, r4
   17190:	3b08      	subs	r3, #8
   17192:	089b      	lsrs	r3, r3, #2
   17194:	430a      	orrs	r2, r1
   17196:	3306      	adds	r3, #6
   17198:	009b      	lsls	r3, r3, #2
   1719a:	18c3      	adds	r3, r0, r3
   1719c:	3304      	adds	r3, #4
   1719e:	601a      	str	r2, [r3, #0]
}
   171a0:	46c0      	nop			; (mov r8, r8)
   171a2:	46bd      	mov	sp, r7
   171a4:	b003      	add	sp, #12
   171a6:	bd90      	pop	{r4, r7, pc}
   171a8:	e000e100 	.word	0xe000e100
   171ac:	e000ed00 	.word	0xe000ed00

000171b0 <LL_GPIO_SetPinMode>:
  *         @arg @ref LL_GPIO_MODE_ALTERNATE
  *         @arg @ref LL_GPIO_MODE_ANALOG
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetPinMode(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Mode)
{
   171b0:	b580      	push	{r7, lr}
   171b2:	b084      	sub	sp, #16
   171b4:	af00      	add	r7, sp, #0
   171b6:	60f8      	str	r0, [r7, #12]
   171b8:	60b9      	str	r1, [r7, #8]
   171ba:	607a      	str	r2, [r7, #4]
  MODIFY_REG(GPIOx->MODER, ((Pin * Pin) * GPIO_MODER_MODER0), ((Pin * Pin) * Mode));
   171bc:	68fb      	ldr	r3, [r7, #12]
   171be:	6819      	ldr	r1, [r3, #0]
   171c0:	68bb      	ldr	r3, [r7, #8]
   171c2:	68ba      	ldr	r2, [r7, #8]
   171c4:	435a      	muls	r2, r3
   171c6:	0013      	movs	r3, r2
   171c8:	005b      	lsls	r3, r3, #1
   171ca:	189b      	adds	r3, r3, r2
   171cc:	43db      	mvns	r3, r3
   171ce:	400b      	ands	r3, r1
   171d0:	001a      	movs	r2, r3
   171d2:	68bb      	ldr	r3, [r7, #8]
   171d4:	68b9      	ldr	r1, [r7, #8]
   171d6:	434b      	muls	r3, r1
   171d8:	6879      	ldr	r1, [r7, #4]
   171da:	434b      	muls	r3, r1
   171dc:	431a      	orrs	r2, r3
   171de:	68fb      	ldr	r3, [r7, #12]
   171e0:	601a      	str	r2, [r3, #0]
}
   171e2:	46c0      	nop			; (mov r8, r8)
   171e4:	46bd      	mov	sp, r7
   171e6:	b004      	add	sp, #16
   171e8:	bd80      	pop	{r7, pc}

000171ea <LL_GPIO_SetPinOutputType>:
  *         @arg @ref LL_GPIO_OUTPUT_PUSHPULL
  *         @arg @ref LL_GPIO_OUTPUT_OPENDRAIN
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetPinOutputType(GPIO_TypeDef *GPIOx, uint32_t PinMask, uint32_t OutputType)
{
   171ea:	b580      	push	{r7, lr}
   171ec:	b084      	sub	sp, #16
   171ee:	af00      	add	r7, sp, #0
   171f0:	60f8      	str	r0, [r7, #12]
   171f2:	60b9      	str	r1, [r7, #8]
   171f4:	607a      	str	r2, [r7, #4]
  MODIFY_REG(GPIOx->OTYPER, PinMask, (PinMask * OutputType));
   171f6:	68fb      	ldr	r3, [r7, #12]
   171f8:	685b      	ldr	r3, [r3, #4]
   171fa:	68ba      	ldr	r2, [r7, #8]
   171fc:	43d2      	mvns	r2, r2
   171fe:	401a      	ands	r2, r3
   17200:	68bb      	ldr	r3, [r7, #8]
   17202:	6879      	ldr	r1, [r7, #4]
   17204:	434b      	muls	r3, r1
   17206:	431a      	orrs	r2, r3
   17208:	68fb      	ldr	r3, [r7, #12]
   1720a:	605a      	str	r2, [r3, #4]
}
   1720c:	46c0      	nop			; (mov r8, r8)
   1720e:	46bd      	mov	sp, r7
   17210:	b004      	add	sp, #16
   17212:	bd80      	pop	{r7, pc}

00017214 <LL_GPIO_SetPinSpeed>:
  *         @arg @ref LL_GPIO_SPEED_FREQ_MEDIUM
  *         @arg @ref LL_GPIO_SPEED_FREQ_HIGH
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetPinSpeed(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t  Speed)
{
   17214:	b580      	push	{r7, lr}
   17216:	b084      	sub	sp, #16
   17218:	af00      	add	r7, sp, #0
   1721a:	60f8      	str	r0, [r7, #12]
   1721c:	60b9      	str	r1, [r7, #8]
   1721e:	607a      	str	r2, [r7, #4]
  MODIFY_REG(GPIOx->OSPEEDR, ((Pin * Pin) * GPIO_OSPEEDR_OSPEEDR0), ((Pin * Pin) * Speed));
   17220:	68fb      	ldr	r3, [r7, #12]
   17222:	6899      	ldr	r1, [r3, #8]
   17224:	68bb      	ldr	r3, [r7, #8]
   17226:	68ba      	ldr	r2, [r7, #8]
   17228:	435a      	muls	r2, r3
   1722a:	0013      	movs	r3, r2
   1722c:	005b      	lsls	r3, r3, #1
   1722e:	189b      	adds	r3, r3, r2
   17230:	43db      	mvns	r3, r3
   17232:	400b      	ands	r3, r1
   17234:	001a      	movs	r2, r3
   17236:	68bb      	ldr	r3, [r7, #8]
   17238:	68b9      	ldr	r1, [r7, #8]
   1723a:	434b      	muls	r3, r1
   1723c:	6879      	ldr	r1, [r7, #4]
   1723e:	434b      	muls	r3, r1
   17240:	431a      	orrs	r2, r3
   17242:	68fb      	ldr	r3, [r7, #12]
   17244:	609a      	str	r2, [r3, #8]
}
   17246:	46c0      	nop			; (mov r8, r8)
   17248:	46bd      	mov	sp, r7
   1724a:	b004      	add	sp, #16
   1724c:	bd80      	pop	{r7, pc}

0001724e <LL_GPIO_SetPinPull>:
  *         @arg @ref LL_GPIO_PULL_UP
  *         @arg @ref LL_GPIO_PULL_DOWN
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetPinPull(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Pull)
{
   1724e:	b580      	push	{r7, lr}
   17250:	b084      	sub	sp, #16
   17252:	af00      	add	r7, sp, #0
   17254:	60f8      	str	r0, [r7, #12]
   17256:	60b9      	str	r1, [r7, #8]
   17258:	607a      	str	r2, [r7, #4]
  MODIFY_REG(GPIOx->PUPDR, ((Pin * Pin) * GPIO_PUPDR_PUPDR0), ((Pin * Pin) * Pull));
   1725a:	68fb      	ldr	r3, [r7, #12]
   1725c:	68d9      	ldr	r1, [r3, #12]
   1725e:	68bb      	ldr	r3, [r7, #8]
   17260:	68ba      	ldr	r2, [r7, #8]
   17262:	435a      	muls	r2, r3
   17264:	0013      	movs	r3, r2
   17266:	005b      	lsls	r3, r3, #1
   17268:	189b      	adds	r3, r3, r2
   1726a:	43db      	mvns	r3, r3
   1726c:	400b      	ands	r3, r1
   1726e:	001a      	movs	r2, r3
   17270:	68bb      	ldr	r3, [r7, #8]
   17272:	68b9      	ldr	r1, [r7, #8]
   17274:	434b      	muls	r3, r1
   17276:	6879      	ldr	r1, [r7, #4]
   17278:	434b      	muls	r3, r1
   1727a:	431a      	orrs	r2, r3
   1727c:	68fb      	ldr	r3, [r7, #12]
   1727e:	60da      	str	r2, [r3, #12]
}
   17280:	46c0      	nop			; (mov r8, r8)
   17282:	46bd      	mov	sp, r7
   17284:	b004      	add	sp, #16
   17286:	bd80      	pop	{r7, pc}

00017288 <LL_GPIO_SetAFPin_0_7>:
  *         @arg @ref LL_GPIO_AF_6
  *         @arg @ref LL_GPIO_AF_7
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetAFPin_0_7(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Alternate)
{
   17288:	b580      	push	{r7, lr}
   1728a:	b084      	sub	sp, #16
   1728c:	af00      	add	r7, sp, #0
   1728e:	60f8      	str	r0, [r7, #12]
   17290:	60b9      	str	r1, [r7, #8]
   17292:	607a      	str	r2, [r7, #4]
  MODIFY_REG(GPIOx->AFR[0], ((((Pin * Pin) * Pin) * Pin) * GPIO_AFRL_AFSEL0),
   17294:	68fb      	ldr	r3, [r7, #12]
   17296:	6a19      	ldr	r1, [r3, #32]
   17298:	68bb      	ldr	r3, [r7, #8]
   1729a:	68ba      	ldr	r2, [r7, #8]
   1729c:	4353      	muls	r3, r2
   1729e:	68ba      	ldr	r2, [r7, #8]
   172a0:	4353      	muls	r3, r2
   172a2:	68ba      	ldr	r2, [r7, #8]
   172a4:	435a      	muls	r2, r3
   172a6:	0013      	movs	r3, r2
   172a8:	011b      	lsls	r3, r3, #4
   172aa:	1a9b      	subs	r3, r3, r2
   172ac:	43db      	mvns	r3, r3
   172ae:	400b      	ands	r3, r1
   172b0:	001a      	movs	r2, r3
   172b2:	68bb      	ldr	r3, [r7, #8]
   172b4:	68b9      	ldr	r1, [r7, #8]
   172b6:	434b      	muls	r3, r1
   172b8:	68b9      	ldr	r1, [r7, #8]
   172ba:	434b      	muls	r3, r1
   172bc:	68b9      	ldr	r1, [r7, #8]
   172be:	434b      	muls	r3, r1
   172c0:	6879      	ldr	r1, [r7, #4]
   172c2:	434b      	muls	r3, r1
   172c4:	431a      	orrs	r2, r3
   172c6:	68fb      	ldr	r3, [r7, #12]
   172c8:	621a      	str	r2, [r3, #32]
             ((((Pin * Pin) * Pin) * Pin) * Alternate));
}
   172ca:	46c0      	nop			; (mov r8, r8)
   172cc:	46bd      	mov	sp, r7
   172ce:	b004      	add	sp, #16
   172d0:	bd80      	pop	{r7, pc}

000172d2 <LL_USART_Enable>:
{
   172d2:	b580      	push	{r7, lr}
   172d4:	b082      	sub	sp, #8
   172d6:	af00      	add	r7, sp, #0
   172d8:	6078      	str	r0, [r7, #4]
  SET_BIT(USARTx->CR1, USART_CR1_UE);
   172da:	687b      	ldr	r3, [r7, #4]
   172dc:	681b      	ldr	r3, [r3, #0]
   172de:	2201      	movs	r2, #1
   172e0:	431a      	orrs	r2, r3
   172e2:	687b      	ldr	r3, [r7, #4]
   172e4:	601a      	str	r2, [r3, #0]
}
   172e6:	46c0      	nop			; (mov r8, r8)
   172e8:	46bd      	mov	sp, r7
   172ea:	b002      	add	sp, #8
   172ec:	bd80      	pop	{r7, pc}

000172ee <LL_USART_Disable>:
{
   172ee:	b580      	push	{r7, lr}
   172f0:	b082      	sub	sp, #8
   172f2:	af00      	add	r7, sp, #0
   172f4:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(USARTx->CR1, USART_CR1_UE);
   172f6:	687b      	ldr	r3, [r7, #4]
   172f8:	681b      	ldr	r3, [r3, #0]
   172fa:	2201      	movs	r2, #1
   172fc:	4393      	bics	r3, r2
   172fe:	001a      	movs	r2, r3
   17300:	687b      	ldr	r3, [r7, #4]
   17302:	601a      	str	r2, [r3, #0]
}
   17304:	46c0      	nop			; (mov r8, r8)
   17306:	46bd      	mov	sp, r7
   17308:	b002      	add	sp, #8
   1730a:	bd80      	pop	{r7, pc}

0001730c <LL_USART_EnableDirectionRx>:
{
   1730c:	b580      	push	{r7, lr}
   1730e:	b082      	sub	sp, #8
   17310:	af00      	add	r7, sp, #0
   17312:	6078      	str	r0, [r7, #4]
  SET_BIT(USARTx->CR1, USART_CR1_RE);
   17314:	687b      	ldr	r3, [r7, #4]
   17316:	681b      	ldr	r3, [r3, #0]
   17318:	2204      	movs	r2, #4
   1731a:	431a      	orrs	r2, r3
   1731c:	687b      	ldr	r3, [r7, #4]
   1731e:	601a      	str	r2, [r3, #0]
}
   17320:	46c0      	nop			; (mov r8, r8)
   17322:	46bd      	mov	sp, r7
   17324:	b002      	add	sp, #8
   17326:	bd80      	pop	{r7, pc}

00017328 <LL_USART_IsActiveFlag_TEACK>:
  * @rmtoll ISR          TEACK         LL_USART_IsActiveFlag_TEACK
  * @param  USARTx USART Instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_USART_IsActiveFlag_TEACK(USART_TypeDef *USARTx)
{
   17328:	b580      	push	{r7, lr}
   1732a:	b082      	sub	sp, #8
   1732c:	af00      	add	r7, sp, #0
   1732e:	6078      	str	r0, [r7, #4]
  return (READ_BIT(USARTx->ISR, USART_ISR_TEACK) == (USART_ISR_TEACK));
   17330:	687b      	ldr	r3, [r7, #4]
   17332:	69da      	ldr	r2, [r3, #28]
   17334:	2380      	movs	r3, #128	; 0x80
   17336:	039b      	lsls	r3, r3, #14
   17338:	4013      	ands	r3, r2
   1733a:	4a05      	ldr	r2, [pc, #20]	; (17350 <LL_USART_IsActiveFlag_TEACK+0x28>)
   1733c:	4694      	mov	ip, r2
   1733e:	4463      	add	r3, ip
   17340:	425a      	negs	r2, r3
   17342:	4153      	adcs	r3, r2
   17344:	b2db      	uxtb	r3, r3
}
   17346:	0018      	movs	r0, r3
   17348:	46bd      	mov	sp, r7
   1734a:	b002      	add	sp, #8
   1734c:	bd80      	pop	{r7, pc}
   1734e:	46c0      	nop			; (mov r8, r8)
   17350:	ffe00000 	.word	0xffe00000

00017354 <LL_USART_EnableIT_RXNE>:
  * @rmtoll CR1          RXNEIE        LL_USART_EnableIT_RXNE
  * @param  USARTx USART Instance
  * @retval None
  */
__STATIC_INLINE void LL_USART_EnableIT_RXNE(USART_TypeDef *USARTx)
{
   17354:	b580      	push	{r7, lr}
   17356:	b082      	sub	sp, #8
   17358:	af00      	add	r7, sp, #0
   1735a:	6078      	str	r0, [r7, #4]
  SET_BIT(USARTx->CR1, USART_CR1_RXNEIE);
   1735c:	687b      	ldr	r3, [r7, #4]
   1735e:	681b      	ldr	r3, [r3, #0]
   17360:	2220      	movs	r2, #32
   17362:	431a      	orrs	r2, r3
   17364:	687b      	ldr	r3, [r7, #4]
   17366:	601a      	str	r2, [r3, #0]
}
   17368:	46c0      	nop			; (mov r8, r8)
   1736a:	46bd      	mov	sp, r7
   1736c:	b002      	add	sp, #8
   1736e:	bd80      	pop	{r7, pc}

00017370 <LL_USART_EnableIT_ERROR>:
  * @rmtoll CR3          EIE           LL_USART_EnableIT_ERROR
  * @param  USARTx USART Instance
  * @retval None
  */
__STATIC_INLINE void LL_USART_EnableIT_ERROR(USART_TypeDef *USARTx)
{
   17370:	b580      	push	{r7, lr}
   17372:	b082      	sub	sp, #8
   17374:	af00      	add	r7, sp, #0
   17376:	6078      	str	r0, [r7, #4]
  SET_BIT(USARTx->CR3, USART_CR3_EIE);
   17378:	687b      	ldr	r3, [r7, #4]
   1737a:	689b      	ldr	r3, [r3, #8]
   1737c:	2201      	movs	r2, #1
   1737e:	431a      	orrs	r2, r3
   17380:	687b      	ldr	r3, [r7, #4]
   17382:	609a      	str	r2, [r3, #8]
}
   17384:	46c0      	nop			; (mov r8, r8)
   17386:	46bd      	mov	sp, r7
   17388:	b002      	add	sp, #8
   1738a:	bd80      	pop	{r7, pc}

0001738c <LL_USART_EnableDMAReq_TX>:
  * @rmtoll CR3          DMAT          LL_USART_EnableDMAReq_TX
  * @param  USARTx USART Instance
  * @retval None
  */
__STATIC_INLINE void LL_USART_EnableDMAReq_TX(USART_TypeDef *USARTx)
{
   1738c:	b580      	push	{r7, lr}
   1738e:	b082      	sub	sp, #8
   17390:	af00      	add	r7, sp, #0
   17392:	6078      	str	r0, [r7, #4]
  SET_BIT(USARTx->CR3, USART_CR3_DMAT);
   17394:	687b      	ldr	r3, [r7, #4]
   17396:	689b      	ldr	r3, [r3, #8]
   17398:	2280      	movs	r2, #128	; 0x80
   1739a:	431a      	orrs	r2, r3
   1739c:	687b      	ldr	r3, [r7, #4]
   1739e:	609a      	str	r2, [r3, #8]
}
   173a0:	46c0      	nop			; (mov r8, r8)
   173a2:	46bd      	mov	sp, r7
   173a4:	b002      	add	sp, #8
   173a6:	bd80      	pop	{r7, pc}

000173a8 <LL_USART_DMA_GetRegAddr>:
  *         @arg @ref LL_USART_DMA_REG_DATA_TRANSMIT
  *         @arg @ref LL_USART_DMA_REG_DATA_RECEIVE
  * @retval Address of data register
  */
__STATIC_INLINE uint32_t LL_USART_DMA_GetRegAddr(USART_TypeDef *USARTx, uint32_t Direction)
{
   173a8:	b590      	push	{r4, r7, lr}
   173aa:	b083      	sub	sp, #12
   173ac:	af00      	add	r7, sp, #0
   173ae:	6078      	str	r0, [r7, #4]
   173b0:	6039      	str	r1, [r7, #0]
  register uint32_t data_reg_addr = 0U;
   173b2:	2400      	movs	r4, #0

  if (Direction == LL_USART_DMA_REG_DATA_TRANSMIT)
   173b4:	683b      	ldr	r3, [r7, #0]
   173b6:	2b00      	cmp	r3, #0
   173b8:	d103      	bne.n	173c2 <LL_USART_DMA_GetRegAddr+0x1a>
  {
    /* return address of TDR register */
    data_reg_addr = (uint32_t) &(USARTx->TDR);
   173ba:	687b      	ldr	r3, [r7, #4]
   173bc:	3328      	adds	r3, #40	; 0x28
   173be:	001c      	movs	r4, r3
   173c0:	e002      	b.n	173c8 <LL_USART_DMA_GetRegAddr+0x20>
  }
  else
  {
    /* return address of RDR register */
    data_reg_addr = (uint32_t) &(USARTx->RDR);
   173c2:	687b      	ldr	r3, [r7, #4]
   173c4:	3324      	adds	r3, #36	; 0x24
   173c6:	001c      	movs	r4, r3
  }

  return data_reg_addr;
   173c8:	0023      	movs	r3, r4
}
   173ca:	0018      	movs	r0, r3
   173cc:	46bd      	mov	sp, r7
   173ce:	b003      	add	sp, #12
   173d0:	bd90      	pop	{r4, r7, pc}
	...

000173d4 <LL_AHB1_GRP1_EnableClock>:
  *
  *         (*) value not defined in all devices.
  * @retval None
*/
__STATIC_INLINE void LL_AHB1_GRP1_EnableClock(uint32_t Periphs)
{
   173d4:	b580      	push	{r7, lr}
   173d6:	b084      	sub	sp, #16
   173d8:	af00      	add	r7, sp, #0
   173da:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  SET_BIT(RCC->AHBENR, Periphs);
   173dc:	4b07      	ldr	r3, [pc, #28]	; (173fc <LL_AHB1_GRP1_EnableClock+0x28>)
   173de:	6959      	ldr	r1, [r3, #20]
   173e0:	4b06      	ldr	r3, [pc, #24]	; (173fc <LL_AHB1_GRP1_EnableClock+0x28>)
   173e2:	687a      	ldr	r2, [r7, #4]
   173e4:	430a      	orrs	r2, r1
   173e6:	615a      	str	r2, [r3, #20]
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->AHBENR, Periphs);
   173e8:	4b04      	ldr	r3, [pc, #16]	; (173fc <LL_AHB1_GRP1_EnableClock+0x28>)
   173ea:	695b      	ldr	r3, [r3, #20]
   173ec:	687a      	ldr	r2, [r7, #4]
   173ee:	4013      	ands	r3, r2
   173f0:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
   173f2:	68fb      	ldr	r3, [r7, #12]
}
   173f4:	46c0      	nop			; (mov r8, r8)
   173f6:	46bd      	mov	sp, r7
   173f8:	b004      	add	sp, #16
   173fa:	bd80      	pop	{r7, pc}
   173fc:	40021000 	.word	0x40021000

00017400 <LL_APB1_GRP1_EnableClock>:
  *
  *         (*) value not defined in all devices.
  * @retval None
*/
__STATIC_INLINE void LL_APB1_GRP1_EnableClock(uint32_t Periphs)
{
   17400:	b580      	push	{r7, lr}
   17402:	b084      	sub	sp, #16
   17404:	af00      	add	r7, sp, #0
   17406:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB1ENR, Periphs);
   17408:	4b07      	ldr	r3, [pc, #28]	; (17428 <LL_APB1_GRP1_EnableClock+0x28>)
   1740a:	69d9      	ldr	r1, [r3, #28]
   1740c:	4b06      	ldr	r3, [pc, #24]	; (17428 <LL_APB1_GRP1_EnableClock+0x28>)
   1740e:	687a      	ldr	r2, [r7, #4]
   17410:	430a      	orrs	r2, r1
   17412:	61da      	str	r2, [r3, #28]
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB1ENR, Periphs);
   17414:	4b04      	ldr	r3, [pc, #16]	; (17428 <LL_APB1_GRP1_EnableClock+0x28>)
   17416:	69db      	ldr	r3, [r3, #28]
   17418:	687a      	ldr	r2, [r7, #4]
   1741a:	4013      	ands	r3, r2
   1741c:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
   1741e:	68fb      	ldr	r3, [r7, #12]
}
   17420:	46c0      	nop			; (mov r8, r8)
   17422:	46bd      	mov	sp, r7
   17424:	b004      	add	sp, #16
   17426:	bd80      	pop	{r7, pc}
   17428:	40021000 	.word	0x40021000

0001742c <LL_APB1_GRP1_DisableClock>:
  *
  *         (*) value not defined in all devices.
  * @retval None
*/
__STATIC_INLINE void LL_APB1_GRP1_DisableClock(uint32_t Periphs)
{
   1742c:	b580      	push	{r7, lr}
   1742e:	b082      	sub	sp, #8
   17430:	af00      	add	r7, sp, #0
   17432:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(RCC->APB1ENR, Periphs);
   17434:	4b05      	ldr	r3, [pc, #20]	; (1744c <LL_APB1_GRP1_DisableClock+0x20>)
   17436:	69da      	ldr	r2, [r3, #28]
   17438:	687b      	ldr	r3, [r7, #4]
   1743a:	43d9      	mvns	r1, r3
   1743c:	4b03      	ldr	r3, [pc, #12]	; (1744c <LL_APB1_GRP1_DisableClock+0x20>)
   1743e:	400a      	ands	r2, r1
   17440:	61da      	str	r2, [r3, #28]
}
   17442:	46c0      	nop			; (mov r8, r8)
   17444:	46bd      	mov	sp, r7
   17446:	b002      	add	sp, #8
   17448:	bd80      	pop	{r7, pc}
   1744a:	46c0      	nop			; (mov r8, r8)
   1744c:	40021000 	.word	0x40021000

00017450 <LL_DMA_EnableChannel>:
  *         @arg @ref LL_DMA_CHANNEL_6
  *         @arg @ref LL_DMA_CHANNEL_7
  * @retval None
  */
__STATIC_INLINE void LL_DMA_EnableChannel(DMA_TypeDef *DMAx, uint32_t Channel)
{
   17450:	b580      	push	{r7, lr}
   17452:	b082      	sub	sp, #8
   17454:	af00      	add	r7, sp, #0
   17456:	6078      	str	r0, [r7, #4]
   17458:	6039      	str	r1, [r7, #0]
  SET_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_EN);
   1745a:	683b      	ldr	r3, [r7, #0]
   1745c:	3b01      	subs	r3, #1
   1745e:	4a0a      	ldr	r2, [pc, #40]	; (17488 <LL_DMA_EnableChannel+0x38>)
   17460:	5cd3      	ldrb	r3, [r2, r3]
   17462:	001a      	movs	r2, r3
   17464:	687b      	ldr	r3, [r7, #4]
   17466:	18d3      	adds	r3, r2, r3
   17468:	681a      	ldr	r2, [r3, #0]
   1746a:	683b      	ldr	r3, [r7, #0]
   1746c:	3b01      	subs	r3, #1
   1746e:	4906      	ldr	r1, [pc, #24]	; (17488 <LL_DMA_EnableChannel+0x38>)
   17470:	5ccb      	ldrb	r3, [r1, r3]
   17472:	0019      	movs	r1, r3
   17474:	687b      	ldr	r3, [r7, #4]
   17476:	18cb      	adds	r3, r1, r3
   17478:	2101      	movs	r1, #1
   1747a:	430a      	orrs	r2, r1
   1747c:	601a      	str	r2, [r3, #0]
}
   1747e:	46c0      	nop			; (mov r8, r8)
   17480:	46bd      	mov	sp, r7
   17482:	b002      	add	sp, #8
   17484:	bd80      	pop	{r7, pc}
   17486:	46c0      	nop			; (mov r8, r8)
   17488:	0001fdcc 	.word	0x0001fdcc

0001748c <LL_DMA_ConfigTransfer>:
  *         @arg @ref LL_DMA_MDATAALIGN_BYTE or @ref LL_DMA_MDATAALIGN_HALFWORD or @ref LL_DMA_MDATAALIGN_WORD
  *         @arg @ref LL_DMA_PRIORITY_LOW or @ref LL_DMA_PRIORITY_MEDIUM or @ref LL_DMA_PRIORITY_HIGH or @ref LL_DMA_PRIORITY_VERYHIGH
  * @retval None
  */
__STATIC_INLINE void LL_DMA_ConfigTransfer(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t Configuration)
{
   1748c:	b580      	push	{r7, lr}
   1748e:	b084      	sub	sp, #16
   17490:	af00      	add	r7, sp, #0
   17492:	60f8      	str	r0, [r7, #12]
   17494:	60b9      	str	r1, [r7, #8]
   17496:	607a      	str	r2, [r7, #4]
  MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
   17498:	68bb      	ldr	r3, [r7, #8]
   1749a:	3b01      	subs	r3, #1
   1749c:	4a0b      	ldr	r2, [pc, #44]	; (174cc <LL_DMA_ConfigTransfer+0x40>)
   1749e:	5cd3      	ldrb	r3, [r2, r3]
   174a0:	001a      	movs	r2, r3
   174a2:	68fb      	ldr	r3, [r7, #12]
   174a4:	18d3      	adds	r3, r2, r3
   174a6:	681b      	ldr	r3, [r3, #0]
   174a8:	4a09      	ldr	r2, [pc, #36]	; (174d0 <LL_DMA_ConfigTransfer+0x44>)
   174aa:	4013      	ands	r3, r2
   174ac:	0019      	movs	r1, r3
   174ae:	68bb      	ldr	r3, [r7, #8]
   174b0:	3b01      	subs	r3, #1
   174b2:	4a06      	ldr	r2, [pc, #24]	; (174cc <LL_DMA_ConfigTransfer+0x40>)
   174b4:	5cd3      	ldrb	r3, [r2, r3]
   174b6:	001a      	movs	r2, r3
   174b8:	68fb      	ldr	r3, [r7, #12]
   174ba:	18d3      	adds	r3, r2, r3
   174bc:	687a      	ldr	r2, [r7, #4]
   174be:	430a      	orrs	r2, r1
   174c0:	601a      	str	r2, [r3, #0]
             DMA_CCR_DIR | DMA_CCR_MEM2MEM | DMA_CCR_CIRC | DMA_CCR_PINC | DMA_CCR_MINC | DMA_CCR_PSIZE | DMA_CCR_MSIZE | DMA_CCR_PL,
             Configuration);
}
   174c2:	46c0      	nop			; (mov r8, r8)
   174c4:	46bd      	mov	sp, r7
   174c6:	b004      	add	sp, #16
   174c8:	bd80      	pop	{r7, pc}
   174ca:	46c0      	nop			; (mov r8, r8)
   174cc:	0001fdcc 	.word	0x0001fdcc
   174d0:	ffff800f 	.word	0xffff800f

000174d4 <LL_DMA_GetDataTransferDirection>:
  *         @arg @ref LL_DMA_DIRECTION_PERIPH_TO_MEMORY
  *         @arg @ref LL_DMA_DIRECTION_MEMORY_TO_PERIPH
  *         @arg @ref LL_DMA_DIRECTION_MEMORY_TO_MEMORY
  */
__STATIC_INLINE uint32_t LL_DMA_GetDataTransferDirection(DMA_TypeDef *DMAx, uint32_t Channel)
{
   174d4:	b580      	push	{r7, lr}
   174d6:	b082      	sub	sp, #8
   174d8:	af00      	add	r7, sp, #0
   174da:	6078      	str	r0, [r7, #4]
   174dc:	6039      	str	r1, [r7, #0]
  return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
   174de:	683b      	ldr	r3, [r7, #0]
   174e0:	3b01      	subs	r3, #1
   174e2:	4a06      	ldr	r2, [pc, #24]	; (174fc <LL_DMA_GetDataTransferDirection+0x28>)
   174e4:	5cd3      	ldrb	r3, [r2, r3]
   174e6:	001a      	movs	r2, r3
   174e8:	687b      	ldr	r3, [r7, #4]
   174ea:	18d3      	adds	r3, r2, r3
   174ec:	681b      	ldr	r3, [r3, #0]
   174ee:	4a04      	ldr	r2, [pc, #16]	; (17500 <LL_DMA_GetDataTransferDirection+0x2c>)
   174f0:	4013      	ands	r3, r2
                   DMA_CCR_DIR | DMA_CCR_MEM2MEM));
}
   174f2:	0018      	movs	r0, r3
   174f4:	46bd      	mov	sp, r7
   174f6:	b002      	add	sp, #8
   174f8:	bd80      	pop	{r7, pc}
   174fa:	46c0      	nop			; (mov r8, r8)
   174fc:	0001fdcc 	.word	0x0001fdcc
   17500:	00004010 	.word	0x00004010

00017504 <LL_DMA_SetDataLength>:
  *         @arg @ref LL_DMA_CHANNEL_7
  * @param  NbData Between Min_Data = 0 and Max_Data = 0x0000FFFF
  * @retval None
  */
__STATIC_INLINE void LL_DMA_SetDataLength(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t NbData)
{
   17504:	b580      	push	{r7, lr}
   17506:	b084      	sub	sp, #16
   17508:	af00      	add	r7, sp, #0
   1750a:	60f8      	str	r0, [r7, #12]
   1750c:	60b9      	str	r1, [r7, #8]
   1750e:	607a      	str	r2, [r7, #4]
  MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CNDTR,
   17510:	68bb      	ldr	r3, [r7, #8]
   17512:	3b01      	subs	r3, #1
   17514:	4a0a      	ldr	r2, [pc, #40]	; (17540 <LL_DMA_SetDataLength+0x3c>)
   17516:	5cd3      	ldrb	r3, [r2, r3]
   17518:	001a      	movs	r2, r3
   1751a:	68fb      	ldr	r3, [r7, #12]
   1751c:	18d3      	adds	r3, r2, r3
   1751e:	685b      	ldr	r3, [r3, #4]
   17520:	0c1b      	lsrs	r3, r3, #16
   17522:	0419      	lsls	r1, r3, #16
   17524:	68bb      	ldr	r3, [r7, #8]
   17526:	3b01      	subs	r3, #1
   17528:	4a05      	ldr	r2, [pc, #20]	; (17540 <LL_DMA_SetDataLength+0x3c>)
   1752a:	5cd3      	ldrb	r3, [r2, r3]
   1752c:	001a      	movs	r2, r3
   1752e:	68fb      	ldr	r3, [r7, #12]
   17530:	18d3      	adds	r3, r2, r3
   17532:	687a      	ldr	r2, [r7, #4]
   17534:	430a      	orrs	r2, r1
   17536:	605a      	str	r2, [r3, #4]
             DMA_CNDTR_NDT, NbData);
}
   17538:	46c0      	nop			; (mov r8, r8)
   1753a:	46bd      	mov	sp, r7
   1753c:	b004      	add	sp, #16
   1753e:	bd80      	pop	{r7, pc}
   17540:	0001fdcc 	.word	0x0001fdcc

00017544 <LL_DMA_ConfigAddresses>:
  *         @arg @ref LL_DMA_DIRECTION_MEMORY_TO_MEMORY
  * @retval None
  */
__STATIC_INLINE void LL_DMA_ConfigAddresses(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t SrcAddress,
                                            uint32_t DstAddress, uint32_t Direction)
{
   17544:	b580      	push	{r7, lr}
   17546:	b084      	sub	sp, #16
   17548:	af00      	add	r7, sp, #0
   1754a:	60f8      	str	r0, [r7, #12]
   1754c:	60b9      	str	r1, [r7, #8]
   1754e:	607a      	str	r2, [r7, #4]
   17550:	603b      	str	r3, [r7, #0]
  /* Direction Memory to Periph */
  if (Direction == LL_DMA_DIRECTION_MEMORY_TO_PERIPH)
   17552:	69bb      	ldr	r3, [r7, #24]
   17554:	2b10      	cmp	r3, #16
   17556:	d112      	bne.n	1757e <LL_DMA_ConfigAddresses+0x3a>
  {
    WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CMAR, SrcAddress);
   17558:	68bb      	ldr	r3, [r7, #8]
   1755a:	3b01      	subs	r3, #1
   1755c:	4a13      	ldr	r2, [pc, #76]	; (175ac <LL_DMA_ConfigAddresses+0x68>)
   1755e:	5cd3      	ldrb	r3, [r2, r3]
   17560:	001a      	movs	r2, r3
   17562:	68fb      	ldr	r3, [r7, #12]
   17564:	18d3      	adds	r3, r2, r3
   17566:	687a      	ldr	r2, [r7, #4]
   17568:	60da      	str	r2, [r3, #12]
    WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CPAR, DstAddress);
   1756a:	68bb      	ldr	r3, [r7, #8]
   1756c:	3b01      	subs	r3, #1
   1756e:	4a0f      	ldr	r2, [pc, #60]	; (175ac <LL_DMA_ConfigAddresses+0x68>)
   17570:	5cd3      	ldrb	r3, [r2, r3]
   17572:	001a      	movs	r2, r3
   17574:	68fb      	ldr	r3, [r7, #12]
   17576:	18d3      	adds	r3, r2, r3
   17578:	683a      	ldr	r2, [r7, #0]
   1757a:	609a      	str	r2, [r3, #8]
  else
  {
    WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CPAR, SrcAddress);
    WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CMAR, DstAddress);
  }
}
   1757c:	e011      	b.n	175a2 <LL_DMA_ConfigAddresses+0x5e>
    WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CPAR, SrcAddress);
   1757e:	68bb      	ldr	r3, [r7, #8]
   17580:	3b01      	subs	r3, #1
   17582:	4a0a      	ldr	r2, [pc, #40]	; (175ac <LL_DMA_ConfigAddresses+0x68>)
   17584:	5cd3      	ldrb	r3, [r2, r3]
   17586:	001a      	movs	r2, r3
   17588:	68fb      	ldr	r3, [r7, #12]
   1758a:	18d3      	adds	r3, r2, r3
   1758c:	687a      	ldr	r2, [r7, #4]
   1758e:	609a      	str	r2, [r3, #8]
    WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CMAR, DstAddress);
   17590:	68bb      	ldr	r3, [r7, #8]
   17592:	3b01      	subs	r3, #1
   17594:	4a05      	ldr	r2, [pc, #20]	; (175ac <LL_DMA_ConfigAddresses+0x68>)
   17596:	5cd3      	ldrb	r3, [r2, r3]
   17598:	001a      	movs	r2, r3
   1759a:	68fb      	ldr	r3, [r7, #12]
   1759c:	18d3      	adds	r3, r2, r3
   1759e:	683a      	ldr	r2, [r7, #0]
   175a0:	60da      	str	r2, [r3, #12]
}
   175a2:	46c0      	nop			; (mov r8, r8)
   175a4:	46bd      	mov	sp, r7
   175a6:	b004      	add	sp, #16
   175a8:	bd80      	pop	{r7, pc}
   175aa:	46c0      	nop			; (mov r8, r8)
   175ac:	0001fdcc 	.word	0x0001fdcc

000175b0 <LL_DMA_EnableIT_TC>:
  *         @arg @ref LL_DMA_CHANNEL_6
  *         @arg @ref LL_DMA_CHANNEL_7
  * @retval None
  */
__STATIC_INLINE void LL_DMA_EnableIT_TC(DMA_TypeDef *DMAx, uint32_t Channel)
{
   175b0:	b580      	push	{r7, lr}
   175b2:	b082      	sub	sp, #8
   175b4:	af00      	add	r7, sp, #0
   175b6:	6078      	str	r0, [r7, #4]
   175b8:	6039      	str	r1, [r7, #0]
  SET_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_TCIE);
   175ba:	683b      	ldr	r3, [r7, #0]
   175bc:	3b01      	subs	r3, #1
   175be:	4a0a      	ldr	r2, [pc, #40]	; (175e8 <LL_DMA_EnableIT_TC+0x38>)
   175c0:	5cd3      	ldrb	r3, [r2, r3]
   175c2:	001a      	movs	r2, r3
   175c4:	687b      	ldr	r3, [r7, #4]
   175c6:	18d3      	adds	r3, r2, r3
   175c8:	681a      	ldr	r2, [r3, #0]
   175ca:	683b      	ldr	r3, [r7, #0]
   175cc:	3b01      	subs	r3, #1
   175ce:	4906      	ldr	r1, [pc, #24]	; (175e8 <LL_DMA_EnableIT_TC+0x38>)
   175d0:	5ccb      	ldrb	r3, [r1, r3]
   175d2:	0019      	movs	r1, r3
   175d4:	687b      	ldr	r3, [r7, #4]
   175d6:	18cb      	adds	r3, r1, r3
   175d8:	2102      	movs	r1, #2
   175da:	430a      	orrs	r2, r1
   175dc:	601a      	str	r2, [r3, #0]
}
   175de:	46c0      	nop			; (mov r8, r8)
   175e0:	46bd      	mov	sp, r7
   175e2:	b002      	add	sp, #8
   175e4:	bd80      	pop	{r7, pc}
   175e6:	46c0      	nop			; (mov r8, r8)
   175e8:	0001fdcc 	.word	0x0001fdcc

000175ec <HW_TRACER_EMB_Init>:
  * @param  callbackTX
  * @param  callbackRX
  * @retval none
  */
void HW_TRACER_EMB_Init(void)
{
   175ec:	b580      	push	{r7, lr}
   175ee:	b088      	sub	sp, #32
   175f0:	af00      	add	r7, sp, #0
  /* Enable the peripheral clock of GPIO Port */
  TRACER_EMB_TX_GPIO_ENABLE_CLOCK();
   175f2:	2380      	movs	r3, #128	; 0x80
   175f4:	029b      	lsls	r3, r3, #10
   175f6:	0018      	movs	r0, r3
   175f8:	f7ff feec 	bl	173d4 <LL_AHB1_GRP1_EnableClock>
  TRACER_EMB_RX_GPIO_ENABLE_CLOCK();
   175fc:	2380      	movs	r3, #128	; 0x80
   175fe:	029b      	lsls	r3, r3, #10
   17600:	0018      	movs	r0, r3
   17602:	f7ff fee7 	bl	173d4 <LL_AHB1_GRP1_EnableClock>

  /* Configure Tx Pin as : Alternate function, High Speed, Push pull, Pull up */
  TRACER_EMB_TX_AF_FUNCTION(TRACER_EMB_TX_GPIO, TRACER_EMB_TX_PIN, TRACER_EMB_TX_AF);
   17606:	2390      	movs	r3, #144	; 0x90
   17608:	05db      	lsls	r3, r3, #23
   1760a:	2204      	movs	r2, #4
   1760c:	2101      	movs	r1, #1
   1760e:	0018      	movs	r0, r3
   17610:	f7ff fe3a 	bl	17288 <LL_GPIO_SetAFPin_0_7>
  LL_GPIO_SetPinMode(TRACER_EMB_TX_GPIO, TRACER_EMB_TX_PIN, LL_GPIO_MODE_ALTERNATE);
   17614:	2390      	movs	r3, #144	; 0x90
   17616:	05db      	lsls	r3, r3, #23
   17618:	2202      	movs	r2, #2
   1761a:	2101      	movs	r1, #1
   1761c:	0018      	movs	r0, r3
   1761e:	f7ff fdc7 	bl	171b0 <LL_GPIO_SetPinMode>
  LL_GPIO_SetPinSpeed(TRACER_EMB_TX_GPIO, TRACER_EMB_TX_PIN, LL_GPIO_SPEED_FREQ_HIGH);
   17622:	2390      	movs	r3, #144	; 0x90
   17624:	05db      	lsls	r3, r3, #23
   17626:	2203      	movs	r2, #3
   17628:	2101      	movs	r1, #1
   1762a:	0018      	movs	r0, r3
   1762c:	f7ff fdf2 	bl	17214 <LL_GPIO_SetPinSpeed>
  LL_GPIO_SetPinOutputType(TRACER_EMB_TX_GPIO, TRACER_EMB_TX_PIN, LL_GPIO_OUTPUT_PUSHPULL);
   17630:	2390      	movs	r3, #144	; 0x90
   17632:	05db      	lsls	r3, r3, #23
   17634:	2200      	movs	r2, #0
   17636:	2101      	movs	r1, #1
   17638:	0018      	movs	r0, r3
   1763a:	f7ff fdd6 	bl	171ea <LL_GPIO_SetPinOutputType>
  LL_GPIO_SetPinPull(TRACER_EMB_TX_GPIO, TRACER_EMB_TX_PIN, LL_GPIO_PULL_UP);
   1763e:	2390      	movs	r3, #144	; 0x90
   17640:	05db      	lsls	r3, r3, #23
   17642:	2201      	movs	r2, #1
   17644:	2101      	movs	r1, #1
   17646:	0018      	movs	r0, r3
   17648:	f7ff fe01 	bl	1724e <LL_GPIO_SetPinPull>

  /* Configure Rx Pin as : Alternate function, High Speed, Push pull, Pull up */
  TRACER_EMB_RX_AF_FUNCTION(TRACER_EMB_RX_GPIO, TRACER_EMB_RX_PIN, TRACER_EMB_RX_AF);
   1764c:	2390      	movs	r3, #144	; 0x90
   1764e:	05db      	lsls	r3, r3, #23
   17650:	2204      	movs	r2, #4
   17652:	2102      	movs	r1, #2
   17654:	0018      	movs	r0, r3
   17656:	f7ff fe17 	bl	17288 <LL_GPIO_SetAFPin_0_7>
  LL_GPIO_SetPinMode(TRACER_EMB_RX_GPIO, TRACER_EMB_RX_PIN, LL_GPIO_MODE_ALTERNATE);
   1765a:	2390      	movs	r3, #144	; 0x90
   1765c:	05db      	lsls	r3, r3, #23
   1765e:	2202      	movs	r2, #2
   17660:	2102      	movs	r1, #2
   17662:	0018      	movs	r0, r3
   17664:	f7ff fda4 	bl	171b0 <LL_GPIO_SetPinMode>
  LL_GPIO_SetPinSpeed(TRACER_EMB_RX_GPIO, TRACER_EMB_RX_PIN, LL_GPIO_SPEED_FREQ_HIGH);
   17668:	2390      	movs	r3, #144	; 0x90
   1766a:	05db      	lsls	r3, r3, #23
   1766c:	2203      	movs	r2, #3
   1766e:	2102      	movs	r1, #2
   17670:	0018      	movs	r0, r3
   17672:	f7ff fdcf 	bl	17214 <LL_GPIO_SetPinSpeed>
  LL_GPIO_SetPinOutputType(TRACER_EMB_RX_GPIO, TRACER_EMB_RX_PIN, LL_GPIO_OUTPUT_PUSHPULL);
   17676:	2390      	movs	r3, #144	; 0x90
   17678:	05db      	lsls	r3, r3, #23
   1767a:	2200      	movs	r2, #0
   1767c:	2102      	movs	r1, #2
   1767e:	0018      	movs	r0, r3
   17680:	f7ff fdb3 	bl	171ea <LL_GPIO_SetPinOutputType>
  LL_GPIO_SetPinPull(TRACER_EMB_RX_GPIO, TRACER_EMB_RX_PIN, LL_GPIO_PULL_UP);
   17684:	2390      	movs	r3, #144	; 0x90
   17686:	05db      	lsls	r3, r3, #23
   17688:	2201      	movs	r2, #1
   1768a:	2102      	movs	r1, #2
   1768c:	0018      	movs	r0, r3
   1768e:	f7ff fdde 	bl	1724e <LL_GPIO_SetPinPull>

  /* Enable the peripheral clock for USART */
  TRACER_EMB_ENABLE_CLK_USART();
   17692:	2380      	movs	r3, #128	; 0x80
   17694:	031b      	lsls	r3, r3, #12
   17696:	0018      	movs	r0, r3
   17698:	f7ff feb2 	bl	17400 <LL_APB1_GRP1_EnableClock>
    /* Configure USART */
    
    LL_USART_InitTypeDef usart_initstruct;

    /* Disable USART prior modifying configuration registers */
    LL_USART_Disable(TRACER_EMB_USART_INSTANCE);
   1769c:	4b2e      	ldr	r3, [pc, #184]	; (17758 <HW_TRACER_EMB_Init+0x16c>)
   1769e:	0018      	movs	r0, r3
   176a0:	f7ff fe25 	bl	172ee <LL_USART_Disable>
    /*  - HardwareFlowControl : LL_USART_HWCONTROL_NONE         */
    /*  - OverSampling        : LL_USART_OVERSAMPLING_16        */
#if defined(USART_PRESC_PRESCALER)
    usart_initstruct.PrescalerValue      = LL_USART_PRESCALER_DIV1;
#endif
    usart_initstruct.BaudRate            = TRACER_EMB_BAUDRATE;
   176a4:	003b      	movs	r3, r7
   176a6:	22e1      	movs	r2, #225	; 0xe1
   176a8:	0312      	lsls	r2, r2, #12
   176aa:	601a      	str	r2, [r3, #0]
    usart_initstruct.DataWidth           = LL_USART_DATAWIDTH_8B;
   176ac:	003b      	movs	r3, r7
   176ae:	2200      	movs	r2, #0
   176b0:	605a      	str	r2, [r3, #4]
    usart_initstruct.StopBits            = LL_USART_STOPBITS_1;
   176b2:	003b      	movs	r3, r7
   176b4:	2200      	movs	r2, #0
   176b6:	609a      	str	r2, [r3, #8]
    usart_initstruct.Parity              = LL_USART_PARITY_NONE;
   176b8:	003b      	movs	r3, r7
   176ba:	2200      	movs	r2, #0
   176bc:	60da      	str	r2, [r3, #12]
    usart_initstruct.TransferDirection   = LL_USART_DIRECTION_TX;
   176be:	003b      	movs	r3, r7
   176c0:	2208      	movs	r2, #8
   176c2:	611a      	str	r2, [r3, #16]
    usart_initstruct.HardwareFlowControl = LL_USART_HWCONTROL_NONE;
   176c4:	003b      	movs	r3, r7
   176c6:	2200      	movs	r2, #0
   176c8:	615a      	str	r2, [r3, #20]
    usart_initstruct.OverSampling        = LL_USART_OVERSAMPLING_16;
   176ca:	003b      	movs	r3, r7
   176cc:	2200      	movs	r2, #0
   176ce:	619a      	str	r2, [r3, #24]
    
    /* Initialize USART instance according to parameters defined in initialization structure */
    LL_USART_Init(TRACER_EMB_USART_INSTANCE, &usart_initstruct);
   176d0:	003b      	movs	r3, r7
   176d2:	4a21      	ldr	r2, [pc, #132]	; (17758 <HW_TRACER_EMB_Init+0x16c>)
   176d4:	0019      	movs	r1, r3
   176d6:	0010      	movs	r0, r2
   176d8:	f7f8 fbc8 	bl	fe6c <LL_USART_Init>
    
    LL_USART_Enable(TRACER_EMB_USART_INSTANCE);
   176dc:	4b1e      	ldr	r3, [pc, #120]	; (17758 <HW_TRACER_EMB_Init+0x16c>)
   176de:	0018      	movs	r0, r3
   176e0:	f7ff fdf7 	bl	172d2 <LL_USART_Enable>
    
    uint32_t _temp1 = LL_USART_IsActiveFlag_TEACK(TRACER_EMB_USART_INSTANCE);
   176e4:	4b1c      	ldr	r3, [pc, #112]	; (17758 <HW_TRACER_EMB_Init+0x16c>)
   176e6:	0018      	movs	r0, r3
   176e8:	f7ff fe1e 	bl	17328 <LL_USART_IsActiveFlag_TEACK>
   176ec:	0003      	movs	r3, r0
   176ee:	61fb      	str	r3, [r7, #28]
    /* Polling USART initialisation */
    while(0u == _temp1)
   176f0:	e005      	b.n	176fe <HW_TRACER_EMB_Init+0x112>
    {
      _temp1 = LL_USART_IsActiveFlag_TEACK(TRACER_EMB_USART_INSTANCE);
   176f2:	4b19      	ldr	r3, [pc, #100]	; (17758 <HW_TRACER_EMB_Init+0x16c>)
   176f4:	0018      	movs	r0, r3
   176f6:	f7ff fe17 	bl	17328 <LL_USART_IsActiveFlag_TEACK>
   176fa:	0003      	movs	r3, r0
   176fc:	61fb      	str	r3, [r7, #28]
    while(0u == _temp1)
   176fe:	69fb      	ldr	r3, [r7, #28]
   17700:	2b00      	cmp	r3, #0
   17702:	d0f6      	beq.n	176f2 <HW_TRACER_EMB_Init+0x106>
  }
#endif     
     
#if TRACER_EMB_DMA_MODE == 1UL
  /* Configure TX DMA */
  TRACER_EMB_ENABLE_CLK_DMA();
   17704:	2001      	movs	r0, #1
   17706:	f7ff fe65 	bl	173d4 <LL_AHB1_GRP1_EnableClock>

  /* (3) Configure the DMA functional parameters for transmission */
  LL_DMA_ConfigTransfer(TRACER_EMB_DMA_INSTANCE, TRACER_EMB_TX_DMA_CHANNEL,
   1770a:	4a14      	ldr	r2, [pc, #80]	; (1775c <HW_TRACER_EMB_Init+0x170>)
   1770c:	4b14      	ldr	r3, [pc, #80]	; (17760 <HW_TRACER_EMB_Init+0x174>)
   1770e:	2107      	movs	r1, #7
   17710:	0018      	movs	r0, r3
   17712:	f7ff febb 	bl	1748c <LL_DMA_ConfigTransfer>

#if defined(DMAMUX_CxCR_DMAREQ_ID)
  LL_DMA_SetPeriphRequest(TRACER_EMB_DMA_INSTANCE, TRACER_EMB_TX_DMA_CHANNEL, TRACER_EMB_TX_DMA_REQUEST);
#endif

  LL_DMA_EnableIT_TC(TRACER_EMB_DMA_INSTANCE, TRACER_EMB_TX_DMA_CHANNEL);
   17716:	4b12      	ldr	r3, [pc, #72]	; (17760 <HW_TRACER_EMB_Init+0x174>)
   17718:	2107      	movs	r1, #7
   1771a:	0018      	movs	r0, r3
   1771c:	f7ff ff48 	bl	175b0 <LL_DMA_EnableIT_TC>
#endif

  /* Configure the interrupt for TX */
  NVIC_SetPriority(TRACER_EMB_TX_DMA_IRQ, 0);
   17720:	2100      	movs	r1, #0
   17722:	200b      	movs	r0, #11
   17724:	f7ff fcd6 	bl	170d4 <__NVIC_SetPriority>
  NVIC_EnableIRQ(TRACER_EMB_TX_DMA_IRQ);
   17728:	200b      	movs	r0, #11
   1772a:	f7ff fcb9 	bl	170a0 <__NVIC_EnableIRQ>
  
  NVIC_SetPriority(TRACER_EMB_USART_IRQ, 3);
   1772e:	2103      	movs	r1, #3
   17730:	201d      	movs	r0, #29
   17732:	f7ff fccf 	bl	170d4 <__NVIC_SetPriority>
  NVIC_EnableIRQ(TRACER_EMB_USART_IRQ);
   17736:	201d      	movs	r0, #29
   17738:	f7ff fcb2 	bl	170a0 <__NVIC_EnableIRQ>

  /* Disable the UART */
  if(NULL == fptr_rx)
   1773c:	4b09      	ldr	r3, [pc, #36]	; (17764 <HW_TRACER_EMB_Init+0x178>)
   1773e:	681b      	ldr	r3, [r3, #0]
   17740:	2b00      	cmp	r3, #0
   17742:	d105      	bne.n	17750 <HW_TRACER_EMB_Init+0x164>
  {
    TRACER_EMB_DISABLE_CLK_USART();
   17744:	2380      	movs	r3, #128	; 0x80
   17746:	031b      	lsls	r3, r3, #12
   17748:	0018      	movs	r0, r3
   1774a:	f7ff fe6f 	bl	1742c <LL_APB1_GRP1_DisableClock>
  }
  return;
   1774e:	46c0      	nop			; (mov r8, r8)
   17750:	46c0      	nop			; (mov r8, r8)
}
   17752:	46bd      	mov	sp, r7
   17754:	b008      	add	sp, #32
   17756:	bd80      	pop	{r7, pc}
   17758:	40004c00 	.word	0x40004c00
   1775c:	00002090 	.word	0x00002090
   17760:	40020000 	.word	0x40020000
   17764:	000320e8 	.word	0x000320e8

00017768 <HW_TRACER_EMB_RegisterRxCallback>:
  * @brief  Allow to update the RX callback
  * @param  callbackRX
  * @retval none
  */
void HW_TRACER_EMB_RegisterRxCallback(void (*callbackRX)(uint8_t, uint8_t))
{
   17768:	b580      	push	{r7, lr}
   1776a:	b082      	sub	sp, #8
   1776c:	af00      	add	r7, sp, #0
   1776e:	6078      	str	r0, [r7, #4]
  fptr_rx = callbackRX;
   17770:	4b05      	ldr	r3, [pc, #20]	; (17788 <HW_TRACER_EMB_RegisterRxCallback+0x20>)
   17772:	687a      	ldr	r2, [r7, #4]
   17774:	601a      	str	r2, [r3, #0]
  TRACER_EMB_ENABLE_CLK_USART();
   17776:	2380      	movs	r3, #128	; 0x80
   17778:	031b      	lsls	r3, r3, #12
   1777a:	0018      	movs	r0, r3
   1777c:	f7ff fe40 	bl	17400 <LL_APB1_GRP1_EnableClock>
}
   17780:	46c0      	nop			; (mov r8, r8)
   17782:	46bd      	mov	sp, r7
   17784:	b002      	add	sp, #8
   17786:	bd80      	pop	{r7, pc}
   17788:	000320e8 	.word	0x000320e8

0001778c <HW_TRACER_EMB_StartRX>:
/**
  * @brief  Start RX reception only when OSKernel have been started
  * @retval none
  */
void HW_TRACER_EMB_StartRX(void)
{
   1778c:	b580      	push	{r7, lr}
   1778e:	af00      	add	r7, sp, #0
  /* Enable USART IT for RX */
  TRACER_EMB_ENABLE_IT_RXNE(TRACER_EMB_USART_INSTANCE);
   17790:	4b0a      	ldr	r3, [pc, #40]	; (177bc <HW_TRACER_EMB_StartRX+0x30>)
   17792:	0018      	movs	r0, r3
   17794:	f7ff fdde 	bl	17354 <LL_USART_EnableIT_RXNE>
  TRACER_EMB_ENABLE_IT_ERROR(TRACER_EMB_USART_INSTANCE);
   17798:	4b08      	ldr	r3, [pc, #32]	; (177bc <HW_TRACER_EMB_StartRX+0x30>)
   1779a:	0018      	movs	r0, r3
   1779c:	f7ff fde8 	bl	17370 <LL_USART_EnableIT_ERROR>

  /* Enable RX/TX */
  TRACER_EMB_ENABLEDIRECTIONRX(TRACER_EMB_USART_INSTANCE);
   177a0:	4b06      	ldr	r3, [pc, #24]	; (177bc <HW_TRACER_EMB_StartRX+0x30>)
   177a2:	0018      	movs	r0, r3
   177a4:	f7ff fdb2 	bl	1730c <LL_USART_EnableDirectionRx>
  
  /* Configure the interrupt for RX */
  NVIC_SetPriority(TRACER_EMB_USART_IRQ, 3);
   177a8:	2103      	movs	r1, #3
   177aa:	201d      	movs	r0, #29
   177ac:	f7ff fc92 	bl	170d4 <__NVIC_SetPriority>
  NVIC_EnableIRQ(TRACER_EMB_USART_IRQ);
   177b0:	201d      	movs	r0, #29
   177b2:	f7ff fc75 	bl	170a0 <__NVIC_EnableIRQ>
}
   177b6:	46c0      	nop			; (mov r8, r8)
   177b8:	46bd      	mov	sp, r7
   177ba:	bd80      	pop	{r7, pc}
   177bc:	40004c00 	.word	0x40004c00

000177c0 <HW_TRACER_EMB_SendData>:
  * @param data pointer
  * @param data size
  * @retval none
  */
void HW_TRACER_EMB_SendData(uint8_t *pData, uint32_t Size)
{
   177c0:	b5b0      	push	{r4, r5, r7, lr}
   177c2:	b084      	sub	sp, #16
   177c4:	af02      	add	r7, sp, #8
   177c6:	6078      	str	r0, [r7, #4]
   177c8:	6039      	str	r1, [r7, #0]
  /* enable the USART */
  TRACER_EMB_ENABLE_CLK_USART();
   177ca:	2380      	movs	r3, #128	; 0x80
   177cc:	031b      	lsls	r3, r3, #12
   177ce:	0018      	movs	r0, r3
   177d0:	f7ff fe16 	bl	17400 <LL_APB1_GRP1_EnableClock>
  
#if TRACER_EMB_DMA_MODE == 1UL
  LL_DMA_ConfigAddresses(TRACER_EMB_DMA_INSTANCE, TRACER_EMB_TX_DMA_CHANNEL,
   177d4:	687c      	ldr	r4, [r7, #4]
   177d6:	4b13      	ldr	r3, [pc, #76]	; (17824 <HW_TRACER_EMB_SendData+0x64>)
   177d8:	2100      	movs	r1, #0
   177da:	0018      	movs	r0, r3
   177dc:	f7ff fde4 	bl	173a8 <LL_USART_DMA_GetRegAddr>
   177e0:	0005      	movs	r5, r0
   177e2:	4b11      	ldr	r3, [pc, #68]	; (17828 <HW_TRACER_EMB_SendData+0x68>)
   177e4:	2107      	movs	r1, #7
   177e6:	0018      	movs	r0, r3
   177e8:	f7ff fe74 	bl	174d4 <LL_DMA_GetDataTransferDirection>
   177ec:	0003      	movs	r3, r0
   177ee:	480e      	ldr	r0, [pc, #56]	; (17828 <HW_TRACER_EMB_SendData+0x68>)
   177f0:	9300      	str	r3, [sp, #0]
   177f2:	002b      	movs	r3, r5
   177f4:	0022      	movs	r2, r4
   177f6:	2107      	movs	r1, #7
   177f8:	f7ff fea4 	bl	17544 <LL_DMA_ConfigAddresses>
                         (uint32_t)pData,
                         TRACER_EMB_DMA_GETREGADDR(TRACER_EMB_USART_INSTANCE, LL_USART_DMA_REG_DATA_TRANSMIT),
                         LL_DMA_GetDataTransferDirection(TRACER_EMB_DMA_INSTANCE, TRACER_EMB_TX_DMA_CHANNEL));
  LL_DMA_SetDataLength(TRACER_EMB_DMA_INSTANCE, TRACER_EMB_TX_DMA_CHANNEL, Size);
   177fc:	683b      	ldr	r3, [r7, #0]
   177fe:	480a      	ldr	r0, [pc, #40]	; (17828 <HW_TRACER_EMB_SendData+0x68>)
   17800:	001a      	movs	r2, r3
   17802:	2107      	movs	r1, #7
   17804:	f7ff fe7e 	bl	17504 <LL_DMA_SetDataLength>

  /* Enable DMA TX Interrupt */
  TRACER_EMB_ENABLEDMAREQ_TX(TRACER_EMB_USART_INSTANCE);
   17808:	4b06      	ldr	r3, [pc, #24]	; (17824 <HW_TRACER_EMB_SendData+0x64>)
   1780a:	0018      	movs	r0, r3
   1780c:	f7ff fdbe 	bl	1738c <LL_USART_EnableDMAReq_TX>

  /* Enable DMA Channel Rx */
  LL_DMA_EnableChannel(TRACER_EMB_DMA_INSTANCE, TRACER_EMB_TX_DMA_CHANNEL);
   17810:	4b05      	ldr	r3, [pc, #20]	; (17828 <HW_TRACER_EMB_SendData+0x68>)
   17812:	2107      	movs	r1, #7
   17814:	0018      	movs	r0, r3
   17816:	f7ff fe1b 	bl	17450 <LL_DMA_EnableChannel>
  txSize = Size;

  /* Enable the TXEIE */
  TRACER_EMB_ENABLE_IT_TXE(TRACER_EMB_USART_INSTANCE);
#endif
}
   1781a:	46c0      	nop			; (mov r8, r8)
   1781c:	46bd      	mov	sp, r7
   1781e:	b002      	add	sp, #8
   17820:	bdb0      	pop	{r4, r5, r7, pc}
   17822:	46c0      	nop			; (mov r8, r8)
   17824:	40004c00 	.word	0x40004c00
   17828:	40020000 	.word	0x40020000

0001782c <USBPD_PE_Init>:
   1782c:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
   1782e:	000d      	movs	r5, r1
   17830:	0017      	movs	r7, r2
   17832:	001e      	movs	r6, r3
   17834:	6869      	ldr	r1, [r5, #4]
   17836:	070a      	lsls	r2, r1, #28
   17838:	0fd2      	lsrs	r2, r2, #31
   1783a:	d002      	beq.n	17842 <USBPD_PE_Init+0x16>
   1783c:	6a71      	ldr	r1, [r6, #36]	; 0x24
   1783e:	2900      	cmp	r1, #0
   17840:	d002      	beq.n	17848 <USBPD_PE_Init+0x1c>
   17842:	6bf1      	ldr	r1, [r6, #60]	; 0x3c
   17844:	2900      	cmp	r1, #0
   17846:	d101      	bne.n	1784c <USBPD_PE_Init+0x20>
   17848:	201b      	movs	r0, #27
   1784a:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   1784c:	4669      	mov	r1, sp
   1784e:	7108      	strb	r0, [r1, #4]
   17850:	4668      	mov	r0, sp
   17852:	7904      	ldrb	r4, [r0, #4]
   17854:	2c08      	cmp	r4, #8
   17856:	d241      	bcs.n	178dc <USBPD_PE_Init+0xb0>
   17858:	20ae      	movs	r0, #174	; 0xae
   1785a:	0080      	lsls	r0, r0, #2
   1785c:	f006 ff10 	bl	1e680 <malloc>
   17860:	498c      	ldr	r1, [pc, #560]	; (17a94 <.text_10>)
   17862:	466a      	mov	r2, sp
   17864:	7912      	ldrb	r2, [r2, #4]
   17866:	0092      	lsls	r2, r2, #2
   17868:	5088      	str	r0, [r1, r2]
   1786a:	2800      	cmp	r0, #0
   1786c:	d101      	bne.n	17872 <USBPD_PE_Init+0x46>
   1786e:	2416      	movs	r4, #22
   17870:	e048      	b.n	17904 <USBPD_PE_Init+0xd8>
   17872:	9002      	str	r0, [sp, #8]
   17874:	21ae      	movs	r1, #174	; 0xae
   17876:	0089      	lsls	r1, r1, #2
   17878:	f006 fece 	bl	1e618 <__aeabi_memclr>
   1787c:	9802      	ldr	r0, [sp, #8]
   1787e:	6005      	str	r5, [r0, #0]
   17880:	9802      	ldr	r0, [sp, #8]
   17882:	6047      	str	r7, [r0, #4]
   17884:	2701      	movs	r7, #1
   17886:	9802      	ldr	r0, [sp, #8]
   17888:	6900      	ldr	r0, [r0, #16]
   1788a:	43b8      	bics	r0, r7
   1788c:	403c      	ands	r4, r7
   1788e:	4304      	orrs	r4, r0
   17890:	9802      	ldr	r0, [sp, #8]
   17892:	6104      	str	r4, [r0, #16]
   17894:	9802      	ldr	r0, [sp, #8]
   17896:	6086      	str	r6, [r0, #8]
   17898:	9802      	ldr	r0, [sp, #8]
   1789a:	497f      	ldr	r1, [pc, #508]	; (17a98 <.text_11>)
   1789c:	1840      	adds	r0, r0, r1
   1789e:	9000      	str	r0, [sp, #0]
   178a0:	9b02      	ldr	r3, [sp, #8]
   178a2:	333c      	adds	r3, #60	; 0x3c
   178a4:	002a      	movs	r2, r5
   178a6:	9802      	ldr	r0, [sp, #8]
   178a8:	21a0      	movs	r1, #160	; 0xa0
   178aa:	0049      	lsls	r1, r1, #1
   178ac:	1841      	adds	r1, r0, r1
   178ae:	4668      	mov	r0, sp
   178b0:	7900      	ldrb	r0, [r0, #4]
   178b2:	f005 fd1f 	bl	1d2f4 <USBPD_PRL_Init>
   178b6:	0004      	movs	r4, r0
   178b8:	d124      	bne.n	17904 <USBPD_PE_Init+0xd8>
   178ba:	9802      	ldr	r0, [sp, #8]
   178bc:	6840      	ldr	r0, [r0, #4]
   178be:	6801      	ldr	r1, [r0, #0]
   178c0:	2603      	movs	r6, #3
   178c2:	9a02      	ldr	r2, [sp, #8]
   178c4:	6812      	ldr	r2, [r2, #0]
   178c6:	6852      	ldr	r2, [r2, #4]
   178c8:	0892      	lsrs	r2, r2, #2
   178ca:	4017      	ands	r7, r2
   178cc:	d008      	beq.n	178e0 <USBPD_PE_Init+0xb4>
   178ce:	2208      	movs	r2, #8
   178d0:	430a      	orrs	r2, r1
   178d2:	6002      	str	r2, [r0, #0]
   178d4:	686b      	ldr	r3, [r5, #4]
   178d6:	4033      	ands	r3, r6
   178d8:	2201      	movs	r2, #1
   178da:	e007      	b.n	178ec <USBPD_PE_Init+0xc0>
   178dc:	2417      	movs	r4, #23
   178de:	e011      	b.n	17904 <USBPD_PE_Init+0xd8>
   178e0:	2208      	movs	r2, #8
   178e2:	4391      	bics	r1, r2
   178e4:	6001      	str	r1, [r0, #0]
   178e6:	686b      	ldr	r3, [r5, #4]
   178e8:	4033      	ands	r3, r6
   178ea:	2200      	movs	r2, #0
   178ec:	4611      	mov	r1, r2
   178ee:	4668      	mov	r0, sp
   178f0:	7900      	ldrb	r0, [r0, #4]
   178f2:	f005 fd54 	bl	1d39e <USBPD_PRL_SetHeader>
   178f6:	6868      	ldr	r0, [r5, #4]
   178f8:	4006      	ands	r6, r0
   178fa:	0031      	movs	r1, r6
   178fc:	4668      	mov	r0, sp
   178fe:	7900      	ldrb	r0, [r0, #4]
   17900:	f005 fda8 	bl	1d454 <USBPD_PRL_CBL_SetHeaderSpecification>
   17904:	0020      	movs	r0, r4
   17906:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

00017908 <USBPD_PE_SetTrace>:
   17908:	0001      	movs	r1, r0
   1790a:	d100      	bne.n	1790e <USBPD_PE_SetTrace+0x6>
   1790c:	4863      	ldr	r0, [pc, #396]	; (17a9c <.text_12>)
   1790e:	4961      	ldr	r1, [pc, #388]	; (17a94 <.text_10>)
   17910:	6208      	str	r0, [r1, #32]
   17912:	4770      	bx	lr

00017914 <USBPD_PE_CheckLIB>:
   17914:	4962      	ldr	r1, [pc, #392]	; (17aa0 <.text_13>)
   17916:	4288      	cmp	r0, r1
   17918:	d101      	bne.n	1791e <USBPD_PE_CheckLIB+0xa>
   1791a:	2001      	movs	r0, #1
   1791c:	4770      	bx	lr
   1791e:	2000      	movs	r0, #0
   17920:	4770      	bx	lr

00017922 <USBPD_PE_GetMemoryConsumption>:
   17922:	b580      	push	{r7, lr}
   17924:	f005 fd38 	bl	1d398 <USBPD_PRL_GetMemoryConsumption>
   17928:	21ae      	movs	r1, #174	; 0xae
   1792a:	0149      	lsls	r1, r1, #5
   1792c:	1840      	adds	r0, r0, r1
   1792e:	bd02      	pop	{r1, pc}

00017930 <USBPD_PE_TimerCounter>:
   17930:	b081      	sub	sp, #4
   17932:	4958      	ldr	r1, [pc, #352]	; (17a94 <.text_10>)
   17934:	0080      	lsls	r0, r0, #2
   17936:	5808      	ldr	r0, [r1, r0]
   17938:	21a5      	movs	r1, #165	; 0xa5
   1793a:	0089      	lsls	r1, r1, #2
   1793c:	1840      	adds	r0, r0, r1
   1793e:	4959      	ldr	r1, [pc, #356]	; (17aa4 <.text_14>)
   17940:	084a      	lsrs	r2, r1, #1
   17942:	8803      	ldrh	r3, [r0, #0]
   17944:	4213      	tst	r3, r2
   17946:	d002      	beq.n	1794e <USBPD_PE_TimerCounter+0x1e>
   17948:	8803      	ldrh	r3, [r0, #0]
   1794a:	185b      	adds	r3, r3, r1
   1794c:	8003      	strh	r3, [r0, #0]
   1794e:	88c3      	ldrh	r3, [r0, #6]
   17950:	4213      	tst	r3, r2
   17952:	d002      	beq.n	1795a <USBPD_PE_TimerCounter+0x2a>
   17954:	88c3      	ldrh	r3, [r0, #6]
   17956:	185b      	adds	r3, r3, r1
   17958:	80c3      	strh	r3, [r0, #6]
   1795a:	8843      	ldrh	r3, [r0, #2]
   1795c:	4213      	tst	r3, r2
   1795e:	d002      	beq.n	17966 <USBPD_PE_TimerCounter+0x36>
   17960:	8843      	ldrh	r3, [r0, #2]
   17962:	185b      	adds	r3, r3, r1
   17964:	8043      	strh	r3, [r0, #2]
   17966:	8903      	ldrh	r3, [r0, #8]
   17968:	4213      	tst	r3, r2
   1796a:	d002      	beq.n	17972 <USBPD_PE_TimerCounter+0x42>
   1796c:	8903      	ldrh	r3, [r0, #8]
   1796e:	185b      	adds	r3, r3, r1
   17970:	8103      	strh	r3, [r0, #8]
   17972:	8883      	ldrh	r3, [r0, #4]
   17974:	4213      	tst	r3, r2
   17976:	d002      	beq.n	1797e <USBPD_PE_TimerCounter+0x4e>
   17978:	8883      	ldrh	r3, [r0, #4]
   1797a:	185b      	adds	r3, r3, r1
   1797c:	8083      	strh	r3, [r0, #4]
   1797e:	8943      	ldrh	r3, [r0, #10]
   17980:	4213      	tst	r3, r2
   17982:	d002      	beq.n	1798a <USBPD_PE_TimerCounter+0x5a>
   17984:	8943      	ldrh	r3, [r0, #10]
   17986:	185b      	adds	r3, r3, r1
   17988:	8143      	strh	r3, [r0, #10]
   1798a:	8983      	ldrh	r3, [r0, #12]
   1798c:	4213      	tst	r3, r2
   1798e:	d002      	beq.n	17996 <USBPD_PE_TimerCounter+0x66>
   17990:	8982      	ldrh	r2, [r0, #12]
   17992:	1851      	adds	r1, r2, r1
   17994:	8181      	strh	r1, [r0, #12]
   17996:	6901      	ldr	r1, [r0, #16]
   17998:	1c49      	adds	r1, r1, #1
   1799a:	6101      	str	r1, [r0, #16]
   1799c:	b001      	add	sp, #4
   1799e:	4770      	bx	lr

000179a0 <USBPD_PE_TimerCounteUpdate>:
   179a0:	b518      	push	{r3, r4, lr}
   179a2:	4a3c      	ldr	r2, [pc, #240]	; (17a94 <.text_10>)
   179a4:	0080      	lsls	r0, r0, #2
   179a6:	5810      	ldr	r0, [r2, r0]
   179a8:	22a5      	movs	r2, #165	; 0xa5
   179aa:	0092      	lsls	r2, r2, #2
   179ac:	1880      	adds	r0, r0, r2
   179ae:	2280      	movs	r2, #128	; 0x80
   179b0:	0212      	lsls	r2, r2, #8
   179b2:	1e53      	subs	r3, r2, #1
   179b4:	8804      	ldrh	r4, [r0, #0]
   179b6:	421c      	tst	r4, r3
   179b8:	d008      	beq.n	179cc <USBPD_PE_TimerCounteUpdate+0x2c>
   179ba:	8804      	ldrh	r4, [r0, #0]
   179bc:	401c      	ands	r4, r3
   179be:	42a1      	cmp	r1, r4
   179c0:	d203      	bcs.n	179ca <USBPD_PE_TimerCounteUpdate+0x2a>
   179c2:	8804      	ldrh	r4, [r0, #0]
   179c4:	1a64      	subs	r4, r4, r1
   179c6:	8004      	strh	r4, [r0, #0]
   179c8:	e000      	b.n	179cc <USBPD_PE_TimerCounteUpdate+0x2c>
   179ca:	8002      	strh	r2, [r0, #0]
   179cc:	88c4      	ldrh	r4, [r0, #6]
   179ce:	421c      	tst	r4, r3
   179d0:	d008      	beq.n	179e4 <USBPD_PE_TimerCounteUpdate+0x44>
   179d2:	88c4      	ldrh	r4, [r0, #6]
   179d4:	401c      	ands	r4, r3
   179d6:	42a1      	cmp	r1, r4
   179d8:	d203      	bcs.n	179e2 <USBPD_PE_TimerCounteUpdate+0x42>
   179da:	88c4      	ldrh	r4, [r0, #6]
   179dc:	1a64      	subs	r4, r4, r1
   179de:	80c4      	strh	r4, [r0, #6]
   179e0:	e000      	b.n	179e4 <USBPD_PE_TimerCounteUpdate+0x44>
   179e2:	80c2      	strh	r2, [r0, #6]
   179e4:	8844      	ldrh	r4, [r0, #2]
   179e6:	421c      	tst	r4, r3
   179e8:	d008      	beq.n	179fc <USBPD_PE_TimerCounteUpdate+0x5c>
   179ea:	8844      	ldrh	r4, [r0, #2]
   179ec:	401c      	ands	r4, r3
   179ee:	42a1      	cmp	r1, r4
   179f0:	d203      	bcs.n	179fa <USBPD_PE_TimerCounteUpdate+0x5a>
   179f2:	8844      	ldrh	r4, [r0, #2]
   179f4:	1a64      	subs	r4, r4, r1
   179f6:	8044      	strh	r4, [r0, #2]
   179f8:	e000      	b.n	179fc <USBPD_PE_TimerCounteUpdate+0x5c>
   179fa:	8042      	strh	r2, [r0, #2]
   179fc:	8904      	ldrh	r4, [r0, #8]
   179fe:	421c      	tst	r4, r3
   17a00:	d008      	beq.n	17a14 <USBPD_PE_TimerCounteUpdate+0x74>
   17a02:	8904      	ldrh	r4, [r0, #8]
   17a04:	401c      	ands	r4, r3
   17a06:	42a1      	cmp	r1, r4
   17a08:	d203      	bcs.n	17a12 <USBPD_PE_TimerCounteUpdate+0x72>
   17a0a:	8904      	ldrh	r4, [r0, #8]
   17a0c:	1a64      	subs	r4, r4, r1
   17a0e:	8104      	strh	r4, [r0, #8]
   17a10:	e000      	b.n	17a14 <USBPD_PE_TimerCounteUpdate+0x74>
   17a12:	8102      	strh	r2, [r0, #8]
   17a14:	8884      	ldrh	r4, [r0, #4]
   17a16:	421c      	tst	r4, r3
   17a18:	d008      	beq.n	17a2c <USBPD_PE_TimerCounteUpdate+0x8c>
   17a1a:	8884      	ldrh	r4, [r0, #4]
   17a1c:	401c      	ands	r4, r3
   17a1e:	42a1      	cmp	r1, r4
   17a20:	d203      	bcs.n	17a2a <USBPD_PE_TimerCounteUpdate+0x8a>
   17a22:	8884      	ldrh	r4, [r0, #4]
   17a24:	1a64      	subs	r4, r4, r1
   17a26:	8084      	strh	r4, [r0, #4]
   17a28:	e000      	b.n	17a2c <USBPD_PE_TimerCounteUpdate+0x8c>
   17a2a:	8082      	strh	r2, [r0, #4]
   17a2c:	8944      	ldrh	r4, [r0, #10]
   17a2e:	421c      	tst	r4, r3
   17a30:	d008      	beq.n	17a44 <USBPD_PE_TimerCounteUpdate+0xa4>
   17a32:	8944      	ldrh	r4, [r0, #10]
   17a34:	401c      	ands	r4, r3
   17a36:	42a1      	cmp	r1, r4
   17a38:	d203      	bcs.n	17a42 <USBPD_PE_TimerCounteUpdate+0xa2>
   17a3a:	8944      	ldrh	r4, [r0, #10]
   17a3c:	1a64      	subs	r4, r4, r1
   17a3e:	8144      	strh	r4, [r0, #10]
   17a40:	e000      	b.n	17a44 <USBPD_PE_TimerCounteUpdate+0xa4>
   17a42:	8142      	strh	r2, [r0, #10]
   17a44:	8984      	ldrh	r4, [r0, #12]
   17a46:	421c      	tst	r4, r3
   17a48:	d006      	beq.n	17a58 <USBPD_PE_TimerCounteUpdate+0xb8>
   17a4a:	8984      	ldrh	r4, [r0, #12]
   17a4c:	4023      	ands	r3, r4
   17a4e:	4299      	cmp	r1, r3
   17a50:	d201      	bcs.n	17a56 <USBPD_PE_TimerCounteUpdate+0xb6>
   17a52:	8982      	ldrh	r2, [r0, #12]
   17a54:	1a52      	subs	r2, r2, r1
   17a56:	8182      	strh	r2, [r0, #12]
   17a58:	6902      	ldr	r2, [r0, #16]
   17a5a:	1851      	adds	r1, r2, r1
   17a5c:	6101      	str	r1, [r0, #16]
   17a5e:	bd11      	pop	{r0, r4, pc}

00017a60 <USBPD_PE_IsCableConnected>:
   17a60:	b538      	push	{r3, r4, r5, lr}
   17a62:	000c      	movs	r4, r1
   17a64:	490b      	ldr	r1, [pc, #44]	; (17a94 <.text_10>)
   17a66:	0082      	lsls	r2, r0, #2
   17a68:	588d      	ldr	r5, [r1, r2]
   17a6a:	2100      	movs	r1, #0
   17a6c:	f004 fa6d 	bl	1bf4a <PE_Reset>
   17a70:	6868      	ldr	r0, [r5, #4]
   17a72:	6801      	ldr	r1, [r0, #0]
   17a74:	2c01      	cmp	r4, #1
   17a76:	d104      	bne.n	17a82 <USBPD_PE_IsCableConnected+0x22>
   17a78:	2280      	movs	r2, #128	; 0x80
   17a7a:	0152      	lsls	r2, r2, #5
   17a7c:	430a      	orrs	r2, r1
   17a7e:	6002      	str	r2, [r0, #0]
   17a80:	e006      	b.n	17a90 <USBPD_PE_IsCableConnected+0x30>
   17a82:	4a09      	ldr	r2, [pc, #36]	; (17aa8 <.text_15>)
   17a84:	400a      	ands	r2, r1
   17a86:	6002      	str	r2, [r0, #0]
   17a88:	2000      	movs	r0, #0
   17a8a:	21a4      	movs	r1, #164	; 0xa4
   17a8c:	0089      	lsls	r1, r1, #2
   17a8e:	5468      	strb	r0, [r5, r1]
   17a90:	2000      	movs	r0, #0
   17a92:	bd32      	pop	{r1, r4, r5, pc}

00017a94 <.text_10>:
   17a94:	0002ff54 	.word	0x0002ff54

00017a98 <.text_11>:
   17a98:	00000262 	.word	0x00000262

00017a9c <.text_12>:
   17a9c:	0001d2c5 	.word	0x0001d2c5

00017aa0 <.text_13>:
   17aa0:	312a0001 	.word	0x312a0001

00017aa4 <.text_14>:
   17aa4:	0000ffff 	.word	0x0000ffff

00017aa8 <.text_15>:
   17aa8:	ffffefff 	.word	0xffffefff

00017aac <USBPD_PE_StateMachine_SRC>:
   17aac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   17aae:	b088      	sub	sp, #32
   17ab0:	0004      	movs	r4, r0
   17ab2:	48bb      	ldr	r0, [pc, #748]	; (17da0 <__iar_annotation$$branch+0x1fc>)
   17ab4:	00a1      	lsls	r1, r4, #2
   17ab6:	5847      	ldr	r7, [r0, r1]
   17ab8:	2500      	movs	r5, #0
   17aba:	20a5      	movs	r0, #165	; 0xa5
   17abc:	0080      	lsls	r0, r0, #2
   17abe:	1838      	adds	r0, r7, r0
   17ac0:	8801      	ldrh	r1, [r0, #0]
   17ac2:	89c0      	ldrh	r0, [r0, #14]
   17ac4:	0502      	lsls	r2, r0, #20
   17ac6:	0f52      	lsrs	r2, r2, #29
   17ac8:	1889      	adds	r1, r1, r2
   17aca:	06c0      	lsls	r0, r0, #27
   17acc:	0ec0      	lsrs	r0, r0, #27
   17ace:	180e      	adds	r6, r1, r0
   17ad0:	b2b6      	uxth	r6, r6
   17ad2:	0038      	movs	r0, r7
   17ad4:	f003 fd9b 	bl	1b60e <PE_Check_RxEvent>
   17ad8:	4669      	mov	r1, sp
   17ada:	7308      	strb	r0, [r1, #12]
   17adc:	4668      	mov	r0, sp
   17ade:	7b00      	ldrb	r0, [r0, #12]
   17ae0:	2803      	cmp	r0, #3
   17ae2:	d001      	beq.n	17ae8 <__iar_annotation$$branch+0x4>

00017ae4 <__iar_annotation$$branch>:
   17ae4:	f000 ff56 	bl	18994 <__iar_annotation$$branch+0x10>
   17ae8:	2001      	movs	r0, #1
   17aea:	e05e      	b.n	17baa <__iar_annotation$$branch+0x6>
   17aec:	a903      	add	r1, sp, #12
   17aee:	0020      	movs	r0, r4
   17af0:	f003 f94a 	bl	1ad88 <PE_StateMachine_VDM>
   17af4:	0005      	movs	r5, r0
   17af6:	48ab      	ldr	r0, [pc, #684]	; (17da4 <__iar_annotation$$branch+0x200>)
   17af8:	1820      	adds	r0, r4, r0
   17afa:	78c2      	ldrb	r2, [r0, #3]
   17afc:	7900      	ldrb	r0, [r0, #4]
   17afe:	4290      	cmp	r0, r2
   17b00:	d00c      	beq.n	17b1c <__iar_annotation$$branch+0x38>
   17b02:	48a8      	ldr	r0, [pc, #672]	; (17da4 <__iar_annotation$$branch+0x200>)
   17b04:	1820      	adds	r0, r4, r0
   17b06:	7102      	strb	r2, [r0, #4]
   17b08:	2000      	movs	r0, #0
   17b0a:	9000      	str	r0, [sp, #0]
   17b0c:	2300      	movs	r3, #0
   17b0e:	6920      	ldr	r0, [r4, #16]
   17b10:	2101      	movs	r1, #1
   17b12:	4001      	ands	r1, r0
   17b14:	2004      	movs	r0, #4
   17b16:	4fa2      	ldr	r7, [pc, #648]	; (17da0 <__iar_annotation$$branch+0x1fc>)
   17b18:	6a3f      	ldr	r7, [r7, #32]
   17b1a:	47b8      	blx	r7
   17b1c:	4668      	mov	r0, sp
   17b1e:	7b00      	ldrb	r0, [r0, #12]
   17b20:	2814      	cmp	r0, #20
   17b22:	d101      	bne.n	17b28 <__iar_annotation$$branch+0x4>

00017b24 <__iar_annotation$$branch>:
   17b24:	f000 fef7 	bl	18916 <__iar_annotation$$branch+0x4>
   17b28:	0020      	movs	r0, r4
   17b2a:	f003 fda2 	bl	1b672 <PE_Check_AMSConflict>
   17b2e:	2815      	cmp	r0, #21
   17b30:	d107      	bne.n	17b42 <__iar_annotation$$branch+0x1e>
   17b32:	2014      	movs	r0, #20
   17b34:	4669      	mov	r1, sp
   17b36:	7308      	strb	r0, [r1, #12]
   17b38:	6921      	ldr	r1, [r4, #16]
   17b3a:	2001      	movs	r0, #1
   17b3c:	4008      	ands	r0, r1
   17b3e:	f005 fe4c 	bl	1d7da <USBPD_PRL_EnableRX>
   17b42:	4898      	ldr	r0, [pc, #608]	; (17da4 <__iar_annotation$$branch+0x200>)
   17b44:	1820      	adds	r0, r4, r0
   17b46:	78c2      	ldrb	r2, [r0, #3]
   17b48:	7901      	ldrb	r1, [r0, #4]
   17b4a:	4291      	cmp	r1, r2
   17b4c:	d00a      	beq.n	17b64 <__iar_annotation$$branch+0x40>
   17b4e:	7102      	strb	r2, [r0, #4]
   17b50:	2000      	movs	r0, #0
   17b52:	9000      	str	r0, [sp, #0]
   17b54:	2300      	movs	r3, #0
   17b56:	6920      	ldr	r0, [r4, #16]
   17b58:	2101      	movs	r1, #1
   17b5a:	4001      	ands	r1, r0
   17b5c:	2004      	movs	r0, #4
   17b5e:	4d90      	ldr	r5, [pc, #576]	; (17da0 <__iar_annotation$$branch+0x1fc>)
   17b60:	6a2d      	ldr	r5, [r5, #32]
   17b62:	47a8      	blx	r5
   17b64:	2500      	movs	r5, #0
   17b66:	9807      	ldr	r0, [sp, #28]
   17b68:	2800      	cmp	r0, #0
   17b6a:	d019      	beq.n	17ba0 <__iar_annotation$$branch+0x7c>
   17b6c:	488c      	ldr	r0, [pc, #560]	; (17da0 <__iar_annotation$$branch+0x1fc>)
   17b6e:	6a41      	ldr	r1, [r0, #36]	; 0x24
   17b70:	4a8d      	ldr	r2, [pc, #564]	; (17da8 <__iar_annotation$$branch+0x204>)
   17b72:	4291      	cmp	r1, r2
   17b74:	d014      	beq.n	17ba0 <__iar_annotation$$branch+0x7c>
   17b76:	6921      	ldr	r1, [r4, #16]
   17b78:	4031      	ands	r1, r6
   17b7a:	0089      	lsls	r1, r1, #2
   17b7c:	5841      	ldr	r1, [r0, r1]
   17b7e:	690a      	ldr	r2, [r1, #16]
   17b80:	0c13      	lsrs	r3, r2, #16
   17b82:	1c5b      	adds	r3, r3, #1
   17b84:	b292      	uxth	r2, r2
   17b86:	041b      	lsls	r3, r3, #16
   17b88:	4313      	orrs	r3, r2
   17b8a:	610b      	str	r3, [r1, #16]
   17b8c:	6921      	ldr	r1, [r4, #16]
   17b8e:	400e      	ands	r6, r1
   17b90:	00b1      	lsls	r1, r6, #2
   17b92:	5840      	ldr	r0, [r0, r1]
   17b94:	6901      	ldr	r1, [r0, #16]
   17b96:	0c0a      	lsrs	r2, r1, #16
   17b98:	2a08      	cmp	r2, #8
   17b9a:	d301      	bcc.n	17ba0 <__iar_annotation$$branch+0x7c>
   17b9c:	b289      	uxth	r1, r1
   17b9e:	6101      	str	r1, [r0, #16]
   17ba0:	2d00      	cmp	r5, #0
   17ba2:	d101      	bne.n	17ba8 <__iar_annotation$$branch+0x4>

00017ba4 <__iar_annotation$$branch>:
   17ba4:	f000 fefb 	bl	1899e <__iar_annotation$$branch+0x1a>
   17ba8:	0028      	movs	r0, r5
   17baa:	b009      	add	sp, #36	; 0x24
   17bac:	bdf0      	pop	{r4, r5, r6, r7, pc}
   17bae:	4668      	mov	r0, sp
   17bb0:	7b40      	ldrb	r0, [r0, #13]
   17bb2:	f005 fe18 	bl	1d7e6 <USBPD_PRL_DisableRX>
   17bb6:	6860      	ldr	r0, [r4, #4]
   17bb8:	6801      	ldr	r1, [r0, #0]
   17bba:	2210      	movs	r2, #16
   17bbc:	4391      	bics	r1, r2
   17bbe:	6001      	str	r1, [r0, #0]
   17bc0:	2501      	movs	r5, #1
   17bc2:	2000      	movs	r0, #0
   17bc4:	9000      	str	r0, [sp, #0]
   17bc6:	2300      	movs	r3, #0
   17bc8:	225f      	movs	r2, #95	; 0x5f
   17bca:	6920      	ldr	r0, [r4, #16]
   17bcc:	2101      	movs	r1, #1
   17bce:	4001      	ands	r1, r0
   17bd0:	2009      	movs	r0, #9
   17bd2:	4e73      	ldr	r6, [pc, #460]	; (17da0 <__iar_annotation$$branch+0x1fc>)
   17bd4:	6a36      	ldr	r6, [r6, #32]
   17bd6:	47b0      	blx	r6
   17bd8:	215f      	movs	r1, #95	; 0x5f
   17bda:	6920      	ldr	r0, [r4, #16]
   17bdc:	4005      	ands	r5, r0
   17bde:	0028      	movs	r0, r5
   17be0:	68a2      	ldr	r2, [r4, #8]
   17be2:	68d2      	ldr	r2, [r2, #12]
   17be4:	4790      	blx	r2
   17be6:	2000      	movs	r0, #0
   17be8:	43c0      	mvns	r0, r0
   17bea:	e7de      	b.n	17baa <__iar_annotation$$branch+0x6>
   17bec:	6860      	ldr	r0, [r4, #4]
   17bee:	6801      	ldr	r1, [r0, #0]
   17bf0:	0b0a      	lsrs	r2, r1, #12
   17bf2:	4032      	ands	r2, r6
   17bf4:	d04d      	beq.n	17c92 <__iar_annotation$$branch+0xee>
   17bf6:	078a      	lsls	r2, r1, #30
   17bf8:	0f92      	lsrs	r2, r2, #30
   17bfa:	2a01      	cmp	r2, #1
   17bfc:	d101      	bne.n	17c02 <__iar_annotation$$branch+0x5e>
   17bfe:	2200      	movs	r2, #0
   17c00:	e000      	b.n	17c04 <__iar_annotation$$branch+0x60>
   17c02:	2201      	movs	r2, #1
   17c04:	2320      	movs	r3, #32
   17c06:	4399      	bics	r1, r3
   17c08:	0152      	lsls	r2, r2, #5
   17c0a:	430a      	orrs	r2, r1
   17c0c:	6002      	str	r2, [r0, #0]
   17c0e:	2000      	movs	r0, #0
   17c10:	7660      	strb	r0, [r4, #25]
   17c12:	6860      	ldr	r0, [r4, #4]
   17c14:	6801      	ldr	r1, [r0, #0]
   17c16:	054a      	lsls	r2, r1, #21
   17c18:	0f52      	lsrs	r2, r2, #29
   17c1a:	2a01      	cmp	r2, #1
   17c1c:	d016      	beq.n	17c4c <__iar_annotation$$branch+0xa8>
   17c1e:	4aad      	ldr	r2, [pc, #692]	; (17ed4 <__iar_annotation$$branch+0x330>)
   17c20:	400a      	ands	r2, r1
   17c22:	00d9      	lsls	r1, r3, #3
   17c24:	4311      	orrs	r1, r2
   17c26:	6001      	str	r1, [r0, #0]
   17c28:	2000      	movs	r0, #0
   17c2a:	9000      	str	r0, [sp, #0]
   17c2c:	2300      	movs	r3, #0
   17c2e:	225a      	movs	r2, #90	; 0x5a
   17c30:	6920      	ldr	r0, [r4, #16]
   17c32:	2101      	movs	r1, #1
   17c34:	4001      	ands	r1, r0
   17c36:	2009      	movs	r0, #9
   17c38:	4f59      	ldr	r7, [pc, #356]	; (17da0 <__iar_annotation$$branch+0x1fc>)
   17c3a:	6a3f      	ldr	r7, [r7, #32]
   17c3c:	47b8      	blx	r7
   17c3e:	215a      	movs	r1, #90	; 0x5a
   17c40:	6922      	ldr	r2, [r4, #16]
   17c42:	2001      	movs	r0, #1
   17c44:	4010      	ands	r0, r2
   17c46:	68a2      	ldr	r2, [r4, #8]
   17c48:	68d2      	ldr	r2, [r2, #12]
   17c4a:	4790      	blx	r2
   17c4c:	6860      	ldr	r0, [r4, #4]
   17c4e:	6800      	ldr	r0, [r0, #0]
   17c50:	0901      	lsrs	r1, r0, #4
   17c52:	4031      	ands	r1, r6
   17c54:	d009      	beq.n	17c6a <__iar_annotation$$branch+0xc6>
   17c56:	48a0      	ldr	r0, [pc, #640]	; (17ed8 <__iar_annotation$$branch+0x334>)
   17c58:	21a5      	movs	r1, #165	; 0xa5
   17c5a:	0089      	lsls	r1, r1, #2
   17c5c:	5260      	strh	r0, [r4, r1]
   17c5e:	2514      	movs	r5, #20
   17c60:	2006      	movs	r0, #6
   17c62:	1fc9      	subs	r1, r1, #7
   17c64:	1861      	adds	r1, r4, r1
   17c66:	70c8      	strb	r0, [r1, #3]
   17c68:	e745      	b.n	17af6 <__iar_annotation$$branch+0x12>
   17c6a:	0bc0      	lsrs	r0, r0, #15
   17c6c:	4030      	ands	r0, r6
   17c6e:	d053      	beq.n	17d18 <__iar_annotation$$branch+0x174>
   17c70:	6820      	ldr	r0, [r4, #0]
   17c72:	6801      	ldr	r1, [r0, #0]
   17c74:	0788      	lsls	r0, r1, #30
   17c76:	d54f      	bpl.n	17d18 <__iar_annotation$$branch+0x174>
   17c78:	68e0      	ldr	r0, [r4, #12]
   17c7a:	2800      	cmp	r0, #0
   17c7c:	d04c      	beq.n	17d18 <__iar_annotation$$branch+0x174>
   17c7e:	4668      	mov	r0, sp
   17c80:	7b40      	ldrb	r0, [r0, #13]
   17c82:	f005 fc11 	bl	1d4a8 <USBPD_PRL_SOPCapability>
   17c86:	7ea0      	ldrb	r0, [r4, #26]
   17c88:	1c40      	adds	r0, r0, #1
   17c8a:	76a0      	strb	r0, [r4, #26]
   17c8c:	2005      	movs	r0, #5
   17c8e:	4945      	ldr	r1, [pc, #276]	; (17da4 <__iar_annotation$$branch+0x200>)
   17c90:	e7e8      	b.n	17c64 <__iar_annotation$$branch+0xc0>
   17c92:	2000      	movs	r0, #0
   17c94:	9000      	str	r0, [sp, #0]
   17c96:	2300      	movs	r3, #0
   17c98:	2221      	movs	r2, #33	; 0x21
   17c9a:	6920      	ldr	r0, [r4, #16]
   17c9c:	2101      	movs	r1, #1
   17c9e:	4001      	ands	r1, r0
   17ca0:	2009      	movs	r0, #9
   17ca2:	4f3f      	ldr	r7, [pc, #252]	; (17da0 <__iar_annotation$$branch+0x1fc>)
   17ca4:	6a3f      	ldr	r7, [r7, #32]
   17ca6:	47b8      	blx	r7
   17ca8:	2121      	movs	r1, #33	; 0x21
   17caa:	6922      	ldr	r2, [r4, #16]
   17cac:	2001      	movs	r0, #1
   17cae:	4010      	ands	r0, r2
   17cb0:	68a2      	ldr	r2, [r4, #8]
   17cb2:	68d2      	ldr	r2, [r2, #12]
   17cb4:	4790      	blx	r2
   17cb6:	e226      	b.n	18106 <__iar_annotation$$branch+0x562>
   17cb8:	a903      	add	r1, sp, #12
   17cba:	0020      	movs	r0, r4
   17cbc:	f002 fef4 	bl	1aaa8 <PE_StateMachine_VDMCable>
   17cc0:	e718      	b.n	17af4 <__iar_annotation$$branch+0x10>
   17cc2:	20a5      	movs	r0, #165	; 0xa5
   17cc4:	0080      	lsls	r0, r0, #2
   17cc6:	5a20      	ldrh	r0, [r4, r0]
   17cc8:	03a9      	lsls	r1, r5, #14
   17cca:	4288      	cmp	r0, r1
   17ccc:	d104      	bne.n	17cd8 <__iar_annotation$$branch+0x134>
   17cce:	2007      	movs	r0, #7
   17cd0:	4934      	ldr	r1, [pc, #208]	; (17da4 <__iar_annotation$$branch+0x200>)
   17cd2:	1861      	adds	r1, r4, r1
   17cd4:	70c8      	strb	r0, [r1, #3]
   17cd6:	2500      	movs	r5, #0
   17cd8:	e70d      	b.n	17af6 <__iar_annotation$$branch+0x12>
   17cda:	0020      	movs	r0, r4
   17cdc:	f000 ff8e 	bl	18bfc <PE_StateMachine_SRC_SendCapa>
   17ce0:	e708      	b.n	17af4 <__iar_annotation$$branch+0x10>
   17ce2:	20a5      	movs	r0, #165	; 0xa5
   17ce4:	0080      	lsls	r0, r0, #2
   17ce6:	1820      	adds	r0, r4, r0
   17ce8:	03a9      	lsls	r1, r5, #14
   17cea:	8882      	ldrh	r2, [r0, #4]
   17cec:	428a      	cmp	r2, r1
   17cee:	d108      	bne.n	17d02 <__iar_annotation$$branch+0x15e>
   17cf0:	2200      	movs	r2, #0
   17cf2:	8082      	strh	r2, [r0, #4]
   17cf4:	7ea2      	ldrb	r2, [r4, #26]
   17cf6:	1c52      	adds	r2, r2, #1
   17cf8:	76a2      	strb	r2, [r4, #26]
   17cfa:	2205      	movs	r2, #5
   17cfc:	4b29      	ldr	r3, [pc, #164]	; (17da4 <__iar_annotation$$branch+0x200>)
   17cfe:	18e3      	adds	r3, r4, r3
   17d00:	70da      	strb	r2, [r3, #3]
   17d02:	8800      	ldrh	r0, [r0, #0]
   17d04:	4288      	cmp	r0, r1
   17d06:	d1e7      	bne.n	17cd8 <__iar_annotation$$branch+0x134>
   17d08:	6820      	ldr	r0, [r4, #0]
   17d0a:	6840      	ldr	r0, [r0, #4]
   17d0c:	09c0      	lsrs	r0, r0, #7
   17d0e:	4030      	ands	r0, r6
   17d10:	d002      	beq.n	17d18 <__iar_annotation$$branch+0x174>
   17d12:	7e60      	ldrb	r0, [r4, #25]
   17d14:	1c40      	adds	r0, r0, #1
   17d16:	7660      	strb	r0, [r4, #25]
   17d18:	2007      	movs	r0, #7
   17d1a:	e7b8      	b.n	17c8e <__iar_annotation$$branch+0xea>
   17d1c:	20a1      	movs	r0, #161	; 0xa1
   17d1e:	0040      	lsls	r0, r0, #1
   17d20:	1820      	adds	r0, r4, r0
   17d22:	7802      	ldrb	r2, [r0, #0]
   17d24:	7843      	ldrb	r3, [r0, #1]
   17d26:	021b      	lsls	r3, r3, #8
   17d28:	18d2      	adds	r2, r2, r3
   17d2a:	7883      	ldrb	r3, [r0, #2]
   17d2c:	041b      	lsls	r3, r3, #16
   17d2e:	18d2      	adds	r2, r2, r3
   17d30:	78c0      	ldrb	r0, [r0, #3]
   17d32:	0600      	lsls	r0, r0, #24
   17d34:	1810      	adds	r0, r2, r0
   17d36:	9000      	str	r0, [sp, #0]
   17d38:	2911      	cmp	r1, #17
   17d3a:	d129      	bne.n	17d90 <__iar_annotation$$branch+0x1ec>
   17d3c:	20a5      	movs	r0, #165	; 0xa5
   17d3e:	0080      	lsls	r0, r0, #2
   17d40:	1820      	adds	r0, r4, r0
   17d42:	89c0      	ldrh	r0, [r0, #14]
   17d44:	0bc1      	lsrs	r1, r0, #15
   17d46:	d123      	bne.n	17d90 <__iar_annotation$$branch+0x1ec>
   17d48:	0b01      	lsrs	r1, r0, #12
   17d4a:	0749      	lsls	r1, r1, #29
   17d4c:	d020      	beq.n	17d90 <__iar_annotation$$branch+0x1ec>
   17d4e:	06c1      	lsls	r1, r0, #27
   17d50:	0ec9      	lsrs	r1, r1, #27
   17d52:	2902      	cmp	r1, #2
   17d54:	d11c      	bne.n	17d90 <__iar_annotation$$branch+0x1ec>
   17d56:	0600      	lsls	r0, r0, #24
   17d58:	0f81      	lsrs	r1, r0, #30
   17d5a:	6922      	ldr	r2, [r4, #16]
   17d5c:	2001      	movs	r0, #1
   17d5e:	4010      	ands	r0, r2
   17d60:	f004 fa4a 	bl	1c1f8 <PE_ExtRevisionInteroperability>
   17d64:	2304      	movs	r3, #4
   17d66:	466a      	mov	r2, sp
   17d68:	2106      	movs	r1, #6
   17d6a:	6925      	ldr	r5, [r4, #16]
   17d6c:	2001      	movs	r0, #1
   17d6e:	4028      	ands	r0, r5
   17d70:	68a5      	ldr	r5, [r4, #8]
   17d72:	69ad      	ldr	r5, [r5, #24]
   17d74:	47a8      	blx	r5
   17d76:	2009      	movs	r0, #9
   17d78:	490a      	ldr	r1, [pc, #40]	; (17da4 <__iar_annotation$$branch+0x200>)
   17d7a:	1861      	adds	r1, r4, r1
   17d7c:	70c8      	strb	r0, [r1, #3]
   17d7e:	2500      	movs	r5, #0
   17d80:	2014      	movs	r0, #20
   17d82:	4669      	mov	r1, sp
   17d84:	7308      	strb	r0, [r1, #12]
   17d86:	6921      	ldr	r1, [r4, #16]
   17d88:	2001      	movs	r0, #1
   17d8a:	4008      	ands	r0, r1
   17d8c:	f005 fd25 	bl	1d7da <USBPD_PRL_EnableRX>
   17d90:	20a5      	movs	r0, #165	; 0xa5
   17d92:	0080      	lsls	r0, r0, #2
   17d94:	5a20      	ldrh	r0, [r4, r0]
   17d96:	03f1      	lsls	r1, r6, #15
   17d98:	4288      	cmp	r0, r1
   17d9a:	d19d      	bne.n	17cd8 <__iar_annotation$$branch+0x134>
   17d9c:	200f      	movs	r0, #15
   17d9e:	e797      	b.n	17cd0 <__iar_annotation$$branch+0x12c>
   17da0:	0002ff54 	.word	0x0002ff54
   17da4:	0000028d 	.word	0x0000028d
   17da8:	b5e8b5cd 	.word	0xb5e8b5cd
   17dac:	0020      	movs	r0, r4
   17dae:	f000 ff8f 	bl	18cd0 <PE_StateMachine_SRC_NegocCapa>
   17db2:	e69f      	b.n	17af4 <__iar_annotation$$branch+0x10>
   17db4:	20a5      	movs	r0, #165	; 0xa5
   17db6:	0080      	lsls	r0, r0, #2
   17db8:	5a20      	ldrh	r0, [r4, r0]
   17dba:	03a9      	lsls	r1, r5, #14
   17dbc:	4288      	cmp	r0, r1
   17dbe:	d162      	bne.n	17e86 <__iar_annotation$$branch+0x2e2>
   17dc0:	6860      	ldr	r0, [r4, #4]
   17dc2:	6801      	ldr	r1, [r0, #0]
   17dc4:	054a      	lsls	r2, r1, #21
   17dc6:	0f52      	lsrs	r2, r2, #29
   17dc8:	2a04      	cmp	r2, #4
   17dca:	d016      	beq.n	17dfa <__iar_annotation$$branch+0x256>
   17dcc:	4a41      	ldr	r2, [pc, #260]	; (17ed4 <__iar_annotation$$branch+0x330>)
   17dce:	400a      	ands	r2, r1
   17dd0:	0269      	lsls	r1, r5, #9
   17dd2:	4311      	orrs	r1, r2
   17dd4:	6001      	str	r1, [r0, #0]
   17dd6:	2000      	movs	r0, #0
   17dd8:	9000      	str	r0, [sp, #0]
   17dda:	2300      	movs	r3, #0
   17ddc:	225a      	movs	r2, #90	; 0x5a
   17dde:	6920      	ldr	r0, [r4, #16]
   17de0:	2101      	movs	r1, #1
   17de2:	4001      	ands	r1, r0
   17de4:	2009      	movs	r0, #9
   17de6:	4fc9      	ldr	r7, [pc, #804]	; (1810c <__iar_annotation$$branch+0x568>)
   17de8:	6a3f      	ldr	r7, [r7, #32]
   17dea:	47b8      	blx	r7
   17dec:	215a      	movs	r1, #90	; 0x5a
   17dee:	6922      	ldr	r2, [r4, #16]
   17df0:	2001      	movs	r0, #1
   17df2:	4010      	ands	r0, r2
   17df4:	68a2      	ldr	r2, [r4, #8]
   17df6:	68d2      	ldr	r2, [r2, #12]
   17df8:	4790      	blx	r2
   17dfa:	68a0      	ldr	r0, [r4, #8]
   17dfc:	6801      	ldr	r1, [r0, #0]
   17dfe:	2900      	cmp	r1, #0
   17e00:	d041      	beq.n	17e86 <__iar_annotation$$branch+0x2e2>
   17e02:	6922      	ldr	r2, [r4, #16]
   17e04:	2001      	movs	r0, #1
   17e06:	4010      	ands	r0, r2
   17e08:	4788      	blx	r1
   17e0a:	2800      	cmp	r0, #0
   17e0c:	d1c6      	bne.n	17d9c <__iar_annotation$$branch+0x1f8>
   17e0e:	200d      	movs	r0, #13
   17e10:	e73d      	b.n	17c8e <__iar_annotation$$branch+0xea>
   17e12:	2000      	movs	r0, #0
   17e14:	9000      	str	r0, [sp, #0]
   17e16:	2303      	movs	r3, #3
   17e18:	2206      	movs	r2, #6
   17e1a:	2100      	movs	r1, #0
   17e1c:	0020      	movs	r0, r4
   17e1e:	f002 fd69 	bl	1a8f4 <PE_Send_CtrlMessage>
   17e22:	2800      	cmp	r0, #0
   17e24:	d12f      	bne.n	17e86 <__iar_annotation$$branch+0x2e2>
   17e26:	6860      	ldr	r0, [r4, #4]
   17e28:	6801      	ldr	r1, [r0, #0]
   17e2a:	054a      	lsls	r2, r1, #21
   17e2c:	0f52      	lsrs	r2, r2, #29
   17e2e:	2a03      	cmp	r2, #3
   17e30:	d017      	beq.n	17e62 <__iar_annotation$$branch+0x2be>
   17e32:	4a28      	ldr	r2, [pc, #160]	; (17ed4 <__iar_annotation$$branch+0x330>)
   17e34:	400a      	ands	r2, r1
   17e36:	21c0      	movs	r1, #192	; 0xc0
   17e38:	0089      	lsls	r1, r1, #2
   17e3a:	4311      	orrs	r1, r2
   17e3c:	6001      	str	r1, [r0, #0]
   17e3e:	2000      	movs	r0, #0
   17e40:	9000      	str	r0, [sp, #0]
   17e42:	2300      	movs	r3, #0
   17e44:	225a      	movs	r2, #90	; 0x5a
   17e46:	6920      	ldr	r0, [r4, #16]
   17e48:	2101      	movs	r1, #1
   17e4a:	4001      	ands	r1, r0
   17e4c:	2009      	movs	r0, #9
   17e4e:	4faf      	ldr	r7, [pc, #700]	; (1810c <__iar_annotation$$branch+0x568>)
   17e50:	6a3f      	ldr	r7, [r7, #32]
   17e52:	47b8      	blx	r7
   17e54:	215a      	movs	r1, #90	; 0x5a
   17e56:	6922      	ldr	r2, [r4, #16]
   17e58:	2001      	movs	r0, #1
   17e5a:	4010      	ands	r0, r2
   17e5c:	68a2      	ldr	r2, [r4, #8]
   17e5e:	68d2      	ldr	r2, [r2, #12]
   17e60:	4790      	blx	r2
   17e62:	2000      	movs	r0, #0
   17e64:	9000      	str	r0, [sp, #0]
   17e66:	2300      	movs	r3, #0
   17e68:	2210      	movs	r2, #16
   17e6a:	6920      	ldr	r0, [r4, #16]
   17e6c:	2101      	movs	r1, #1
   17e6e:	4001      	ands	r1, r0
   17e70:	2009      	movs	r0, #9
   17e72:	4fa6      	ldr	r7, [pc, #664]	; (1810c <__iar_annotation$$branch+0x568>)
   17e74:	6a3f      	ldr	r7, [r7, #32]
   17e76:	47b8      	blx	r7
   17e78:	2110      	movs	r1, #16
   17e7a:	6922      	ldr	r2, [r4, #16]
   17e7c:	2001      	movs	r0, #1
   17e7e:	4010      	ands	r0, r2
   17e80:	68a2      	ldr	r2, [r4, #8]
   17e82:	68d2      	ldr	r2, [r2, #12]
   17e84:	4790      	blx	r2
   17e86:	e636      	b.n	17af6 <__iar_annotation$$branch+0x12>
   17e88:	2500      	movs	r5, #0
   17e8a:	43ed      	mvns	r5, r5
   17e8c:	e633      	b.n	17af6 <__iar_annotation$$branch+0x12>
   17e8e:	9600      	str	r6, [sp, #0]
   17e90:	2397      	movs	r3, #151	; 0x97
   17e92:	2202      	movs	r2, #2
   17e94:	2100      	movs	r1, #0
   17e96:	0020      	movs	r0, r4
   17e98:	f002 fd2c 	bl	1a8f4 <PE_Send_CtrlMessage>
   17e9c:	2800      	cmp	r0, #0
   17e9e:	d1f5      	bne.n	17e8c <__iar_annotation$$branch+0x2e8>
   17ea0:	83a5      	strh	r5, [r4, #28]
   17ea2:	2000      	movs	r0, #0
   17ea4:	9000      	str	r0, [sp, #0]
   17ea6:	2300      	movs	r3, #0
   17ea8:	2229      	movs	r2, #41	; 0x29
   17eaa:	6920      	ldr	r0, [r4, #16]
   17eac:	2101      	movs	r1, #1
   17eae:	4001      	ands	r1, r0
   17eb0:	2009      	movs	r0, #9
   17eb2:	4d96      	ldr	r5, [pc, #600]	; (1810c <__iar_annotation$$branch+0x568>)
   17eb4:	6a2d      	ldr	r5, [r5, #32]
   17eb6:	47a8      	blx	r5
   17eb8:	2129      	movs	r1, #41	; 0x29
   17eba:	6922      	ldr	r2, [r4, #16]
   17ebc:	2001      	movs	r0, #1
   17ebe:	4010      	ands	r0, r2
   17ec0:	68a2      	ldr	r2, [r4, #8]
   17ec2:	68d2      	ldr	r2, [r2, #12]
   17ec4:	4790      	blx	r2
   17ec6:	48aa      	ldr	r0, [pc, #680]	; (18170 <__iar_annotation$$branch+0x5cc>)
   17ec8:	21a5      	movs	r1, #165	; 0xa5
   17eca:	0089      	lsls	r1, r1, #2
   17ecc:	5260      	strh	r0, [r4, r1]
   17ece:	4da9      	ldr	r5, [pc, #676]	; (18174 <__iar_annotation$$branch+0x5d0>)
   17ed0:	e611      	b.n	17af6 <__iar_annotation$$branch+0x12>
   17ed2:	bf00      	nop
   17ed4:	fffff8ff 	.word	0xfffff8ff
   17ed8:	00008014 	.word	0x00008014
   17edc:	20a5      	movs	r0, #165	; 0xa5
   17ede:	0080      	lsls	r0, r0, #2
   17ee0:	5a20      	ldrh	r0, [r4, r0]
   17ee2:	03a9      	lsls	r1, r5, #14
   17ee4:	4288      	cmp	r0, r1
   17ee6:	d1f3      	bne.n	17ed0 <__iar_annotation$$branch+0x32c>
   17ee8:	2000      	movs	r0, #0
   17eea:	9000      	str	r0, [sp, #0]
   17eec:	2300      	movs	r3, #0
   17eee:	222a      	movs	r2, #42	; 0x2a
   17ef0:	6920      	ldr	r0, [r4, #16]
   17ef2:	2101      	movs	r1, #1
   17ef4:	4001      	ands	r1, r0
   17ef6:	2009      	movs	r0, #9
   17ef8:	4f84      	ldr	r7, [pc, #528]	; (1810c <__iar_annotation$$branch+0x568>)
   17efa:	6a3f      	ldr	r7, [r7, #32]
   17efc:	47b8      	blx	r7
   17efe:	212a      	movs	r1, #42	; 0x2a
   17f00:	6922      	ldr	r2, [r4, #16]
   17f02:	2001      	movs	r0, #1
   17f04:	4010      	ands	r0, r2
   17f06:	68a2      	ldr	r2, [r4, #8]
   17f08:	68d2      	ldr	r2, [r2, #12]
   17f0a:	4790      	blx	r2
   17f0c:	2000      	movs	r0, #0
   17f0e:	9000      	str	r0, [sp, #0]
   17f10:	2303      	movs	r3, #3
   17f12:	2206      	movs	r2, #6
   17f14:	2100      	movs	r1, #0
   17f16:	0020      	movs	r0, r4
   17f18:	f002 fcec 	bl	1a8f4 <PE_Send_CtrlMessage>
   17f1c:	2800      	cmp	r0, #0
   17f1e:	d116      	bne.n	17f4e <__iar_annotation$$branch+0x3aa>
   17f20:	9000      	str	r0, [sp, #0]
   17f22:	2300      	movs	r3, #0
   17f24:	222e      	movs	r2, #46	; 0x2e
   17f26:	6920      	ldr	r0, [r4, #16]
   17f28:	2101      	movs	r1, #1
   17f2a:	4001      	ands	r1, r0
   17f2c:	2009      	movs	r0, #9
   17f2e:	4f77      	ldr	r7, [pc, #476]	; (1810c <__iar_annotation$$branch+0x568>)
   17f30:	6a3f      	ldr	r7, [r7, #32]
   17f32:	47b8      	blx	r7
   17f34:	212e      	movs	r1, #46	; 0x2e
   17f36:	e7a0      	b.n	17e7a <__iar_annotation$$branch+0x2d6>
   17f38:	0020      	movs	r0, r4
   17f3a:	f002 fd57 	bl	1a9ec <PE_PerformSoftReset>
   17f3e:	2000      	movs	r0, #0
   17f40:	9000      	str	r0, [sp, #0]
   17f42:	2307      	movs	r3, #7
   17f44:	2203      	movs	r2, #3
   17f46:	2100      	movs	r1, #0
   17f48:	0020      	movs	r0, r4
   17f4a:	f002 fcd3 	bl	1a8f4 <PE_Send_CtrlMessage>
   17f4e:	e5d2      	b.n	17af6 <__iar_annotation$$branch+0x12>
   17f50:	2000      	movs	r0, #0
   17f52:	9000      	str	r0, [sp, #0]
   17f54:	2312      	movs	r3, #18
   17f56:	220d      	movs	r2, #13
   17f58:	4887      	ldr	r0, [pc, #540]	; (18178 <__iar_annotation$$branch+0x5d4>)
   17f5a:	1820      	adds	r0, r4, r0
   17f5c:	7981      	ldrb	r1, [r0, #6]
   17f5e:	0020      	movs	r0, r4
   17f60:	f002 fcc8 	bl	1a8f4 <PE_Send_CtrlMessage>
   17f64:	2800      	cmp	r0, #0
   17f66:	d1f2      	bne.n	17f4e <__iar_annotation$$branch+0x3aa>
   17f68:	20a5      	movs	r0, #165	; 0xa5
   17f6a:	0080      	lsls	r0, r0, #2
   17f6c:	5227      	strh	r7, [r4, r0]
   17f6e:	2518      	movs	r5, #24
   17f70:	2000      	movs	r0, #0
   17f72:	9000      	str	r0, [sp, #0]
   17f74:	2300      	movs	r3, #0
   17f76:	2230      	movs	r2, #48	; 0x30
   17f78:	6920      	ldr	r0, [r4, #16]
   17f7a:	2101      	movs	r1, #1
   17f7c:	4001      	ands	r1, r0
   17f7e:	2009      	movs	r0, #9
   17f80:	4f62      	ldr	r7, [pc, #392]	; (1810c <__iar_annotation$$branch+0x568>)
   17f82:	6a3f      	ldr	r7, [r7, #32]
   17f84:	47b8      	blx	r7
   17f86:	2130      	movs	r1, #48	; 0x30
   17f88:	e777      	b.n	17e7a <__iar_annotation$$branch+0x2d6>
   17f8a:	2911      	cmp	r1, #17
   17f8c:	d125      	bne.n	17fda <__iar_annotation$$branch+0x436>
   17f8e:	20a5      	movs	r0, #165	; 0xa5
   17f90:	0080      	lsls	r0, r0, #2
   17f92:	1820      	adds	r0, r4, r0
   17f94:	89c0      	ldrh	r0, [r0, #14]
   17f96:	4979      	ldr	r1, [pc, #484]	; (1817c <__iar_annotation$$branch+0x5d8>)
   17f98:	4001      	ands	r1, r0
   17f9a:	2903      	cmp	r1, #3
   17f9c:	d11d      	bne.n	17fda <__iar_annotation$$branch+0x436>
   17f9e:	2000      	movs	r0, #0
   17fa0:	9000      	str	r0, [sp, #0]
   17fa2:	2300      	movs	r3, #0
   17fa4:	2231      	movs	r2, #49	; 0x31
   17fa6:	6920      	ldr	r0, [r4, #16]
   17fa8:	2101      	movs	r1, #1
   17faa:	4001      	ands	r1, r0
   17fac:	2009      	movs	r0, #9
   17fae:	4f57      	ldr	r7, [pc, #348]	; (1810c <__iar_annotation$$branch+0x568>)
   17fb0:	6a3f      	ldr	r7, [r7, #32]
   17fb2:	47b8      	blx	r7
   17fb4:	2131      	movs	r1, #49	; 0x31
   17fb6:	6922      	ldr	r2, [r4, #16]
   17fb8:	2001      	movs	r0, #1
   17fba:	4010      	ands	r0, r2
   17fbc:	68a2      	ldr	r2, [r4, #8]
   17fbe:	68d2      	ldr	r2, [r2, #12]
   17fc0:	4790      	blx	r2
   17fc2:	2007      	movs	r0, #7
   17fc4:	496c      	ldr	r1, [pc, #432]	; (18178 <__iar_annotation$$branch+0x5d4>)
   17fc6:	1861      	adds	r1, r4, r1
   17fc8:	70c8      	strb	r0, [r1, #3]
   17fca:	2014      	movs	r0, #20
   17fcc:	4669      	mov	r1, sp
   17fce:	7308      	strb	r0, [r1, #12]
   17fd0:	6921      	ldr	r1, [r4, #16]
   17fd2:	2001      	movs	r0, #1
   17fd4:	4008      	ands	r0, r1
   17fd6:	f005 fc00 	bl	1d7da <USBPD_PRL_EnableRX>
   17fda:	20a5      	movs	r0, #165	; 0xa5
   17fdc:	0080      	lsls	r0, r0, #2
   17fde:	5a20      	ldrh	r0, [r4, r0]
   17fe0:	03a9      	lsls	r1, r5, #14
   17fe2:	4288      	cmp	r0, r1
   17fe4:	d124      	bne.n	18030 <__iar_annotation$$branch+0x48c>
   17fe6:	e6d9      	b.n	17d9c <__iar_annotation$$branch+0x1f8>
   17fe8:	2105      	movs	r1, #5
   17fea:	0020      	movs	r0, r4
   17fec:	f002 fd10 	bl	1aa10 <PE_Send_RESET>
   17ff0:	6860      	ldr	r0, [r4, #4]
   17ff2:	6801      	ldr	r1, [r0, #0]
   17ff4:	2210      	movs	r2, #16
   17ff6:	4391      	bics	r1, r2
   17ff8:	6001      	str	r1, [r0, #0]
   17ffa:	7e20      	ldrb	r0, [r4, #24]
   17ffc:	1c40      	adds	r0, r0, #1
   17ffe:	7620      	strb	r0, [r4, #24]
   18000:	6920      	ldr	r0, [r4, #16]
   18002:	4b5f      	ldr	r3, [pc, #380]	; (18180 <__iar_annotation$$branch+0x5dc>)
   18004:	4003      	ands	r3, r0
   18006:	6123      	str	r3, [r4, #16]
   18008:	485b      	ldr	r0, [pc, #364]	; (18178 <__iar_annotation$$branch+0x5d4>)
   1800a:	1827      	adds	r7, r4, r0
   1800c:	2000      	movs	r0, #0
   1800e:	7038      	strb	r0, [r7, #0]
   18010:	68a0      	ldr	r0, [r4, #8]
   18012:	6845      	ldr	r5, [r0, #4]
   18014:	2d00      	cmp	r5, #0
   18016:	d004      	beq.n	18022 <__iar_annotation$$branch+0x47e>
   18018:	2202      	movs	r2, #2
   1801a:	2101      	movs	r1, #1
   1801c:	2001      	movs	r0, #1
   1801e:	4018      	ands	r0, r3
   18020:	47a8      	blx	r5
   18022:	4858      	ldr	r0, [pc, #352]	; (18184 <__iar_annotation$$branch+0x5e0>)
   18024:	21a5      	movs	r1, #165	; 0xa5
   18026:	0089      	lsls	r1, r1, #2
   18028:	5260      	strh	r0, [r4, r1]
   1802a:	251b      	movs	r5, #27
   1802c:	2015      	movs	r0, #21
   1802e:	70f8      	strb	r0, [r7, #3]
   18030:	e561      	b.n	17af6 <__iar_annotation$$branch+0x12>
   18032:	1cf8      	adds	r0, r7, #3
   18034:	21a5      	movs	r1, #165	; 0xa5
   18036:	0089      	lsls	r1, r1, #2
   18038:	5260      	strh	r0, [r4, r1]
   1803a:	251b      	movs	r5, #27
   1803c:	2015      	movs	r0, #21
   1803e:	1fc9      	subs	r1, r1, #7
   18040:	1861      	adds	r1, r4, r1
   18042:	70c8      	strb	r0, [r1, #3]
   18044:	2000      	movs	r0, #0
   18046:	9000      	str	r0, [sp, #0]
   18048:	2300      	movs	r3, #0
   1804a:	221e      	movs	r2, #30
   1804c:	6920      	ldr	r0, [r4, #16]
   1804e:	2101      	movs	r1, #1
   18050:	4001      	ands	r1, r0
   18052:	2009      	movs	r0, #9
   18054:	4f2d      	ldr	r7, [pc, #180]	; (1810c <__iar_annotation$$branch+0x568>)
   18056:	6a3f      	ldr	r7, [r7, #32]
   18058:	47b8      	blx	r7
   1805a:	211e      	movs	r1, #30
   1805c:	e70d      	b.n	17e7a <__iar_annotation$$branch+0x2d6>
   1805e:	20a5      	movs	r0, #165	; 0xa5
   18060:	0080      	lsls	r0, r0, #2
   18062:	1820      	adds	r0, r4, r0
   18064:	8801      	ldrh	r1, [r0, #0]
   18066:	03aa      	lsls	r2, r5, #14
   18068:	4291      	cmp	r1, r2
   1806a:	d1e1      	bne.n	18030 <__iar_annotation$$branch+0x48c>
   1806c:	7e21      	ldrb	r1, [r4, #24]
   1806e:	2903      	cmp	r1, #3
   18070:	d241      	bcs.n	180f6 <__iar_annotation$$branch+0x552>
   18072:	4945      	ldr	r1, [pc, #276]	; (18188 <__iar_annotation$$branch+0x5e4>)
   18074:	8001      	strh	r1, [r0, #0]
   18076:	2017      	movs	r0, #23
   18078:	493f      	ldr	r1, [pc, #252]	; (18178 <__iar_annotation$$branch+0x5d4>)
   1807a:	1861      	adds	r1, r4, r1
   1807c:	70c8      	strb	r0, [r1, #3]
   1807e:	2500      	movs	r5, #0
   18080:	68a0      	ldr	r0, [r4, #8]
   18082:	6843      	ldr	r3, [r0, #4]
   18084:	2b00      	cmp	r3, #0
   18086:	d013      	beq.n	180b0 <__iar_annotation$$branch+0x50c>
   18088:	6927      	ldr	r7, [r4, #16]
   1808a:	05b8      	lsls	r0, r7, #22
   1808c:	0f80      	lsrs	r0, r0, #30
   1808e:	1e42      	subs	r2, r0, #1
   18090:	4192      	sbcs	r2, r2
   18092:	0fd2      	lsrs	r2, r2, #31
   18094:	2101      	movs	r1, #1
   18096:	2001      	movs	r0, #1
   18098:	4038      	ands	r0, r7
   1809a:	4798      	blx	r3
   1809c:	68a0      	ldr	r0, [r4, #8]
   1809e:	6843      	ldr	r3, [r0, #4]
   180a0:	2b00      	cmp	r3, #0
   180a2:	d005      	beq.n	180b0 <__iar_annotation$$branch+0x50c>
   180a4:	2203      	movs	r2, #3
   180a6:	2101      	movs	r1, #1
   180a8:	6927      	ldr	r7, [r4, #16]
   180aa:	2001      	movs	r0, #1
   180ac:	4038      	ands	r0, r7
   180ae:	4798      	blx	r3
   180b0:	e521      	b.n	17af6 <__iar_annotation$$branch+0x12>
   180b2:	2100      	movs	r1, #0
   180b4:	4668      	mov	r0, sp
   180b6:	7b40      	ldrb	r0, [r0, #13]
   180b8:	68a2      	ldr	r2, [r4, #8]
   180ba:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
   180bc:	4790      	blx	r2
   180be:	2801      	cmp	r0, #1
   180c0:	d109      	bne.n	180d6 <__iar_annotation$$branch+0x532>
   180c2:	48c1      	ldr	r0, [pc, #772]	; (183c8 <__iar_annotation$$branch+0x824>)
   180c4:	21a5      	movs	r1, #165	; 0xa5
   180c6:	0089      	lsls	r1, r1, #2
   180c8:	5260      	strh	r0, [r4, r1]
   180ca:	25c8      	movs	r5, #200	; 0xc8
   180cc:	00ad      	lsls	r5, r5, #2
   180ce:	2013      	movs	r0, #19
   180d0:	1fc9      	subs	r1, r1, #7
   180d2:	1861      	adds	r1, r4, r1
   180d4:	70c8      	strb	r0, [r1, #3]
   180d6:	20a5      	movs	r0, #165	; 0xa5
   180d8:	0080      	lsls	r0, r0, #2
   180da:	5a20      	ldrh	r0, [r4, r0]
   180dc:	03f1      	lsls	r1, r6, #15
   180de:	4288      	cmp	r0, r1
   180e0:	d1e6      	bne.n	180b0 <__iar_annotation$$branch+0x50c>
   180e2:	68a0      	ldr	r0, [r4, #8]
   180e4:	6843      	ldr	r3, [r0, #4]
   180e6:	2b00      	cmp	r3, #0
   180e8:	d005      	beq.n	180f6 <__iar_annotation$$branch+0x552>
   180ea:	2206      	movs	r2, #6
   180ec:	2101      	movs	r1, #1
   180ee:	6927      	ldr	r7, [r4, #16]
   180f0:	2001      	movs	r0, #1
   180f2:	4038      	ands	r0, r7
   180f4:	4798      	blx	r3
   180f6:	6920      	ldr	r0, [r4, #16]
   180f8:	0840      	lsrs	r0, r0, #1
   180fa:	4030      	ands	r0, r6
   180fc:	d003      	beq.n	18106 <__iar_annotation$$branch+0x562>
   180fe:	68a0      	ldr	r0, [r4, #8]
   18100:	6b40      	ldr	r0, [r0, #52]	; 0x34
   18102:	2800      	cmp	r0, #0
   18104:	d14d      	bne.n	181a2 <__iar_annotation$$branch+0x5fe>
   18106:	2000      	movs	r0, #0
   18108:	e5c1      	b.n	17c8e <__iar_annotation$$branch+0xea>
   1810a:	bf00      	nop
   1810c:	0002ff54 	.word	0x0002ff54
   18110:	20a5      	movs	r0, #165	; 0xa5
   18112:	0080      	lsls	r0, r0, #2
   18114:	5a20      	ldrh	r0, [r4, r0]
   18116:	03a9      	lsls	r1, r5, #14
   18118:	4288      	cmp	r0, r1
   1811a:	d127      	bne.n	1816c <__iar_annotation$$branch+0x5c8>
   1811c:	68a0      	ldr	r0, [r4, #8]
   1811e:	6843      	ldr	r3, [r0, #4]
   18120:	2b00      	cmp	r3, #0
   18122:	d005      	beq.n	18130 <__iar_annotation$$branch+0x58c>
   18124:	2204      	movs	r2, #4
   18126:	2101      	movs	r1, #1
   18128:	6927      	ldr	r7, [r4, #16]
   1812a:	2001      	movs	r0, #1
   1812c:	4038      	ands	r0, r7
   1812e:	4798      	blx	r3
   18130:	2101      	movs	r1, #1
   18132:	4668      	mov	r0, sp
   18134:	7b40      	ldrb	r0, [r0, #13]
   18136:	68a2      	ldr	r2, [r4, #8]
   18138:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
   1813a:	4790      	blx	r2
   1813c:	2801      	cmp	r0, #1
   1813e:	68a0      	ldr	r0, [r4, #8]
   18140:	6843      	ldr	r3, [r0, #4]
   18142:	d123      	bne.n	1818c <__iar_annotation$$branch+0x5e8>
   18144:	2b00      	cmp	r3, #0
   18146:	d005      	beq.n	18154 <__iar_annotation$$branch+0x5b0>
   18148:	2205      	movs	r2, #5
   1814a:	2101      	movs	r1, #1
   1814c:	6927      	ldr	r7, [r4, #16]
   1814e:	2001      	movs	r0, #1
   18150:	4038      	ands	r0, r7
   18152:	4798      	blx	r3
   18154:	2101      	movs	r1, #1
   18156:	4668      	mov	r0, sp
   18158:	7b40      	ldrb	r0, [r0, #13]
   1815a:	f003 fef6 	bl	1bf4a <PE_Reset>
   1815e:	4668      	mov	r0, sp
   18160:	7b40      	ldrb	r0, [r0, #13]
   18162:	f005 fd85 	bl	1dc70 <USBPD_PRL_PowerSinkReset>
   18166:	4904      	ldr	r1, [pc, #16]	; (18178 <__iar_annotation$$branch+0x5d4>)
   18168:	1861      	adds	r1, r4, r1
   1816a:	70cd      	strb	r5, [r1, #3]
   1816c:	e4c3      	b.n	17af6 <__iar_annotation$$branch+0x12>
   1816e:	bf00      	nop
   18170:	00008226 	.word	0x00008226
   18174:	00000226 	.word	0x00000226
   18178:	0000028d 	.word	0x0000028d
   1817c:	0000f01f 	.word	0x0000f01f
   18180:	fffffcff 	.word	0xfffffcff
   18184:	0000801b 	.word	0x0000801b
   18188:	0000828a 	.word	0x0000828a
   1818c:	2b00      	cmp	r3, #0
   1818e:	d005      	beq.n	1819c <__iar_annotation$$branch+0x5f8>
   18190:	2206      	movs	r2, #6
   18192:	2101      	movs	r1, #1
   18194:	6925      	ldr	r5, [r4, #16]
   18196:	2001      	movs	r0, #1
   18198:	4028      	ands	r0, r5
   1819a:	4798      	blx	r3
   1819c:	68a0      	ldr	r0, [r4, #8]
   1819e:	6b40      	ldr	r0, [r0, #52]	; 0x34
   181a0:	2800      	cmp	r0, #0
   181a2:	d000      	beq.n	181a6 <__iar_annotation$$branch+0x602>
   181a4:	e25f      	b.n	18666 <__iar_annotation$$branch+0xac2>
   181a6:	2500      	movs	r5, #0
   181a8:	e7dd      	b.n	18166 <__iar_annotation$$branch+0x5c2>
   181aa:	9600      	str	r6, [sp, #0]
   181ac:	231b      	movs	r3, #27
   181ae:	2207      	movs	r2, #7
   181b0:	2100      	movs	r1, #0
   181b2:	0020      	movs	r0, r4
   181b4:	f002 fb9e 	bl	1a8f4 <PE_Send_CtrlMessage>
   181b8:	2800      	cmp	r0, #0
   181ba:	d1d7      	bne.n	1816c <__iar_annotation$$branch+0x5c8>
   181bc:	2006      	movs	r0, #6
   181be:	83a0      	strh	r0, [r4, #28]
   181c0:	20a5      	movs	r0, #165	; 0xa5
   181c2:	0080      	lsls	r0, r0, #2
   181c4:	5227      	strh	r7, [r4, r0]
   181c6:	2518      	movs	r5, #24
   181c8:	2000      	movs	r0, #0
   181ca:	9000      	str	r0, [sp, #0]
   181cc:	2300      	movs	r3, #0
   181ce:	220b      	movs	r2, #11
   181d0:	6920      	ldr	r0, [r4, #16]
   181d2:	2101      	movs	r1, #1
   181d4:	4001      	ands	r1, r0
   181d6:	2009      	movs	r0, #9
   181d8:	4fce      	ldr	r7, [pc, #824]	; (18514 <__iar_annotation$$branch+0x970>)
   181da:	6a3f      	ldr	r7, [r7, #32]
   181dc:	47b8      	blx	r7
   181de:	210b      	movs	r1, #11
   181e0:	e64b      	b.n	17e7a <__iar_annotation$$branch+0x2d6>
   181e2:	2911      	cmp	r1, #17
   181e4:	d161      	bne.n	182aa <__iar_annotation$$branch+0x706>
   181e6:	20a5      	movs	r0, #165	; 0xa5
   181e8:	0080      	lsls	r0, r0, #2
   181ea:	1820      	adds	r0, r4, r0
   181ec:	89c0      	ldrh	r0, [r0, #14]
   181ee:	0bc1      	lsrs	r1, r0, #15
   181f0:	d12f      	bne.n	18252 <__iar_annotation$$branch+0x6ae>
   181f2:	0441      	lsls	r1, r0, #17
   181f4:	0f49      	lsrs	r1, r1, #29
   181f6:	d02c      	beq.n	18252 <__iar_annotation$$branch+0x6ae>
   181f8:	06c0      	lsls	r0, r0, #27
   181fa:	0ec0      	lsrs	r0, r0, #27
   181fc:	2801      	cmp	r0, #1
   181fe:	d128      	bne.n	18252 <__iar_annotation$$branch+0x6ae>
   18200:	008b      	lsls	r3, r1, #2
   18202:	20a1      	movs	r0, #161	; 0xa1
   18204:	0040      	lsls	r0, r0, #1
   18206:	1822      	adds	r2, r4, r0
   18208:	2104      	movs	r1, #4
   1820a:	6925      	ldr	r5, [r4, #16]
   1820c:	2001      	movs	r0, #1
   1820e:	4028      	ands	r0, r5
   18210:	68a5      	ldr	r5, [r4, #8]
   18212:	69ad      	ldr	r5, [r5, #24]
   18214:	47a8      	blx	r5
   18216:	2003      	movs	r0, #3
   18218:	49bf      	ldr	r1, [pc, #764]	; (18518 <__iar_annotation$$branch+0x974>)
   1821a:	1861      	adds	r1, r4, r1
   1821c:	70c8      	strb	r0, [r1, #3]
   1821e:	2500      	movs	r5, #0
   18220:	2014      	movs	r0, #20
   18222:	4669      	mov	r1, sp
   18224:	7308      	strb	r0, [r1, #12]
   18226:	6921      	ldr	r1, [r4, #16]
   18228:	2001      	movs	r0, #1
   1822a:	4008      	ands	r0, r1
   1822c:	f005 fad5 	bl	1d7da <USBPD_PRL_EnableRX>
   18230:	9500      	str	r5, [sp, #0]
   18232:	2300      	movs	r3, #0
   18234:	220d      	movs	r2, #13
   18236:	6920      	ldr	r0, [r4, #16]
   18238:	2101      	movs	r1, #1
   1823a:	4001      	ands	r1, r0
   1823c:	2009      	movs	r0, #9
   1823e:	4fb5      	ldr	r7, [pc, #724]	; (18514 <__iar_annotation$$branch+0x970>)
   18240:	6a3f      	ldr	r7, [r7, #32]
   18242:	47b8      	blx	r7
   18244:	210d      	movs	r1, #13
   18246:	6922      	ldr	r2, [r4, #16]
   18248:	2001      	movs	r0, #1
   1824a:	4010      	ands	r0, r2
   1824c:	68a2      	ldr	r2, [r4, #8]
   1824e:	68d2      	ldr	r2, [r2, #12]
   18250:	4790      	blx	r2
   18252:	20a5      	movs	r0, #165	; 0xa5
   18254:	0080      	lsls	r0, r0, #2
   18256:	1820      	adds	r0, r4, r0
   18258:	89c0      	ldrh	r0, [r0, #14]
   1825a:	21f0      	movs	r1, #240	; 0xf0
   1825c:	0209      	lsls	r1, r1, #8
   1825e:	4001      	ands	r1, r0
   18260:	d123      	bne.n	182aa <__iar_annotation$$branch+0x706>
   18262:	06c0      	lsls	r0, r0, #27
   18264:	0ec0      	lsrs	r0, r0, #27
   18266:	2804      	cmp	r0, #4
   18268:	d001      	beq.n	1826e <__iar_annotation$$branch+0x6ca>
   1826a:	2810      	cmp	r0, #16
   1826c:	d11d      	bne.n	182aa <__iar_annotation$$branch+0x706>
   1826e:	2003      	movs	r0, #3
   18270:	49a9      	ldr	r1, [pc, #676]	; (18518 <__iar_annotation$$branch+0x974>)
   18272:	1861      	adds	r1, r4, r1
   18274:	70c8      	strb	r0, [r1, #3]
   18276:	2500      	movs	r5, #0
   18278:	2014      	movs	r0, #20
   1827a:	4669      	mov	r1, sp
   1827c:	7308      	strb	r0, [r1, #12]
   1827e:	6921      	ldr	r1, [r4, #16]
   18280:	2001      	movs	r0, #1
   18282:	4008      	ands	r0, r1
   18284:	f005 faa9 	bl	1d7da <USBPD_PRL_EnableRX>
   18288:	9500      	str	r5, [sp, #0]
   1828a:	2300      	movs	r3, #0
   1828c:	220e      	movs	r2, #14
   1828e:	6920      	ldr	r0, [r4, #16]
   18290:	2101      	movs	r1, #1
   18292:	4001      	ands	r1, r0
   18294:	2009      	movs	r0, #9
   18296:	4f9f      	ldr	r7, [pc, #636]	; (18514 <__iar_annotation$$branch+0x970>)
   18298:	6a3f      	ldr	r7, [r7, #32]
   1829a:	47b8      	blx	r7
   1829c:	210e      	movs	r1, #14
   1829e:	6922      	ldr	r2, [r4, #16]
   182a0:	2001      	movs	r0, #1
   182a2:	4010      	ands	r0, r2
   182a4:	68a2      	ldr	r2, [r4, #8]
   182a6:	68d2      	ldr	r2, [r2, #12]
   182a8:	4790      	blx	r2
   182aa:	20a5      	movs	r0, #165	; 0xa5
   182ac:	0080      	lsls	r0, r0, #2
   182ae:	5a20      	ldrh	r0, [r4, r0]
   182b0:	03f1      	lsls	r1, r6, #15
   182b2:	4288      	cmp	r0, r1
   182b4:	d000      	beq.n	182b8 <__iar_annotation$$branch+0x714>
   182b6:	e41e      	b.n	17af6 <__iar_annotation$$branch+0x12>
   182b8:	2003      	movs	r0, #3
   182ba:	e509      	b.n	17cd0 <__iar_annotation$$branch+0x12c>
   182bc:	68a0      	ldr	r0, [r4, #8]
   182be:	6881      	ldr	r1, [r0, #8]
   182c0:	2900      	cmp	r1, #0
   182c2:	d025      	beq.n	18310 <__iar_annotation$$branch+0x76c>
   182c4:	6922      	ldr	r2, [r4, #16]
   182c6:	2001      	movs	r0, #1
   182c8:	4010      	ands	r0, r2
   182ca:	4788      	blx	r1
   182cc:	280a      	cmp	r0, #10
   182ce:	d002      	beq.n	182d6 <__iar_annotation$$branch+0x732>
   182d0:	280d      	cmp	r0, #13
   182d2:	d018      	beq.n	18306 <__iar_annotation$$branch+0x762>
   182d4:	e01c      	b.n	18310 <__iar_annotation$$branch+0x76c>
   182d6:	4891      	ldr	r0, [pc, #580]	; (1851c <__iar_annotation$$branch+0x978>)
   182d8:	21a5      	movs	r1, #165	; 0xa5
   182da:	0089      	lsls	r1, r1, #2
   182dc:	5260      	strh	r0, [r4, r1]
   182de:	251e      	movs	r5, #30
   182e0:	2000      	movs	r0, #0
   182e2:	9000      	str	r0, [sp, #0]
   182e4:	2324      	movs	r3, #36	; 0x24
   182e6:	2203      	movs	r2, #3
   182e8:	2100      	movs	r1, #0
   182ea:	0020      	movs	r0, r4
   182ec:	f002 fb02 	bl	1a8f4 <PE_Send_CtrlMessage>
   182f0:	2800      	cmp	r0, #0
   182f2:	d1df      	bne.n	182b4 <__iar_annotation$$branch+0x710>
   182f4:	2201      	movs	r2, #1
   182f6:	2101      	movs	r1, #1
   182f8:	6923      	ldr	r3, [r4, #16]
   182fa:	2001      	movs	r0, #1
   182fc:	4018      	ands	r0, r3
   182fe:	68a3      	ldr	r3, [r4, #8]
   18300:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   18302:	4798      	blx	r3
   18304:	e732      	b.n	1816c <__iar_annotation$$branch+0x5c8>
   18306:	2000      	movs	r0, #0
   18308:	9000      	str	r0, [sp, #0]
   1830a:	2303      	movs	r3, #3
   1830c:	220c      	movs	r2, #12
   1830e:	e61a      	b.n	17f46 <__iar_annotation$$branch+0x3a2>
   18310:	2000      	movs	r0, #0
   18312:	9000      	str	r0, [sp, #0]
   18314:	2303      	movs	r3, #3
   18316:	2204      	movs	r2, #4
   18318:	e615      	b.n	17f46 <__iar_annotation$$branch+0x3a2>
   1831a:	20a5      	movs	r0, #165	; 0xa5
   1831c:	0080      	lsls	r0, r0, #2
   1831e:	5a20      	ldrh	r0, [r4, r0]
   18320:	03a9      	lsls	r1, r5, #14
   18322:	4288      	cmp	r0, r1
   18324:	d1c6      	bne.n	182b4 <__iar_annotation$$branch+0x710>
   18326:	6860      	ldr	r0, [r4, #4]
   18328:	6801      	ldr	r1, [r0, #0]
   1832a:	054a      	lsls	r2, r1, #21
   1832c:	0f52      	lsrs	r2, r2, #29
   1832e:	2a04      	cmp	r2, #4
   18330:	d016      	beq.n	18360 <__iar_annotation$$branch+0x7bc>
   18332:	4ace      	ldr	r2, [pc, #824]	; (1866c <__iar_annotation$$branch+0xac8>)
   18334:	400a      	ands	r2, r1
   18336:	0269      	lsls	r1, r5, #9
   18338:	4311      	orrs	r1, r2
   1833a:	6001      	str	r1, [r0, #0]
   1833c:	2000      	movs	r0, #0
   1833e:	9000      	str	r0, [sp, #0]
   18340:	2300      	movs	r3, #0
   18342:	225a      	movs	r2, #90	; 0x5a
   18344:	6920      	ldr	r0, [r4, #16]
   18346:	2101      	movs	r1, #1
   18348:	4001      	ands	r1, r0
   1834a:	2009      	movs	r0, #9
   1834c:	4f71      	ldr	r7, [pc, #452]	; (18514 <__iar_annotation$$branch+0x970>)
   1834e:	6a3f      	ldr	r7, [r7, #32]
   18350:	47b8      	blx	r7
   18352:	215a      	movs	r1, #90	; 0x5a
   18354:	6922      	ldr	r2, [r4, #16]
   18356:	2001      	movs	r0, #1
   18358:	4010      	ands	r0, r2
   1835a:	68a2      	ldr	r2, [r4, #8]
   1835c:	68d2      	ldr	r2, [r2, #12]
   1835e:	4790      	blx	r2
   18360:	6860      	ldr	r0, [r4, #4]
   18362:	6801      	ldr	r1, [r0, #0]
   18364:	2210      	movs	r2, #16
   18366:	430a      	orrs	r2, r1
   18368:	6002      	str	r2, [r0, #0]
   1836a:	2206      	movs	r2, #6
   1836c:	2101      	movs	r1, #1
   1836e:	6923      	ldr	r3, [r4, #16]
   18370:	2001      	movs	r0, #1
   18372:	4018      	ands	r0, r3
   18374:	68a3      	ldr	r3, [r4, #8]
   18376:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   18378:	4798      	blx	r3
   1837a:	2207      	movs	r2, #7
   1837c:	2101      	movs	r1, #1
   1837e:	6923      	ldr	r3, [r4, #16]
   18380:	2001      	movs	r0, #1
   18382:	4018      	ands	r0, r3
   18384:	68a3      	ldr	r3, [r4, #8]
   18386:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   18388:	4798      	blx	r3
   1838a:	2100      	movs	r1, #0
   1838c:	6922      	ldr	r2, [r4, #16]
   1838e:	2001      	movs	r0, #1
   18390:	4010      	ands	r0, r2
   18392:	f005 f822 	bl	1d3da <USBPD_PRL_SetHeaderPowerRole>
   18396:	2000      	movs	r0, #0
   18398:	9000      	str	r0, [sp, #0]
   1839a:	2325      	movs	r3, #37	; 0x25
   1839c:	2206      	movs	r2, #6
   1839e:	2100      	movs	r1, #0
   183a0:	0020      	movs	r0, r4
   183a2:	f002 faa7 	bl	1a8f4 <PE_Send_CtrlMessage>
   183a6:	2800      	cmp	r0, #0
   183a8:	d10d      	bne.n	183c6 <__iar_annotation$$branch+0x822>
   183aa:	2208      	movs	r2, #8
   183ac:	2101      	movs	r1, #1
   183ae:	6923      	ldr	r3, [r4, #16]
   183b0:	2001      	movs	r0, #1
   183b2:	4018      	ands	r0, r3
   183b4:	68a3      	ldr	r3, [r4, #8]
   183b6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   183b8:	4798      	blx	r3
   183ba:	48bd      	ldr	r0, [pc, #756]	; (186b0 <__iar_annotation$$branch+0xb0c>)
   183bc:	21a5      	movs	r1, #165	; 0xa5
   183be:	0089      	lsls	r1, r1, #2
   183c0:	5260      	strh	r0, [r4, r1]
   183c2:	25d7      	movs	r5, #215	; 0xd7
   183c4:	006d      	lsls	r5, r5, #1
   183c6:	e6d1      	b.n	1816c <__iar_annotation$$branch+0x5c8>
   183c8:	00008320 	.word	0x00008320
   183cc:	2911      	cmp	r1, #17
   183ce:	d113      	bne.n	183f8 <__iar_annotation$$branch+0x854>
   183d0:	20a5      	movs	r0, #165	; 0xa5
   183d2:	0080      	lsls	r0, r0, #2
   183d4:	1820      	adds	r0, r4, r0
   183d6:	89c0      	ldrh	r0, [r0, #14]
   183d8:	49b6      	ldr	r1, [pc, #728]	; (186b4 <__iar_annotation$$branch+0xb10>)
   183da:	4001      	ands	r1, r0
   183dc:	2906      	cmp	r1, #6
   183de:	d10b      	bne.n	183f8 <__iar_annotation$$branch+0x854>
   183e0:	2014      	movs	r0, #20
   183e2:	4669      	mov	r1, sp
   183e4:	7308      	strb	r0, [r1, #12]
   183e6:	6921      	ldr	r1, [r4, #16]
   183e8:	2001      	movs	r0, #1
   183ea:	4008      	ands	r0, r1
   183ec:	f005 f9f5 	bl	1d7da <USBPD_PRL_EnableRX>
   183f0:	2026      	movs	r0, #38	; 0x26
   183f2:	4949      	ldr	r1, [pc, #292]	; (18518 <__iar_annotation$$branch+0x974>)
   183f4:	1861      	adds	r1, r4, r1
   183f6:	70c8      	strb	r0, [r1, #3]
   183f8:	20a5      	movs	r0, #165	; 0xa5
   183fa:	0080      	lsls	r0, r0, #2
   183fc:	5a20      	ldrh	r0, [r4, r0]
   183fe:	03a9      	lsls	r1, r5, #14
   18400:	4288      	cmp	r0, r1
   18402:	d1e0      	bne.n	183c6 <__iar_annotation$$branch+0x822>
   18404:	68a3      	ldr	r3, [r4, #8]
   18406:	6b58      	ldr	r0, [r3, #52]	; 0x34
   18408:	2800      	cmp	r0, #0
   1840a:	d000      	beq.n	1840e <__iar_annotation$$branch+0x86a>
   1840c:	e12b      	b.n	18666 <__iar_annotation$$branch+0xac2>
   1840e:	220a      	movs	r2, #10
   18410:	2101      	movs	r1, #1
   18412:	6925      	ldr	r5, [r4, #16]
   18414:	2001      	movs	r0, #1
   18416:	4028      	ands	r0, r5
   18418:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   1841a:	4798      	blx	r3
   1841c:	e4be      	b.n	17d9c <__iar_annotation$$branch+0x1f8>
   1841e:	2100      	movs	r1, #0
   18420:	0020      	movs	r0, r4
   18422:	f003 f8e4 	bl	1b5ee <PE_ChangePowerRole>
   18426:	220d      	movs	r2, #13
   18428:	2100      	movs	r1, #0
   1842a:	6923      	ldr	r3, [r4, #16]
   1842c:	2001      	movs	r0, #1
   1842e:	4018      	ands	r0, r3
   18430:	68a3      	ldr	r3, [r4, #8]
   18432:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   18434:	4798      	blx	r3
   18436:	2000      	movs	r0, #0
   18438:	9000      	str	r0, [sp, #0]
   1843a:	2300      	movs	r3, #0
   1843c:	2214      	movs	r2, #20
   1843e:	6920      	ldr	r0, [r4, #16]
   18440:	2101      	movs	r1, #1
   18442:	4001      	ands	r1, r0
   18444:	2009      	movs	r0, #9
   18446:	4d33      	ldr	r5, [pc, #204]	; (18514 <__iar_annotation$$branch+0x970>)
   18448:	6a2d      	ldr	r5, [r5, #32]
   1844a:	47a8      	blx	r5
   1844c:	2114      	movs	r1, #20
   1844e:	6922      	ldr	r2, [r4, #16]
   18450:	2001      	movs	r0, #1
   18452:	4010      	ands	r0, r2
   18454:	68a2      	ldr	r2, [r4, #8]
   18456:	68d2      	ldr	r2, [r2, #12]
   18458:	4790      	blx	r2
   1845a:	220e      	movs	r2, #14
   1845c:	2100      	movs	r1, #0
   1845e:	6923      	ldr	r3, [r4, #16]
   18460:	2001      	movs	r0, #1
   18462:	4018      	ands	r0, r3
   18464:	68a3      	ldr	r3, [r4, #8]
   18466:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   18468:	4798      	blx	r3
   1846a:	0020      	movs	r0, r4
   1846c:	f003 fe37 	bl	1c0de <PE_ResetDuringSwap>
   18470:	e431      	b.n	17cd6 <__iar_annotation$$branch+0x132>
   18472:	9600      	str	r6, [sp, #0]
   18474:	231f      	movs	r3, #31
   18476:	220a      	movs	r2, #10
   18478:	2100      	movs	r1, #0
   1847a:	0020      	movs	r0, r4
   1847c:	f002 fa3a 	bl	1a8f4 <PE_Send_CtrlMessage>
   18480:	2800      	cmp	r0, #0
   18482:	d1a0      	bne.n	183c6 <__iar_annotation$$branch+0x822>
   18484:	2008      	movs	r0, #8
   18486:	83a0      	strh	r0, [r4, #28]
   18488:	20a5      	movs	r0, #165	; 0xa5
   1848a:	0080      	lsls	r0, r0, #2
   1848c:	5227      	strh	r7, [r4, r0]
   1848e:	2518      	movs	r5, #24
   18490:	2202      	movs	r2, #2
   18492:	2101      	movs	r1, #1
   18494:	6923      	ldr	r3, [r4, #16]
   18496:	2001      	movs	r0, #1
   18498:	4018      	ands	r0, r3
   1849a:	68a3      	ldr	r3, [r4, #8]
   1849c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   1849e:	4798      	blx	r3
   184a0:	2000      	movs	r0, #0
   184a2:	9000      	str	r0, [sp, #0]
   184a4:	2300      	movs	r3, #0
   184a6:	2239      	movs	r2, #57	; 0x39
   184a8:	6920      	ldr	r0, [r4, #16]
   184aa:	2101      	movs	r1, #1
   184ac:	4001      	ands	r1, r0
   184ae:	2009      	movs	r0, #9
   184b0:	4f18      	ldr	r7, [pc, #96]	; (18514 <__iar_annotation$$branch+0x970>)
   184b2:	6a3f      	ldr	r7, [r7, #32]
   184b4:	47b8      	blx	r7
   184b6:	2139      	movs	r1, #57	; 0x39
   184b8:	e4df      	b.n	17e7a <__iar_annotation$$branch+0x2d6>
   184ba:	2911      	cmp	r1, #17
   184bc:	d106      	bne.n	184cc <__iar_annotation$$branch+0x928>
   184be:	20a5      	movs	r0, #165	; 0xa5
   184c0:	0080      	lsls	r0, r0, #2
   184c2:	1820      	adds	r0, r4, r0
   184c4:	89c0      	ldrh	r0, [r0, #14]
   184c6:	21f0      	movs	r1, #240	; 0xf0
   184c8:	0209      	lsls	r1, r1, #8
   184ca:	4001      	ands	r1, r0
   184cc:	d178      	bne.n	185c0 <__iar_annotation$$branch+0xa1c>
   184ce:	2703      	movs	r7, #3
   184d0:	06c0      	lsls	r0, r0, #27
   184d2:	0ec0      	lsrs	r0, r0, #27
   184d4:	2803      	cmp	r0, #3
   184d6:	d006      	beq.n	184e6 <__iar_annotation$$branch+0x942>
   184d8:	2804      	cmp	r0, #4
   184da:	d036      	beq.n	1854a <__iar_annotation$$branch+0x9a6>
   184dc:	280c      	cmp	r0, #12
   184de:	d01f      	beq.n	18520 <__iar_annotation$$branch+0x97c>
   184e0:	2810      	cmp	r0, #16
   184e2:	d047      	beq.n	18574 <__iar_annotation$$branch+0x9d0>
   184e4:	e06c      	b.n	185c0 <__iar_annotation$$branch+0xa1c>
   184e6:	2000      	movs	r0, #0
   184e8:	9000      	str	r0, [sp, #0]
   184ea:	2300      	movs	r3, #0
   184ec:	223a      	movs	r2, #58	; 0x3a
   184ee:	6920      	ldr	r0, [r4, #16]
   184f0:	2101      	movs	r1, #1
   184f2:	4001      	ands	r1, r0
   184f4:	2009      	movs	r0, #9
   184f6:	4d07      	ldr	r5, [pc, #28]	; (18514 <__iar_annotation$$branch+0x970>)
   184f8:	6a2d      	ldr	r5, [r5, #32]
   184fa:	47a8      	blx	r5
   184fc:	213a      	movs	r1, #58	; 0x3a
   184fe:	6922      	ldr	r2, [r4, #16]
   18500:	2001      	movs	r0, #1
   18502:	4010      	ands	r0, r2
   18504:	68a2      	ldr	r2, [r4, #8]
   18506:	68d2      	ldr	r2, [r2, #12]
   18508:	4790      	blx	r2
   1850a:	2020      	movs	r0, #32
   1850c:	4902      	ldr	r1, [pc, #8]	; (18518 <__iar_annotation$$branch+0x974>)
   1850e:	1861      	adds	r1, r4, r1
   18510:	70c8      	strb	r0, [r1, #3]
   18512:	e04c      	b.n	185ae <__iar_annotation$$branch+0xa0a>
   18514:	0002ff54 	.word	0x0002ff54
   18518:	0000028d 	.word	0x0000028d
   1851c:	0000801e 	.word	0x0000801e
   18520:	2205      	movs	r2, #5
   18522:	2101      	movs	r1, #1
   18524:	6923      	ldr	r3, [r4, #16]
   18526:	2001      	movs	r0, #1
   18528:	4018      	ands	r0, r3
   1852a:	68a3      	ldr	r3, [r4, #8]
   1852c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   1852e:	4798      	blx	r3
   18530:	2000      	movs	r0, #0
   18532:	9000      	str	r0, [sp, #0]
   18534:	2300      	movs	r3, #0
   18536:	223b      	movs	r2, #59	; 0x3b
   18538:	6920      	ldr	r0, [r4, #16]
   1853a:	2101      	movs	r1, #1
   1853c:	4001      	ands	r1, r0
   1853e:	2009      	movs	r0, #9
   18540:	4db3      	ldr	r5, [pc, #716]	; (18810 <__iar_annotation$$branch+0xc6c>)
   18542:	6a2d      	ldr	r5, [r5, #32]
   18544:	47a8      	blx	r5
   18546:	213b      	movs	r1, #59	; 0x3b
   18548:	e028      	b.n	1859c <__iar_annotation$$branch+0x9f8>
   1854a:	2204      	movs	r2, #4
   1854c:	2101      	movs	r1, #1
   1854e:	6923      	ldr	r3, [r4, #16]
   18550:	2001      	movs	r0, #1
   18552:	4018      	ands	r0, r3
   18554:	68a3      	ldr	r3, [r4, #8]
   18556:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   18558:	4798      	blx	r3
   1855a:	2000      	movs	r0, #0
   1855c:	9000      	str	r0, [sp, #0]
   1855e:	2300      	movs	r3, #0
   18560:	2216      	movs	r2, #22
   18562:	6920      	ldr	r0, [r4, #16]
   18564:	2101      	movs	r1, #1
   18566:	4001      	ands	r1, r0
   18568:	2009      	movs	r0, #9
   1856a:	4da9      	ldr	r5, [pc, #676]	; (18810 <__iar_annotation$$branch+0xc6c>)
   1856c:	6a2d      	ldr	r5, [r5, #32]
   1856e:	47a8      	blx	r5
   18570:	2116      	movs	r1, #22
   18572:	e013      	b.n	1859c <__iar_annotation$$branch+0x9f8>
   18574:	2204      	movs	r2, #4
   18576:	2101      	movs	r1, #1
   18578:	6923      	ldr	r3, [r4, #16]
   1857a:	2001      	movs	r0, #1
   1857c:	4018      	ands	r0, r3
   1857e:	68a3      	ldr	r3, [r4, #8]
   18580:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   18582:	4798      	blx	r3
   18584:	2000      	movs	r0, #0
   18586:	9000      	str	r0, [sp, #0]
   18588:	2300      	movs	r3, #0
   1858a:	2217      	movs	r2, #23
   1858c:	6920      	ldr	r0, [r4, #16]
   1858e:	2101      	movs	r1, #1
   18590:	4001      	ands	r1, r0
   18592:	2009      	movs	r0, #9
   18594:	4d9e      	ldr	r5, [pc, #632]	; (18810 <__iar_annotation$$branch+0xc6c>)
   18596:	6a2d      	ldr	r5, [r5, #32]
   18598:	47a8      	blx	r5
   1859a:	2117      	movs	r1, #23
   1859c:	6922      	ldr	r2, [r4, #16]
   1859e:	2001      	movs	r0, #1
   185a0:	4010      	ands	r0, r2
   185a2:	68a2      	ldr	r2, [r4, #8]
   185a4:	68d2      	ldr	r2, [r2, #12]
   185a6:	4790      	blx	r2
   185a8:	489a      	ldr	r0, [pc, #616]	; (18814 <__iar_annotation$$branch+0xc70>)
   185aa:	1820      	adds	r0, r4, r0
   185ac:	70c7      	strb	r7, [r0, #3]
   185ae:	2500      	movs	r5, #0
   185b0:	2014      	movs	r0, #20
   185b2:	4669      	mov	r1, sp
   185b4:	7308      	strb	r0, [r1, #12]
   185b6:	6921      	ldr	r1, [r4, #16]
   185b8:	2001      	movs	r0, #1
   185ba:	4008      	ands	r0, r1
   185bc:	f005 f90d 	bl	1d7da <USBPD_PRL_EnableRX>
   185c0:	20a5      	movs	r0, #165	; 0xa5
   185c2:	0080      	lsls	r0, r0, #2
   185c4:	5a20      	ldrh	r0, [r4, r0]
   185c6:	03f1      	lsls	r1, r6, #15
   185c8:	4288      	cmp	r0, r1
   185ca:	d124      	bne.n	18616 <__iar_annotation$$branch+0xa72>
   185cc:	e674      	b.n	182b8 <__iar_annotation$$branch+0x714>
   185ce:	6860      	ldr	r0, [r4, #4]
   185d0:	6801      	ldr	r1, [r0, #0]
   185d2:	2210      	movs	r2, #16
   185d4:	430a      	orrs	r2, r1
   185d6:	6002      	str	r2, [r0, #0]
   185d8:	2206      	movs	r2, #6
   185da:	2101      	movs	r1, #1
   185dc:	6923      	ldr	r3, [r4, #16]
   185de:	2001      	movs	r0, #1
   185e0:	4018      	ands	r0, r3
   185e2:	68a3      	ldr	r3, [r4, #8]
   185e4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   185e6:	4798      	blx	r3
   185e8:	2207      	movs	r2, #7
   185ea:	2101      	movs	r1, #1
   185ec:	6923      	ldr	r3, [r4, #16]
   185ee:	2001      	movs	r0, #1
   185f0:	4018      	ands	r0, r3
   185f2:	68a3      	ldr	r3, [r4, #8]
   185f4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   185f6:	4798      	blx	r3
   185f8:	2100      	movs	r1, #0
   185fa:	6922      	ldr	r2, [r4, #16]
   185fc:	2001      	movs	r0, #1
   185fe:	4010      	ands	r0, r2
   18600:	f004 feeb 	bl	1d3da <USBPD_PRL_SetHeaderPowerRole>
   18604:	2000      	movs	r0, #0
   18606:	9000      	str	r0, [sp, #0]
   18608:	2321      	movs	r3, #33	; 0x21
   1860a:	2206      	movs	r2, #6
   1860c:	2100      	movs	r1, #0
   1860e:	0020      	movs	r0, r4
   18610:	f002 f970 	bl	1a8f4 <PE_Send_CtrlMessage>
   18614:	2800      	cmp	r0, #0
   18616:	d000      	beq.n	1861a <__iar_annotation$$branch+0xa76>
   18618:	e5a8      	b.n	1816c <__iar_annotation$$branch+0x5c8>
   1861a:	2208      	movs	r2, #8
   1861c:	2101      	movs	r1, #1
   1861e:	6923      	ldr	r3, [r4, #16]
   18620:	2001      	movs	r0, #1
   18622:	4018      	ands	r0, r3
   18624:	68a3      	ldr	r3, [r4, #8]
   18626:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   18628:	4798      	blx	r3
   1862a:	487b      	ldr	r0, [pc, #492]	; (18818 <__iar_annotation$$branch+0xc74>)
   1862c:	21a5      	movs	r1, #165	; 0xa5
   1862e:	0089      	lsls	r1, r1, #2
   18630:	5260      	strh	r0, [r4, r1]
   18632:	25f0      	movs	r5, #240	; 0xf0
   18634:	e6c6      	b.n	183c4 <__iar_annotation$$branch+0x820>
   18636:	2911      	cmp	r1, #17
   18638:	d10b      	bne.n	18652 <__iar_annotation$$branch+0xaae>
   1863a:	2026      	movs	r0, #38	; 0x26
   1863c:	4975      	ldr	r1, [pc, #468]	; (18814 <__iar_annotation$$branch+0xc70>)
   1863e:	1861      	adds	r1, r4, r1
   18640:	70c8      	strb	r0, [r1, #3]
   18642:	2014      	movs	r0, #20
   18644:	4669      	mov	r1, sp
   18646:	7308      	strb	r0, [r1, #12]
   18648:	6921      	ldr	r1, [r4, #16]
   1864a:	2001      	movs	r0, #1
   1864c:	4008      	ands	r0, r1
   1864e:	f005 f8c4 	bl	1d7da <USBPD_PRL_EnableRX>
   18652:	20a5      	movs	r0, #165	; 0xa5
   18654:	0080      	lsls	r0, r0, #2
   18656:	5a20      	ldrh	r0, [r4, r0]
   18658:	03a9      	lsls	r1, r5, #14
   1865a:	4288      	cmp	r0, r1
   1865c:	d156      	bne.n	1870c <__iar_annotation$$branch+0xb68>
   1865e:	68a0      	ldr	r0, [r4, #8]
   18660:	6b40      	ldr	r0, [r0, #52]	; 0x34
   18662:	2800      	cmp	r0, #0
   18664:	d05c      	beq.n	18720 <__iar_annotation$$branch+0xb7c>
   18666:	2092      	movs	r0, #146	; 0x92
   18668:	e627      	b.n	182ba <__iar_annotation$$branch+0x716>
   1866a:	bf00      	nop
   1866c:	fffff8ff 	.word	0xfffff8ff
   18670:	4968      	ldr	r1, [pc, #416]	; (18814 <__iar_annotation$$branch+0xc70>)
   18672:	1867      	adds	r7, r4, r1
   18674:	2803      	cmp	r0, #3
   18676:	d124      	bne.n	186c2 <__iar_annotation$$branch+0xb1e>
   18678:	2000      	movs	r0, #0
   1867a:	83a0      	strh	r0, [r4, #28]
   1867c:	4668      	mov	r0, sp
   1867e:	7b40      	ldrb	r0, [r0, #13]
   18680:	f005 f8ab 	bl	1d7da <USBPD_PRL_EnableRX>
   18684:	6921      	ldr	r1, [r4, #16]
   18686:	2001      	movs	r0, #1
   18688:	4008      	ands	r0, r1
   1868a:	f004 fef7 	bl	1d47c <USBPD_PRL_SRCReleaseSinkNG>
   1868e:	2004      	movs	r0, #4
   18690:	70f8      	strb	r0, [r7, #3]
   18692:	6920      	ldr	r0, [r4, #16]
   18694:	0700      	lsls	r0, r0, #28
   18696:	0f80      	lsrs	r0, r0, #30
   18698:	2803      	cmp	r0, #3
   1869a:	d10d      	bne.n	186b8 <__iar_annotation$$branch+0xb14>
   1869c:	20a5      	movs	r0, #165	; 0xa5
   1869e:	0080      	lsls	r0, r0, #2
   186a0:	1820      	adds	r0, r4, r0
   186a2:	8981      	ldrh	r1, [r0, #12]
   186a4:	0449      	lsls	r1, r1, #17
   186a6:	d10c      	bne.n	186c2 <__iar_annotation$$branch+0xb1e>
   186a8:	49b7      	ldr	r1, [pc, #732]	; (18988 <__iar_annotation$$branch+0x4>)
   186aa:	8181      	strh	r1, [r0, #12]
   186ac:	4db7      	ldr	r5, [pc, #732]	; (1898c <__iar_annotation$$branch+0x8>)
   186ae:	e008      	b.n	186c2 <__iar_annotation$$branch+0xb1e>
   186b0:	000081ae 	.word	0x000081ae
   186b4:	0000f01f 	.word	0x0000f01f
   186b8:	2000      	movs	r0, #0
   186ba:	21a5      	movs	r1, #165	; 0xa5
   186bc:	0089      	lsls	r1, r1, #2
   186be:	1861      	adds	r1, r4, r1
   186c0:	8188      	strh	r0, [r1, #12]
   186c2:	4668      	mov	r0, sp
   186c4:	7b00      	ldrb	r0, [r0, #12]
   186c6:	2814      	cmp	r0, #20
   186c8:	d021      	beq.n	1870e <__iar_annotation$$branch+0xb6a>
   186ca:	7978      	ldrb	r0, [r7, #5]
   186cc:	71b8      	strb	r0, [r7, #6]
   186ce:	20a5      	movs	r0, #165	; 0xa5
   186d0:	0080      	lsls	r0, r0, #2
   186d2:	1820      	adds	r0, r4, r0
   186d4:	89c0      	ldrh	r0, [r0, #14]
   186d6:	0bc1      	lsrs	r1, r0, #15
   186d8:	d003      	beq.n	186e2 <__iar_annotation$$branch+0xb3e>
   186da:	0020      	movs	r0, r4
   186dc:	f003 fade 	bl	1bc9c <PE_Check_ExtendedMessage>
   186e0:	e00c      	b.n	186fc <__iar_annotation$$branch+0xb58>
   186e2:	21f0      	movs	r1, #240	; 0xf0
   186e4:	0209      	lsls	r1, r1, #8
   186e6:	4001      	ands	r1, r0
   186e8:	d104      	bne.n	186f4 <__iar_annotation$$branch+0xb50>
   186ea:	a903      	add	r1, sp, #12
   186ec:	0020      	movs	r0, r4
   186ee:	f003 f813 	bl	1b718 <PE_Check_ControlMessage>
   186f2:	e003      	b.n	186fc <__iar_annotation$$branch+0xb58>
   186f4:	0020      	movs	r0, r4
   186f6:	f003 f9cb 	bl	1ba90 <PE_Check_DataMessage>
   186fa:	0005      	movs	r5, r0
   186fc:	2014      	movs	r0, #20
   186fe:	4669      	mov	r1, sp
   18700:	7308      	strb	r0, [r1, #12]
   18702:	6921      	ldr	r1, [r4, #16]
   18704:	2001      	movs	r0, #1
   18706:	4008      	ands	r0, r1
   18708:	f005 f867 	bl	1d7da <USBPD_PRL_EnableRX>
   1870c:	e52e      	b.n	1816c <__iar_annotation$$branch+0x5c8>
   1870e:	20a5      	movs	r0, #165	; 0xa5
   18710:	0080      	lsls	r0, r0, #2
   18712:	1820      	adds	r0, r4, r0
   18714:	03f1      	lsls	r1, r6, #15
   18716:	8982      	ldrh	r2, [r0, #12]
   18718:	428a      	cmp	r2, r1
   1871a:	d102      	bne.n	18722 <__iar_annotation$$branch+0xb7e>
   1871c:	2100      	movs	r1, #0
   1871e:	8181      	strh	r1, [r0, #12]
   18720:	e67c      	b.n	1841c <__iar_annotation$$branch+0x878>
   18722:	78ba      	ldrb	r2, [r7, #2]
   18724:	2a00      	cmp	r2, #0
   18726:	d10e      	bne.n	18746 <__iar_annotation$$branch+0xba2>
   18728:	783a      	ldrb	r2, [r7, #0]
   1872a:	2a00      	cmp	r2, #0
   1872c:	d00b      	beq.n	18746 <__iar_annotation$$branch+0xba2>
   1872e:	7879      	ldrb	r1, [r7, #1]
   18730:	71b9      	strb	r1, [r7, #6]
   18732:	70fa      	strb	r2, [r7, #3]
   18734:	2500      	movs	r5, #0
   18736:	703d      	strb	r5, [r7, #0]
   18738:	6941      	ldr	r1, [r0, #20]
   1873a:	6181      	str	r1, [r0, #24]
   1873c:	6920      	ldr	r0, [r4, #16]
   1873e:	0371      	lsls	r1, r6, #13
   18740:	4301      	orrs	r1, r0
   18742:	6121      	str	r1, [r4, #16]
   18744:	e512      	b.n	1816c <__iar_annotation$$branch+0x5c8>
   18746:	8882      	ldrh	r2, [r0, #4]
   18748:	428a      	cmp	r2, r1
   1874a:	d106      	bne.n	1875a <__iar_annotation$$branch+0xbb6>
   1874c:	2500      	movs	r5, #0
   1874e:	8085      	strh	r5, [r0, #4]
   18750:	7ea0      	ldrb	r0, [r4, #26]
   18752:	1c40      	adds	r0, r0, #1
   18754:	76a0      	strb	r0, [r4, #26]
   18756:	2005      	movs	r0, #5
   18758:	e469      	b.n	1802e <__iar_annotation$$branch+0x48a>
   1875a:	2500      	movs	r5, #0
   1875c:	43ed      	mvns	r5, r5
   1875e:	1e49      	subs	r1, r1, #1
   18760:	8982      	ldrh	r2, [r0, #12]
   18762:	420a      	tst	r2, r1
   18764:	d001      	beq.n	1876a <__iar_annotation$$branch+0xbc6>
   18766:	8985      	ldrh	r5, [r0, #12]
   18768:	400d      	ands	r5, r1
   1876a:	8882      	ldrh	r2, [r0, #4]
   1876c:	420a      	tst	r2, r1
   1876e:	d006      	beq.n	1877e <__iar_annotation$$branch+0xbda>
   18770:	8882      	ldrh	r2, [r0, #4]
   18772:	400a      	ands	r2, r1
   18774:	4295      	cmp	r5, r2
   18776:	d302      	bcc.n	1877e <__iar_annotation$$branch+0xbda>
   18778:	8880      	ldrh	r0, [r0, #4]
   1877a:	000d      	movs	r5, r1
   1877c:	4005      	ands	r5, r0
   1877e:	e4f5      	b.n	1816c <__iar_annotation$$branch+0x5c8>
   18780:	2000      	movs	r0, #0
   18782:	9002      	str	r0, [sp, #8]
   18784:	2003      	movs	r0, #3
   18786:	9001      	str	r0, [sp, #4]
   18788:	9600      	str	r6, [sp, #0]
   1878a:	20ab      	movs	r0, #171	; 0xab
   1878c:	0080      	lsls	r0, r0, #2
   1878e:	1823      	adds	r3, r4, r0
   18790:	2206      	movs	r2, #6
   18792:	2100      	movs	r1, #0
   18794:	0020      	movs	r0, r4
   18796:	f002 f8ed 	bl	1a974 <PE_Send_DataMessage>
   1879a:	2800      	cmp	r0, #0
   1879c:	d1ef      	bne.n	1877e <__iar_annotation$$branch+0xbda>
   1879e:	9000      	str	r0, [sp, #0]
   187a0:	2300      	movs	r3, #0
   187a2:	225d      	movs	r2, #93	; 0x5d
   187a4:	6920      	ldr	r0, [r4, #16]
   187a6:	2101      	movs	r1, #1
   187a8:	4001      	ands	r1, r0
   187aa:	2009      	movs	r0, #9
   187ac:	4f18      	ldr	r7, [pc, #96]	; (18810 <__iar_annotation$$branch+0xc6c>)
   187ae:	6a3f      	ldr	r7, [r7, #32]
   187b0:	47b8      	blx	r7
   187b2:	215d      	movs	r1, #93	; 0x5d
   187b4:	e680      	b.n	184b8 <__iar_annotation$$branch+0x914>
   187b6:	ab05      	add	r3, sp, #20
   187b8:	aa04      	add	r2, sp, #16
   187ba:	210a      	movs	r1, #10
   187bc:	4668      	mov	r0, sp
   187be:	7b40      	ldrb	r0, [r0, #13]
   187c0:	68a7      	ldr	r7, [r4, #8]
   187c2:	697f      	ldr	r7, [r7, #20]
   187c4:	47b8      	blx	r7
   187c6:	2000      	movs	r0, #0
   187c8:	2221      	movs	r2, #33	; 0x21
   187ca:	54a0      	strb	r0, [r4, r2]
   187cc:	2120      	movs	r1, #32
   187ce:	5460      	strb	r0, [r4, r1]
   187d0:	9a05      	ldr	r2, [sp, #20]
   187d2:	a904      	add	r1, sp, #16
   187d4:	0020      	movs	r0, r4
   187d6:	3022      	adds	r0, #34	; 0x22
   187d8:	f005 ff23 	bl	1e622 <__aeabi_memcpy>
   187dc:	2000      	movs	r0, #0
   187de:	9002      	str	r0, [sp, #8]
   187e0:	2003      	movs	r0, #3
   187e2:	9001      	str	r0, [sp, #4]
   187e4:	2008      	movs	r0, #8
   187e6:	9000      	str	r0, [sp, #0]
   187e8:	0023      	movs	r3, r4
   187ea:	331e      	adds	r3, #30
   187ec:	220c      	movs	r2, #12
   187ee:	2100      	movs	r1, #0
   187f0:	0020      	movs	r0, r4
   187f2:	f003 fe55 	bl	1c4a0 <PE_Send_ExtendedMessage>
   187f6:	2000      	movs	r0, #0
   187f8:	9000      	str	r0, [sp, #0]
   187fa:	2300      	movs	r3, #0
   187fc:	224c      	movs	r2, #76	; 0x4c
   187fe:	6920      	ldr	r0, [r4, #16]
   18800:	2101      	movs	r1, #1
   18802:	4001      	ands	r1, r0
   18804:	2009      	movs	r0, #9
   18806:	4f02      	ldr	r7, [pc, #8]	; (18810 <__iar_annotation$$branch+0xc6c>)
   18808:	6a3f      	ldr	r7, [r7, #32]
   1880a:	47b8      	blx	r7
   1880c:	214c      	movs	r1, #76	; 0x4c
   1880e:	e653      	b.n	184b8 <__iar_annotation$$branch+0x914>
   18810:	0002ff54 	.word	0x0002ff54
   18814:	0000028d 	.word	0x0000028d
   18818:	000081e0 	.word	0x000081e0
   1881c:	9600      	str	r6, [sp, #0]
   1881e:	2339      	movs	r3, #57	; 0x39
   18820:	20ad      	movs	r0, #173	; 0xad
   18822:	0080      	lsls	r0, r0, #2
   18824:	5c22      	ldrb	r2, [r4, r0]
   18826:	3827      	subs	r0, #39	; 0x27
   18828:	1820      	adds	r0, r4, r0
   1882a:	7841      	ldrb	r1, [r0, #1]
   1882c:	0020      	movs	r0, r4
   1882e:	f002 f861 	bl	1a8f4 <PE_Send_CtrlMessage>
   18832:	2800      	cmp	r0, #0
   18834:	d16d      	bne.n	18912 <__iar_annotation$$branch>
   18836:	20ad      	movs	r0, #173	; 0xad
   18838:	0080      	lsls	r0, r0, #2
   1883a:	1820      	adds	r0, r4, r0
   1883c:	8840      	ldrh	r0, [r0, #2]
   1883e:	83a0      	strh	r0, [r4, #28]
   18840:	20a5      	movs	r0, #165	; 0xa5
   18842:	0080      	lsls	r0, r0, #2
   18844:	5227      	strh	r7, [r4, r0]
   18846:	2518      	movs	r5, #24
   18848:	2000      	movs	r0, #0
   1884a:	9000      	str	r0, [sp, #0]
   1884c:	2300      	movs	r3, #0
   1884e:	2244      	movs	r2, #68	; 0x44
   18850:	6920      	ldr	r0, [r4, #16]
   18852:	2101      	movs	r1, #1
   18854:	4001      	ands	r1, r0
   18856:	2009      	movs	r0, #9
   18858:	4f4d      	ldr	r7, [pc, #308]	; (18990 <__iar_annotation$$branch+0xc>)
   1885a:	6a3f      	ldr	r7, [r7, #32]
   1885c:	47b8      	blx	r7
   1885e:	2144      	movs	r1, #68	; 0x44
   18860:	e62a      	b.n	184b8 <__iar_annotation$$branch+0x914>
   18862:	20a5      	movs	r0, #165	; 0xa5
   18864:	0080      	lsls	r0, r0, #2
   18866:	5a20      	ldrh	r0, [r4, r0]
   18868:	03aa      	lsls	r2, r5, #14
   1886a:	4290      	cmp	r0, r2
   1886c:	d102      	bne.n	18874 <__iar_annotation$$branch+0xcd0>
   1886e:	2914      	cmp	r1, #20
   18870:	d100      	bne.n	18874 <__iar_annotation$$branch+0xcd0>
   18872:	e521      	b.n	182b8 <__iar_annotation$$branch+0x714>
   18874:	2914      	cmp	r1, #20
   18876:	d04c      	beq.n	18912 <__iar_annotation$$branch>
   18878:	20a5      	movs	r0, #165	; 0xa5
   1887a:	0080      	lsls	r0, r0, #2
   1887c:	1820      	adds	r0, r4, r0
   1887e:	89c0      	ldrh	r0, [r0, #14]
   18880:	2714      	movs	r7, #20
   18882:	0bc1      	lsrs	r1, r0, #15
   18884:	d005      	beq.n	18892 <__iar_annotation$$branch+0xcee>
   18886:	0020      	movs	r0, r4
   18888:	f003 fa08 	bl	1bc9c <PE_Check_ExtendedMessage>
   1888c:	4668      	mov	r0, sp
   1888e:	7307      	strb	r7, [r0, #12]
   18890:	e737      	b.n	18702 <__iar_annotation$$branch+0xb5e>
   18892:	06c0      	lsls	r0, r0, #27
   18894:	0ec0      	lsrs	r0, r0, #27
   18896:	2810      	cmp	r0, #16
   18898:	d000      	beq.n	1889c <__iar_annotation$$branch+0xcf8>
   1889a:	e50d      	b.n	182b8 <__iar_annotation$$branch+0x714>
   1889c:	4668      	mov	r0, sp
   1889e:	7307      	strb	r7, [r0, #12]
   188a0:	6921      	ldr	r1, [r4, #16]
   188a2:	2001      	movs	r0, #1
   188a4:	4008      	ands	r0, r1
   188a6:	f004 ff98 	bl	1d7da <USBPD_PRL_EnableRX>
   188aa:	2500      	movs	r5, #0
   188ac:	21a5      	movs	r1, #165	; 0xa5
   188ae:	0089      	lsls	r1, r1, #2
   188b0:	5265      	strh	r5, [r4, r1]
   188b2:	2003      	movs	r0, #3
   188b4:	1fc9      	subs	r1, r1, #7
   188b6:	1861      	adds	r1, r4, r1
   188b8:	70c8      	strb	r0, [r1, #3]
   188ba:	9500      	str	r5, [sp, #0]
   188bc:	2300      	movs	r3, #0
   188be:	2259      	movs	r2, #89	; 0x59
   188c0:	6920      	ldr	r0, [r4, #16]
   188c2:	2101      	movs	r1, #1
   188c4:	4001      	ands	r1, r0
   188c6:	2009      	movs	r0, #9
   188c8:	4f31      	ldr	r7, [pc, #196]	; (18990 <__iar_annotation$$branch+0xc>)
   188ca:	6a3f      	ldr	r7, [r7, #32]
   188cc:	47b8      	blx	r7
   188ce:	2159      	movs	r1, #89	; 0x59
   188d0:	e5f2      	b.n	184b8 <__iar_annotation$$branch+0x914>
   188d2:	0020      	movs	r0, r4
   188d4:	f003 fe52 	bl	1c57c <PE_SubStateMachine_ExtendedMessages>
   188d8:	e003      	b.n	188e2 <__iar_annotation$$branch>
   188da:	a903      	add	r1, sp, #12
   188dc:	0020      	movs	r0, r4
   188de:	f003 ff4d 	bl	1c77c <PE_SubStateMachine_Generic>

000188e2 <__iar_annotation$$branch>:
   188e2:	f7ff f907 	bl	17af4 <__iar_annotation$$branch+0x10>
   188e6:	a903      	add	r1, sp, #12
   188e8:	0020      	movs	r0, r4
   188ea:	f004 fb2d 	bl	1cf48 <PE_SubStateMachine_VconnSwap>
   188ee:	0005      	movs	r5, r0
   188f0:	6860      	ldr	r0, [r4, #4]
   188f2:	6800      	ldr	r0, [r0, #0]
   188f4:	0bc0      	lsrs	r0, r0, #15
   188f6:	4030      	ands	r0, r6
   188f8:	d006      	beq.n	18908 <__iar_annotation$$branch+0x26>
   188fa:	6820      	ldr	r0, [r4, #0]
   188fc:	6801      	ldr	r1, [r0, #0]
   188fe:	4668      	mov	r0, sp
   18900:	7b40      	ldrb	r0, [r0, #13]
   18902:	f004 fdd1 	bl	1d4a8 <USBPD_PRL_SOPCapability>
   18906:	e004      	b.n	18912 <__iar_annotation$$branch>
   18908:	2101      	movs	r1, #1
   1890a:	e7f8      	b.n	188fe <__iar_annotation$$branch+0x1c>
   1890c:	0020      	movs	r0, r4
   1890e:	f002 fe21 	bl	1b554 <PE_StateMachine_UVDM>

00018912 <__iar_annotation$$branch>:
   18912:	f7ff f8f0 	bl	17af6 <__iar_annotation$$branch+0x12>
   18916:	48b6      	ldr	r0, [pc, #728]	; (18bf0 <.text_17>)
   18918:	1827      	adds	r7, r4, r0
   1891a:	78b8      	ldrb	r0, [r7, #2]
   1891c:	2800      	cmp	r0, #0
   1891e:	d02d      	beq.n	1897c <__iar_annotation$$branch+0x6a>
   18920:	6920      	ldr	r0, [r4, #16]
   18922:	0b01      	lsrs	r1, r0, #12
   18924:	4031      	ands	r1, r6
   18926:	d029      	beq.n	1897c <__iar_annotation$$branch+0x6a>
   18928:	0b41      	lsrs	r1, r0, #13
   1892a:	4031      	ands	r1, r6
   1892c:	d014      	beq.n	18958 <__iar_annotation$$branch+0x46>
   1892e:	2100      	movs	r1, #0
   18930:	9100      	str	r1, [sp, #0]
   18932:	2300      	movs	r3, #0
   18934:	225b      	movs	r2, #91	; 0x5b
   18936:	2101      	movs	r1, #1
   18938:	4001      	ands	r1, r0
   1893a:	2009      	movs	r0, #9
   1893c:	4d14      	ldr	r5, [pc, #80]	; (18990 <__iar_annotation$$branch+0xc>)
   1893e:	6a2d      	ldr	r5, [r5, #32]
   18940:	47a8      	blx	r5
   18942:	215b      	movs	r1, #91	; 0x5b
   18944:	6922      	ldr	r2, [r4, #16]
   18946:	2001      	movs	r0, #1
   18948:	4010      	ands	r0, r2
   1894a:	68a2      	ldr	r2, [r4, #8]
   1894c:	68d2      	ldr	r2, [r2, #12]
   1894e:	4790      	blx	r2
   18950:	6920      	ldr	r0, [r4, #16]
   18952:	49a8      	ldr	r1, [pc, #672]	; (18bf4 <.text_18>)
   18954:	4001      	ands	r1, r0
   18956:	6121      	str	r1, [r4, #16]
   18958:	2003      	movs	r0, #3
   1895a:	70f8      	strb	r0, [r7, #3]
   1895c:	7939      	ldrb	r1, [r7, #4]
   1895e:	2903      	cmp	r1, #3
   18960:	d00b      	beq.n	1897a <__iar_annotation$$branch+0x68>
   18962:	7138      	strb	r0, [r7, #4]
   18964:	2000      	movs	r0, #0
   18966:	9000      	str	r0, [sp, #0]
   18968:	2300      	movs	r3, #0
   1896a:	2203      	movs	r2, #3
   1896c:	6920      	ldr	r0, [r4, #16]
   1896e:	2101      	movs	r1, #1
   18970:	4001      	ands	r1, r0
   18972:	2004      	movs	r0, #4
   18974:	4d06      	ldr	r5, [pc, #24]	; (18990 <__iar_annotation$$branch+0xc>)
   18976:	6a2d      	ldr	r5, [r5, #32]
   18978:	47a8      	blx	r5
   1897a:	2501      	movs	r5, #1
   1897c:	6920      	ldr	r0, [r4, #16]
   1897e:	499e      	ldr	r1, [pc, #632]	; (18bf8 <.text_19>)
   18980:	4001      	ands	r1, r0
   18982:	6121      	str	r1, [r4, #16]

00018984 <__iar_annotation$$branch>:
   18984:	f7ff f8ef 	bl	17b66 <__iar_annotation$$branch+0x42>
   18988:	0000b6b0 	.word	0x0000b6b0
   1898c:	000036b0 	.word	0x000036b0
   18990:	0002ff54 	.word	0x0002ff54
   18994:	4668      	mov	r0, sp
   18996:	7344      	strb	r4, [r0, #13]
   18998:	003c      	movs	r4, r7
   1899a:	9507      	str	r5, [sp, #28]
   1899c:	9606      	str	r6, [sp, #24]
   1899e:	2601      	movs	r6, #1
   189a0:	6860      	ldr	r0, [r4, #4]
   189a2:	6800      	ldr	r0, [r0, #0]
   189a4:	0b00      	lsrs	r0, r0, #12
   189a6:	4030      	ands	r0, r6
   189a8:	d101      	bne.n	189ae <__iar_annotation$$branch+0x4>

000189aa <__iar_annotation$$branch>:
   189aa:	f7ff f8fe 	bl	17baa <__iar_annotation$$branch+0x6>
   189ae:	2502      	movs	r5, #2
   189b0:	488f      	ldr	r0, [pc, #572]	; (18bf0 <.text_17>)
   189b2:	5c22      	ldrb	r2, [r4, r0]
   189b4:	2a0f      	cmp	r2, #15
   189b6:	d115      	bne.n	189e4 <__iar_annotation$$branch+0x3a>
   189b8:	1820      	adds	r0, r4, r0
   189ba:	70c2      	strb	r2, [r0, #3]
   189bc:	2100      	movs	r1, #0
   189be:	7001      	strb	r1, [r0, #0]
   189c0:	23a5      	movs	r3, #165	; 0xa5
   189c2:	009b      	lsls	r3, r3, #2
   189c4:	18e3      	adds	r3, r4, r3
   189c6:	6199      	str	r1, [r3, #24]
   189c8:	7901      	ldrb	r1, [r0, #4]
   189ca:	4291      	cmp	r1, r2
   189cc:	d00a      	beq.n	189e4 <__iar_annotation$$branch+0x3a>
   189ce:	7102      	strb	r2, [r0, #4]
   189d0:	2000      	movs	r0, #0
   189d2:	9000      	str	r0, [sp, #0]
   189d4:	2300      	movs	r3, #0
   189d6:	6920      	ldr	r0, [r4, #16]
   189d8:	2101      	movs	r1, #1
   189da:	4001      	ands	r1, r0
   189dc:	2004      	movs	r0, #4
   189de:	4fba      	ldr	r7, [pc, #744]	; (18cc8 <.text_21>)
   189e0:	6a3f      	ldr	r7, [r7, #32]
   189e2:	47b8      	blx	r7
   189e4:	4668      	mov	r0, sp
   189e6:	7b00      	ldrb	r0, [r0, #12]
   189e8:	2801      	cmp	r0, #1
   189ea:	d11f      	bne.n	18a2c <__iar_annotation$$branch+0x82>
   189ec:	6860      	ldr	r0, [r4, #4]
   189ee:	6800      	ldr	r0, [r0, #0]
   189f0:	08c0      	lsrs	r0, r0, #3
   189f2:	4030      	ands	r0, r6
   189f4:	21a5      	movs	r1, #165	; 0xa5
   189f6:	0089      	lsls	r1, r1, #2
   189f8:	1861      	adds	r1, r4, r1
   189fa:	89c9      	ldrh	r1, [r1, #14]
   189fc:	0949      	lsrs	r1, r1, #5
   189fe:	2201      	movs	r2, #1
   18a00:	400a      	ands	r2, r1
   18a02:	4290      	cmp	r0, r2
   18a04:	d112      	bne.n	18a2c <__iar_annotation$$branch+0x82>
   18a06:	487a      	ldr	r0, [pc, #488]	; (18bf0 <.text_17>)
   18a08:	1820      	adds	r0, r4, r0
   18a0a:	2192      	movs	r1, #146	; 0x92
   18a0c:	70c1      	strb	r1, [r0, #3]
   18a0e:	7902      	ldrb	r2, [r0, #4]
   18a10:	2a92      	cmp	r2, #146	; 0x92
   18a12:	d00b      	beq.n	18a2c <__iar_annotation$$branch+0x82>
   18a14:	7101      	strb	r1, [r0, #4]
   18a16:	2000      	movs	r0, #0
   18a18:	9000      	str	r0, [sp, #0]
   18a1a:	2300      	movs	r3, #0
   18a1c:	2292      	movs	r2, #146	; 0x92
   18a1e:	6920      	ldr	r0, [r4, #16]
   18a20:	2101      	movs	r1, #1
   18a22:	4001      	ands	r1, r0
   18a24:	2004      	movs	r0, #4
   18a26:	4fa8      	ldr	r7, [pc, #672]	; (18cc8 <.text_21>)
   18a28:	6a3f      	ldr	r7, [r7, #32]
   18a2a:	47b8      	blx	r7
   18a2c:	9806      	ldr	r0, [sp, #24]
   18a2e:	2800      	cmp	r0, #0
   18a30:	d005      	beq.n	18a3e <__iar_annotation$$branch+0x94>
   18a32:	2107      	movs	r1, #7
   18a34:	f006 facc 	bl	1efd0 <__aeabi_uidivmod>
   18a38:	2900      	cmp	r1, #0
   18a3a:	d100      	bne.n	18a3e <__iar_annotation$$branch+0x94>
   18a3c:	9607      	str	r6, [sp, #28]
   18a3e:	486c      	ldr	r0, [pc, #432]	; (18bf0 <.text_17>)
   18a40:	1820      	adds	r0, r4, r0
   18a42:	78c0      	ldrb	r0, [r0, #3]
   18a44:	4669      	mov	r1, sp
   18a46:	7b09      	ldrb	r1, [r1, #12]
   18a48:	4fa0      	ldr	r7, [pc, #640]	; (18ccc <.text_22>)
   18a4a:	0002      	movs	r2, r0
   18a4c:	d101      	bne.n	18a52 <__iar_annotation$$branch+0x4>

00018a4e <__iar_annotation$$branch>:
   18a4e:	f7ff f8ae 	bl	17bae <__iar_annotation$$branch+0xa>
   18a52:	1e42      	subs	r2, r0, #1
   18a54:	d073      	beq.n	18b3e <__iar_annotation$$branch+0x14>
   18a56:	1e52      	subs	r2, r2, #1
   18a58:	d101      	bne.n	18a5e <__iar_annotation$$branch+0x4>

00018a5a <__iar_annotation$$branch>:
   18a5a:	f7ff f8c7 	bl	17bec <__iar_annotation$$branch+0x48>
   18a5e:	1e52      	subs	r2, r2, #1
   18a60:	2a01      	cmp	r2, #1
   18a62:	d800      	bhi.n	18a66 <__iar_annotation$$branch+0xc>
   18a64:	e604      	b.n	18670 <__iar_annotation$$branch+0xacc>
   18a66:	1e92      	subs	r2, r2, #2
   18a68:	d100      	bne.n	18a6c <__iar_annotation$$branch+0x12>
   18a6a:	e0a0      	b.n	18bae <__iar_annotation$$branch+0xa>
   18a6c:	1e52      	subs	r2, r2, #1
   18a6e:	d101      	bne.n	18a74 <__iar_annotation$$branch+0x4>

00018a70 <__iar_annotation$$branch>:
   18a70:	f7ff f927 	bl	17cc2 <__iar_annotation$$branch+0x11e>
   18a74:	1e52      	subs	r2, r2, #1
   18a76:	d101      	bne.n	18a7c <__iar_annotation$$branch+0x4>

00018a78 <__iar_annotation$$branch>:
   18a78:	f7ff f92f 	bl	17cda <__iar_annotation$$branch+0x136>
   18a7c:	1e52      	subs	r2, r2, #1
   18a7e:	d101      	bne.n	18a84 <__iar_annotation$$branch+0x4>

00018a80 <__iar_annotation$$branch>:
   18a80:	f7ff f92f 	bl	17ce2 <__iar_annotation$$branch+0x13e>
   18a84:	1e52      	subs	r2, r2, #1
   18a86:	d101      	bne.n	18a8c <__iar_annotation$$branch+0x4>

00018a88 <__iar_annotation$$branch>:
   18a88:	f7ff f990 	bl	17dac <__iar_annotation$$branch+0x208>
   18a8c:	1ed2      	subs	r2, r2, #3
   18a8e:	d101      	bne.n	18a94 <__iar_annotation$$branch+0x4>

00018a90 <__iar_annotation$$branch>:
   18a90:	f7ff f990 	bl	17db4 <__iar_annotation$$branch+0x210>
   18a94:	1e52      	subs	r2, r2, #1
   18a96:	d101      	bne.n	18a9c <__iar_annotation$$branch+0x4>

00018a98 <__iar_annotation$$branch>:
   18a98:	f7ff f9bb 	bl	17e12 <__iar_annotation$$branch+0x26e>
   18a9c:	1e52      	subs	r2, r2, #1
   18a9e:	d101      	bne.n	18aa4 <__iar_annotation$$branch+0x4>

00018aa0 <__iar_annotation$$branch>:
   18aa0:	f7ff f9f2 	bl	17e88 <__iar_annotation$$branch+0x2e4>
   18aa4:	1e52      	subs	r2, r2, #1
   18aa6:	d101      	bne.n	18aac <__iar_annotation$$branch+0x4>

00018aa8 <__iar_annotation$$branch>:
   18aa8:	f7ff fa9e 	bl	17fe8 <__iar_annotation$$branch+0x444>
   18aac:	1e52      	subs	r2, r2, #1
   18aae:	d101      	bne.n	18ab4 <__iar_annotation$$branch+0x4>

00018ab0 <__iar_annotation$$branch>:
   18ab0:	f7ff fa42 	bl	17f38 <__iar_annotation$$branch+0x394>
   18ab4:	1e52      	subs	r2, r2, #1
   18ab6:	d101      	bne.n	18abc <__iar_annotation$$branch+0x4>

00018ab8 <__iar_annotation$$branch>:
   18ab8:	f7ff fa4a 	bl	17f50 <__iar_annotation$$branch+0x3ac>
   18abc:	1e52      	subs	r2, r2, #1
   18abe:	d101      	bne.n	18ac4 <__iar_annotation$$branch+0x4>

00018ac0 <__iar_annotation$$branch>:
   18ac0:	f7ff fa63 	bl	17f8a <__iar_annotation$$branch+0x3e6>
   18ac4:	1e52      	subs	r2, r2, #1
   18ac6:	d101      	bne.n	18acc <__iar_annotation$$branch+0x4>

00018ac8 <__iar_annotation$$branch>:
   18ac8:	f7ff fb22 	bl	18110 <__iar_annotation$$branch+0x56c>
   18acc:	1e52      	subs	r2, r2, #1
   18ace:	d101      	bne.n	18ad4 <__iar_annotation$$branch+0x4>

00018ad0 <__iar_annotation$$branch>:
   18ad0:	f7ff faaf 	bl	18032 <__iar_annotation$$branch+0x48e>
   18ad4:	1e52      	subs	r2, r2, #1
   18ad6:	d101      	bne.n	18adc <__iar_annotation$$branch+0x4>

00018ad8 <__iar_annotation$$branch>:
   18ad8:	f7ff fac1 	bl	1805e <__iar_annotation$$branch+0x4ba>
   18adc:	1e52      	subs	r2, r2, #1
   18ade:	d101      	bne.n	18ae4 <__iar_annotation$$branch+0x4>

00018ae0 <__iar_annotation$$branch>:
   18ae0:	f7ff f91c 	bl	17d1c <__iar_annotation$$branch+0x178>
   18ae4:	1e52      	subs	r2, r2, #1
   18ae6:	d101      	bne.n	18aec <__iar_annotation$$branch+0x4>

00018ae8 <__iar_annotation$$branch>:
   18ae8:	f7ff fae3 	bl	180b2 <__iar_annotation$$branch+0x50e>
   18aec:	1e52      	subs	r2, r2, #1
   18aee:	2a01      	cmp	r2, #1
   18af0:	d925      	bls.n	18b3e <__iar_annotation$$branch+0x14>
   18af2:	1e92      	subs	r2, r2, #2
   18af4:	d101      	bne.n	18afa <__iar_annotation$$branch+0x4>

00018af6 <__iar_annotation$$branch>:
   18af6:	f7ff fb58 	bl	181aa <__iar_annotation$$branch+0x606>
   18afa:	1e52      	subs	r2, r2, #1
   18afc:	d101      	bne.n	18b02 <__iar_annotation$$branch+0x4>

00018afe <__iar_annotation$$branch>:
   18afe:	f7ff fb70 	bl	181e2 <__iar_annotation$$branch+0x63e>
   18b02:	1e92      	subs	r2, r2, #2
   18b04:	d01b      	beq.n	18b3e <__iar_annotation$$branch+0x14>
   18b06:	1e52      	subs	r2, r2, #1
   18b08:	d100      	bne.n	18b0c <__iar_annotation$$branch+0xe>
   18b0a:	e4b2      	b.n	18472 <__iar_annotation$$branch+0x8ce>
   18b0c:	1e52      	subs	r2, r2, #1
   18b0e:	d100      	bne.n	18b12 <__iar_annotation$$branch+0x14>
   18b10:	e4d3      	b.n	184ba <__iar_annotation$$branch+0x916>
   18b12:	1e52      	subs	r2, r2, #1
   18b14:	d100      	bne.n	18b18 <__iar_annotation$$branch+0x1a>
   18b16:	e55a      	b.n	185ce <__iar_annotation$$branch+0xa2a>
   18b18:	1e52      	subs	r2, r2, #1
   18b1a:	d100      	bne.n	18b1e <__iar_annotation$$branch+0x20>
   18b1c:	e58b      	b.n	18636 <__iar_annotation$$branch+0xa92>
   18b1e:	1e52      	subs	r2, r2, #1
   18b20:	d101      	bne.n	18b26 <__iar_annotation$$branch+0x4>

00018b22 <__iar_annotation$$branch>:
   18b22:	f7ff fbcb 	bl	182bc <__iar_annotation$$branch+0x718>
   18b26:	1e92      	subs	r2, r2, #2
   18b28:	d101      	bne.n	18b2e <__iar_annotation$$branch+0x4>

00018b2a <__iar_annotation$$branch>:
   18b2a:	f7ff fbf6 	bl	1831a <__iar_annotation$$branch+0x776>
   18b2e:	1e52      	subs	r2, r2, #1
   18b30:	d100      	bne.n	18b34 <__iar_annotation$$branch+0xa>
   18b32:	e44b      	b.n	183cc <__iar_annotation$$branch+0x828>
   18b34:	1e52      	subs	r2, r2, #1
   18b36:	d100      	bne.n	18b3a <__iar_annotation$$branch+0x10>
   18b38:	e471      	b.n	1841e <__iar_annotation$$branch+0x87a>
   18b3a:	1e52      	subs	r2, r2, #1
   18b3c:	2a02      	cmp	r2, #2
   18b3e:	d800      	bhi.n	18b42 <__iar_annotation$$branch+0x18>
   18b40:	e6cb      	b.n	188da <__iar_annotation$$branch+0xd36>
   18b42:	1ed2      	subs	r2, r2, #3
   18b44:	d101      	bne.n	18b4a <__iar_annotation$$branch+0x4>

00018b46 <__iar_annotation$$branch>:
   18b46:	f7ff fbe3 	bl	18310 <__iar_annotation$$branch+0x76c>
   18b4a:	1e52      	subs	r2, r2, #1
   18b4c:	d100      	bne.n	18b50 <__iar_annotation$$branch+0xa>
   18b4e:	e617      	b.n	18780 <__iar_annotation$$branch+0xbdc>
   18b50:	1e52      	subs	r2, r2, #1
   18b52:	d0f4      	beq.n	18b3e <__iar_annotation$$branch+0x14>
   18b54:	1e52      	subs	r2, r2, #1
   18b56:	d100      	bne.n	18b5a <__iar_annotation$$branch+0x14>
   18b58:	e62d      	b.n	187b6 <__iar_annotation$$branch+0xc12>
   18b5a:	1e52      	subs	r2, r2, #1
   18b5c:	d100      	bne.n	18b60 <__iar_annotation$$branch+0x1a>
   18b5e:	e65d      	b.n	1881c <__iar_annotation$$branch+0xc78>
   18b60:	1e52      	subs	r2, r2, #1
   18b62:	2a01      	cmp	r2, #1
   18b64:	d9eb      	bls.n	18b3e <__iar_annotation$$branch+0x14>
   18b66:	1e92      	subs	r2, r2, #2
   18b68:	d001      	beq.n	18b6e <__iar_annotation$$branch+0x28>
   18b6a:	1e92      	subs	r2, r2, #2
   18b6c:	2a05      	cmp	r2, #5
   18b6e:	d800      	bhi.n	18b72 <__iar_annotation$$branch+0x2c>
   18b70:	e6af      	b.n	188d2 <__iar_annotation$$branch+0xd2e>
   18b72:	1f92      	subs	r2, r2, #6
   18b74:	d100      	bne.n	18b78 <__iar_annotation$$branch+0x32>
   18b76:	e674      	b.n	18862 <__iar_annotation$$branch+0xcbe>
   18b78:	1e52      	subs	r2, r2, #1
   18b7a:	2a03      	cmp	r2, #3
   18b7c:	d9df      	bls.n	18b3e <__iar_annotation$$branch+0x14>
   18b7e:	3a28      	subs	r2, #40	; 0x28
   18b80:	2a01      	cmp	r2, #1
   18b82:	d9dc      	bls.n	18b3e <__iar_annotation$$branch+0x14>
   18b84:	3a12      	subs	r2, #18
   18b86:	d0da      	beq.n	18b3e <__iar_annotation$$branch+0x14>
   18b88:	3a12      	subs	r2, #18
   18b8a:	d100      	bne.n	18b8e <__iar_annotation$$branch+0x48>
   18b8c:	e6be      	b.n	1890c <__iar_annotation$$branch+0x2a>
   18b8e:	3a0c      	subs	r2, #12
   18b90:	d01a      	beq.n	18bc8 <__iar_annotation$$branch+0x4>
   18b92:	1e52      	subs	r2, r2, #1
   18b94:	2a02      	cmp	r2, #2
   18b96:	d9d2      	bls.n	18b3e <__iar_annotation$$branch+0x14>
   18b98:	1ed2      	subs	r2, r2, #3
   18b9a:	d101      	bne.n	18ba0 <__iar_annotation$$branch+0x4>

00018b9c <__iar_annotation$$branch>:
   18b9c:	f7ff f977 	bl	17e8e <__iar_annotation$$branch+0x2ea>
   18ba0:	1e52      	subs	r2, r2, #1
   18ba2:	d101      	bne.n	18ba8 <__iar_annotation$$branch+0x4>

00018ba4 <__iar_annotation$$branch>:
   18ba4:	f7ff f99a 	bl	17edc <__iar_annotation$$branch+0x338>
   18ba8:	1e92      	subs	r2, r2, #2
   18baa:	d0c8      	beq.n	18b3e <__iar_annotation$$branch+0x14>
   18bac:	1e52      	subs	r2, r2, #1
   18bae:	d101      	bne.n	18bb4 <__iar_annotation$$branch+0x4>

00018bb0 <__iar_annotation$$branch>:
   18bb0:	f7ff f882 	bl	17cb8 <__iar_annotation$$branch+0x114>
   18bb4:	1e92      	subs	r2, r2, #2
   18bb6:	2a08      	cmp	r2, #8
   18bb8:	d800      	bhi.n	18bbc <__iar_annotation$$branch+0xc>
   18bba:	e694      	b.n	188e6 <__iar_annotation$$branch+0x4>
   18bbc:	3a0a      	subs	r2, #10
   18bbe:	2a02      	cmp	r2, #2
   18bc0:	d800      	bhi.n	18bc4 <__iar_annotation$$branch>
   18bc2:	e6a6      	b.n	18912 <__iar_annotation$$branch>

00018bc4 <__iar_annotation$$branch>:
   18bc4:	f7fe ff92 	bl	17aec <__iar_annotation$$branch+0x8>
   18bc8:	4668      	mov	r0, sp
   18bca:	7b40      	ldrb	r0, [r0, #13]
   18bcc:	f004 fe0b 	bl	1d7e6 <USBPD_PRL_DisableRX>
   18bd0:	6860      	ldr	r0, [r4, #4]
   18bd2:	6801      	ldr	r1, [r0, #0]
   18bd4:	2210      	movs	r2, #16
   18bd6:	4391      	bics	r1, r2
   18bd8:	6001      	str	r1, [r0, #0]
   18bda:	68a0      	ldr	r0, [r4, #8]
   18bdc:	6b41      	ldr	r1, [r0, #52]	; 0x34
   18bde:	2900      	cmp	r1, #0
   18be0:	d003      	beq.n	18bea <__iar_annotation$$branch>
   18be2:	7c22      	ldrb	r2, [r4, #16]
   18be4:	07d0      	lsls	r0, r2, #31
   18be6:	0fc0      	lsrs	r0, r0, #31
   18be8:	4788      	blx	r1

00018bea <__iar_annotation$$branch>:
   18bea:	f7fe fffc 	bl	17be6 <__iar_annotation$$branch+0x42>
	...

00018bf0 <.text_17>:
   18bf0:	0000028d 	.word	0x0000028d

00018bf4 <.text_18>:
   18bf4:	ffffdfff 	.word	0xffffdfff

00018bf8 <.text_19>:
   18bf8:	ffffefff 	.word	0xffffefff

00018bfc <PE_StateMachine_SRC_SendCapa>:
   18bfc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   18bfe:	0004      	movs	r4, r0
   18c00:	2502      	movs	r5, #2
   18c02:	4f31      	ldr	r7, [pc, #196]	; (18cc8 <.text_21>)
   18c04:	2600      	movs	r6, #0
   18c06:	6920      	ldr	r0, [r4, #16]
   18c08:	0780      	lsls	r0, r0, #30
   18c0a:	0fc1      	lsrs	r1, r0, #31
   18c0c:	0020      	movs	r0, r4
   18c0e:	f001 fe49 	bl	1a8a4 <PE_Send_SRCCapabilities>
   18c12:	2805      	cmp	r0, #5
   18c14:	d002      	beq.n	18c1c <PE_StateMachine_SRC_SendCapa+0x20>
   18c16:	2809      	cmp	r0, #9
   18c18:	d053      	beq.n	18cc2 <PE_StateMachine_SRC_SendCapa+0xc6>
   18c1a:	e01f      	b.n	18c5c <PE_StateMachine_SRC_SendCapa+0x60>
   18c1c:	2001      	movs	r0, #1
   18c1e:	83a0      	strh	r0, [r4, #28]
   18c20:	6920      	ldr	r0, [r4, #16]
   18c22:	4305      	orrs	r5, r0
   18c24:	0028      	movs	r0, r5
   18c26:	6120      	str	r0, [r4, #16]
   18c28:	7666      	strb	r6, [r4, #25]
   18c2a:	7626      	strb	r6, [r4, #24]
   18c2c:	21a4      	movs	r1, #164	; 0xa4
   18c2e:	0089      	lsls	r1, r1, #2
   18c30:	1861      	adds	r1, r4, r1
   18c32:	4a26      	ldr	r2, [pc, #152]	; (18ccc <.text_22>)
   18c34:	808a      	strh	r2, [r1, #4]
   18c36:	2518      	movs	r5, #24
   18c38:	2216      	movs	r2, #22
   18c3a:	700a      	strb	r2, [r1, #0]
   18c3c:	9600      	str	r6, [sp, #0]
   18c3e:	2300      	movs	r3, #0
   18c40:	220f      	movs	r2, #15
   18c42:	07c1      	lsls	r1, r0, #31
   18c44:	0fc9      	lsrs	r1, r1, #31
   18c46:	2009      	movs	r0, #9
   18c48:	6a3e      	ldr	r6, [r7, #32]
   18c4a:	47b0      	blx	r6
   18c4c:	210f      	movs	r1, #15
   18c4e:	7c22      	ldrb	r2, [r4, #16]
   18c50:	07d0      	lsls	r0, r2, #31
   18c52:	0fc0      	lsrs	r0, r0, #31
   18c54:	68a2      	ldr	r2, [r4, #8]
   18c56:	68d2      	ldr	r2, [r2, #12]
   18c58:	4790      	blx	r2
   18c5a:	e032      	b.n	18cc2 <PE_StateMachine_SRC_SendCapa+0xc6>
   18c5c:	6920      	ldr	r0, [r4, #16]
   18c5e:	0781      	lsls	r1, r0, #30
   18c60:	0fc9      	lsrs	r1, r1, #31
   18c62:	d112      	bne.n	18c8a <PE_StateMachine_SRC_SendCapa+0x8e>
   18c64:	7e61      	ldrb	r1, [r4, #25]
   18c66:	2933      	cmp	r1, #51	; 0x33
   18c68:	d219      	bcs.n	18c9e <PE_StateMachine_SRC_SendCapa+0xa2>
   18c6a:	20a4      	movs	r0, #164	; 0xa4
   18c6c:	0080      	lsls	r0, r0, #2
   18c6e:	1821      	adds	r1, r4, r0
   18c70:	484a      	ldr	r0, [pc, #296]	; (18d9c <.text_24>)
   18c72:	8088      	strh	r0, [r1, #4]
   18c74:	2596      	movs	r5, #150	; 0x96
   18c76:	2008      	movs	r0, #8
   18c78:	7008      	strb	r0, [r1, #0]
   18c7a:	4849      	ldr	r0, [pc, #292]	; (18da0 <.text_25>)
   18c7c:	890a      	ldrh	r2, [r1, #8]
   18c7e:	4202      	tst	r2, r0
   18c80:	d01f      	beq.n	18cc2 <PE_StateMachine_SRC_SendCapa+0xc6>
   18c82:	8909      	ldrh	r1, [r1, #8]
   18c84:	0005      	movs	r5, r0
   18c86:	400d      	ands	r5, r1
   18c88:	e01b      	b.n	18cc2 <PE_StateMachine_SRC_SendCapa+0xc6>
   18c8a:	07c0      	lsls	r0, r0, #31
   18c8c:	0fc0      	lsrs	r0, r0, #31
   18c8e:	f004 fbf5 	bl	1d47c <USBPD_PRL_SRCReleaseSinkNG>
   18c92:	200f      	movs	r0, #15
   18c94:	21a4      	movs	r1, #164	; 0xa4
   18c96:	0089      	lsls	r1, r1, #2
   18c98:	5460      	strb	r0, [r4, r1]
   18c9a:	2500      	movs	r5, #0
   18c9c:	e011      	b.n	18cc2 <PE_StateMachine_SRC_SendCapa+0xc6>
   18c9e:	9600      	str	r6, [sp, #0]
   18ca0:	2300      	movs	r3, #0
   18ca2:	2221      	movs	r2, #33	; 0x21
   18ca4:	07c1      	lsls	r1, r0, #31
   18ca6:	0fc9      	lsrs	r1, r1, #31
   18ca8:	2009      	movs	r0, #9
   18caa:	6a3f      	ldr	r7, [r7, #32]
   18cac:	47b8      	blx	r7
   18cae:	2121      	movs	r1, #33	; 0x21
   18cb0:	7c22      	ldrb	r2, [r4, #16]
   18cb2:	07d0      	lsls	r0, r2, #31
   18cb4:	0fc0      	lsrs	r0, r0, #31
   18cb6:	68a2      	ldr	r2, [r4, #8]
   18cb8:	68d2      	ldr	r2, [r2, #12]
   18cba:	4790      	blx	r2
   18cbc:	20a4      	movs	r0, #164	; 0xa4
   18cbe:	0080      	lsls	r0, r0, #2
   18cc0:	5426      	strb	r6, [r4, r0]
   18cc2:	0028      	movs	r0, r5
   18cc4:	bdf2      	pop	{r1, r4, r5, r6, r7, pc}
	...

00018cc8 <.text_21>:
   18cc8:	0002ff54 	.word	0x0002ff54

00018ccc <.text_22>:
   18ccc:	00008018 	.word	0x00008018

00018cd0 <PE_StateMachine_SRC_NegocCapa>:
   18cd0:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
   18cd2:	0006      	movs	r6, r0
   18cd4:	2002      	movs	r0, #2
   18cd6:	9002      	str	r0, [sp, #8]
   18cd8:	2403      	movs	r4, #3
   18cda:	2507      	movs	r5, #7
   18cdc:	a901      	add	r1, sp, #4
   18cde:	7c32      	ldrb	r2, [r6, #16]
   18ce0:	07d0      	lsls	r0, r2, #31
   18ce2:	0fc0      	lsrs	r0, r0, #31
   18ce4:	68b2      	ldr	r2, [r6, #8]
   18ce6:	69d2      	ldr	r2, [r2, #28]
   18ce8:	4790      	blx	r2
   18cea:	280a      	cmp	r0, #10
   18cec:	d009      	beq.n	18d02 <PE_StateMachine_SRC_NegocCapa+0x32>
   18cee:	280b      	cmp	r0, #11
   18cf0:	d002      	beq.n	18cf8 <PE_StateMachine_SRC_NegocCapa+0x28>
   18cf2:	280d      	cmp	r0, #13
   18cf4:	d031      	beq.n	18d5a <PE_StateMachine_SRC_NegocCapa+0x8a>
   18cf6:	e03d      	b.n	18d74 <PE_StateMachine_SRC_NegocCapa+0xa4>
   18cf8:	2000      	movs	r0, #0
   18cfa:	9000      	str	r0, [sp, #0]
   18cfc:	230c      	movs	r3, #12
   18cfe:	2202      	movs	r2, #2
   18d00:	e044      	b.n	18d8c <PE_StateMachine_SRC_NegocCapa+0xbc>
   18d02:	20a5      	movs	r0, #165	; 0xa5
   18d04:	0080      	lsls	r0, r0, #2
   18d06:	1830      	adds	r0, r6, r0
   18d08:	6871      	ldr	r1, [r6, #4]
   18d0a:	6809      	ldr	r1, [r1, #0]
   18d0c:	0a09      	lsrs	r1, r1, #8
   18d0e:	400d      	ands	r5, r1
   18d10:	2d01      	cmp	r5, #1
   18d12:	d00c      	beq.n	18d2e <PE_StateMachine_SRC_NegocCapa+0x5e>
   18d14:	9901      	ldr	r1, [sp, #4]
   18d16:	2903      	cmp	r1, #3
   18d18:	d109      	bne.n	18d2e <PE_StateMachine_SRC_NegocCapa+0x5e>
   18d1a:	6931      	ldr	r1, [r6, #16]
   18d1c:	0889      	lsrs	r1, r1, #2
   18d1e:	400c      	ands	r4, r1
   18d20:	2c03      	cmp	r4, #3
   18d22:	d104      	bne.n	18d2e <PE_StateMachine_SRC_NegocCapa+0x5e>
   18d24:	2180      	movs	r1, #128	; 0x80
   18d26:	0209      	lsls	r1, r1, #8
   18d28:	8001      	strh	r1, [r0, #0]
   18d2a:	2000      	movs	r0, #0
   18d2c:	e002      	b.n	18d34 <PE_StateMachine_SRC_NegocCapa+0x64>
   18d2e:	491d      	ldr	r1, [pc, #116]	; (18da4 <.text_26>)
   18d30:	8001      	strh	r1, [r0, #0]
   18d32:	201e      	movs	r0, #30
   18d34:	9002      	str	r0, [sp, #8]
   18d36:	2000      	movs	r0, #0
   18d38:	9000      	str	r0, [sp, #0]
   18d3a:	230c      	movs	r3, #12
   18d3c:	2203      	movs	r2, #3
   18d3e:	2100      	movs	r1, #0
   18d40:	0030      	movs	r0, r6
   18d42:	f001 fdd7 	bl	1a8f4 <PE_Send_CtrlMessage>
   18d46:	6930      	ldr	r0, [r6, #16]
   18d48:	210c      	movs	r1, #12
   18d4a:	4388      	bics	r0, r1
   18d4c:	9901      	ldr	r1, [sp, #4]
   18d4e:	0089      	lsls	r1, r1, #2
   18d50:	220c      	movs	r2, #12
   18d52:	400a      	ands	r2, r1
   18d54:	4302      	orrs	r2, r0
   18d56:	6132      	str	r2, [r6, #16]
   18d58:	e01c      	b.n	18d94 <PE_StateMachine_SRC_NegocCapa+0xc4>
   18d5a:	6870      	ldr	r0, [r6, #4]
   18d5c:	6800      	ldr	r0, [r0, #0]
   18d5e:	0a00      	lsrs	r0, r0, #8
   18d60:	4005      	ands	r5, r0
   18d62:	2d03      	cmp	r5, #3
   18d64:	d101      	bne.n	18d6a <PE_StateMachine_SRC_NegocCapa+0x9a>
   18d66:	2303      	movs	r3, #3
   18d68:	e000      	b.n	18d6c <PE_StateMachine_SRC_NegocCapa+0x9c>
   18d6a:	230e      	movs	r3, #14
   18d6c:	2000      	movs	r0, #0
   18d6e:	9000      	str	r0, [sp, #0]
   18d70:	220c      	movs	r2, #12
   18d72:	e00b      	b.n	18d8c <PE_StateMachine_SRC_NegocCapa+0xbc>
   18d74:	6870      	ldr	r0, [r6, #4]
   18d76:	6800      	ldr	r0, [r0, #0]
   18d78:	0a00      	lsrs	r0, r0, #8
   18d7a:	4005      	ands	r5, r0
   18d7c:	2d03      	cmp	r5, #3
   18d7e:	d101      	bne.n	18d84 <PE_StateMachine_SRC_NegocCapa+0xb4>
   18d80:	2303      	movs	r3, #3
   18d82:	e000      	b.n	18d86 <PE_StateMachine_SRC_NegocCapa+0xb6>
   18d84:	230e      	movs	r3, #14
   18d86:	2000      	movs	r0, #0
   18d88:	9000      	str	r0, [sp, #0]
   18d8a:	2204      	movs	r2, #4
   18d8c:	2100      	movs	r1, #0
   18d8e:	0030      	movs	r0, r6
   18d90:	f001 fdb0 	bl	1a8f4 <PE_Send_CtrlMessage>
   18d94:	9802      	ldr	r0, [sp, #8]
   18d96:	b004      	add	sp, #16
   18d98:	bd70      	pop	{r4, r5, r6, pc}
	...

00018d9c <.text_24>:
   18d9c:	00008096 	.word	0x00008096

00018da0 <.text_25>:
   18da0:	00007fff 	.word	0x00007fff

00018da4 <.text_26>:
   18da4:	0000801e 	.word	0x0000801e

00018da8 <USBPD_PE_StateMachine_SNK>:
   18da8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   18daa:	b08e      	sub	sp, #56	; 0x38
   18dac:	0004      	movs	r4, r0
   18dae:	48cc      	ldr	r0, [pc, #816]	; (190e0 <__iar_annotation$$branch+0x240>)
   18db0:	00a1      	lsls	r1, r4, #2
   18db2:	5847      	ldr	r7, [r0, r1]
   18db4:	2500      	movs	r5, #0
   18db6:	20a5      	movs	r0, #165	; 0xa5
   18db8:	0080      	lsls	r0, r0, #2
   18dba:	1838      	adds	r0, r7, r0
   18dbc:	8801      	ldrh	r1, [r0, #0]
   18dbe:	89c0      	ldrh	r0, [r0, #14]
   18dc0:	0502      	lsls	r2, r0, #20
   18dc2:	0f52      	lsrs	r2, r2, #29
   18dc4:	1889      	adds	r1, r1, r2
   18dc6:	06c0      	lsls	r0, r0, #27
   18dc8:	0ec0      	lsrs	r0, r0, #27
   18dca:	180e      	adds	r6, r1, r0
   18dcc:	b2b6      	uxth	r6, r6
   18dce:	0038      	movs	r0, r7
   18dd0:	f002 fc1d 	bl	1b60e <PE_Check_RxEvent>
   18dd4:	4669      	mov	r1, sp
   18dd6:	7308      	strb	r0, [r1, #12]
   18dd8:	4668      	mov	r0, sp
   18dda:	7b00      	ldrb	r0, [r0, #12]
   18ddc:	2803      	cmp	r0, #3
   18dde:	d001      	beq.n	18de4 <__iar_annotation$$branch+0x4>

00018de0 <__iar_annotation$$branch>:
   18de0:	f000 ff40 	bl	19c64 <__iar_annotation$$branch+0xe>
   18de4:	2001      	movs	r0, #1
   18de6:	e05e      	b.n	18ea6 <__iar_annotation$$branch+0x6>
   18de8:	a903      	add	r1, sp, #12
   18dea:	0020      	movs	r0, r4
   18dec:	f001 ffcc 	bl	1ad88 <PE_StateMachine_VDM>
   18df0:	0005      	movs	r5, r0
   18df2:	48bc      	ldr	r0, [pc, #752]	; (190e4 <__iar_annotation$$branch+0x244>)
   18df4:	1820      	adds	r0, r4, r0
   18df6:	78c2      	ldrb	r2, [r0, #3]
   18df8:	7900      	ldrb	r0, [r0, #4]
   18dfa:	4290      	cmp	r0, r2
   18dfc:	d00c      	beq.n	18e18 <__iar_annotation$$branch+0x38>
   18dfe:	48b9      	ldr	r0, [pc, #740]	; (190e4 <__iar_annotation$$branch+0x244>)
   18e00:	1820      	adds	r0, r4, r0
   18e02:	7102      	strb	r2, [r0, #4]
   18e04:	2000      	movs	r0, #0
   18e06:	9000      	str	r0, [sp, #0]
   18e08:	2300      	movs	r3, #0
   18e0a:	6920      	ldr	r0, [r4, #16]
   18e0c:	2101      	movs	r1, #1
   18e0e:	4001      	ands	r1, r0
   18e10:	2004      	movs	r0, #4
   18e12:	4fb3      	ldr	r7, [pc, #716]	; (190e0 <__iar_annotation$$branch+0x240>)
   18e14:	6a3f      	ldr	r7, [r7, #32]
   18e16:	47b8      	blx	r7
   18e18:	4668      	mov	r0, sp
   18e1a:	7b00      	ldrb	r0, [r0, #12]
   18e1c:	2814      	cmp	r0, #20
   18e1e:	d101      	bne.n	18e24 <__iar_annotation$$branch+0x4>

00018e20 <__iar_annotation$$branch>:
   18e20:	f000 fee2 	bl	19be8 <__iar_annotation$$branch+0xd48>
   18e24:	0020      	movs	r0, r4
   18e26:	f002 fc24 	bl	1b672 <PE_Check_AMSConflict>
   18e2a:	2815      	cmp	r0, #21
   18e2c:	d107      	bne.n	18e3e <__iar_annotation$$branch+0x1e>
   18e2e:	2014      	movs	r0, #20
   18e30:	4669      	mov	r1, sp
   18e32:	7308      	strb	r0, [r1, #12]
   18e34:	6921      	ldr	r1, [r4, #16]
   18e36:	2001      	movs	r0, #1
   18e38:	4008      	ands	r0, r1
   18e3a:	f004 fcce 	bl	1d7da <USBPD_PRL_EnableRX>
   18e3e:	48a9      	ldr	r0, [pc, #676]	; (190e4 <__iar_annotation$$branch+0x244>)
   18e40:	1820      	adds	r0, r4, r0
   18e42:	78c2      	ldrb	r2, [r0, #3]
   18e44:	7901      	ldrb	r1, [r0, #4]
   18e46:	4291      	cmp	r1, r2
   18e48:	d00a      	beq.n	18e60 <__iar_annotation$$branch+0x40>
   18e4a:	7102      	strb	r2, [r0, #4]
   18e4c:	2000      	movs	r0, #0
   18e4e:	9000      	str	r0, [sp, #0]
   18e50:	2300      	movs	r3, #0
   18e52:	6920      	ldr	r0, [r4, #16]
   18e54:	2101      	movs	r1, #1
   18e56:	4001      	ands	r1, r0
   18e58:	2004      	movs	r0, #4
   18e5a:	4da1      	ldr	r5, [pc, #644]	; (190e0 <__iar_annotation$$branch+0x240>)
   18e5c:	6a2d      	ldr	r5, [r5, #32]
   18e5e:	47a8      	blx	r5
   18e60:	2500      	movs	r5, #0
   18e62:	9806      	ldr	r0, [sp, #24]
   18e64:	2800      	cmp	r0, #0
   18e66:	d019      	beq.n	18e9c <__iar_annotation$$branch+0x7c>
   18e68:	489d      	ldr	r0, [pc, #628]	; (190e0 <__iar_annotation$$branch+0x240>)
   18e6a:	6a41      	ldr	r1, [r0, #36]	; 0x24
   18e6c:	4a9e      	ldr	r2, [pc, #632]	; (190e8 <__iar_annotation$$branch+0x248>)
   18e6e:	4291      	cmp	r1, r2
   18e70:	d014      	beq.n	18e9c <__iar_annotation$$branch+0x7c>
   18e72:	6921      	ldr	r1, [r4, #16]
   18e74:	4031      	ands	r1, r6
   18e76:	0089      	lsls	r1, r1, #2
   18e78:	5841      	ldr	r1, [r0, r1]
   18e7a:	690a      	ldr	r2, [r1, #16]
   18e7c:	0c13      	lsrs	r3, r2, #16
   18e7e:	1c5b      	adds	r3, r3, #1
   18e80:	b292      	uxth	r2, r2
   18e82:	041b      	lsls	r3, r3, #16
   18e84:	4313      	orrs	r3, r2
   18e86:	610b      	str	r3, [r1, #16]
   18e88:	6921      	ldr	r1, [r4, #16]
   18e8a:	400e      	ands	r6, r1
   18e8c:	00b1      	lsls	r1, r6, #2
   18e8e:	5840      	ldr	r0, [r0, r1]
   18e90:	6901      	ldr	r1, [r0, #16]
   18e92:	0c0a      	lsrs	r2, r1, #16
   18e94:	2a08      	cmp	r2, #8
   18e96:	d301      	bcc.n	18e9c <__iar_annotation$$branch+0x7c>
   18e98:	b289      	uxth	r1, r1
   18e9a:	6101      	str	r1, [r0, #16]
   18e9c:	2d00      	cmp	r5, #0
   18e9e:	d101      	bne.n	18ea4 <__iar_annotation$$branch+0x4>

00018ea0 <__iar_annotation$$branch>:
   18ea0:	f000 fee5 	bl	19c6e <__iar_annotation$$branch+0x18>
   18ea4:	0028      	movs	r0, r5
   18ea6:	b00f      	add	sp, #60	; 0x3c
   18ea8:	bdf0      	pop	{r4, r5, r6, r7, pc}
   18eaa:	4668      	mov	r0, sp
   18eac:	7b40      	ldrb	r0, [r0, #13]
   18eae:	f004 fc9a 	bl	1d7e6 <USBPD_PRL_DisableRX>
   18eb2:	6860      	ldr	r0, [r4, #4]
   18eb4:	6801      	ldr	r1, [r0, #0]
   18eb6:	2210      	movs	r2, #16
   18eb8:	4391      	bics	r1, r2
   18eba:	6001      	str	r1, [r0, #0]
   18ebc:	2501      	movs	r5, #1
   18ebe:	2000      	movs	r0, #0
   18ec0:	9000      	str	r0, [sp, #0]
   18ec2:	2300      	movs	r3, #0
   18ec4:	225f      	movs	r2, #95	; 0x5f
   18ec6:	6920      	ldr	r0, [r4, #16]
   18ec8:	2101      	movs	r1, #1
   18eca:	4001      	ands	r1, r0
   18ecc:	2009      	movs	r0, #9
   18ece:	4e84      	ldr	r6, [pc, #528]	; (190e0 <__iar_annotation$$branch+0x240>)
   18ed0:	6a36      	ldr	r6, [r6, #32]
   18ed2:	47b0      	blx	r6
   18ed4:	215f      	movs	r1, #95	; 0x5f
   18ed6:	6920      	ldr	r0, [r4, #16]
   18ed8:	4005      	ands	r5, r0
   18eda:	0028      	movs	r0, r5
   18edc:	68a2      	ldr	r2, [r4, #8]
   18ede:	68d2      	ldr	r2, [r2, #12]
   18ee0:	4790      	blx	r2
   18ee2:	2000      	movs	r0, #0
   18ee4:	43c0      	mvns	r0, r0
   18ee6:	e7de      	b.n	18ea6 <__iar_annotation$$branch+0x6>
   18ee8:	6921      	ldr	r1, [r4, #16]
   18eea:	2001      	movs	r0, #1
   18eec:	4008      	ands	r0, r1
   18eee:	f004 fc48 	bl	1d782 <USBPD_PRL_Reset>
   18ef2:	6860      	ldr	r0, [r4, #4]
   18ef4:	6800      	ldr	r0, [r0, #0]
   18ef6:	0bc0      	lsrs	r0, r0, #15
   18ef8:	4030      	ands	r0, r6
   18efa:	d002      	beq.n	18f02 <__iar_annotation$$branch+0x62>
   18efc:	6820      	ldr	r0, [r4, #0]
   18efe:	6801      	ldr	r1, [r0, #0]
   18f00:	e000      	b.n	18f04 <__iar_annotation$$branch+0x64>
   18f02:	2101      	movs	r1, #1
   18f04:	4668      	mov	r0, sp
   18f06:	7b40      	ldrb	r0, [r0, #13]
   18f08:	f004 face 	bl	1d4a8 <USBPD_PRL_SOPCapability>
   18f0c:	6860      	ldr	r0, [r4, #4]
   18f0e:	6801      	ldr	r1, [r0, #0]
   18f10:	0b0a      	lsrs	r2, r1, #12
   18f12:	4032      	ands	r2, r6
   18f14:	d015      	beq.n	18f42 <__iar_annotation$$branch+0xa2>
   18f16:	078a      	lsls	r2, r1, #30
   18f18:	0f92      	lsrs	r2, r2, #30
   18f1a:	2a01      	cmp	r2, #1
   18f1c:	d101      	bne.n	18f22 <__iar_annotation$$branch+0x82>
   18f1e:	2200      	movs	r2, #0
   18f20:	e000      	b.n	18f24 <__iar_annotation$$branch+0x84>
   18f22:	2201      	movs	r2, #1
   18f24:	2320      	movs	r3, #32
   18f26:	4399      	bics	r1, r3
   18f28:	0152      	lsls	r2, r2, #5
   18f2a:	430a      	orrs	r2, r1
   18f2c:	6002      	str	r2, [r0, #0]
   18f2e:	48c3      	ldr	r0, [pc, #780]	; (1923c <__iar_annotation$$branch+0x39c>)
   18f30:	21a5      	movs	r1, #165	; 0xa5
   18f32:	0089      	lsls	r1, r1, #2
   18f34:	5260      	strh	r0, [r4, r1]
   18f36:	25fa      	movs	r5, #250	; 0xfa
   18f38:	006d      	lsls	r5, r5, #1
   18f3a:	2043      	movs	r0, #67	; 0x43
   18f3c:	1fc9      	subs	r1, r1, #7
   18f3e:	1861      	adds	r1, r4, r1
   18f40:	70c8      	strb	r0, [r1, #3]
   18f42:	e756      	b.n	18df2 <__iar_annotation$$branch+0x12>
   18f44:	2911      	cmp	r1, #17
   18f46:	d138      	bne.n	18fba <__iar_annotation$$branch+0x11a>
   18f48:	20a5      	movs	r0, #165	; 0xa5
   18f4a:	0080      	lsls	r0, r0, #2
   18f4c:	1827      	adds	r7, r4, r0
   18f4e:	89f8      	ldrh	r0, [r7, #14]
   18f50:	0bc1      	lsrs	r1, r0, #15
   18f52:	d132      	bne.n	18fba <__iar_annotation$$branch+0x11a>
   18f54:	0b01      	lsrs	r1, r0, #12
   18f56:	0749      	lsls	r1, r1, #29
   18f58:	d02f      	beq.n	18fba <__iar_annotation$$branch+0x11a>
   18f5a:	06c1      	lsls	r1, r0, #27
   18f5c:	0ec9      	lsrs	r1, r1, #27
   18f5e:	2901      	cmp	r1, #1
   18f60:	d12b      	bne.n	18fba <__iar_annotation$$branch+0x11a>
   18f62:	2100      	movs	r1, #0
   18f64:	7621      	strb	r1, [r4, #24]
   18f66:	6921      	ldr	r1, [r4, #16]
   18f68:	2202      	movs	r2, #2
   18f6a:	430a      	orrs	r2, r1
   18f6c:	6122      	str	r2, [r4, #16]
   18f6e:	0600      	lsls	r0, r0, #24
   18f70:	0f81      	lsrs	r1, r0, #30
   18f72:	4668      	mov	r0, sp
   18f74:	7b40      	ldrb	r0, [r0, #13]
   18f76:	f003 f93f 	bl	1c1f8 <PE_ExtRevisionInteroperability>
   18f7a:	89f8      	ldrh	r0, [r7, #14]
   18f7c:	0440      	lsls	r0, r0, #17
   18f7e:	0f40      	lsrs	r0, r0, #29
   18f80:	0083      	lsls	r3, r0, #2
   18f82:	20a1      	movs	r0, #161	; 0xa1
   18f84:	0040      	lsls	r0, r0, #1
   18f86:	1822      	adds	r2, r4, r0
   18f88:	2104      	movs	r1, #4
   18f8a:	6927      	ldr	r7, [r4, #16]
   18f8c:	2001      	movs	r0, #1
   18f8e:	4038      	ands	r0, r7
   18f90:	68a7      	ldr	r7, [r4, #8]
   18f92:	69bf      	ldr	r7, [r7, #24]
   18f94:	47b8      	blx	r7
   18f96:	83a6      	strh	r6, [r4, #28]
   18f98:	2014      	movs	r0, #20
   18f9a:	4669      	mov	r1, sp
   18f9c:	7308      	strb	r0, [r1, #12]
   18f9e:	6921      	ldr	r1, [r4, #16]
   18fa0:	2001      	movs	r0, #1
   18fa2:	4008      	ands	r0, r1
   18fa4:	f004 fc19 	bl	1d7da <USBPD_PRL_EnableRX>
   18fa8:	6860      	ldr	r0, [r4, #4]
   18faa:	6801      	ldr	r1, [r0, #0]
   18fac:	2210      	movs	r2, #16
   18fae:	4391      	bics	r1, r2
   18fb0:	6001      	str	r1, [r0, #0]
   18fb2:	2044      	movs	r0, #68	; 0x44
   18fb4:	494b      	ldr	r1, [pc, #300]	; (190e4 <__iar_annotation$$branch+0x244>)
   18fb6:	1861      	adds	r1, r4, r1
   18fb8:	70c8      	strb	r0, [r1, #3]
   18fba:	20a5      	movs	r0, #165	; 0xa5
   18fbc:	0080      	lsls	r0, r0, #2
   18fbe:	5a20      	ldrh	r0, [r4, r0]
   18fc0:	03a9      	lsls	r1, r5, #14
   18fc2:	4288      	cmp	r0, r1
   18fc4:	d104      	bne.n	18fd0 <__iar_annotation$$branch+0x130>
   18fc6:	200f      	movs	r0, #15
   18fc8:	4946      	ldr	r1, [pc, #280]	; (190e4 <__iar_annotation$$branch+0x244>)
   18fca:	1861      	adds	r1, r4, r1
   18fcc:	70c8      	strb	r0, [r1, #3]
   18fce:	2500      	movs	r5, #0
   18fd0:	e70f      	b.n	18df2 <__iar_annotation$$branch+0x12>
   18fd2:	2001      	movs	r0, #1
   18fd4:	83a0      	strh	r0, [r4, #28]
   18fd6:	466a      	mov	r2, sp
   18fd8:	0021      	movs	r1, r4
   18fda:	3114      	adds	r1, #20
   18fdc:	6923      	ldr	r3, [r4, #16]
   18fde:	4018      	ands	r0, r3
   18fe0:	68a3      	ldr	r3, [r4, #8]
   18fe2:	6a1b      	ldr	r3, [r3, #32]
   18fe4:	4798      	blx	r3
   18fe6:	6920      	ldr	r0, [r4, #16]
   18fe8:	210c      	movs	r1, #12
   18fea:	4388      	bics	r0, r1
   18fec:	9900      	ldr	r1, [sp, #0]
   18fee:	0089      	lsls	r1, r1, #2
   18ff0:	220c      	movs	r2, #12
   18ff2:	400a      	ands	r2, r1
   18ff4:	4302      	orrs	r2, r0
   18ff6:	6122      	str	r2, [r4, #16]
   18ff8:	2045      	movs	r0, #69	; 0x45
   18ffa:	e7e5      	b.n	18fc8 <__iar_annotation$$branch+0x128>
   18ffc:	6920      	ldr	r0, [r4, #16]
   18ffe:	0bc0      	lsrs	r0, r0, #15
   19000:	4030      	ands	r0, r6
   19002:	d000      	beq.n	19006 <__iar_annotation$$branch+0x166>
   19004:	2002      	movs	r0, #2
   19006:	9002      	str	r0, [sp, #8]
   19008:	2046      	movs	r0, #70	; 0x46
   1900a:	9001      	str	r0, [sp, #4]
   1900c:	9600      	str	r6, [sp, #0]
   1900e:	0023      	movs	r3, r4
   19010:	3314      	adds	r3, #20
   19012:	2202      	movs	r2, #2
   19014:	2100      	movs	r1, #0
   19016:	0020      	movs	r0, r4
   19018:	f001 fcac 	bl	1a974 <PE_Send_DataMessage>
   1901c:	2800      	cmp	r0, #0
   1901e:	d107      	bne.n	19030 <__iar_annotation$$branch+0x190>
   19020:	6920      	ldr	r0, [r4, #16]
   19022:	49ce      	ldr	r1, [pc, #824]	; (1935c <__iar_annotation$$branch+0x4bc>)
   19024:	4001      	ands	r1, r0
   19026:	6121      	str	r1, [r4, #16]
   19028:	20a5      	movs	r0, #165	; 0xa5
   1902a:	0080      	lsls	r0, r0, #2
   1902c:	5227      	strh	r7, [r4, r0]
   1902e:	2518      	movs	r5, #24
   19030:	e6df      	b.n	18df2 <__iar_annotation$$branch+0x12>
   19032:	a903      	add	r1, sp, #12
   19034:	0020      	movs	r0, r4
   19036:	f000 ff37 	bl	19ea8 <PE_StateMachine_SNK_SelectCapa>
   1903a:	e6d9      	b.n	18df0 <__iar_annotation$$branch+0x10>
   1903c:	2911      	cmp	r1, #17
   1903e:	d159      	bne.n	190f4 <__iar_annotation$$branch+0x254>
   19040:	20a5      	movs	r0, #165	; 0xa5
   19042:	0080      	lsls	r0, r0, #2
   19044:	1820      	adds	r0, r4, r0
   19046:	89c0      	ldrh	r0, [r0, #14]
   19048:	49c5      	ldr	r1, [pc, #788]	; (19360 <__iar_annotation$$branch+0x4c0>)
   1904a:	4001      	ands	r1, r0
   1904c:	2906      	cmp	r1, #6
   1904e:	d151      	bne.n	190f4 <__iar_annotation$$branch+0x254>
   19050:	2014      	movs	r0, #20
   19052:	4669      	mov	r1, sp
   19054:	7308      	strb	r0, [r1, #12]
   19056:	6921      	ldr	r1, [r4, #16]
   19058:	2001      	movs	r0, #1
   1905a:	4008      	ands	r0, r1
   1905c:	f004 fbbd 	bl	1d7da <USBPD_PRL_EnableRX>
   19060:	6860      	ldr	r0, [r4, #4]
   19062:	6801      	ldr	r1, [r0, #0]
   19064:	054a      	lsls	r2, r1, #21
   19066:	0f52      	lsrs	r2, r2, #29
   19068:	2a03      	cmp	r2, #3
   1906a:	d017      	beq.n	1909c <__iar_annotation$$branch+0x1fc>
   1906c:	4abd      	ldr	r2, [pc, #756]	; (19364 <__iar_annotation$$branch+0x4c4>)
   1906e:	400a      	ands	r2, r1
   19070:	21c0      	movs	r1, #192	; 0xc0
   19072:	0089      	lsls	r1, r1, #2
   19074:	4311      	orrs	r1, r2
   19076:	6001      	str	r1, [r0, #0]
   19078:	2000      	movs	r0, #0
   1907a:	9000      	str	r0, [sp, #0]
   1907c:	2300      	movs	r3, #0
   1907e:	225a      	movs	r2, #90	; 0x5a
   19080:	6920      	ldr	r0, [r4, #16]
   19082:	2101      	movs	r1, #1
   19084:	4001      	ands	r1, r0
   19086:	2009      	movs	r0, #9
   19088:	4d15      	ldr	r5, [pc, #84]	; (190e0 <__iar_annotation$$branch+0x240>)
   1908a:	6a2d      	ldr	r5, [r5, #32]
   1908c:	47a8      	blx	r5
   1908e:	215a      	movs	r1, #90	; 0x5a
   19090:	6922      	ldr	r2, [r4, #16]
   19092:	2001      	movs	r0, #1
   19094:	4010      	ands	r0, r2
   19096:	68a2      	ldr	r2, [r4, #8]
   19098:	68d2      	ldr	r2, [r2, #12]
   1909a:	4790      	blx	r2
   1909c:	2500      	movs	r5, #0
   1909e:	83a5      	strh	r5, [r4, #28]
   190a0:	2003      	movs	r0, #3
   190a2:	4910      	ldr	r1, [pc, #64]	; (190e4 <__iar_annotation$$branch+0x244>)
   190a4:	1861      	adds	r1, r4, r1
   190a6:	70c8      	strb	r0, [r1, #3]
   190a8:	9500      	str	r5, [sp, #0]
   190aa:	2300      	movs	r3, #0
   190ac:	2210      	movs	r2, #16
   190ae:	6920      	ldr	r0, [r4, #16]
   190b0:	2101      	movs	r1, #1
   190b2:	4001      	ands	r1, r0
   190b4:	2009      	movs	r0, #9
   190b6:	4f0a      	ldr	r7, [pc, #40]	; (190e0 <__iar_annotation$$branch+0x240>)
   190b8:	6a3f      	ldr	r7, [r7, #32]
   190ba:	47b8      	blx	r7
   190bc:	2110      	movs	r1, #16
   190be:	6922      	ldr	r2, [r4, #16]
   190c0:	2001      	movs	r0, #1
   190c2:	4010      	ands	r0, r2
   190c4:	68a2      	ldr	r2, [r4, #8]
   190c6:	68d2      	ldr	r2, [r2, #12]
   190c8:	4790      	blx	r2
   190ca:	6920      	ldr	r0, [r4, #16]
   190cc:	0700      	lsls	r0, r0, #28
   190ce:	0f80      	lsrs	r0, r0, #30
   190d0:	2803      	cmp	r0, #3
   190d2:	d10b      	bne.n	190ec <__iar_annotation$$branch+0x24c>
   190d4:	48a4      	ldr	r0, [pc, #656]	; (19368 <__iar_annotation$$branch+0x4c8>)
   190d6:	21a5      	movs	r1, #165	; 0xa5
   190d8:	0089      	lsls	r1, r1, #2
   190da:	1861      	adds	r1, r4, r1
   190dc:	8148      	strh	r0, [r1, #10]
   190de:	e009      	b.n	190f4 <__iar_annotation$$branch+0x254>
   190e0:	0002ff54 	.word	0x0002ff54
   190e4:	0000028d 	.word	0x0000028d
   190e8:	b5e8b5cd 	.word	0xb5e8b5cd
   190ec:	21a5      	movs	r1, #165	; 0xa5
   190ee:	0089      	lsls	r1, r1, #2
   190f0:	1861      	adds	r1, r4, r1
   190f2:	814d      	strh	r5, [r1, #10]
   190f4:	20a5      	movs	r0, #165	; 0xa5
   190f6:	0080      	lsls	r0, r0, #2
   190f8:	5a20      	ldrh	r0, [r4, r0]
   190fa:	03f1      	lsls	r1, r6, #15
   190fc:	4288      	cmp	r0, r1
   190fe:	d197      	bne.n	19030 <__iar_annotation$$branch+0x190>
   19100:	e761      	b.n	18fc6 <__iar_annotation$$branch+0x126>
   19102:	a903      	add	r1, sp, #12
   19104:	0020      	movs	r0, r4
   19106:	f001 fccf 	bl	1aaa8 <PE_StateMachine_VDMCable>
   1910a:	e671      	b.n	18df0 <__iar_annotation$$branch+0x10>
   1910c:	6860      	ldr	r0, [r4, #4]
   1910e:	6800      	ldr	r0, [r0, #0]
   19110:	0bc0      	lsrs	r0, r0, #15
   19112:	4030      	ands	r0, r6
   19114:	d008      	beq.n	19128 <__iar_annotation$$branch+0x288>
   19116:	68a0      	ldr	r0, [r4, #8]
   19118:	6b02      	ldr	r2, [r0, #48]	; 0x30
   1911a:	2a00      	cmp	r2, #0
   1911c:	d004      	beq.n	19128 <__iar_annotation$$branch+0x288>
   1911e:	2100      	movs	r1, #0
   19120:	6923      	ldr	r3, [r4, #16]
   19122:	2001      	movs	r0, #1
   19124:	4018      	ands	r0, r3
   19126:	4790      	blx	r2
   19128:	6920      	ldr	r0, [r4, #16]
   1912a:	4990      	ldr	r1, [pc, #576]	; (1936c <__iar_annotation$$branch+0x4cc>)
   1912c:	4001      	ands	r1, r0
   1912e:	6121      	str	r1, [r4, #16]
   19130:	2000      	movs	r0, #0
   19132:	83a0      	strh	r0, [r4, #28]
   19134:	498e      	ldr	r1, [pc, #568]	; (19370 <__iar_annotation$$branch+0x4d0>)
   19136:	5460      	strb	r0, [r4, r1]
   19138:	6860      	ldr	r0, [r4, #4]
   1913a:	6801      	ldr	r1, [r0, #0]
   1913c:	2210      	movs	r2, #16
   1913e:	4391      	bics	r1, r2
   19140:	6001      	str	r1, [r0, #0]
   19142:	6860      	ldr	r0, [r4, #4]
   19144:	6801      	ldr	r1, [r0, #0]
   19146:	054a      	lsls	r2, r1, #21
   19148:	0f52      	lsrs	r2, r2, #29
   1914a:	2a01      	cmp	r2, #1
   1914c:	d016      	beq.n	1917c <__iar_annotation$$branch+0x2dc>
   1914e:	4a85      	ldr	r2, [pc, #532]	; (19364 <__iar_annotation$$branch+0x4c4>)
   19150:	400a      	ands	r2, r1
   19152:	01e9      	lsls	r1, r5, #7
   19154:	4311      	orrs	r1, r2
   19156:	6001      	str	r1, [r0, #0]
   19158:	2000      	movs	r0, #0
   1915a:	9000      	str	r0, [sp, #0]
   1915c:	2300      	movs	r3, #0
   1915e:	225a      	movs	r2, #90	; 0x5a
   19160:	6920      	ldr	r0, [r4, #16]
   19162:	2101      	movs	r1, #1
   19164:	4001      	ands	r1, r0
   19166:	2009      	movs	r0, #9
   19168:	4f82      	ldr	r7, [pc, #520]	; (19374 <__iar_annotation$$branch+0x4d4>)
   1916a:	6a3f      	ldr	r7, [r7, #32]
   1916c:	47b8      	blx	r7
   1916e:	215a      	movs	r1, #90	; 0x5a
   19170:	6922      	ldr	r2, [r4, #16]
   19172:	2001      	movs	r0, #1
   19174:	4010      	ands	r0, r2
   19176:	68a2      	ldr	r2, [r4, #8]
   19178:	68d2      	ldr	r2, [r2, #12]
   1917a:	4790      	blx	r2
   1917c:	7e20      	ldrb	r0, [r4, #24]
   1917e:	2803      	cmp	r0, #3
   19180:	d30b      	bcc.n	1919a <__iar_annotation$$branch+0x2fa>
   19182:	6920      	ldr	r0, [r4, #16]
   19184:	0840      	lsrs	r0, r0, #1
   19186:	4030      	ands	r0, r6
   19188:	d004      	beq.n	19194 <__iar_annotation$$branch+0x2f4>
   1918a:	68a0      	ldr	r0, [r4, #8]
   1918c:	6b40      	ldr	r0, [r0, #52]	; 0x34
   1918e:	2800      	cmp	r0, #0
   19190:	d000      	beq.n	19194 <__iar_annotation$$branch+0x2f4>
   19192:	e3a9      	b.n	198e8 <__iar_annotation$$branch+0xa48>
   19194:	2000      	movs	r0, #0
   19196:	4976      	ldr	r1, [pc, #472]	; (19370 <__iar_annotation$$branch+0x4d0>)
   19198:	e6d1      	b.n	18f3e <__iar_annotation$$branch+0x9e>
   1919a:	1c40      	adds	r0, r0, #1
   1919c:	7620      	strb	r0, [r4, #24]
   1919e:	2105      	movs	r1, #5
   191a0:	0020      	movs	r0, r4
   191a2:	f001 fc35 	bl	1aa10 <PE_Send_RESET>
   191a6:	2101      	movs	r1, #1
   191a8:	4668      	mov	r0, sp
   191aa:	7b40      	ldrb	r0, [r0, #13]
   191ac:	f002 fecd 	bl	1bf4a <PE_Reset>
   191b0:	48d5      	ldr	r0, [pc, #852]	; (19508 <__iar_annotation$$branch+0x668>)
   191b2:	21a5      	movs	r1, #165	; 0xa5
   191b4:	0089      	lsls	r1, r1, #2
   191b6:	5260      	strh	r0, [r4, r1]
   191b8:	68a0      	ldr	r0, [r4, #8]
   191ba:	6843      	ldr	r3, [r0, #4]
   191bc:	2b00      	cmp	r3, #0
   191be:	d005      	beq.n	191cc <__iar_annotation$$branch+0x32c>
   191c0:	2201      	movs	r2, #1
   191c2:	2101      	movs	r1, #1
   191c4:	6925      	ldr	r5, [r4, #16]
   191c6:	2001      	movs	r0, #1
   191c8:	4028      	ands	r0, r5
   191ca:	4798      	blx	r3
   191cc:	209b      	movs	r0, #155	; 0x9b
   191ce:	e6fb      	b.n	18fc8 <__iar_annotation$$branch+0x128>
   191d0:	6860      	ldr	r0, [r4, #4]
   191d2:	6800      	ldr	r0, [r0, #0]
   191d4:	0bc0      	lsrs	r0, r0, #15
   191d6:	4030      	ands	r0, r6
   191d8:	d008      	beq.n	191ec <__iar_annotation$$branch+0x34c>
   191da:	68a0      	ldr	r0, [r4, #8]
   191dc:	6b02      	ldr	r2, [r0, #48]	; 0x30
   191de:	2a00      	cmp	r2, #0
   191e0:	d004      	beq.n	191ec <__iar_annotation$$branch+0x34c>
   191e2:	2100      	movs	r1, #0
   191e4:	6923      	ldr	r3, [r4, #16]
   191e6:	2001      	movs	r0, #1
   191e8:	4018      	ands	r0, r3
   191ea:	4790      	blx	r2
   191ec:	2000      	movs	r0, #0
   191ee:	9000      	str	r0, [sp, #0]
   191f0:	2300      	movs	r3, #0
   191f2:	221e      	movs	r2, #30
   191f4:	6920      	ldr	r0, [r4, #16]
   191f6:	2101      	movs	r1, #1
   191f8:	4001      	ands	r1, r0
   191fa:	2009      	movs	r0, #9
   191fc:	4d5d      	ldr	r5, [pc, #372]	; (19374 <__iar_annotation$$branch+0x4d4>)
   191fe:	6a2d      	ldr	r5, [r5, #32]
   19200:	47a8      	blx	r5
   19202:	211e      	movs	r1, #30
   19204:	6922      	ldr	r2, [r4, #16]
   19206:	2001      	movs	r0, #1
   19208:	4010      	ands	r0, r2
   1920a:	68a2      	ldr	r2, [r4, #8]
   1920c:	68d2      	ldr	r2, [r2, #12]
   1920e:	4790      	blx	r2
   19210:	2101      	movs	r1, #1
   19212:	4668      	mov	r0, sp
   19214:	7b40      	ldrb	r0, [r0, #13]
   19216:	f002 fe98 	bl	1bf4a <PE_Reset>
   1921a:	68a0      	ldr	r0, [r4, #8]
   1921c:	6843      	ldr	r3, [r0, #4]
   1921e:	2b00      	cmp	r3, #0
   19220:	d005      	beq.n	1922e <__iar_annotation$$branch+0x38e>
   19222:	2200      	movs	r2, #0
   19224:	2101      	movs	r1, #1
   19226:	6925      	ldr	r5, [r4, #16]
   19228:	2001      	movs	r0, #1
   1922a:	4028      	ands	r0, r5
   1922c:	4798      	blx	r3
   1922e:	48b6      	ldr	r0, [pc, #728]	; (19508 <__iar_annotation$$branch+0x668>)
   19230:	21a5      	movs	r1, #165	; 0xa5
   19232:	0089      	lsls	r1, r1, #2
   19234:	5260      	strh	r0, [r4, r1]
   19236:	209b      	movs	r0, #155	; 0x9b
   19238:	1fc9      	subs	r1, r1, #7
   1923a:	e6c6      	b.n	18fca <__iar_annotation$$branch+0x12a>
   1923c:	000081f4 	.word	0x000081f4
   19240:	2100      	movs	r1, #0
   19242:	4668      	mov	r0, sp
   19244:	7b40      	ldrb	r0, [r0, #13]
   19246:	68a2      	ldr	r2, [r4, #8]
   19248:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
   1924a:	4790      	blx	r2
   1924c:	2801      	cmp	r0, #1
   1924e:	d119      	bne.n	19284 <__iar_annotation$$branch+0x3e4>
   19250:	48ae      	ldr	r0, [pc, #696]	; (1950c <__iar_annotation$$branch+0x66c>)
   19252:	21a5      	movs	r1, #165	; 0xa5
   19254:	0089      	lsls	r1, r1, #2
   19256:	5260      	strh	r0, [r4, r1]
   19258:	2040      	movs	r0, #64	; 0x40
   1925a:	1fc9      	subs	r1, r1, #7
   1925c:	1861      	adds	r1, r4, r1
   1925e:	70c8      	strb	r0, [r1, #3]
   19260:	2500      	movs	r5, #0
   19262:	9500      	str	r5, [sp, #0]
   19264:	2300      	movs	r3, #0
   19266:	2213      	movs	r2, #19
   19268:	6920      	ldr	r0, [r4, #16]
   1926a:	2101      	movs	r1, #1
   1926c:	4001      	ands	r1, r0
   1926e:	2009      	movs	r0, #9
   19270:	4f40      	ldr	r7, [pc, #256]	; (19374 <__iar_annotation$$branch+0x4d4>)
   19272:	6a3f      	ldr	r7, [r7, #32]
   19274:	47b8      	blx	r7
   19276:	2113      	movs	r1, #19
   19278:	6922      	ldr	r2, [r4, #16]
   1927a:	2001      	movs	r0, #1
   1927c:	4010      	ands	r0, r2
   1927e:	68a2      	ldr	r2, [r4, #8]
   19280:	68d2      	ldr	r2, [r2, #12]
   19282:	4790      	blx	r2
   19284:	20a5      	movs	r0, #165	; 0xa5
   19286:	0080      	lsls	r0, r0, #2
   19288:	5a20      	ldrh	r0, [r4, r0]
   1928a:	03f1      	lsls	r1, r6, #15
   1928c:	4288      	cmp	r0, r1
   1928e:	d145      	bne.n	1931c <__iar_annotation$$branch+0x47c>
   19290:	e029      	b.n	192e6 <__iar_annotation$$branch+0x446>
   19292:	2101      	movs	r1, #1
   19294:	4668      	mov	r0, sp
   19296:	7b40      	ldrb	r0, [r0, #13]
   19298:	68a2      	ldr	r2, [r4, #8]
   1929a:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
   1929c:	4790      	blx	r2
   1929e:	2801      	cmp	r0, #1
   192a0:	d11b      	bne.n	192da <__iar_annotation$$branch+0x43a>
   192a2:	68a0      	ldr	r0, [r4, #8]
   192a4:	6843      	ldr	r3, [r0, #4]
   192a6:	2b00      	cmp	r3, #0
   192a8:	d005      	beq.n	192b6 <__iar_annotation$$branch+0x416>
   192aa:	2205      	movs	r2, #5
   192ac:	2100      	movs	r1, #0
   192ae:	6925      	ldr	r5, [r4, #16]
   192b0:	2001      	movs	r0, #1
   192b2:	4028      	ands	r0, r5
   192b4:	4798      	blx	r3
   192b6:	4668      	mov	r0, sp
   192b8:	7b40      	ldrb	r0, [r0, #13]
   192ba:	f004 fcd9 	bl	1dc70 <USBPD_PRL_PowerSinkReset>
   192be:	4668      	mov	r0, sp
   192c0:	7b40      	ldrb	r0, [r0, #13]
   192c2:	f004 fa8a 	bl	1d7da <USBPD_PRL_EnableRX>
   192c6:	4892      	ldr	r0, [pc, #584]	; (19510 <__iar_annotation$$branch+0x670>)
   192c8:	21a5      	movs	r1, #165	; 0xa5
   192ca:	0089      	lsls	r1, r1, #2
   192cc:	5260      	strh	r0, [r4, r1]
   192ce:	25fa      	movs	r5, #250	; 0xfa
   192d0:	006d      	lsls	r5, r5, #1
   192d2:	2043      	movs	r0, #67	; 0x43
   192d4:	1fc9      	subs	r1, r1, #7
   192d6:	1861      	adds	r1, r4, r1
   192d8:	70c8      	strb	r0, [r1, #3]
   192da:	20a5      	movs	r0, #165	; 0xa5
   192dc:	0080      	lsls	r0, r0, #2
   192de:	5a20      	ldrh	r0, [r4, r0]
   192e0:	03f1      	lsls	r1, r6, #15
   192e2:	4288      	cmp	r0, r1
   192e4:	d11a      	bne.n	1931c <__iar_annotation$$branch+0x47c>
   192e6:	68a0      	ldr	r0, [r4, #8]
   192e8:	6843      	ldr	r3, [r0, #4]
   192ea:	2b00      	cmp	r3, #0
   192ec:	d005      	beq.n	192fa <__iar_annotation$$branch+0x45a>
   192ee:	2206      	movs	r2, #6
   192f0:	2100      	movs	r1, #0
   192f2:	6925      	ldr	r5, [r4, #16]
   192f4:	2001      	movs	r0, #1
   192f6:	4028      	ands	r0, r5
   192f8:	4798      	blx	r3
   192fa:	7e20      	ldrb	r0, [r4, #24]
   192fc:	2803      	cmp	r0, #3
   192fe:	d200      	bcs.n	19302 <__iar_annotation$$branch+0x462>
   19300:	e661      	b.n	18fc6 <__iar_annotation$$branch+0x126>
   19302:	6920      	ldr	r0, [r4, #16]
   19304:	0840      	lsrs	r0, r0, #1
   19306:	4030      	ands	r0, r6
   19308:	d004      	beq.n	19314 <__iar_annotation$$branch+0x474>
   1930a:	68a0      	ldr	r0, [r4, #8]
   1930c:	6b40      	ldr	r0, [r0, #52]	; 0x34
   1930e:	2800      	cmp	r0, #0
   19310:	d000      	beq.n	19314 <__iar_annotation$$branch+0x474>
   19312:	e2e9      	b.n	198e8 <__iar_annotation$$branch+0xa48>
   19314:	2500      	movs	r5, #0
   19316:	4916      	ldr	r1, [pc, #88]	; (19370 <__iar_annotation$$branch+0x4d0>)
   19318:	1861      	adds	r1, r4, r1
   1931a:	70cd      	strb	r5, [r1, #3]
   1931c:	e569      	b.n	18df2 <__iar_annotation$$branch+0x12>
   1931e:	0020      	movs	r0, r4
   19320:	f001 fb64 	bl	1a9ec <PE_PerformSoftReset>
   19324:	2000      	movs	r0, #0
   19326:	9000      	str	r0, [sp, #0]
   19328:	2303      	movs	r3, #3
   1932a:	2203      	movs	r2, #3
   1932c:	2100      	movs	r1, #0
   1932e:	0020      	movs	r0, r4
   19330:	f001 fae0 	bl	1a8f4 <PE_Send_CtrlMessage>
   19334:	2800      	cmp	r0, #0
   19336:	d1f1      	bne.n	1931c <__iar_annotation$$branch+0x47c>
   19338:	9000      	str	r0, [sp, #0]
   1933a:	2300      	movs	r3, #0
   1933c:	2231      	movs	r2, #49	; 0x31
   1933e:	6920      	ldr	r0, [r4, #16]
   19340:	2101      	movs	r1, #1
   19342:	4001      	ands	r1, r0
   19344:	2009      	movs	r0, #9
   19346:	4f0b      	ldr	r7, [pc, #44]	; (19374 <__iar_annotation$$branch+0x4d4>)
   19348:	6a3f      	ldr	r7, [r7, #32]
   1934a:	47b8      	blx	r7
   1934c:	2131      	movs	r1, #49	; 0x31
   1934e:	6922      	ldr	r2, [r4, #16]
   19350:	2001      	movs	r0, #1
   19352:	4010      	ands	r0, r2
   19354:	68a2      	ldr	r2, [r4, #8]
   19356:	68d2      	ldr	r2, [r2, #12]
   19358:	4790      	blx	r2
   1935a:	e54a      	b.n	18df2 <__iar_annotation$$branch+0x12>
   1935c:	ffff7fff 	.word	0xffff7fff
   19360:	0000f01f 	.word	0x0000f01f
   19364:	fffff8ff 	.word	0xfffff8ff
   19368:	0000a328 	.word	0x0000a328
   1936c:	fffffcff 	.word	0xfffffcff
   19370:	0000028d 	.word	0x0000028d
   19374:	0002ff54 	.word	0x0002ff54
   19378:	6860      	ldr	r0, [r4, #4]
   1937a:	6800      	ldr	r0, [r0, #0]
   1937c:	0540      	lsls	r0, r0, #21
   1937e:	0f40      	lsrs	r0, r0, #29
   19380:	2804      	cmp	r0, #4
   19382:	d100      	bne.n	19386 <__iar_annotation$$branch+0x4e6>
   19384:	e61f      	b.n	18fc6 <__iar_annotation$$branch+0x126>
   19386:	2000      	movs	r0, #0
   19388:	9000      	str	r0, [sp, #0]
   1938a:	2350      	movs	r3, #80	; 0x50
   1938c:	220d      	movs	r2, #13
   1938e:	2100      	movs	r1, #0
   19390:	0020      	movs	r0, r4
   19392:	f001 faaf 	bl	1a8f4 <PE_Send_CtrlMessage>
   19396:	2800      	cmp	r0, #0
   19398:	d1df      	bne.n	1935a <__iar_annotation$$branch+0x4ba>
   1939a:	2003      	movs	r0, #3
   1939c:	83a0      	strh	r0, [r4, #28]
   1939e:	20a5      	movs	r0, #165	; 0xa5
   193a0:	0080      	lsls	r0, r0, #2
   193a2:	5227      	strh	r7, [r4, r0]
   193a4:	2518      	movs	r5, #24
   193a6:	2000      	movs	r0, #0
   193a8:	9000      	str	r0, [sp, #0]
   193aa:	2300      	movs	r3, #0
   193ac:	2230      	movs	r2, #48	; 0x30
   193ae:	6920      	ldr	r0, [r4, #16]
   193b0:	2101      	movs	r1, #1
   193b2:	4001      	ands	r1, r0
   193b4:	2009      	movs	r0, #9
   193b6:	4fc0      	ldr	r7, [pc, #768]	; (196b8 <__iar_annotation$$branch+0x818>)
   193b8:	6a3f      	ldr	r7, [r7, #32]
   193ba:	47b8      	blx	r7
   193bc:	2130      	movs	r1, #48	; 0x30
   193be:	e7c6      	b.n	1934e <__iar_annotation$$branch+0x4ae>
   193c0:	2911      	cmp	r1, #17
   193c2:	d117      	bne.n	193f4 <__iar_annotation$$branch+0x554>
   193c4:	20a5      	movs	r0, #165	; 0xa5
   193c6:	0080      	lsls	r0, r0, #2
   193c8:	1820      	adds	r0, r4, r0
   193ca:	89c0      	ldrh	r0, [r0, #14]
   193cc:	49bb      	ldr	r1, [pc, #748]	; (196bc <__iar_annotation$$branch+0x81c>)
   193ce:	4001      	ands	r1, r0
   193d0:	2903      	cmp	r1, #3
   193d2:	d10f      	bne.n	193f4 <__iar_annotation$$branch+0x554>
   193d4:	0020      	movs	r0, r4
   193d6:	f001 fb09 	bl	1a9ec <PE_PerformSoftReset>
   193da:	2003      	movs	r0, #3
   193dc:	49b8      	ldr	r1, [pc, #736]	; (196c0 <__iar_annotation$$branch+0x820>)
   193de:	1861      	adds	r1, r4, r1
   193e0:	70c8      	strb	r0, [r1, #3]
   193e2:	2500      	movs	r5, #0
   193e4:	2014      	movs	r0, #20
   193e6:	4669      	mov	r1, sp
   193e8:	7308      	strb	r0, [r1, #12]
   193ea:	6921      	ldr	r1, [r4, #16]
   193ec:	2001      	movs	r0, #1
   193ee:	4008      	ands	r0, r1
   193f0:	f004 f9f3 	bl	1d7da <USBPD_PRL_EnableRX>
   193f4:	e67e      	b.n	190f4 <__iar_annotation$$branch+0x254>
   193f6:	9500      	str	r5, [sp, #0]
   193f8:	2343      	movs	r3, #67	; 0x43
   193fa:	2207      	movs	r2, #7
   193fc:	2100      	movs	r1, #0
   193fe:	0020      	movs	r0, r4
   19400:	f001 fa78 	bl	1a8f4 <PE_Send_CtrlMessage>
   19404:	2800      	cmp	r0, #0
   19406:	d13b      	bne.n	19480 <__iar_annotation$$branch+0x5e0>
   19408:	2006      	movs	r0, #6
   1940a:	83a0      	strh	r0, [r4, #28]
   1940c:	20a5      	movs	r0, #165	; 0xa5
   1940e:	0080      	lsls	r0, r0, #2
   19410:	5227      	strh	r7, [r4, r0]
   19412:	2518      	movs	r5, #24
   19414:	2000      	movs	r0, #0
   19416:	9000      	str	r0, [sp, #0]
   19418:	2300      	movs	r3, #0
   1941a:	220b      	movs	r2, #11
   1941c:	6920      	ldr	r0, [r4, #16]
   1941e:	2101      	movs	r1, #1
   19420:	4001      	ands	r1, r0
   19422:	2009      	movs	r0, #9
   19424:	4fa4      	ldr	r7, [pc, #656]	; (196b8 <__iar_annotation$$branch+0x818>)
   19426:	6a3f      	ldr	r7, [r7, #32]
   19428:	47b8      	blx	r7
   1942a:	210b      	movs	r1, #11
   1942c:	e78f      	b.n	1934e <__iar_annotation$$branch+0x4ae>
   1942e:	2911      	cmp	r1, #17
   19430:	d126      	bne.n	19480 <__iar_annotation$$branch+0x5e0>
   19432:	20a5      	movs	r0, #165	; 0xa5
   19434:	0080      	lsls	r0, r0, #2
   19436:	1820      	adds	r0, r4, r0
   19438:	89c0      	ldrh	r0, [r0, #14]
   1943a:	49a0      	ldr	r1, [pc, #640]	; (196bc <__iar_annotation$$branch+0x81c>)
   1943c:	4001      	ands	r1, r0
   1943e:	2906      	cmp	r1, #6
   19440:	d11e      	bne.n	19480 <__iar_annotation$$branch+0x5e0>
   19442:	2000      	movs	r0, #0
   19444:	9000      	str	r0, [sp, #0]
   19446:	2300      	movs	r3, #0
   19448:	222c      	movs	r2, #44	; 0x2c
   1944a:	6920      	ldr	r0, [r4, #16]
   1944c:	2101      	movs	r1, #1
   1944e:	4001      	ands	r1, r0
   19450:	2009      	movs	r0, #9
   19452:	4d99      	ldr	r5, [pc, #612]	; (196b8 <__iar_annotation$$branch+0x818>)
   19454:	6a2d      	ldr	r5, [r5, #32]
   19456:	47a8      	blx	r5
   19458:	212c      	movs	r1, #44	; 0x2c
   1945a:	6922      	ldr	r2, [r4, #16]
   1945c:	2001      	movs	r0, #1
   1945e:	4010      	ands	r0, r2
   19460:	68a2      	ldr	r2, [r4, #8]
   19462:	68d2      	ldr	r2, [r2, #12]
   19464:	4790      	blx	r2
   19466:	2003      	movs	r0, #3
   19468:	4995      	ldr	r1, [pc, #596]	; (196c0 <__iar_annotation$$branch+0x820>)
   1946a:	1861      	adds	r1, r4, r1
   1946c:	70c8      	strb	r0, [r1, #3]
   1946e:	2500      	movs	r5, #0
   19470:	2014      	movs	r0, #20
   19472:	4669      	mov	r1, sp
   19474:	7308      	strb	r0, [r1, #12]
   19476:	6921      	ldr	r1, [r4, #16]
   19478:	2001      	movs	r0, #1
   1947a:	4008      	ands	r0, r1
   1947c:	f004 f9ad 	bl	1d7da <USBPD_PRL_EnableRX>
   19480:	e4b7      	b.n	18df2 <__iar_annotation$$branch+0x12>
   19482:	2000      	movs	r0, #0
   19484:	9000      	str	r0, [sp, #0]
   19486:	2303      	movs	r3, #3
   19488:	2204      	movs	r2, #4
   1948a:	2100      	movs	r1, #0
   1948c:	0020      	movs	r0, r4
   1948e:	f001 fa31 	bl	1a8f4 <PE_Send_CtrlMessage>
   19492:	2800      	cmp	r0, #0
   19494:	d1f4      	bne.n	19480 <__iar_annotation$$branch+0x5e0>
   19496:	9000      	str	r0, [sp, #0]
   19498:	2300      	movs	r3, #0
   1949a:	2216      	movs	r2, #22
   1949c:	6920      	ldr	r0, [r4, #16]
   1949e:	2101      	movs	r1, #1
   194a0:	4001      	ands	r1, r0
   194a2:	2009      	movs	r0, #9
   194a4:	4f84      	ldr	r7, [pc, #528]	; (196b8 <__iar_annotation$$branch+0x818>)
   194a6:	6a3f      	ldr	r7, [r7, #32]
   194a8:	47b8      	blx	r7
   194aa:	2116      	movs	r1, #22
   194ac:	e74f      	b.n	1934e <__iar_annotation$$branch+0x4ae>
   194ae:	4984      	ldr	r1, [pc, #528]	; (196c0 <__iar_annotation$$branch+0x820>)
   194b0:	1865      	adds	r5, r4, r1
   194b2:	2849      	cmp	r0, #73	; 0x49
   194b4:	d105      	bne.n	194c2 <__iar_annotation$$branch+0x622>
   194b6:	4883      	ldr	r0, [pc, #524]	; (196c4 <__iar_annotation$$branch+0x824>)
   194b8:	1dc9      	adds	r1, r1, #7
   194ba:	1861      	adds	r1, r4, r1
   194bc:	8048      	strh	r0, [r1, #2]
   194be:	2003      	movs	r0, #3
   194c0:	70e8      	strb	r0, [r5, #3]
   194c2:	78e8      	ldrb	r0, [r5, #3]
   194c4:	2803      	cmp	r0, #3
   194c6:	d119      	bne.n	194fc <__iar_annotation$$branch+0x65c>
   194c8:	2000      	movs	r0, #0
   194ca:	83a0      	strh	r0, [r4, #28]
   194cc:	4668      	mov	r0, sp
   194ce:	7b40      	ldrb	r0, [r0, #13]
   194d0:	f004 f983 	bl	1d7da <USBPD_PRL_EnableRX>
   194d4:	2004      	movs	r0, #4
   194d6:	70e8      	strb	r0, [r5, #3]
   194d8:	2000      	movs	r0, #0
   194da:	9000      	str	r0, [sp, #0]
   194dc:	2300      	movs	r3, #0
   194de:	2220      	movs	r2, #32
   194e0:	6920      	ldr	r0, [r4, #16]
   194e2:	2101      	movs	r1, #1
   194e4:	4001      	ands	r1, r0
   194e6:	2009      	movs	r0, #9
   194e8:	4d73      	ldr	r5, [pc, #460]	; (196b8 <__iar_annotation$$branch+0x818>)
   194ea:	6a2d      	ldr	r5, [r5, #32]
   194ec:	47a8      	blx	r5
   194ee:	2120      	movs	r1, #32
   194f0:	6922      	ldr	r2, [r4, #16]
   194f2:	2001      	movs	r0, #1
   194f4:	4010      	ands	r0, r2
   194f6:	68a2      	ldr	r2, [r4, #8]
   194f8:	68d2      	ldr	r2, [r2, #12]
   194fa:	4790      	blx	r2
   194fc:	a903      	add	r1, sp, #12
   194fe:	0020      	movs	r0, r4
   19500:	f000 fd82 	bl	1a008 <PE_StateMachine_SNK_ReadyWait>
   19504:	e474      	b.n	18df0 <__iar_annotation$$branch+0x10>
   19506:	bf00      	nop
   19508:	000083e8 	.word	0x000083e8
   1950c:	000088e3 	.word	0x000088e3
   19510:	000081f4 	.word	0x000081f4
   19514:	68a0      	ldr	r0, [r4, #8]
   19516:	6881      	ldr	r1, [r0, #8]
   19518:	2900      	cmp	r1, #0
   1951a:	d037      	beq.n	1958c <__iar_annotation$$branch+0x6ec>
   1951c:	4668      	mov	r0, sp
   1951e:	7b40      	ldrb	r0, [r0, #13]
   19520:	4788      	blx	r1
   19522:	280a      	cmp	r0, #10
   19524:	d002      	beq.n	1952c <__iar_annotation$$branch+0x68c>
   19526:	280d      	cmp	r0, #13
   19528:	d027      	beq.n	1957a <__iar_annotation$$branch+0x6da>
   1952a:	e02f      	b.n	1958c <__iar_annotation$$branch+0x6ec>
   1952c:	2201      	movs	r2, #1
   1952e:	2100      	movs	r1, #0
   19530:	6923      	ldr	r3, [r4, #16]
   19532:	2001      	movs	r0, #1
   19534:	4018      	ands	r0, r3
   19536:	68a3      	ldr	r3, [r4, #8]
   19538:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   1953a:	4798      	blx	r3
   1953c:	2000      	movs	r0, #0
   1953e:	9000      	str	r0, [sp, #0]
   19540:	2352      	movs	r3, #82	; 0x52
   19542:	2203      	movs	r2, #3
   19544:	2100      	movs	r1, #0
   19546:	0020      	movs	r0, r4
   19548:	f001 f9d4 	bl	1a8f4 <PE_Send_CtrlMessage>
   1954c:	2800      	cmp	r0, #0
   1954e:	d113      	bne.n	19578 <__iar_annotation$$branch+0x6d8>
   19550:	2008      	movs	r0, #8
   19552:	83a0      	strh	r0, [r4, #28]
   19554:	6860      	ldr	r0, [r4, #4]
   19556:	6801      	ldr	r1, [r0, #0]
   19558:	2210      	movs	r2, #16
   1955a:	430a      	orrs	r2, r1
   1955c:	6002      	str	r2, [r0, #0]
   1955e:	2206      	movs	r2, #6
   19560:	2100      	movs	r1, #0
   19562:	6923      	ldr	r3, [r4, #16]
   19564:	2001      	movs	r0, #1
   19566:	4018      	ands	r0, r3
   19568:	68a3      	ldr	r3, [r4, #8]
   1956a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   1956c:	4798      	blx	r3
   1956e:	48b5      	ldr	r0, [pc, #724]	; (19844 <__iar_annotation$$branch+0x9a4>)
   19570:	21a5      	movs	r1, #165	; 0xa5
   19572:	0089      	lsls	r1, r1, #2
   19574:	5260      	strh	r0, [r4, r1]
   19576:	4db4      	ldr	r5, [pc, #720]	; (19848 <__iar_annotation$$branch+0x9a8>)
   19578:	e43b      	b.n	18df2 <__iar_annotation$$branch+0x12>
   1957a:	2000      	movs	r0, #0
   1957c:	9000      	str	r0, [sp, #0]
   1957e:	2303      	movs	r3, #3
   19580:	220c      	movs	r2, #12
   19582:	2100      	movs	r1, #0
   19584:	0020      	movs	r0, r4
   19586:	f001 f9b5 	bl	1a8f4 <PE_Send_CtrlMessage>
   1958a:	e432      	b.n	18df2 <__iar_annotation$$branch+0x12>
   1958c:	202a      	movs	r0, #42	; 0x2a
   1958e:	e51b      	b.n	18fc8 <__iar_annotation$$branch+0x128>
   19590:	2911      	cmp	r1, #17
   19592:	d11b      	bne.n	195cc <__iar_annotation$$branch+0x72c>
   19594:	20a5      	movs	r0, #165	; 0xa5
   19596:	0080      	lsls	r0, r0, #2
   19598:	1820      	adds	r0, r4, r0
   1959a:	89c0      	ldrh	r0, [r0, #14]
   1959c:	4947      	ldr	r1, [pc, #284]	; (196bc <__iar_annotation$$branch+0x81c>)
   1959e:	4001      	ands	r1, r0
   195a0:	2906      	cmp	r1, #6
   195a2:	d113      	bne.n	195cc <__iar_annotation$$branch+0x72c>
   195a4:	2209      	movs	r2, #9
   195a6:	2100      	movs	r1, #0
   195a8:	6923      	ldr	r3, [r4, #16]
   195aa:	2001      	movs	r0, #1
   195ac:	4018      	ands	r0, r3
   195ae:	68a3      	ldr	r3, [r4, #8]
   195b0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   195b2:	4798      	blx	r3
   195b4:	2053      	movs	r0, #83	; 0x53
   195b6:	4942      	ldr	r1, [pc, #264]	; (196c0 <__iar_annotation$$branch+0x820>)
   195b8:	1861      	adds	r1, r4, r1
   195ba:	70c8      	strb	r0, [r1, #3]
   195bc:	2014      	movs	r0, #20
   195be:	4669      	mov	r1, sp
   195c0:	7308      	strb	r0, [r1, #12]
   195c2:	6921      	ldr	r1, [r4, #16]
   195c4:	2001      	movs	r0, #1
   195c6:	4008      	ands	r0, r1
   195c8:	f004 f907 	bl	1d7da <USBPD_PRL_EnableRX>
   195cc:	20a5      	movs	r0, #165	; 0xa5
   195ce:	0080      	lsls	r0, r0, #2
   195d0:	5a20      	ldrh	r0, [r4, r0]
   195d2:	03a9      	lsls	r1, r5, #14
   195d4:	4288      	cmp	r0, r1
   195d6:	d1d8      	bne.n	1958a <__iar_annotation$$branch+0x6ea>
   195d8:	68a0      	ldr	r0, [r4, #8]
   195da:	6b40      	ldr	r0, [r0, #52]	; 0x34
   195dc:	2800      	cmp	r0, #0
   195de:	d100      	bne.n	195e2 <__iar_annotation$$branch+0x742>
   195e0:	e4f1      	b.n	18fc6 <__iar_annotation$$branch+0x126>
   195e2:	e181      	b.n	198e8 <__iar_annotation$$branch+0xa48>
   195e4:	6860      	ldr	r0, [r4, #4]
   195e6:	6801      	ldr	r1, [r0, #0]
   195e8:	054a      	lsls	r2, r1, #21
   195ea:	0f52      	lsrs	r2, r2, #29
   195ec:	2a04      	cmp	r2, #4
   195ee:	d016      	beq.n	1961e <__iar_annotation$$branch+0x77e>
   195f0:	4ad2      	ldr	r2, [pc, #840]	; (1993c <__iar_annotation$$branch+0xa9c>)
   195f2:	400a      	ands	r2, r1
   195f4:	0269      	lsls	r1, r5, #9
   195f6:	4311      	orrs	r1, r2
   195f8:	6001      	str	r1, [r0, #0]
   195fa:	2000      	movs	r0, #0
   195fc:	9000      	str	r0, [sp, #0]
   195fe:	2300      	movs	r3, #0
   19600:	225a      	movs	r2, #90	; 0x5a
   19602:	6920      	ldr	r0, [r4, #16]
   19604:	2101      	movs	r1, #1
   19606:	4001      	ands	r1, r0
   19608:	2009      	movs	r0, #9
   1960a:	4f2b      	ldr	r7, [pc, #172]	; (196b8 <__iar_annotation$$branch+0x818>)
   1960c:	6a3f      	ldr	r7, [r7, #32]
   1960e:	47b8      	blx	r7
   19610:	215a      	movs	r1, #90	; 0x5a
   19612:	6922      	ldr	r2, [r4, #16]
   19614:	2001      	movs	r0, #1
   19616:	4010      	ands	r0, r2
   19618:	68a2      	ldr	r2, [r4, #8]
   1961a:	68d2      	ldr	r2, [r2, #12]
   1961c:	4790      	blx	r2
   1961e:	220a      	movs	r2, #10
   19620:	2100      	movs	r1, #0
   19622:	6923      	ldr	r3, [r4, #16]
   19624:	2001      	movs	r0, #1
   19626:	4018      	ands	r0, r3
   19628:	68a3      	ldr	r3, [r4, #8]
   1962a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   1962c:	4798      	blx	r3
   1962e:	6921      	ldr	r1, [r4, #16]
   19630:	2001      	movs	r0, #1
   19632:	4008      	ands	r0, r1
   19634:	f003 ff1e 	bl	1d474 <USBPD_PRL_SRCSetSinkNG>
   19638:	220b      	movs	r2, #11
   1963a:	2101      	movs	r1, #1
   1963c:	6923      	ldr	r3, [r4, #16]
   1963e:	2001      	movs	r0, #1
   19640:	4018      	ands	r0, r3
   19642:	68a3      	ldr	r3, [r4, #8]
   19644:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   19646:	4798      	blx	r3
   19648:	2101      	movs	r1, #1
   1964a:	4668      	mov	r0, sp
   1964c:	7b40      	ldrb	r0, [r0, #13]
   1964e:	f003 fec4 	bl	1d3da <USBPD_PRL_SetHeaderPowerRole>
   19652:	2000      	movs	r0, #0
   19654:	9000      	str	r0, [sp, #0]
   19656:	2354      	movs	r3, #84	; 0x54
   19658:	2206      	movs	r2, #6
   1965a:	2100      	movs	r1, #0
   1965c:	0020      	movs	r0, r4
   1965e:	f001 f949 	bl	1a8f4 <PE_Send_CtrlMessage>
   19662:	2800      	cmp	r0, #0
   19664:	d10c      	bne.n	19680 <__iar_annotation$$branch+0x7e0>
   19666:	220c      	movs	r2, #12
   19668:	2100      	movs	r1, #0
   1966a:	6923      	ldr	r3, [r4, #16]
   1966c:	2001      	movs	r0, #1
   1966e:	4018      	ands	r0, r3
   19670:	68a3      	ldr	r3, [r4, #8]
   19672:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   19674:	4798      	blx	r3
   19676:	48b2      	ldr	r0, [pc, #712]	; (19940 <__iar_annotation$$branch+0xaa0>)
   19678:	21a5      	movs	r1, #165	; 0xa5
   1967a:	0089      	lsls	r1, r1, #2
   1967c:	5260      	strh	r0, [r4, r1]
   1967e:	2514      	movs	r5, #20
   19680:	480f      	ldr	r0, [pc, #60]	; (196c0 <__iar_annotation$$branch+0x820>)
   19682:	1820      	adds	r0, r4, r0
   19684:	78c0      	ldrb	r0, [r0, #3]
   19686:	2854      	cmp	r0, #84	; 0x54
   19688:	d014      	beq.n	196b4 <__iar_annotation$$branch+0x814>
   1968a:	2100      	movs	r1, #0
   1968c:	4668      	mov	r0, sp
   1968e:	7b40      	ldrb	r0, [r0, #13]
   19690:	f003 fea3 	bl	1d3da <USBPD_PRL_SetHeaderPowerRole>
   19694:	2206      	movs	r2, #6
   19696:	2101      	movs	r1, #1
   19698:	6923      	ldr	r3, [r4, #16]
   1969a:	2001      	movs	r0, #1
   1969c:	4018      	ands	r0, r3
   1969e:	68a3      	ldr	r3, [r4, #8]
   196a0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   196a2:	4798      	blx	r3
   196a4:	2207      	movs	r2, #7
   196a6:	2100      	movs	r1, #0
   196a8:	6923      	ldr	r3, [r4, #16]
   196aa:	2001      	movs	r0, #1
   196ac:	4018      	ands	r0, r3
   196ae:	68a3      	ldr	r3, [r4, #8]
   196b0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   196b2:	4798      	blx	r3
   196b4:	e769      	b.n	1958a <__iar_annotation$$branch+0x6ea>
   196b6:	bf00      	nop
   196b8:	0002ff54 	.word	0x0002ff54
   196bc:	0000f01f 	.word	0x0000f01f
   196c0:	0000028d 	.word	0x0000028d
   196c4:	00008064 	.word	0x00008064
   196c8:	20a5      	movs	r0, #165	; 0xa5
   196ca:	0080      	lsls	r0, r0, #2
   196cc:	5a20      	ldrh	r0, [r4, r0]
   196ce:	03a9      	lsls	r1, r5, #14
   196d0:	4288      	cmp	r0, r1
   196d2:	d1ef      	bne.n	196b4 <__iar_annotation$$branch+0x814>
   196d4:	2101      	movs	r1, #1
   196d6:	0020      	movs	r0, r4
   196d8:	f001 ff89 	bl	1b5ee <PE_ChangePowerRole>
   196dc:	220e      	movs	r2, #14
   196de:	2101      	movs	r1, #1
   196e0:	6923      	ldr	r3, [r4, #16]
   196e2:	2001      	movs	r0, #1
   196e4:	4018      	ands	r0, r3
   196e6:	68a3      	ldr	r3, [r4, #8]
   196e8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   196ea:	4798      	blx	r3
   196ec:	6921      	ldr	r1, [r4, #16]
   196ee:	2001      	movs	r0, #1
   196f0:	4008      	ands	r0, r1
   196f2:	f003 fec3 	bl	1d47c <USBPD_PRL_SRCReleaseSinkNG>
   196f6:	0020      	movs	r0, r4
   196f8:	f002 fcf1 	bl	1c0de <PE_ResetDuringSwap>
   196fc:	2000      	movs	r0, #0
   196fe:	9000      	str	r0, [sp, #0]
   19700:	2300      	movs	r3, #0
   19702:	2215      	movs	r2, #21
   19704:	6920      	ldr	r0, [r4, #16]
   19706:	2101      	movs	r1, #1
   19708:	4001      	ands	r1, r0
   1970a:	2009      	movs	r0, #9
   1970c:	4f8d      	ldr	r7, [pc, #564]	; (19944 <__iar_annotation$$branch+0xaa4>)
   1970e:	6a3f      	ldr	r7, [r7, #32]
   19710:	47b8      	blx	r7
   19712:	2115      	movs	r1, #21
   19714:	e61b      	b.n	1934e <__iar_annotation$$branch+0x4ae>
   19716:	2202      	movs	r2, #2
   19718:	2100      	movs	r1, #0
   1971a:	6923      	ldr	r3, [r4, #16]
   1971c:	2001      	movs	r0, #1
   1971e:	4018      	ands	r0, r3
   19720:	68a3      	ldr	r3, [r4, #8]
   19722:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   19724:	4798      	blx	r3
   19726:	9500      	str	r5, [sp, #0]
   19728:	2358      	movs	r3, #88	; 0x58
   1972a:	20ad      	movs	r0, #173	; 0xad
   1972c:	0080      	lsls	r0, r0, #2
   1972e:	5c22      	ldrb	r2, [r4, r0]
   19730:	2100      	movs	r1, #0
   19732:	0020      	movs	r0, r4
   19734:	f001 f8de 	bl	1a8f4 <PE_Send_CtrlMessage>
   19738:	2800      	cmp	r0, #0
   1973a:	d000      	beq.n	1973e <__iar_annotation$$branch+0x89e>
   1973c:	e104      	b.n	19948 <__iar_annotation$$branch+0xaa8>
   1973e:	20ad      	movs	r0, #173	; 0xad
   19740:	0080      	lsls	r0, r0, #2
   19742:	1820      	adds	r0, r4, r0
   19744:	8840      	ldrh	r0, [r0, #2]
   19746:	83a0      	strh	r0, [r4, #28]
   19748:	e46e      	b.n	19028 <__iar_annotation$$branch+0x188>
   1974a:	2911      	cmp	r1, #17
   1974c:	d112      	bne.n	19774 <__iar_annotation$$branch+0x8d4>
   1974e:	20a5      	movs	r0, #165	; 0xa5
   19750:	0080      	lsls	r0, r0, #2
   19752:	1820      	adds	r0, r4, r0
   19754:	89c1      	ldrh	r1, [r0, #14]
   19756:	22f0      	movs	r2, #240	; 0xf0
   19758:	0212      	lsls	r2, r2, #8
   1975a:	400a      	ands	r2, r1
   1975c:	d10a      	bne.n	19774 <__iar_annotation$$branch+0x8d4>
   1975e:	2703      	movs	r7, #3
   19760:	06c9      	lsls	r1, r1, #27
   19762:	0ec9      	lsrs	r1, r1, #27
   19764:	2903      	cmp	r1, #3
   19766:	d006      	beq.n	19776 <__iar_annotation$$branch+0x8d6>
   19768:	2904      	cmp	r1, #4
   1976a:	d05d      	beq.n	19828 <__iar_annotation$$branch+0x988>
   1976c:	290c      	cmp	r1, #12
   1976e:	d04e      	beq.n	1980e <__iar_annotation$$branch+0x96e>
   19770:	2910      	cmp	r1, #16
   19772:	d06b      	beq.n	1984c <__iar_annotation$$branch+0x9ac>
   19774:	e088      	b.n	19888 <__iar_annotation$$branch+0x9e8>
   19776:	6861      	ldr	r1, [r4, #4]
   19778:	680a      	ldr	r2, [r1, #0]
   1977a:	2310      	movs	r3, #16
   1977c:	4313      	orrs	r3, r2
   1977e:	600b      	str	r3, [r1, #0]
   19780:	4930      	ldr	r1, [pc, #192]	; (19844 <__iar_annotation$$branch+0x9a4>)
   19782:	8001      	strh	r1, [r0, #0]
   19784:	4d30      	ldr	r5, [pc, #192]	; (19848 <__iar_annotation$$branch+0x9a8>)
   19786:	2206      	movs	r2, #6
   19788:	2100      	movs	r1, #0
   1978a:	6923      	ldr	r3, [r4, #16]
   1978c:	2001      	movs	r0, #1
   1978e:	4018      	ands	r0, r3
   19790:	68a3      	ldr	r3, [r4, #8]
   19792:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   19794:	4798      	blx	r3
   19796:	6860      	ldr	r0, [r4, #4]
   19798:	6801      	ldr	r1, [r0, #0]
   1979a:	054a      	lsls	r2, r1, #21
   1979c:	0f52      	lsrs	r2, r2, #29
   1979e:	2a04      	cmp	r2, #4
   197a0:	d016      	beq.n	197d0 <__iar_annotation$$branch+0x930>
   197a2:	4a66      	ldr	r2, [pc, #408]	; (1993c <__iar_annotation$$branch+0xa9c>)
   197a4:	400a      	ands	r2, r1
   197a6:	02b1      	lsls	r1, r6, #10
   197a8:	4311      	orrs	r1, r2
   197aa:	6001      	str	r1, [r0, #0]
   197ac:	2000      	movs	r0, #0
   197ae:	9000      	str	r0, [sp, #0]
   197b0:	2300      	movs	r3, #0
   197b2:	225a      	movs	r2, #90	; 0x5a
   197b4:	6920      	ldr	r0, [r4, #16]
   197b6:	2101      	movs	r1, #1
   197b8:	4001      	ands	r1, r0
   197ba:	2009      	movs	r0, #9
   197bc:	4f61      	ldr	r7, [pc, #388]	; (19944 <__iar_annotation$$branch+0xaa4>)
   197be:	6a3f      	ldr	r7, [r7, #32]
   197c0:	47b8      	blx	r7
   197c2:	215a      	movs	r1, #90	; 0x5a
   197c4:	6922      	ldr	r2, [r4, #16]
   197c6:	2001      	movs	r0, #1
   197c8:	4010      	ands	r0, r2
   197ca:	68a2      	ldr	r2, [r4, #8]
   197cc:	68d2      	ldr	r2, [r2, #12]
   197ce:	4790      	blx	r2
   197d0:	2000      	movs	r0, #0
   197d2:	9000      	str	r0, [sp, #0]
   197d4:	2300      	movs	r3, #0
   197d6:	223a      	movs	r2, #58	; 0x3a
   197d8:	6920      	ldr	r0, [r4, #16]
   197da:	2101      	movs	r1, #1
   197dc:	4001      	ands	r1, r0
   197de:	2009      	movs	r0, #9
   197e0:	4f58      	ldr	r7, [pc, #352]	; (19944 <__iar_annotation$$branch+0xaa4>)
   197e2:	6a3f      	ldr	r7, [r7, #32]
   197e4:	47b8      	blx	r7
   197e6:	213a      	movs	r1, #58	; 0x3a
   197e8:	6922      	ldr	r2, [r4, #16]
   197ea:	2001      	movs	r0, #1
   197ec:	4010      	ands	r0, r2
   197ee:	68a2      	ldr	r2, [r4, #8]
   197f0:	68d2      	ldr	r2, [r2, #12]
   197f2:	4790      	blx	r2
   197f4:	2014      	movs	r0, #20
   197f6:	4669      	mov	r1, sp
   197f8:	7308      	strb	r0, [r1, #12]
   197fa:	6921      	ldr	r1, [r4, #16]
   197fc:	2001      	movs	r0, #1
   197fe:	4008      	ands	r0, r1
   19800:	f003 ffeb 	bl	1d7da <USBPD_PRL_EnableRX>
   19804:	2059      	movs	r0, #89	; 0x59
   19806:	49d1      	ldr	r1, [pc, #836]	; (19b4c <__iar_annotation$$branch+0xcac>)
   19808:	1861      	adds	r1, r4, r1
   1980a:	70c8      	strb	r0, [r1, #3]
   1980c:	e03c      	b.n	19888 <__iar_annotation$$branch+0x9e8>
   1980e:	2000      	movs	r0, #0
   19810:	9000      	str	r0, [sp, #0]
   19812:	2300      	movs	r3, #0
   19814:	223b      	movs	r2, #59	; 0x3b
   19816:	6920      	ldr	r0, [r4, #16]
   19818:	2101      	movs	r1, #1
   1981a:	4001      	ands	r1, r0
   1981c:	2009      	movs	r0, #9
   1981e:	4d49      	ldr	r5, [pc, #292]	; (19944 <__iar_annotation$$branch+0xaa4>)
   19820:	6a2d      	ldr	r5, [r5, #32]
   19822:	47a8      	blx	r5
   19824:	213b      	movs	r1, #59	; 0x3b
   19826:	e01d      	b.n	19864 <__iar_annotation$$branch+0x9c4>
   19828:	2000      	movs	r0, #0
   1982a:	9000      	str	r0, [sp, #0]
   1982c:	2300      	movs	r3, #0
   1982e:	2216      	movs	r2, #22
   19830:	6920      	ldr	r0, [r4, #16]
   19832:	2101      	movs	r1, #1
   19834:	4001      	ands	r1, r0
   19836:	2009      	movs	r0, #9
   19838:	4d42      	ldr	r5, [pc, #264]	; (19944 <__iar_annotation$$branch+0xaa4>)
   1983a:	6a2d      	ldr	r5, [r5, #32]
   1983c:	47a8      	blx	r5
   1983e:	2116      	movs	r1, #22
   19840:	e010      	b.n	19864 <__iar_annotation$$branch+0x9c4>
   19842:	bf00      	nop
   19844:	00008343 	.word	0x00008343
   19848:	00000343 	.word	0x00000343
   1984c:	2000      	movs	r0, #0
   1984e:	9000      	str	r0, [sp, #0]
   19850:	2300      	movs	r3, #0
   19852:	2217      	movs	r2, #23
   19854:	6920      	ldr	r0, [r4, #16]
   19856:	2101      	movs	r1, #1
   19858:	4001      	ands	r1, r0
   1985a:	2009      	movs	r0, #9
   1985c:	4d39      	ldr	r5, [pc, #228]	; (19944 <__iar_annotation$$branch+0xaa4>)
   1985e:	6a2d      	ldr	r5, [r5, #32]
   19860:	47a8      	blx	r5
   19862:	2117      	movs	r1, #23
   19864:	6922      	ldr	r2, [r4, #16]
   19866:	2001      	movs	r0, #1
   19868:	4010      	ands	r0, r2
   1986a:	68a2      	ldr	r2, [r4, #8]
   1986c:	68d2      	ldr	r2, [r2, #12]
   1986e:	4790      	blx	r2
   19870:	2014      	movs	r0, #20
   19872:	4669      	mov	r1, sp
   19874:	7308      	strb	r0, [r1, #12]
   19876:	6921      	ldr	r1, [r4, #16]
   19878:	2001      	movs	r0, #1
   1987a:	4008      	ands	r0, r1
   1987c:	f003 ffad 	bl	1d7da <USBPD_PRL_EnableRX>
   19880:	48b2      	ldr	r0, [pc, #712]	; (19b4c <__iar_annotation$$branch+0xcac>)
   19882:	1820      	adds	r0, r4, r0
   19884:	70c7      	strb	r7, [r0, #3]
   19886:	2500      	movs	r5, #0
   19888:	20a5      	movs	r0, #165	; 0xa5
   1988a:	0080      	lsls	r0, r0, #2
   1988c:	5a20      	ldrh	r0, [r4, r0]
   1988e:	03f1      	lsls	r1, r6, #15
   19890:	4288      	cmp	r0, r1
   19892:	d152      	bne.n	1993a <__iar_annotation$$branch+0xa9a>
   19894:	e165      	b.n	19b62 <__iar_annotation$$branch+0xcc2>
   19896:	2911      	cmp	r1, #17
   19898:	d113      	bne.n	198c2 <__iar_annotation$$branch+0xa22>
   1989a:	20a5      	movs	r0, #165	; 0xa5
   1989c:	0080      	lsls	r0, r0, #2
   1989e:	1820      	adds	r0, r4, r0
   198a0:	89c0      	ldrh	r0, [r0, #14]
   198a2:	49c0      	ldr	r1, [pc, #768]	; (19ba4 <__iar_annotation$$branch+0xd04>)
   198a4:	4001      	ands	r1, r0
   198a6:	2906      	cmp	r1, #6
   198a8:	d10b      	bne.n	198c2 <__iar_annotation$$branch+0xa22>
   198aa:	205a      	movs	r0, #90	; 0x5a
   198ac:	49a7      	ldr	r1, [pc, #668]	; (19b4c <__iar_annotation$$branch+0xcac>)
   198ae:	1861      	adds	r1, r4, r1
   198b0:	70c8      	strb	r0, [r1, #3]
   198b2:	2014      	movs	r0, #20
   198b4:	4669      	mov	r1, sp
   198b6:	7308      	strb	r0, [r1, #12]
   198b8:	6921      	ldr	r1, [r4, #16]
   198ba:	2001      	movs	r0, #1
   198bc:	4008      	ands	r0, r1
   198be:	f003 ff8c 	bl	1d7da <USBPD_PRL_EnableRX>
   198c2:	20a5      	movs	r0, #165	; 0xa5
   198c4:	0080      	lsls	r0, r0, #2
   198c6:	5a20      	ldrh	r0, [r4, r0]
   198c8:	03a9      	lsls	r1, r5, #14
   198ca:	4288      	cmp	r0, r1
   198cc:	d135      	bne.n	1993a <__iar_annotation$$branch+0xa9a>
   198ce:	220f      	movs	r2, #15
   198d0:	2100      	movs	r1, #0
   198d2:	6923      	ldr	r3, [r4, #16]
   198d4:	2001      	movs	r0, #1
   198d6:	4018      	ands	r0, r3
   198d8:	68a3      	ldr	r3, [r4, #8]
   198da:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   198dc:	4798      	blx	r3
   198de:	68a0      	ldr	r0, [r4, #8]
   198e0:	6b40      	ldr	r0, [r0, #52]	; 0x34
   198e2:	2800      	cmp	r0, #0
   198e4:	d100      	bne.n	198e8 <__iar_annotation$$branch+0xa48>
   198e6:	e67a      	b.n	195de <__iar_annotation$$branch+0x73e>
   198e8:	2092      	movs	r0, #146	; 0x92
   198ea:	e650      	b.n	1958e <__iar_annotation$$branch+0x6ee>
   198ec:	220a      	movs	r2, #10
   198ee:	2100      	movs	r1, #0
   198f0:	6923      	ldr	r3, [r4, #16]
   198f2:	2001      	movs	r0, #1
   198f4:	4018      	ands	r0, r3
   198f6:	68a3      	ldr	r3, [r4, #8]
   198f8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   198fa:	4798      	blx	r3
   198fc:	220b      	movs	r2, #11
   198fe:	2101      	movs	r1, #1
   19900:	6923      	ldr	r3, [r4, #16]
   19902:	2001      	movs	r0, #1
   19904:	4018      	ands	r0, r3
   19906:	68a3      	ldr	r3, [r4, #8]
   19908:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   1990a:	4798      	blx	r3
   1990c:	2000      	movs	r0, #0
   1990e:	9000      	str	r0, [sp, #0]
   19910:	235b      	movs	r3, #91	; 0x5b
   19912:	2206      	movs	r2, #6
   19914:	2100      	movs	r1, #0
   19916:	0020      	movs	r0, r4
   19918:	f000 ffec 	bl	1a8f4 <PE_Send_CtrlMessage>
   1991c:	2800      	cmp	r0, #0
   1991e:	d113      	bne.n	19948 <__iar_annotation$$branch+0xaa8>
   19920:	220c      	movs	r2, #12
   19922:	2100      	movs	r1, #0
   19924:	6923      	ldr	r3, [r4, #16]
   19926:	2001      	movs	r0, #1
   19928:	4018      	ands	r0, r3
   1992a:	68a3      	ldr	r3, [r4, #8]
   1992c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   1992e:	4798      	blx	r3
   19930:	4803      	ldr	r0, [pc, #12]	; (19940 <__iar_annotation$$branch+0xaa0>)
   19932:	21a5      	movs	r1, #165	; 0xa5
   19934:	0089      	lsls	r1, r1, #2
   19936:	5260      	strh	r0, [r4, r1]
   19938:	2514      	movs	r5, #20
   1993a:	e626      	b.n	1958a <__iar_annotation$$branch+0x6ea>
   1993c:	fffff8ff 	.word	0xfffff8ff
   19940:	00008014 	.word	0x00008014
   19944:	0002ff54 	.word	0x0002ff54
   19948:	220f      	movs	r2, #15
   1994a:	e6ac      	b.n	196a6 <__iar_annotation$$branch+0x806>
   1994c:	20a5      	movs	r0, #165	; 0xa5
   1994e:	0080      	lsls	r0, r0, #2
   19950:	5a20      	ldrh	r0, [r4, r0]
   19952:	03a9      	lsls	r1, r5, #14
   19954:	4288      	cmp	r0, r1
   19956:	d1f0      	bne.n	1993a <__iar_annotation$$branch+0xa9a>
   19958:	2101      	movs	r1, #1
   1995a:	0020      	movs	r0, r4
   1995c:	f001 fe47 	bl	1b5ee <PE_ChangePowerRole>
   19960:	0020      	movs	r0, r4
   19962:	f002 fbbc 	bl	1c0de <PE_ResetDuringSwap>
   19966:	220e      	movs	r2, #14
   19968:	2101      	movs	r1, #1
   1996a:	6923      	ldr	r3, [r4, #16]
   1996c:	2001      	movs	r0, #1
   1996e:	4018      	ands	r0, r3
   19970:	68a3      	ldr	r3, [r4, #8]
   19972:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   19974:	4798      	blx	r3
   19976:	e6c1      	b.n	196fc <__iar_annotation$$branch+0x85c>
   19978:	ab04      	add	r3, sp, #16
   1997a:	aa07      	add	r2, sp, #28
   1997c:	2100      	movs	r1, #0
   1997e:	6927      	ldr	r7, [r4, #16]
   19980:	2001      	movs	r0, #1
   19982:	4038      	ands	r0, r7
   19984:	68a7      	ldr	r7, [r4, #8]
   19986:	697f      	ldr	r7, [r7, #20]
   19988:	47b8      	blx	r7
   1998a:	2000      	movs	r0, #0
   1998c:	9002      	str	r0, [sp, #8]
   1998e:	2003      	movs	r0, #3
   19990:	9001      	str	r0, [sp, #4]
   19992:	9804      	ldr	r0, [sp, #16]
   19994:	0880      	lsrs	r0, r0, #2
   19996:	9000      	str	r0, [sp, #0]
   19998:	ab07      	add	r3, sp, #28
   1999a:	2201      	movs	r2, #1
   1999c:	2100      	movs	r1, #0
   1999e:	0020      	movs	r0, r4
   199a0:	f000 ffe8 	bl	1a974 <PE_Send_DataMessage>
   199a4:	e5f1      	b.n	1958a <__iar_annotation$$branch+0x6ea>
   199a6:	2000      	movs	r0, #0
   199a8:	9002      	str	r0, [sp, #8]
   199aa:	2003      	movs	r0, #3
   199ac:	9001      	str	r0, [sp, #4]
   199ae:	9600      	str	r6, [sp, #0]
   199b0:	20ab      	movs	r0, #171	; 0xab
   199b2:	0080      	lsls	r0, r0, #2
   199b4:	1823      	adds	r3, r4, r0
   199b6:	2206      	movs	r2, #6
   199b8:	2100      	movs	r1, #0
   199ba:	0020      	movs	r0, r4
   199bc:	f000 ffda 	bl	1a974 <PE_Send_DataMessage>
   199c0:	2800      	cmp	r0, #0
   199c2:	d1ef      	bne.n	199a4 <__iar_annotation$$branch+0xb04>
   199c4:	9000      	str	r0, [sp, #0]
   199c6:	2300      	movs	r3, #0
   199c8:	225d      	movs	r2, #93	; 0x5d
   199ca:	6920      	ldr	r0, [r4, #16]
   199cc:	2101      	movs	r1, #1
   199ce:	4001      	ands	r1, r0
   199d0:	2009      	movs	r0, #9
   199d2:	4fa2      	ldr	r7, [pc, #648]	; (19c5c <__iar_annotation$$branch+0x6>)
   199d4:	6a3f      	ldr	r7, [r7, #32]
   199d6:	47b8      	blx	r7
   199d8:	215d      	movs	r1, #93	; 0x5d
   199da:	e4b8      	b.n	1934e <__iar_annotation$$branch+0x4ae>
   199dc:	9500      	str	r5, [sp, #0]
   199de:	2366      	movs	r3, #102	; 0x66
   199e0:	2214      	movs	r2, #20
   199e2:	2100      	movs	r1, #0
   199e4:	0020      	movs	r0, r4
   199e6:	f000 ff85 	bl	1a8f4 <PE_Send_CtrlMessage>
   199ea:	2800      	cmp	r0, #0
   199ec:	d117      	bne.n	19a1e <__iar_annotation$$branch+0xb7e>
   199ee:	20a5      	movs	r0, #165	; 0xa5
   199f0:	0080      	lsls	r0, r0, #2
   199f2:	5227      	strh	r7, [r4, r0]
   199f4:	2518      	movs	r5, #24
   199f6:	2000      	movs	r0, #0
   199f8:	9000      	str	r0, [sp, #0]
   199fa:	2300      	movs	r3, #0
   199fc:	224a      	movs	r2, #74	; 0x4a
   199fe:	6920      	ldr	r0, [r4, #16]
   19a00:	2101      	movs	r1, #1
   19a02:	4001      	ands	r1, r0
   19a04:	2009      	movs	r0, #9
   19a06:	4f95      	ldr	r7, [pc, #596]	; (19c5c <__iar_annotation$$branch+0x6>)
   19a08:	6a3f      	ldr	r7, [r7, #32]
   19a0a:	47b8      	blx	r7
   19a0c:	214a      	movs	r1, #74	; 0x4a
   19a0e:	6922      	ldr	r2, [r4, #16]
   19a10:	2001      	movs	r0, #1
   19a12:	4010      	ands	r0, r2
   19a14:	68a2      	ldr	r2, [r4, #8]
   19a16:	68d2      	ldr	r2, [r2, #12]
   19a18:	4790      	blx	r2
   19a1a:	200b      	movs	r0, #11
   19a1c:	83a0      	strh	r0, [r4, #28]
   19a1e:	e5b4      	b.n	1958a <__iar_annotation$$branch+0x6ea>
   19a20:	2911      	cmp	r1, #17
   19a22:	d132      	bne.n	19a8a <__iar_annotation$$branch+0xbea>
   19a24:	20a5      	movs	r0, #165	; 0xa5
   19a26:	0080      	lsls	r0, r0, #2
   19a28:	1820      	adds	r0, r4, r0
   19a2a:	89c0      	ldrh	r0, [r0, #14]
   19a2c:	0bc1      	lsrs	r1, r0, #15
   19a2e:	d02c      	beq.n	19a8a <__iar_annotation$$branch+0xbea>
   19a30:	06c0      	lsls	r0, r0, #27
   19a32:	0ec0      	lsrs	r0, r0, #27
   19a34:	280c      	cmp	r0, #12
   19a36:	d128      	bne.n	19a8a <__iar_annotation$$branch+0xbea>
   19a38:	2304      	movs	r3, #4
   19a3a:	20a2      	movs	r0, #162	; 0xa2
   19a3c:	0040      	lsls	r0, r0, #1
   19a3e:	1822      	adds	r2, r4, r0
   19a40:	210a      	movs	r1, #10
   19a42:	6925      	ldr	r5, [r4, #16]
   19a44:	2001      	movs	r0, #1
   19a46:	4028      	ands	r0, r5
   19a48:	68a5      	ldr	r5, [r4, #8]
   19a4a:	69ad      	ldr	r5, [r5, #24]
   19a4c:	47a8      	blx	r5
   19a4e:	2003      	movs	r0, #3
   19a50:	493e      	ldr	r1, [pc, #248]	; (19b4c <__iar_annotation$$branch+0xcac>)
   19a52:	1861      	adds	r1, r4, r1
   19a54:	70c8      	strb	r0, [r1, #3]
   19a56:	2500      	movs	r5, #0
   19a58:	2014      	movs	r0, #20
   19a5a:	4669      	mov	r1, sp
   19a5c:	7308      	strb	r0, [r1, #12]
   19a5e:	6921      	ldr	r1, [r4, #16]
   19a60:	2001      	movs	r0, #1
   19a62:	4008      	ands	r0, r1
   19a64:	f003 feb9 	bl	1d7da <USBPD_PRL_EnableRX>
   19a68:	9500      	str	r5, [sp, #0]
   19a6a:	2300      	movs	r3, #0
   19a6c:	224b      	movs	r2, #75	; 0x4b
   19a6e:	6920      	ldr	r0, [r4, #16]
   19a70:	2101      	movs	r1, #1
   19a72:	4001      	ands	r1, r0
   19a74:	2009      	movs	r0, #9
   19a76:	4f79      	ldr	r7, [pc, #484]	; (19c5c <__iar_annotation$$branch+0x6>)
   19a78:	6a3f      	ldr	r7, [r7, #32]
   19a7a:	47b8      	blx	r7
   19a7c:	214b      	movs	r1, #75	; 0x4b
   19a7e:	6922      	ldr	r2, [r4, #16]
   19a80:	2001      	movs	r0, #1
   19a82:	4010      	ands	r0, r2
   19a84:	68a2      	ldr	r2, [r4, #8]
   19a86:	68d2      	ldr	r2, [r2, #12]
   19a88:	4790      	blx	r2
   19a8a:	20a5      	movs	r0, #165	; 0xa5
   19a8c:	0080      	lsls	r0, r0, #2
   19a8e:	5a20      	ldrh	r0, [r4, r0]
   19a90:	03f1      	lsls	r1, r6, #15
   19a92:	4288      	cmp	r0, r1
   19a94:	d1c3      	bne.n	19a1e <__iar_annotation$$branch+0xb7e>
   19a96:	e4e6      	b.n	19466 <__iar_annotation$$branch+0x5c6>
   19a98:	9500      	str	r5, [sp, #0]
   19a9a:	2339      	movs	r3, #57	; 0x39
   19a9c:	20ad      	movs	r0, #173	; 0xad
   19a9e:	0080      	lsls	r0, r0, #2
   19aa0:	5c22      	ldrb	r2, [r4, r0]
   19aa2:	2100      	movs	r1, #0
   19aa4:	0020      	movs	r0, r4
   19aa6:	f000 ff25 	bl	1a8f4 <PE_Send_CtrlMessage>
   19aaa:	2800      	cmp	r0, #0
   19aac:	d135      	bne.n	19b1a <__iar_annotation$$branch+0xc7a>
   19aae:	20ad      	movs	r0, #173	; 0xad
   19ab0:	0080      	lsls	r0, r0, #2
   19ab2:	1820      	adds	r0, r4, r0
   19ab4:	8840      	ldrh	r0, [r0, #2]
   19ab6:	83a0      	strh	r0, [r4, #28]
   19ab8:	6860      	ldr	r0, [r4, #4]
   19aba:	6801      	ldr	r1, [r0, #0]
   19abc:	054a      	lsls	r2, r1, #21
   19abe:	0f52      	lsrs	r2, r2, #29
   19ac0:	2a03      	cmp	r2, #3
   19ac2:	d017      	beq.n	19af4 <__iar_annotation$$branch+0xc54>
   19ac4:	4a66      	ldr	r2, [pc, #408]	; (19c60 <__iar_annotation$$branch+0xa>)
   19ac6:	400a      	ands	r2, r1
   19ac8:	21c0      	movs	r1, #192	; 0xc0
   19aca:	0089      	lsls	r1, r1, #2
   19acc:	4311      	orrs	r1, r2
   19ace:	6001      	str	r1, [r0, #0]
   19ad0:	2000      	movs	r0, #0
   19ad2:	9000      	str	r0, [sp, #0]
   19ad4:	2300      	movs	r3, #0
   19ad6:	225a      	movs	r2, #90	; 0x5a
   19ad8:	6920      	ldr	r0, [r4, #16]
   19ada:	2101      	movs	r1, #1
   19adc:	4001      	ands	r1, r0
   19ade:	2009      	movs	r0, #9
   19ae0:	4d5e      	ldr	r5, [pc, #376]	; (19c5c <__iar_annotation$$branch+0x6>)
   19ae2:	6a2d      	ldr	r5, [r5, #32]
   19ae4:	47a8      	blx	r5
   19ae6:	215a      	movs	r1, #90	; 0x5a
   19ae8:	6922      	ldr	r2, [r4, #16]
   19aea:	2001      	movs	r0, #1
   19aec:	4010      	ands	r0, r2
   19aee:	68a2      	ldr	r2, [r4, #8]
   19af0:	68d2      	ldr	r2, [r2, #12]
   19af2:	4790      	blx	r2
   19af4:	2000      	movs	r0, #0
   19af6:	9000      	str	r0, [sp, #0]
   19af8:	2300      	movs	r3, #0
   19afa:	2244      	movs	r2, #68	; 0x44
   19afc:	6920      	ldr	r0, [r4, #16]
   19afe:	2101      	movs	r1, #1
   19b00:	4001      	ands	r1, r0
   19b02:	2009      	movs	r0, #9
   19b04:	4d55      	ldr	r5, [pc, #340]	; (19c5c <__iar_annotation$$branch+0x6>)
   19b06:	6a2d      	ldr	r5, [r5, #32]
   19b08:	47a8      	blx	r5
   19b0a:	2144      	movs	r1, #68	; 0x44
   19b0c:	6922      	ldr	r2, [r4, #16]
   19b0e:	2001      	movs	r0, #1
   19b10:	4010      	ands	r0, r2
   19b12:	68a2      	ldr	r2, [r4, #8]
   19b14:	68d2      	ldr	r2, [r2, #12]
   19b16:	4790      	blx	r2
   19b18:	e616      	b.n	19748 <__iar_annotation$$branch+0x8a8>
   19b1a:	6860      	ldr	r0, [r4, #4]
   19b1c:	6801      	ldr	r1, [r0, #0]
   19b1e:	054a      	lsls	r2, r1, #21
   19b20:	0f52      	lsrs	r2, r2, #29
   19b22:	2a03      	cmp	r2, #3
   19b24:	d059      	beq.n	19bda <__iar_annotation$$branch+0xd3a>
   19b26:	4a4e      	ldr	r2, [pc, #312]	; (19c60 <__iar_annotation$$branch+0xa>)
   19b28:	400a      	ands	r2, r1
   19b2a:	21c0      	movs	r1, #192	; 0xc0
   19b2c:	0089      	lsls	r1, r1, #2
   19b2e:	4311      	orrs	r1, r2
   19b30:	6001      	str	r1, [r0, #0]
   19b32:	2000      	movs	r0, #0
   19b34:	9000      	str	r0, [sp, #0]
   19b36:	2300      	movs	r3, #0
   19b38:	225a      	movs	r2, #90	; 0x5a
   19b3a:	6920      	ldr	r0, [r4, #16]
   19b3c:	2101      	movs	r1, #1
   19b3e:	4001      	ands	r1, r0
   19b40:	2009      	movs	r0, #9
   19b42:	4f46      	ldr	r7, [pc, #280]	; (19c5c <__iar_annotation$$branch+0x6>)
   19b44:	6a3f      	ldr	r7, [r7, #32]
   19b46:	47b8      	blx	r7
   19b48:	215a      	movs	r1, #90	; 0x5a
   19b4a:	e746      	b.n	199da <__iar_annotation$$branch+0xb3a>
   19b4c:	0000028d 	.word	0x0000028d
   19b50:	20a5      	movs	r0, #165	; 0xa5
   19b52:	0080      	lsls	r0, r0, #2
   19b54:	1827      	adds	r7, r4, r0
   19b56:	8838      	ldrh	r0, [r7, #0]
   19b58:	03aa      	lsls	r2, r5, #14
   19b5a:	4290      	cmp	r0, r2
   19b5c:	d103      	bne.n	19b66 <__iar_annotation$$branch+0xcc6>
   19b5e:	2914      	cmp	r1, #20
   19b60:	d101      	bne.n	19b66 <__iar_annotation$$branch+0xcc6>
   19b62:	2003      	movs	r0, #3
   19b64:	e513      	b.n	1958e <__iar_annotation$$branch+0x6ee>
   19b66:	2914      	cmp	r1, #20
   19b68:	d037      	beq.n	19bda <__iar_annotation$$branch+0xd3a>
   19b6a:	89f8      	ldrh	r0, [r7, #14]
   19b6c:	0bc0      	lsrs	r0, r0, #15
   19b6e:	d00a      	beq.n	19b86 <__iar_annotation$$branch+0xce6>
   19b70:	0020      	movs	r0, r4
   19b72:	f002 f893 	bl	1bc9c <PE_Check_ExtendedMessage>
   19b76:	2014      	movs	r0, #20
   19b78:	4669      	mov	r1, sp
   19b7a:	7308      	strb	r0, [r1, #12]
   19b7c:	6921      	ldr	r1, [r4, #16]
   19b7e:	2001      	movs	r0, #1
   19b80:	4008      	ands	r0, r1
   19b82:	f003 fe2a 	bl	1d7da <USBPD_PRL_EnableRX>
   19b86:	89f8      	ldrh	r0, [r7, #14]
   19b88:	4906      	ldr	r1, [pc, #24]	; (19ba4 <__iar_annotation$$branch+0xd04>)
   19b8a:	4001      	ands	r1, r0
   19b8c:	2910      	cmp	r1, #16
   19b8e:	d124      	bne.n	19bda <__iar_annotation$$branch+0xd3a>
   19b90:	2014      	movs	r0, #20
   19b92:	4669      	mov	r1, sp
   19b94:	7308      	strb	r0, [r1, #12]
   19b96:	6921      	ldr	r1, [r4, #16]
   19b98:	2001      	movs	r0, #1
   19b9a:	4008      	ands	r0, r1
   19b9c:	f003 fe1d 	bl	1d7da <USBPD_PRL_EnableRX>
   19ba0:	e7df      	b.n	19b62 <__iar_annotation$$branch+0xcc2>
   19ba2:	bf00      	nop
   19ba4:	0000f01f 	.word	0x0000f01f
   19ba8:	0020      	movs	r0, r4
   19baa:	f002 fce7 	bl	1c57c <PE_SubStateMachine_ExtendedMessages>
   19bae:	e4a9      	b.n	19504 <__iar_annotation$$branch+0x664>
   19bb0:	a903      	add	r1, sp, #12
   19bb2:	0020      	movs	r0, r4
   19bb4:	f002 fde2 	bl	1c77c <PE_SubStateMachine_Generic>
   19bb8:	e4a4      	b.n	19504 <__iar_annotation$$branch+0x664>
   19bba:	a903      	add	r1, sp, #12
   19bbc:	0020      	movs	r0, r4
   19bbe:	f003 f9c3 	bl	1cf48 <PE_SubStateMachine_VconnSwap>
   19bc2:	0005      	movs	r5, r0
   19bc4:	6860      	ldr	r0, [r4, #4]
   19bc6:	6800      	ldr	r0, [r0, #0]
   19bc8:	0bc0      	lsrs	r0, r0, #15
   19bca:	4030      	ands	r0, r6
   19bcc:	d006      	beq.n	19bdc <__iar_annotation$$branch+0xd3c>
   19bce:	6820      	ldr	r0, [r4, #0]
   19bd0:	6801      	ldr	r1, [r0, #0]
   19bd2:	4668      	mov	r0, sp
   19bd4:	7b40      	ldrb	r0, [r0, #13]
   19bd6:	f003 fc67 	bl	1d4a8 <USBPD_PRL_SOPCapability>
   19bda:	e4d6      	b.n	1958a <__iar_annotation$$branch+0x6ea>
   19bdc:	2101      	movs	r1, #1
   19bde:	e7f8      	b.n	19bd2 <__iar_annotation$$branch+0xd32>
   19be0:	0020      	movs	r0, r4
   19be2:	f001 fcb7 	bl	1b554 <PE_StateMachine_UVDM>
   19be6:	e4d0      	b.n	1958a <__iar_annotation$$branch+0x6ea>
   19be8:	48ab      	ldr	r0, [pc, #684]	; (19e98 <.text_28>)
   19bea:	1827      	adds	r7, r4, r0
   19bec:	78b8      	ldrb	r0, [r7, #2]
   19bee:	2800      	cmp	r0, #0
   19bf0:	d02d      	beq.n	19c4e <__iar_annotation$$branch+0xdae>
   19bf2:	6920      	ldr	r0, [r4, #16]
   19bf4:	0b01      	lsrs	r1, r0, #12
   19bf6:	4031      	ands	r1, r6
   19bf8:	d029      	beq.n	19c4e <__iar_annotation$$branch+0xdae>
   19bfa:	0b41      	lsrs	r1, r0, #13
   19bfc:	4031      	ands	r1, r6
   19bfe:	d014      	beq.n	19c2a <__iar_annotation$$branch+0xd8a>
   19c00:	2100      	movs	r1, #0
   19c02:	9100      	str	r1, [sp, #0]
   19c04:	2300      	movs	r3, #0
   19c06:	225b      	movs	r2, #91	; 0x5b
   19c08:	2101      	movs	r1, #1
   19c0a:	4001      	ands	r1, r0
   19c0c:	2009      	movs	r0, #9
   19c0e:	4d13      	ldr	r5, [pc, #76]	; (19c5c <__iar_annotation$$branch+0x6>)
   19c10:	6a2d      	ldr	r5, [r5, #32]
   19c12:	47a8      	blx	r5
   19c14:	215b      	movs	r1, #91	; 0x5b
   19c16:	6922      	ldr	r2, [r4, #16]
   19c18:	2001      	movs	r0, #1
   19c1a:	4010      	ands	r0, r2
   19c1c:	68a2      	ldr	r2, [r4, #8]
   19c1e:	68d2      	ldr	r2, [r2, #12]
   19c20:	4790      	blx	r2
   19c22:	6920      	ldr	r0, [r4, #16]
   19c24:	499d      	ldr	r1, [pc, #628]	; (19e9c <.text_29>)
   19c26:	4001      	ands	r1, r0
   19c28:	6121      	str	r1, [r4, #16]
   19c2a:	2003      	movs	r0, #3
   19c2c:	70f8      	strb	r0, [r7, #3]
   19c2e:	7939      	ldrb	r1, [r7, #4]
   19c30:	2903      	cmp	r1, #3
   19c32:	d00b      	beq.n	19c4c <__iar_annotation$$branch+0xdac>
   19c34:	7138      	strb	r0, [r7, #4]
   19c36:	2000      	movs	r0, #0
   19c38:	9000      	str	r0, [sp, #0]
   19c3a:	2300      	movs	r3, #0
   19c3c:	2203      	movs	r2, #3
   19c3e:	6920      	ldr	r0, [r4, #16]
   19c40:	2101      	movs	r1, #1
   19c42:	4001      	ands	r1, r0
   19c44:	2004      	movs	r0, #4
   19c46:	4d05      	ldr	r5, [pc, #20]	; (19c5c <__iar_annotation$$branch+0x6>)
   19c48:	6a2d      	ldr	r5, [r5, #32]
   19c4a:	47a8      	blx	r5
   19c4c:	2501      	movs	r5, #1
   19c4e:	6920      	ldr	r0, [r4, #16]
   19c50:	4993      	ldr	r1, [pc, #588]	; (19ea0 <.text_30>)
   19c52:	4001      	ands	r1, r0
   19c54:	6121      	str	r1, [r4, #16]

00019c56 <__iar_annotation$$branch>:
   19c56:	f7ff f904 	bl	18e62 <__iar_annotation$$branch+0x42>
   19c5a:	bf00      	nop
   19c5c:	0002ff54 	.word	0x0002ff54
   19c60:	fffff8ff 	.word	0xfffff8ff
   19c64:	4668      	mov	r0, sp
   19c66:	7344      	strb	r4, [r0, #13]
   19c68:	003c      	movs	r4, r7
   19c6a:	9506      	str	r5, [sp, #24]
   19c6c:	9605      	str	r6, [sp, #20]
   19c6e:	2601      	movs	r6, #1
   19c70:	6860      	ldr	r0, [r4, #4]
   19c72:	6800      	ldr	r0, [r0, #0]
   19c74:	0b00      	lsrs	r0, r0, #12
   19c76:	4030      	ands	r0, r6
   19c78:	d101      	bne.n	19c7e <__iar_annotation$$branch+0x4>

00019c7a <__iar_annotation$$branch>:
   19c7a:	f7ff f914 	bl	18ea6 <__iar_annotation$$branch+0x6>
   19c7e:	2502      	movs	r5, #2
   19c80:	4885      	ldr	r0, [pc, #532]	; (19e98 <.text_28>)
   19c82:	5c22      	ldrb	r2, [r4, r0]
   19c84:	2a0f      	cmp	r2, #15
   19c86:	d111      	bne.n	19cac <__iar_annotation$$branch+0x32>
   19c88:	1820      	adds	r0, r4, r0
   19c8a:	70c2      	strb	r2, [r0, #3]
   19c8c:	2100      	movs	r1, #0
   19c8e:	7001      	strb	r1, [r0, #0]
   19c90:	7901      	ldrb	r1, [r0, #4]
   19c92:	4291      	cmp	r1, r2
   19c94:	d00a      	beq.n	19cac <__iar_annotation$$branch+0x32>
   19c96:	7102      	strb	r2, [r0, #4]
   19c98:	2000      	movs	r0, #0
   19c9a:	9000      	str	r0, [sp, #0]
   19c9c:	2300      	movs	r3, #0
   19c9e:	6920      	ldr	r0, [r4, #16]
   19ca0:	2101      	movs	r1, #1
   19ca2:	4001      	ands	r1, r0
   19ca4:	2004      	movs	r0, #4
   19ca6:	4f7f      	ldr	r7, [pc, #508]	; (19ea4 <.text_31>)
   19ca8:	6a3f      	ldr	r7, [r7, #32]
   19caa:	47b8      	blx	r7
   19cac:	4668      	mov	r0, sp
   19cae:	7b00      	ldrb	r0, [r0, #12]
   19cb0:	2801      	cmp	r0, #1
   19cb2:	d11f      	bne.n	19cf4 <__iar_annotation$$branch+0x7a>
   19cb4:	6860      	ldr	r0, [r4, #4]
   19cb6:	6800      	ldr	r0, [r0, #0]
   19cb8:	08c0      	lsrs	r0, r0, #3
   19cba:	4030      	ands	r0, r6
   19cbc:	21a5      	movs	r1, #165	; 0xa5
   19cbe:	0089      	lsls	r1, r1, #2
   19cc0:	1861      	adds	r1, r4, r1
   19cc2:	89c9      	ldrh	r1, [r1, #14]
   19cc4:	0949      	lsrs	r1, r1, #5
   19cc6:	2201      	movs	r2, #1
   19cc8:	400a      	ands	r2, r1
   19cca:	4290      	cmp	r0, r2
   19ccc:	d112      	bne.n	19cf4 <__iar_annotation$$branch+0x7a>
   19cce:	4872      	ldr	r0, [pc, #456]	; (19e98 <.text_28>)
   19cd0:	1820      	adds	r0, r4, r0
   19cd2:	2192      	movs	r1, #146	; 0x92
   19cd4:	70c1      	strb	r1, [r0, #3]
   19cd6:	7902      	ldrb	r2, [r0, #4]
   19cd8:	2a92      	cmp	r2, #146	; 0x92
   19cda:	d00b      	beq.n	19cf4 <__iar_annotation$$branch+0x7a>
   19cdc:	7101      	strb	r1, [r0, #4]
   19cde:	2000      	movs	r0, #0
   19ce0:	9000      	str	r0, [sp, #0]
   19ce2:	2300      	movs	r3, #0
   19ce4:	2292      	movs	r2, #146	; 0x92
   19ce6:	6920      	ldr	r0, [r4, #16]
   19ce8:	2101      	movs	r1, #1
   19cea:	4001      	ands	r1, r0
   19cec:	2004      	movs	r0, #4
   19cee:	4f6d      	ldr	r7, [pc, #436]	; (19ea4 <.text_31>)
   19cf0:	6a3f      	ldr	r7, [r7, #32]
   19cf2:	47b8      	blx	r7
   19cf4:	9805      	ldr	r0, [sp, #20]
   19cf6:	2800      	cmp	r0, #0
   19cf8:	d005      	beq.n	19d06 <__iar_annotation$$branch+0x8c>
   19cfa:	2107      	movs	r1, #7
   19cfc:	f005 f968 	bl	1efd0 <__aeabi_uidivmod>
   19d00:	2900      	cmp	r1, #0
   19d02:	d100      	bne.n	19d06 <__iar_annotation$$branch+0x8c>
   19d04:	9606      	str	r6, [sp, #24]
   19d06:	4864      	ldr	r0, [pc, #400]	; (19e98 <.text_28>)
   19d08:	1820      	adds	r0, r4, r0
   19d0a:	78c0      	ldrb	r0, [r0, #3]
   19d0c:	4669      	mov	r1, sp
   19d0e:	7b09      	ldrb	r1, [r1, #12]
   19d10:	4fbc      	ldr	r7, [pc, #752]	; (1a004 <.text_33>)
   19d12:	0002      	movs	r2, r0
   19d14:	d101      	bne.n	19d1a <__iar_annotation$$branch+0x4>

00019d16 <__iar_annotation$$branch>:
   19d16:	f7ff f8c8 	bl	18eaa <__iar_annotation$$branch+0xa>
   19d1a:	1e42      	subs	r2, r0, #1
   19d1c:	d040      	beq.n	19da0 <__iar_annotation$$branch+0x30>
   19d1e:	1e92      	subs	r2, r2, #2
   19d20:	2a01      	cmp	r2, #1
   19d22:	d801      	bhi.n	19d28 <__iar_annotation$$branch+0x4>

00019d24 <__iar_annotation$$branch>:
   19d24:	f7ff fbc3 	bl	194ae <__iar_annotation$$branch+0x60e>
   19d28:	1e92      	subs	r2, r2, #2
   19d2a:	d100      	bne.n	19d2e <__iar_annotation$$branch+0xa>
   19d2c:	e094      	b.n	19e58 <__iar_annotation$$branch+0xa>
   19d2e:	3a0a      	subs	r2, #10
   19d30:	d101      	bne.n	19d36 <__iar_annotation$$branch+0x4>

00019d32 <__iar_annotation$$branch>:
   19d32:	f7ff f9eb 	bl	1910c <__iar_annotation$$branch+0x26c>
   19d36:	1e52      	subs	r2, r2, #1
   19d38:	d101      	bne.n	19d3e <__iar_annotation$$branch+0x4>

00019d3a <__iar_annotation$$branch>:
   19d3a:	f7ff faf0 	bl	1931e <__iar_annotation$$branch+0x47e>
   19d3e:	1e52      	subs	r2, r2, #1
   19d40:	d101      	bne.n	19d46 <__iar_annotation$$branch+0x4>

00019d42 <__iar_annotation$$branch>:
   19d42:	f7ff fb19 	bl	19378 <__iar_annotation$$branch+0x4d8>
   19d46:	1fd2      	subs	r2, r2, #7
   19d48:	2a01      	cmp	r2, #1
   19d4a:	d929      	bls.n	19da0 <__iar_annotation$$branch+0x30>
   19d4c:	1e92      	subs	r2, r2, #2
   19d4e:	d101      	bne.n	19d54 <__iar_annotation$$branch+0x4>

00019d50 <__iar_annotation$$branch>:
   19d50:	f7ff fb51 	bl	193f6 <__iar_annotation$$branch+0x556>
   19d54:	1ed2      	subs	r2, r2, #3
   19d56:	d023      	beq.n	19da0 <__iar_annotation$$branch+0x30>
   19d58:	1e52      	subs	r2, r2, #1
   19d5a:	d100      	bne.n	19d5e <__iar_annotation$$branch+0xe>
   19d5c:	e4db      	b.n	19716 <__iar_annotation$$branch+0x876>
   19d5e:	1f12      	subs	r2, r2, #4
   19d60:	d101      	bne.n	19d66 <__iar_annotation$$branch+0x4>

00019d62 <__iar_annotation$$branch>:
   19d62:	f7ff fbd7 	bl	19514 <__iar_annotation$$branch+0x674>
   19d66:	1f52      	subs	r2, r2, #5
   19d68:	2a02      	cmp	r2, #2
   19d6a:	d919      	bls.n	19da0 <__iar_annotation$$branch+0x30>
   19d6c:	1ed2      	subs	r2, r2, #3
   19d6e:	d101      	bne.n	19d74 <__iar_annotation$$branch+0x4>

00019d70 <__iar_annotation$$branch>:
   19d70:	f7ff fb87 	bl	19482 <__iar_annotation$$branch+0x5e2>
   19d74:	1e52      	subs	r2, r2, #1
   19d76:	d100      	bne.n	19d7a <__iar_annotation$$branch+0xa>
   19d78:	e615      	b.n	199a6 <__iar_annotation$$branch+0xb06>
   19d7a:	1e52      	subs	r2, r2, #1
   19d7c:	d010      	beq.n	19da0 <__iar_annotation$$branch+0x30>
   19d7e:	1e92      	subs	r2, r2, #2
   19d80:	d100      	bne.n	19d84 <__iar_annotation$$branch+0x14>
   19d82:	e689      	b.n	19a98 <__iar_annotation$$branch+0xbf8>
   19d84:	1e52      	subs	r2, r2, #1
   19d86:	2a01      	cmp	r2, #1
   19d88:	d90a      	bls.n	19da0 <__iar_annotation$$branch+0x30>
   19d8a:	1e92      	subs	r2, r2, #2
   19d8c:	d001      	beq.n	19d92 <__iar_annotation$$branch+0x22>
   19d8e:	1e92      	subs	r2, r2, #2
   19d90:	2a05      	cmp	r2, #5
   19d92:	d800      	bhi.n	19d96 <__iar_annotation$$branch+0x26>
   19d94:	e708      	b.n	19ba8 <__iar_annotation$$branch+0xd08>
   19d96:	1f92      	subs	r2, r2, #6
   19d98:	d100      	bne.n	19d9c <__iar_annotation$$branch+0x2c>
   19d9a:	e6d9      	b.n	19b50 <__iar_annotation$$branch+0xcb0>
   19d9c:	1e52      	subs	r2, r2, #1
   19d9e:	2a03      	cmp	r2, #3
   19da0:	d800      	bhi.n	19da4 <__iar_annotation$$branch+0x34>
   19da2:	e705      	b.n	19bb0 <__iar_annotation$$branch+0xd10>
   19da4:	1f12      	subs	r2, r2, #4
   19da6:	d101      	bne.n	19dac <__iar_annotation$$branch+0x4>

00019da8 <__iar_annotation$$branch>:
   19da8:	f7ff f89e 	bl	18ee8 <__iar_annotation$$branch+0x48>
   19dac:	1e52      	subs	r2, r2, #1
   19dae:	d101      	bne.n	19db4 <__iar_annotation$$branch+0x4>

00019db0 <__iar_annotation$$branch>:
   19db0:	f7ff fa0e 	bl	191d0 <__iar_annotation$$branch+0x330>
   19db4:	1e52      	subs	r2, r2, #1
   19db6:	d101      	bne.n	19dbc <__iar_annotation$$branch+0x4>

00019db8 <__iar_annotation$$branch>:
   19db8:	f7ff fa6b 	bl	19292 <__iar_annotation$$branch+0x3f2>
   19dbc:	1ed2      	subs	r2, r2, #3
   19dbe:	d101      	bne.n	19dc4 <__iar_annotation$$branch+0x4>

00019dc0 <__iar_annotation$$branch>:
   19dc0:	f7ff f8c0 	bl	18f44 <__iar_annotation$$branch+0xa4>
   19dc4:	1e52      	subs	r2, r2, #1
   19dc6:	d101      	bne.n	19dcc <__iar_annotation$$branch+0x4>

00019dc8 <__iar_annotation$$branch>:
   19dc8:	f7ff f903 	bl	18fd2 <__iar_annotation$$branch+0x132>
   19dcc:	1e52      	subs	r2, r2, #1
   19dce:	d101      	bne.n	19dd4 <__iar_annotation$$branch+0x4>

00019dd0 <__iar_annotation$$branch>:
   19dd0:	f7ff f914 	bl	18ffc <__iar_annotation$$branch+0x15c>
   19dd4:	1e52      	subs	r2, r2, #1
   19dd6:	d101      	bne.n	19ddc <__iar_annotation$$branch+0x4>

00019dd8 <__iar_annotation$$branch>:
   19dd8:	f7ff f92b 	bl	19032 <__iar_annotation$$branch+0x192>
   19ddc:	1e52      	subs	r2, r2, #1
   19dde:	d101      	bne.n	19de4 <__iar_annotation$$branch+0x4>

00019de0 <__iar_annotation$$branch>:
   19de0:	f7ff f92c 	bl	1903c <__iar_annotation$$branch+0x19c>
   19de4:	1e92      	subs	r2, r2, #2
   19de6:	d09c      	beq.n	19d22 <__iar_annotation$$branch+0xc>
   19de8:	1ed2      	subs	r2, r2, #3
   19dea:	d100      	bne.n	19dee <__iar_annotation$$branch+0xe>
   19dec:	e5c4      	b.n	19978 <__iar_annotation$$branch+0xad8>
   19dee:	1f12      	subs	r2, r2, #4
   19df0:	d101      	bne.n	19df6 <__iar_annotation$$branch+0x4>

00019df2 <__iar_annotation$$branch>:
   19df2:	f7ff fae5 	bl	193c0 <__iar_annotation$$branch+0x520>
   19df6:	1e92      	subs	r2, r2, #2
   19df8:	d101      	bne.n	19dfe <__iar_annotation$$branch+0x4>

00019dfa <__iar_annotation$$branch>:
   19dfa:	f7ff fbc9 	bl	19590 <__iar_annotation$$branch+0x6f0>
   19dfe:	1e52      	subs	r2, r2, #1
   19e00:	d101      	bne.n	19e06 <__iar_annotation$$branch+0x4>

00019e02 <__iar_annotation$$branch>:
   19e02:	f7ff fbef 	bl	195e4 <__iar_annotation$$branch+0x744>
   19e06:	1e52      	subs	r2, r2, #1
   19e08:	d100      	bne.n	19e0c <__iar_annotation$$branch+0xa>
   19e0a:	e45d      	b.n	196c8 <__iar_annotation$$branch+0x828>
   19e0c:	1f12      	subs	r2, r2, #4
   19e0e:	d100      	bne.n	19e12 <__iar_annotation$$branch+0x10>
   19e10:	e49b      	b.n	1974a <__iar_annotation$$branch+0x8aa>
   19e12:	1e52      	subs	r2, r2, #1
   19e14:	d100      	bne.n	19e18 <__iar_annotation$$branch+0x16>
   19e16:	e53e      	b.n	19896 <__iar_annotation$$branch+0x9f6>
   19e18:	1e52      	subs	r2, r2, #1
   19e1a:	d100      	bne.n	19e1e <__iar_annotation$$branch+0x1c>
   19e1c:	e566      	b.n	198ec <__iar_annotation$$branch+0xa4c>
   19e1e:	1e52      	subs	r2, r2, #1
   19e20:	d100      	bne.n	19e24 <__iar_annotation$$branch+0x22>
   19e22:	e593      	b.n	1994c <__iar_annotation$$branch+0xaac>
   19e24:	1fd2      	subs	r2, r2, #7
   19e26:	2a02      	cmp	r2, #2
   19e28:	d9ba      	bls.n	19da0 <__iar_annotation$$branch+0x30>
   19e2a:	1ed2      	subs	r2, r2, #3
   19e2c:	d100      	bne.n	19e30 <__iar_annotation$$branch+0x2e>
   19e2e:	e5d5      	b.n	199dc <__iar_annotation$$branch+0xb3c>
   19e30:	1e52      	subs	r2, r2, #1
   19e32:	d100      	bne.n	19e36 <__iar_annotation$$branch+0x34>
   19e34:	e5f4      	b.n	19a20 <__iar_annotation$$branch+0xb80>
   19e36:	3a0e      	subs	r2, #14
   19e38:	d0b2      	beq.n	19da0 <__iar_annotation$$branch+0x30>
   19e3a:	3a12      	subs	r2, #18
   19e3c:	d100      	bne.n	19e40 <__iar_annotation$$branch+0x3e>
   19e3e:	e6cf      	b.n	19be0 <__iar_annotation$$branch+0xd40>
   19e40:	3a0c      	subs	r2, #12
   19e42:	d016      	beq.n	19e72 <__iar_annotation$$branch+0x4>
   19e44:	1e52      	subs	r2, r2, #1
   19e46:	2a02      	cmp	r2, #2
   19e48:	d9aa      	bls.n	19da0 <__iar_annotation$$branch+0x30>
   19e4a:	1f52      	subs	r2, r2, #5
   19e4c:	d101      	bne.n	19e52 <__iar_annotation$$branch+0x4>

00019e4e <__iar_annotation$$branch>:
   19e4e:	f7ff faee 	bl	1942e <__iar_annotation$$branch+0x58e>
   19e52:	1e52      	subs	r2, r2, #1
   19e54:	d0a4      	beq.n	19da0 <__iar_annotation$$branch+0x30>
   19e56:	1e52      	subs	r2, r2, #1
   19e58:	d101      	bne.n	19e5e <__iar_annotation$$branch+0x4>

00019e5a <__iar_annotation$$branch>:
   19e5a:	f7ff f952 	bl	19102 <__iar_annotation$$branch+0x262>
   19e5e:	1e52      	subs	r2, r2, #1
   19e60:	d101      	bne.n	19e66 <__iar_annotation$$branch+0x4>

00019e62 <__iar_annotation$$branch>:
   19e62:	f7ff f9ed 	bl	19240 <__iar_annotation$$branch+0x3a0>
   19e66:	1e52      	subs	r2, r2, #1
   19e68:	2a08      	cmp	r2, #8
   19e6a:	d800      	bhi.n	19e6e <__iar_annotation$$branch>
   19e6c:	e6a5      	b.n	19bba <__iar_annotation$$branch+0xd1a>

00019e6e <__iar_annotation$$branch>:
   19e6e:	f7fe ffbb 	bl	18de8 <__iar_annotation$$branch+0x8>
   19e72:	4668      	mov	r0, sp
   19e74:	7b40      	ldrb	r0, [r0, #13]
   19e76:	f003 fcb6 	bl	1d7e6 <USBPD_PRL_DisableRX>
   19e7a:	6860      	ldr	r0, [r4, #4]
   19e7c:	6801      	ldr	r1, [r0, #0]
   19e7e:	2210      	movs	r2, #16
   19e80:	4391      	bics	r1, r2
   19e82:	6001      	str	r1, [r0, #0]
   19e84:	68a0      	ldr	r0, [r4, #8]
   19e86:	6b41      	ldr	r1, [r0, #52]	; 0x34
   19e88:	2900      	cmp	r1, #0
   19e8a:	d003      	beq.n	19e94 <__iar_annotation$$branch>
   19e8c:	7c22      	ldrb	r2, [r4, #16]
   19e8e:	07d0      	lsls	r0, r2, #31
   19e90:	0fc0      	lsrs	r0, r0, #31
   19e92:	4788      	blx	r1

00019e94 <__iar_annotation$$branch>:
   19e94:	f7ff f825 	bl	18ee2 <__iar_annotation$$branch+0x42>

00019e98 <.text_28>:
   19e98:	0000028d 	.word	0x0000028d

00019e9c <.text_29>:
   19e9c:	ffffdfff 	.word	0xffffdfff

00019ea0 <.text_30>:
   19ea0:	ffffefff 	.word	0xffffefff

00019ea4 <.text_31>:
   19ea4:	0002ff54 	.word	0x0002ff54

00019ea8 <PE_StateMachine_SNK_SelectCapa>:
   19ea8:	b5f3      	push	{r0, r1, r4, r5, r6, r7, lr}
   19eaa:	b081      	sub	sp, #4
   19eac:	0005      	movs	r5, r0
   19eae:	2402      	movs	r4, #2
   19eb0:	7808      	ldrb	r0, [r1, #0]
   19eb2:	2811      	cmp	r0, #17
   19eb4:	d16a      	bne.n	19f8c <PE_StateMachine_SNK_SelectCapa+0xe4>
   19eb6:	20a4      	movs	r0, #164	; 0xa4
   19eb8:	0080      	lsls	r0, r0, #2
   19eba:	1828      	adds	r0, r5, r0
   19ebc:	8a40      	ldrh	r0, [r0, #18]
   19ebe:	21f0      	movs	r1, #240	; 0xf0
   19ec0:	0209      	lsls	r1, r1, #8
   19ec2:	4001      	ands	r1, r0
   19ec4:	d162      	bne.n	19f8c <PE_StateMachine_SNK_SelectCapa+0xe4>
   19ec6:	2601      	movs	r6, #1
   19ec8:	4aaf      	ldr	r2, [pc, #700]	; (1a188 <.text_37>)
   19eca:	2107      	movs	r1, #7
   19ecc:	06c3      	lsls	r3, r0, #27
   19ece:	0edb      	lsrs	r3, r3, #27
   19ed0:	1e9b      	subs	r3, r3, #2
   19ed2:	2b01      	cmp	r3, #1
   19ed4:	d904      	bls.n	19ee0 <PE_StateMachine_SNK_SelectCapa+0x38>
   19ed6:	1e9b      	subs	r3, r3, #2
   19ed8:	d026      	beq.n	19f28 <PE_StateMachine_SNK_SelectCapa+0x80>
   19eda:	3b08      	subs	r3, #8
   19edc:	d024      	beq.n	19f28 <PE_StateMachine_SNK_SelectCapa+0x80>
   19ede:	e045      	b.n	19f6c <PE_StateMachine_SNK_SelectCapa+0xc4>
   19ee0:	20a4      	movs	r0, #164	; 0xa4
   19ee2:	0080      	lsls	r0, r0, #2
   19ee4:	1828      	adds	r0, r5, r0
   19ee6:	2347      	movs	r3, #71	; 0x47
   19ee8:	7003      	strb	r3, [r0, #0]
   19eea:	8082      	strh	r2, [r0, #4]
   19eec:	24fa      	movs	r4, #250	; 0xfa
   19eee:	0064      	lsls	r4, r4, #1
   19ef0:	6868      	ldr	r0, [r5, #4]
   19ef2:	6802      	ldr	r2, [r0, #0]
   19ef4:	0a13      	lsrs	r3, r2, #8
   19ef6:	4019      	ands	r1, r3
   19ef8:	2904      	cmp	r1, #4
   19efa:	d030      	beq.n	19f5e <PE_StateMachine_SNK_SelectCapa+0xb6>
   19efc:	49bb      	ldr	r1, [pc, #748]	; (1a1ec <.text_39>)
   19efe:	4011      	ands	r1, r2
   19f00:	02b2      	lsls	r2, r6, #10
   19f02:	430a      	orrs	r2, r1
   19f04:	6002      	str	r2, [r0, #0]
   19f06:	2000      	movs	r0, #0
   19f08:	9000      	str	r0, [sp, #0]
   19f0a:	2300      	movs	r3, #0
   19f0c:	225a      	movs	r2, #90	; 0x5a
   19f0e:	6929      	ldr	r1, [r5, #16]
   19f10:	4031      	ands	r1, r6
   19f12:	2009      	movs	r0, #9
   19f14:	4fb6      	ldr	r7, [pc, #728]	; (1a1f0 <.text_40>)
   19f16:	6a3f      	ldr	r7, [r7, #32]
   19f18:	47b8      	blx	r7
   19f1a:	215a      	movs	r1, #90	; 0x5a
   19f1c:	6928      	ldr	r0, [r5, #16]
   19f1e:	4030      	ands	r0, r6
   19f20:	68aa      	ldr	r2, [r5, #8]
   19f22:	68d2      	ldr	r2, [r2, #12]
   19f24:	4790      	blx	r2
   19f26:	e01a      	b.n	19f5e <PE_StateMachine_SNK_SelectCapa+0xb6>
   19f28:	686b      	ldr	r3, [r5, #4]
   19f2a:	681b      	ldr	r3, [r3, #0]
   19f2c:	0a1b      	lsrs	r3, r3, #8
   19f2e:	4019      	ands	r1, r3
   19f30:	2903      	cmp	r1, #3
   19f32:	d008      	beq.n	19f46 <PE_StateMachine_SNK_SelectCapa+0x9e>
   19f34:	20a4      	movs	r0, #164	; 0xa4
   19f36:	0080      	lsls	r0, r0, #2
   19f38:	1828      	adds	r0, r5, r0
   19f3a:	2143      	movs	r1, #67	; 0x43
   19f3c:	7001      	strb	r1, [r0, #0]
   19f3e:	8082      	strh	r2, [r0, #4]
   19f40:	24fa      	movs	r4, #250	; 0xfa
   19f42:	0064      	lsls	r4, r4, #1
   19f44:	e00b      	b.n	19f5e <PE_StateMachine_SNK_SelectCapa+0xb6>
   19f46:	21a4      	movs	r1, #164	; 0xa4
   19f48:	0089      	lsls	r1, r1, #2
   19f4a:	1869      	adds	r1, r5, r1
   19f4c:	2400      	movs	r4, #0
   19f4e:	06c0      	lsls	r0, r0, #27
   19f50:	0ec0      	lsrs	r0, r0, #27
   19f52:	280c      	cmp	r0, #12
   19f54:	d101      	bne.n	19f5a <PE_StateMachine_SNK_SelectCapa+0xb2>
   19f56:	2049      	movs	r0, #73	; 0x49
   19f58:	e000      	b.n	19f5c <PE_StateMachine_SNK_SelectCapa+0xb4>
   19f5a:	2003      	movs	r0, #3
   19f5c:	7008      	strb	r0, [r1, #0]
   19f5e:	2014      	movs	r0, #20
   19f60:	9902      	ldr	r1, [sp, #8]
   19f62:	7008      	strb	r0, [r1, #0]
   19f64:	6928      	ldr	r0, [r5, #16]
   19f66:	4030      	ands	r0, r6
   19f68:	f003 fc37 	bl	1d7da <USBPD_PRL_EnableRX>
   19f6c:	48a0      	ldr	r0, [pc, #640]	; (1a1f0 <.text_40>)
   19f6e:	6a07      	ldr	r7, [r0, #32]
   19f70:	20a4      	movs	r0, #164	; 0xa4
   19f72:	0080      	lsls	r0, r0, #2
   19f74:	1828      	adds	r0, r5, r0
   19f76:	7c80      	ldrb	r0, [r0, #18]
   19f78:	06c0      	lsls	r0, r0, #27
   19f7a:	0ec0      	lsrs	r0, r0, #27
   19f7c:	2802      	cmp	r0, #2
   19f7e:	d010      	beq.n	19fa2 <PE_StateMachine_SNK_SelectCapa+0xfa>
   19f80:	2803      	cmp	r0, #3
   19f82:	d004      	beq.n	19f8e <PE_StateMachine_SNK_SelectCapa+0xe6>
   19f84:	2804      	cmp	r0, #4
   19f86:	d016      	beq.n	19fb6 <PE_StateMachine_SNK_SelectCapa+0x10e>
   19f88:	280c      	cmp	r0, #12
   19f8a:	d01e      	beq.n	19fca <PE_StateMachine_SNK_SelectCapa+0x122>
   19f8c:	e02c      	b.n	19fe8 <PE_StateMachine_SNK_SelectCapa+0x140>
   19f8e:	2000      	movs	r0, #0
   19f90:	9000      	str	r0, [sp, #0]
   19f92:	2300      	movs	r3, #0
   19f94:	2201      	movs	r2, #1
   19f96:	6929      	ldr	r1, [r5, #16]
   19f98:	4031      	ands	r1, r6
   19f9a:	2009      	movs	r0, #9
   19f9c:	47b8      	blx	r7
   19f9e:	2101      	movs	r1, #1
   19fa0:	e01c      	b.n	19fdc <PE_StateMachine_SNK_SelectCapa+0x134>
   19fa2:	2000      	movs	r0, #0
   19fa4:	9000      	str	r0, [sp, #0]
   19fa6:	2300      	movs	r3, #0
   19fa8:	2204      	movs	r2, #4
   19faa:	6929      	ldr	r1, [r5, #16]
   19fac:	4031      	ands	r1, r6
   19fae:	2009      	movs	r0, #9
   19fb0:	47b8      	blx	r7
   19fb2:	2104      	movs	r1, #4
   19fb4:	e012      	b.n	19fdc <PE_StateMachine_SNK_SelectCapa+0x134>
   19fb6:	2000      	movs	r0, #0
   19fb8:	9000      	str	r0, [sp, #0]
   19fba:	2300      	movs	r3, #0
   19fbc:	2202      	movs	r2, #2
   19fbe:	6929      	ldr	r1, [r5, #16]
   19fc0:	4031      	ands	r1, r6
   19fc2:	2009      	movs	r0, #9
   19fc4:	47b8      	blx	r7
   19fc6:	2102      	movs	r1, #2
   19fc8:	e008      	b.n	19fdc <PE_StateMachine_SNK_SelectCapa+0x134>
   19fca:	2000      	movs	r0, #0
   19fcc:	9000      	str	r0, [sp, #0]
   19fce:	2300      	movs	r3, #0
   19fd0:	2203      	movs	r2, #3
   19fd2:	6929      	ldr	r1, [r5, #16]
   19fd4:	4031      	ands	r1, r6
   19fd6:	2009      	movs	r0, #9
   19fd8:	47b8      	blx	r7
   19fda:	2103      	movs	r1, #3
   19fdc:	6928      	ldr	r0, [r5, #16]
   19fde:	4006      	ands	r6, r0
   19fe0:	0030      	movs	r0, r6
   19fe2:	68aa      	ldr	r2, [r5, #8]
   19fe4:	68d2      	ldr	r2, [r2, #12]
   19fe6:	4790      	blx	r2
   19fe8:	20a4      	movs	r0, #164	; 0xa4
   19fea:	0080      	lsls	r0, r0, #2
   19fec:	1828      	adds	r0, r5, r0
   19fee:	8881      	ldrh	r1, [r0, #4]
   19ff0:	2280      	movs	r2, #128	; 0x80
   19ff2:	0212      	lsls	r2, r2, #8
   19ff4:	4291      	cmp	r1, r2
   19ff6:	d102      	bne.n	19ffe <PE_StateMachine_SNK_SelectCapa+0x156>
   19ff8:	210f      	movs	r1, #15
   19ffa:	7001      	strb	r1, [r0, #0]
   19ffc:	2400      	movs	r4, #0
   19ffe:	0020      	movs	r0, r4
   1a000:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	...

0001a004 <.text_33>:
   1a004:	00008018 	.word	0x00008018

0001a008 <PE_StateMachine_SNK_ReadyWait>:
   1a008:	b5f3      	push	{r0, r1, r4, r5, r6, r7, lr}
   1a00a:	b081      	sub	sp, #4
   1a00c:	0004      	movs	r4, r0
   1a00e:	2502      	movs	r5, #2
   1a010:	6922      	ldr	r2, [r4, #16]
   1a012:	07d0      	lsls	r0, r2, #31
   1a014:	0fc0      	lsrs	r0, r0, #31
   1a016:	21a6      	movs	r1, #166	; 0xa6
   1a018:	0089      	lsls	r1, r1, #2
   1a01a:	1867      	adds	r7, r4, r1
   1a01c:	390b      	subs	r1, #11
   1a01e:	1866      	adds	r6, r4, r1
   1a020:	9902      	ldr	r1, [sp, #8]
   1a022:	7809      	ldrb	r1, [r1, #0]
   1a024:	2914      	cmp	r1, #20
   1a026:	d01e      	beq.n	1a066 <PE_StateMachine_SNK_ReadyWait+0x5e>
   1a028:	7970      	ldrb	r0, [r6, #5]
   1a02a:	71b0      	strb	r0, [r6, #6]
   1a02c:	8978      	ldrh	r0, [r7, #10]
   1a02e:	0bc1      	lsrs	r1, r0, #15
   1a030:	d003      	beq.n	1a03a <PE_StateMachine_SNK_ReadyWait+0x32>
   1a032:	0020      	movs	r0, r4
   1a034:	f001 fe32 	bl	1bc9c <PE_Check_ExtendedMessage>
   1a038:	e00c      	b.n	1a054 <PE_StateMachine_SNK_ReadyWait+0x4c>
   1a03a:	21f0      	movs	r1, #240	; 0xf0
   1a03c:	0209      	lsls	r1, r1, #8
   1a03e:	4001      	ands	r1, r0
   1a040:	d104      	bne.n	1a04c <PE_StateMachine_SNK_ReadyWait+0x44>
   1a042:	9902      	ldr	r1, [sp, #8]
   1a044:	0020      	movs	r0, r4
   1a046:	f001 fb67 	bl	1b718 <PE_Check_ControlMessage>
   1a04a:	e003      	b.n	1a054 <PE_StateMachine_SNK_ReadyWait+0x4c>
   1a04c:	0020      	movs	r0, r4
   1a04e:	f001 fd1f 	bl	1ba90 <PE_Check_DataMessage>
   1a052:	0005      	movs	r5, r0
   1a054:	2014      	movs	r0, #20
   1a056:	9902      	ldr	r1, [sp, #8]
   1a058:	7008      	strb	r0, [r1, #0]
   1a05a:	7c21      	ldrb	r1, [r4, #16]
   1a05c:	07c8      	lsls	r0, r1, #31
   1a05e:	0fc0      	lsrs	r0, r0, #31
   1a060:	f003 fbbb 	bl	1d7da <USBPD_PRL_EnableRX>
   1a064:	e079      	b.n	1a15a <PE_StateMachine_SNK_ReadyWait+0x152>
   1a066:	0c11      	lsrs	r1, r2, #16
   1a068:	250f      	movs	r5, #15
   1a06a:	2900      	cmp	r1, #0
   1a06c:	d018      	beq.n	1a0a0 <PE_StateMachine_SNK_ReadyWait+0x98>
   1a06e:	2080      	movs	r0, #128	; 0x80
   1a070:	0200      	lsls	r0, r0, #8
   1a072:	887a      	ldrh	r2, [r7, #2]
   1a074:	4282      	cmp	r2, r0
   1a076:	d105      	bne.n	1a084 <PE_StateMachine_SNK_ReadyWait+0x7c>
   1a078:	70f5      	strb	r5, [r6, #3]
   1a07a:	7e20      	ldrb	r0, [r4, #24]
   1a07c:	1c40      	adds	r0, r0, #1
   1a07e:	7620      	strb	r0, [r4, #24]
   1a080:	2500      	movs	r5, #0
   1a082:	e06a      	b.n	1a15a <PE_StateMachine_SNK_ReadyWait+0x152>
   1a084:	68fa      	ldr	r2, [r7, #12]
   1a086:	0512      	lsls	r2, r2, #20
   1a088:	0d12      	lsrs	r2, r2, #20
   1a08a:	897b      	ldrh	r3, [r7, #10]
   1a08c:	051b      	lsls	r3, r3, #20
   1a08e:	0f5b      	lsrs	r3, r3, #29
   1a090:	1859      	adds	r1, r3, r1
   1a092:	2333      	movs	r3, #51	; 0x33
   1a094:	4359      	muls	r1, r3
   1a096:	188d      	adds	r5, r1, r2
   1a098:	4328      	orrs	r0, r5
   1a09a:	8078      	strh	r0, [r7, #2]
   1a09c:	b2ad      	uxth	r5, r5
   1a09e:	e05c      	b.n	1a15a <PE_StateMachine_SNK_ReadyWait+0x152>
   1a0a0:	88f9      	ldrh	r1, [r7, #6]
   1a0a2:	2380      	movs	r3, #128	; 0x80
   1a0a4:	021b      	lsls	r3, r3, #8
   1a0a6:	4299      	cmp	r1, r3
   1a0a8:	d106      	bne.n	1a0b8 <PE_StateMachine_SNK_ReadyWait+0xb0>
   1a0aa:	2045      	movs	r0, #69	; 0x45
   1a0ac:	70f0      	strb	r0, [r6, #3]
   1a0ae:	2500      	movs	r5, #0
   1a0b0:	4618      	mov	r0, r3
   1a0b2:	4310      	orrs	r0, r2
   1a0b4:	6120      	str	r0, [r4, #16]
   1a0b6:	e050      	b.n	1a15a <PE_StateMachine_SNK_ReadyWait+0x152>
   1a0b8:	78b1      	ldrb	r1, [r6, #2]
   1a0ba:	2900      	cmp	r1, #0
   1a0bc:	d127      	bne.n	1a10e <PE_StateMachine_SNK_ReadyWait+0x106>
   1a0be:	7831      	ldrb	r1, [r6, #0]
   1a0c0:	2900      	cmp	r1, #0
   1a0c2:	d024      	beq.n	1a10e <PE_StateMachine_SNK_ReadyWait+0x106>
   1a0c4:	f003 f9e8 	bl	1d498 <USBPD_PRL_IsResistor_SinkTxOK>
   1a0c8:	2801      	cmp	r0, #1
   1a0ca:	d105      	bne.n	1a0d8 <PE_StateMachine_SNK_ReadyWait+0xd0>
   1a0cc:	6860      	ldr	r0, [r4, #4]
   1a0ce:	7800      	ldrb	r0, [r0, #0]
   1a0d0:	0780      	lsls	r0, r0, #30
   1a0d2:	0f80      	lsrs	r0, r0, #30
   1a0d4:	2802      	cmp	r0, #2
   1a0d6:	d005      	beq.n	1a0e4 <PE_StateMachine_SNK_ReadyWait+0xdc>
   1a0d8:	6860      	ldr	r0, [r4, #4]
   1a0da:	7800      	ldrb	r0, [r0, #0]
   1a0dc:	0780      	lsls	r0, r0, #30
   1a0de:	0f80      	lsrs	r0, r0, #30
   1a0e0:	2801      	cmp	r0, #1
   1a0e2:	d114      	bne.n	1a10e <PE_StateMachine_SNK_ReadyWait+0x106>
   1a0e4:	7870      	ldrb	r0, [r6, #1]
   1a0e6:	71b0      	strb	r0, [r6, #6]
   1a0e8:	7830      	ldrb	r0, [r6, #0]
   1a0ea:	70f0      	strb	r0, [r6, #3]
   1a0ec:	2845      	cmp	r0, #69	; 0x45
   1a0ee:	d104      	bne.n	1a0fa <PE_StateMachine_SNK_ReadyWait+0xf2>
   1a0f0:	6920      	ldr	r0, [r4, #16]
   1a0f2:	2180      	movs	r1, #128	; 0x80
   1a0f4:	0209      	lsls	r1, r1, #8
   1a0f6:	4301      	orrs	r1, r0
   1a0f8:	6121      	str	r1, [r4, #16]
   1a0fa:	2500      	movs	r5, #0
   1a0fc:	7035      	strb	r5, [r6, #0]
   1a0fe:	6938      	ldr	r0, [r7, #16]
   1a100:	6178      	str	r0, [r7, #20]
   1a102:	6920      	ldr	r0, [r4, #16]
   1a104:	2180      	movs	r1, #128	; 0x80
   1a106:	0189      	lsls	r1, r1, #6
   1a108:	4301      	orrs	r1, r0
   1a10a:	6121      	str	r1, [r4, #16]
   1a10c:	e025      	b.n	1a15a <PE_StateMachine_SNK_ReadyWait+0x152>
   1a10e:	8838      	ldrh	r0, [r7, #0]
   1a110:	2180      	movs	r1, #128	; 0x80
   1a112:	0209      	lsls	r1, r1, #8
   1a114:	4288      	cmp	r0, r1
   1a116:	d107      	bne.n	1a128 <PE_StateMachine_SNK_ReadyWait+0x120>
   1a118:	2500      	movs	r5, #0
   1a11a:	803d      	strh	r5, [r7, #0]
   1a11c:	7ea0      	ldrb	r0, [r4, #26]
   1a11e:	1c40      	adds	r0, r0, #1
   1a120:	76a0      	strb	r0, [r4, #26]
   1a122:	2005      	movs	r0, #5
   1a124:	70f0      	strb	r0, [r6, #3]
   1a126:	e018      	b.n	1a15a <PE_StateMachine_SNK_ReadyWait+0x152>
   1a128:	2000      	movs	r0, #0
   1a12a:	43c0      	mvns	r0, r0
   1a12c:	0c41      	lsrs	r1, r0, #17
   1a12e:	88fa      	ldrh	r2, [r7, #6]
   1a130:	420a      	tst	r2, r1
   1a132:	d001      	beq.n	1a138 <PE_StateMachine_SNK_ReadyWait+0x130>
   1a134:	88f8      	ldrh	r0, [r7, #6]
   1a136:	4008      	ands	r0, r1
   1a138:	883a      	ldrh	r2, [r7, #0]
   1a13a:	420a      	tst	r2, r1
   1a13c:	d006      	beq.n	1a14c <PE_StateMachine_SNK_ReadyWait+0x144>
   1a13e:	883a      	ldrh	r2, [r7, #0]
   1a140:	400a      	ands	r2, r1
   1a142:	4290      	cmp	r0, r2
   1a144:	d302      	bcc.n	1a14c <PE_StateMachine_SNK_ReadyWait+0x144>
   1a146:	883a      	ldrh	r2, [r7, #0]
   1a148:	0008      	movs	r0, r1
   1a14a:	4010      	ands	r0, r2
   1a14c:	7831      	ldrb	r1, [r6, #0]
   1a14e:	2900      	cmp	r1, #0
   1a150:	d002      	beq.n	1a158 <PE_StateMachine_SNK_ReadyWait+0x150>
   1a152:	280f      	cmp	r0, #15
   1a154:	d300      	bcc.n	1a158 <PE_StateMachine_SNK_ReadyWait+0x150>
   1a156:	200f      	movs	r0, #15
   1a158:	0005      	movs	r5, r0
   1a15a:	0028      	movs	r0, r5
   1a15c:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

0001a15e <USBPD_PE_StateMachine_DRP>:
   1a15e:	b580      	push	{r7, lr}
   1a160:	49ae      	ldr	r1, [pc, #696]	; (1a41c <.text_46>)
   1a162:	0082      	lsls	r2, r0, #2
   1a164:	5889      	ldr	r1, [r1, r2]
   1a166:	6849      	ldr	r1, [r1, #4]
   1a168:	6809      	ldr	r1, [r1, #0]
   1a16a:	074a      	lsls	r2, r1, #29
   1a16c:	0fd2      	lsrs	r2, r2, #31
   1a16e:	d002      	beq.n	1a176 <USBPD_PE_StateMachine_DRP+0x18>
   1a170:	f7fd fc9c 	bl	17aac <USBPD_PE_StateMachine_SRC>
   1a174:	bd02      	pop	{r1, pc}
   1a176:	f7fe fe17 	bl	18da8 <USBPD_PE_StateMachine_SNK>
   1a17a:	bd02      	pop	{r1, pc}

0001a17c <USBPD_PE_InitVDM_Callback>:
   1a17c:	4aa7      	ldr	r2, [pc, #668]	; (1a41c <.text_46>)
   1a17e:	0080      	lsls	r0, r0, #2
   1a180:	5810      	ldr	r0, [r2, r0]
   1a182:	60c1      	str	r1, [r0, #12]
   1a184:	4770      	bx	lr
	...

0001a188 <.text_37>:
   1a188:	000081f4 	.word	0x000081f4

0001a18c <USBPD_PE_SVDM_RequestIdentity>:
   1a18c:	b570      	push	{r4, r5, r6, lr}
   1a18e:	4a18      	ldr	r2, [pc, #96]	; (1a1f0 <.text_40>)
   1a190:	0083      	lsls	r3, r0, #2
   1a192:	58d2      	ldr	r2, [r2, r3]
   1a194:	2301      	movs	r3, #1
   1a196:	6814      	ldr	r4, [r2, #0]
   1a198:	6864      	ldr	r4, [r4, #4]
   1a19a:	0a64      	lsrs	r4, r4, #9
   1a19c:	401c      	ands	r4, r3
   1a19e:	d004      	beq.n	1a1aa <USBPD_PE_SVDM_RequestIdentity+0x1e>
   1a1a0:	68d4      	ldr	r4, [r2, #12]
   1a1a2:	2c00      	cmp	r4, #0
   1a1a4:	d001      	beq.n	1a1aa <USBPD_PE_SVDM_RequestIdentity+0x1e>
   1a1a6:	2902      	cmp	r1, #2
   1a1a8:	d101      	bne.n	1a1ae <USBPD_PE_SVDM_RequestIdentity+0x22>
   1a1aa:	2002      	movs	r0, #2
   1a1ac:	bd70      	pop	{r4, r5, r6, pc}
   1a1ae:	4caf      	ldr	r4, [pc, #700]	; (1a46c <.text_48>)
   1a1b0:	1914      	adds	r4, r2, r4
   1a1b2:	7825      	ldrb	r5, [r4, #0]
   1a1b4:	2d00      	cmp	r5, #0
   1a1b6:	d104      	bne.n	1a1c2 <USBPD_PE_SVDM_RequestIdentity+0x36>
   1a1b8:	6855      	ldr	r5, [r2, #4]
   1a1ba:	682e      	ldr	r6, [r5, #0]
   1a1bc:	0b36      	lsrs	r6, r6, #12
   1a1be:	4033      	ands	r3, r6
   1a1c0:	d101      	bne.n	1a1c6 <USBPD_PE_SVDM_RequestIdentity+0x3a>
   1a1c2:	2003      	movs	r0, #3
   1a1c4:	bd70      	pop	{r4, r5, r6, pc}
   1a1c6:	7061      	strb	r1, [r4, #1]
   1a1c8:	2901      	cmp	r1, #1
   1a1ca:	d10d      	bne.n	1a1e8 <USBPD_PE_SVDM_RequestIdentity+0x5c>
   1a1cc:	6829      	ldr	r1, [r5, #0]
   1a1ce:	4bb1      	ldr	r3, [pc, #708]	; (1a494 <.text_51>)
   1a1d0:	400b      	ands	r3, r1
   1a1d2:	2582      	movs	r5, #130	; 0x82
   1a1d4:	006d      	lsls	r5, r5, #1
   1a1d6:	42ab      	cmp	r3, r5
   1a1d8:	d003      	beq.n	1a1e2 <USBPD_PE_SVDM_RequestIdentity+0x56>
   1a1da:	0549      	lsls	r1, r1, #21
   1a1dc:	0f49      	lsrs	r1, r1, #29
   1a1de:	2903      	cmp	r1, #3
   1a1e0:	d102      	bne.n	1a1e8 <USBPD_PE_SVDM_RequestIdentity+0x5c>
   1a1e2:	2105      	movs	r1, #5
   1a1e4:	7021      	strb	r1, [r4, #0]
   1a1e6:	e143      	b.n	1a470 <.text_49>
   1a1e8:	2010      	movs	r0, #16
   1a1ea:	bd70      	pop	{r4, r5, r6, pc}

0001a1ec <.text_39>:
   1a1ec:	fffff8ff 	.word	0xfffff8ff

0001a1f0 <.text_40>:
   1a1f0:	0002ff54 	.word	0x0002ff54

0001a1f4 <USBPD_PE_SVDM_RequestSVID>:
   1a1f4:	b570      	push	{r4, r5, r6, lr}
   1a1f6:	000a      	movs	r2, r1
   1a1f8:	4988      	ldr	r1, [pc, #544]	; (1a41c <.text_46>)
   1a1fa:	0083      	lsls	r3, r0, #2
   1a1fc:	58cb      	ldr	r3, [r1, r3]
   1a1fe:	68d9      	ldr	r1, [r3, #12]
   1a200:	2900      	cmp	r1, #0
   1a202:	d001      	beq.n	1a208 <USBPD_PE_SVDM_RequestSVID+0x14>
   1a204:	2a02      	cmp	r2, #2
   1a206:	d101      	bne.n	1a20c <USBPD_PE_SVDM_RequestSVID+0x18>
   1a208:	2002      	movs	r0, #2
   1a20a:	bd70      	pop	{r4, r5, r6, pc}
   1a20c:	4997      	ldr	r1, [pc, #604]	; (1a46c <.text_48>)
   1a20e:	185c      	adds	r4, r3, r1
   1a210:	7821      	ldrb	r1, [r4, #0]
   1a212:	2900      	cmp	r1, #0
   1a214:	d105      	bne.n	1a222 <USBPD_PE_SVDM_RequestSVID+0x2e>
   1a216:	6859      	ldr	r1, [r3, #4]
   1a218:	680e      	ldr	r6, [r1, #0]
   1a21a:	2501      	movs	r5, #1
   1a21c:	0b31      	lsrs	r1, r6, #12
   1a21e:	4029      	ands	r1, r5
   1a220:	d101      	bne.n	1a226 <USBPD_PE_SVDM_RequestSVID+0x32>
   1a222:	2003      	movs	r0, #3
   1a224:	bd70      	pop	{r4, r5, r6, pc}
   1a226:	2110      	movs	r1, #16
   1a228:	0576      	lsls	r6, r6, #21
   1a22a:	0f76      	lsrs	r6, r6, #29
   1a22c:	2e03      	cmp	r6, #3
   1a22e:	d001      	beq.n	1a234 <USBPD_PE_SVDM_RequestSVID+0x40>
   1a230:	2010      	movs	r0, #16
   1a232:	bd70      	pop	{r4, r5, r6, pc}
   1a234:	7062      	strb	r2, [r4, #1]
   1a236:	267f      	movs	r6, #127	; 0x7f
   1a238:	7026      	strb	r6, [r4, #0]
   1a23a:	2a00      	cmp	r2, #0
   1a23c:	d005      	beq.n	1a24a <USBPD_PE_SVDM_RequestSVID+0x56>
   1a23e:	2a01      	cmp	r2, #1
   1a240:	d107      	bne.n	1a252 <USBPD_PE_SVDM_RequestSVID+0x5e>
   1a242:	691a      	ldr	r2, [r3, #16]
   1a244:	0b92      	lsrs	r2, r2, #14
   1a246:	4015      	ands	r5, r2
   1a248:	d003      	beq.n	1a252 <USBPD_PE_SVDM_RequestSVID+0x5e>
   1a24a:	6899      	ldr	r1, [r3, #8]
   1a24c:	6a89      	ldr	r1, [r1, #40]	; 0x28
   1a24e:	4788      	blx	r1
   1a250:	2100      	movs	r1, #0
   1a252:	0008      	movs	r0, r1
   1a254:	bd70      	pop	{r4, r5, r6, pc}

0001a256 <USBPD_PE_SVDM_RequestMode>:
   1a256:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1a258:	4b70      	ldr	r3, [pc, #448]	; (1a41c <.text_46>)
   1a25a:	0084      	lsls	r4, r0, #2
   1a25c:	591c      	ldr	r4, [r3, r4]
   1a25e:	68e3      	ldr	r3, [r4, #12]
   1a260:	2b00      	cmp	r3, #0
   1a262:	d002      	beq.n	1a26a <USBPD_PE_SVDM_RequestMode+0x14>
   1a264:	000b      	movs	r3, r1
   1a266:	2902      	cmp	r1, #2
   1a268:	d101      	bne.n	1a26e <USBPD_PE_SVDM_RequestMode+0x18>
   1a26a:	2002      	movs	r0, #2
   1a26c:	bdf2      	pop	{r1, r4, r5, r6, r7, pc}
   1a26e:	219c      	movs	r1, #156	; 0x9c
   1a270:	0089      	lsls	r1, r1, #2
   1a272:	1865      	adds	r5, r4, r1
   1a274:	7f69      	ldrb	r1, [r5, #29]
   1a276:	2900      	cmp	r1, #0
   1a278:	d105      	bne.n	1a286 <USBPD_PE_SVDM_RequestMode+0x30>
   1a27a:	6861      	ldr	r1, [r4, #4]
   1a27c:	680f      	ldr	r7, [r1, #0]
   1a27e:	2601      	movs	r6, #1
   1a280:	0b39      	lsrs	r1, r7, #12
   1a282:	4031      	ands	r1, r6
   1a284:	d101      	bne.n	1a28a <USBPD_PE_SVDM_RequestMode+0x34>
   1a286:	2003      	movs	r0, #3
   1a288:	bdf2      	pop	{r1, r4, r5, r6, r7, pc}
   1a28a:	2110      	movs	r1, #16
   1a28c:	057f      	lsls	r7, r7, #21
   1a28e:	0f7f      	lsrs	r7, r7, #29
   1a290:	2f03      	cmp	r7, #3
   1a292:	d001      	beq.n	1a298 <USBPD_PE_SVDM_RequestMode+0x42>
   1a294:	2010      	movs	r0, #16
   1a296:	bdf2      	pop	{r1, r4, r5, r6, r7, pc}
   1a298:	77ab      	strb	r3, [r5, #30]
   1a29a:	2781      	movs	r7, #129	; 0x81
   1a29c:	776f      	strb	r7, [r5, #29]
   1a29e:	802a      	strh	r2, [r5, #0]
   1a2a0:	2b00      	cmp	r3, #0
   1a2a2:	d005      	beq.n	1a2b0 <USBPD_PE_SVDM_RequestMode+0x5a>
   1a2a4:	2b01      	cmp	r3, #1
   1a2a6:	d107      	bne.n	1a2b8 <USBPD_PE_SVDM_RequestMode+0x62>
   1a2a8:	6922      	ldr	r2, [r4, #16]
   1a2aa:	0b92      	lsrs	r2, r2, #14
   1a2ac:	4016      	ands	r6, r2
   1a2ae:	d003      	beq.n	1a2b8 <USBPD_PE_SVDM_RequestMode+0x62>
   1a2b0:	68a1      	ldr	r1, [r4, #8]
   1a2b2:	6a89      	ldr	r1, [r1, #40]	; 0x28
   1a2b4:	4788      	blx	r1
   1a2b6:	2100      	movs	r1, #0
   1a2b8:	0008      	movs	r0, r1
   1a2ba:	bdf2      	pop	{r1, r4, r5, r6, r7, pc}

0001a2bc <USBPD_PE_SVDM_RequestModeEnter>:
   1a2bc:	b5f1      	push	{r0, r4, r5, r6, r7, lr}
   1a2be:	4857      	ldr	r0, [pc, #348]	; (1a41c <.text_46>)
   1a2c0:	466c      	mov	r4, sp
   1a2c2:	7824      	ldrb	r4, [r4, #0]
   1a2c4:	00a4      	lsls	r4, r4, #2
   1a2c6:	5904      	ldr	r4, [r0, r4]
   1a2c8:	68e0      	ldr	r0, [r4, #12]
   1a2ca:	2800      	cmp	r0, #0
   1a2cc:	d101      	bne.n	1a2d2 <USBPD_PE_SVDM_RequestModeEnter+0x16>
   1a2ce:	2002      	movs	r0, #2
   1a2d0:	bdf2      	pop	{r1, r4, r5, r6, r7, pc}
   1a2d2:	209c      	movs	r0, #156	; 0x9c
   1a2d4:	0080      	lsls	r0, r0, #2
   1a2d6:	1820      	adds	r0, r4, r0
   1a2d8:	7f40      	ldrb	r0, [r0, #29]
   1a2da:	2800      	cmp	r0, #0
   1a2dc:	d105      	bne.n	1a2ea <USBPD_PE_SVDM_RequestModeEnter+0x2e>
   1a2de:	6860      	ldr	r0, [r4, #4]
   1a2e0:	6806      	ldr	r6, [r0, #0]
   1a2e2:	2501      	movs	r5, #1
   1a2e4:	0b30      	lsrs	r0, r6, #12
   1a2e6:	4028      	ands	r0, r5
   1a2e8:	d101      	bne.n	1a2ee <USBPD_PE_SVDM_RequestModeEnter+0x32>
   1a2ea:	2003      	movs	r0, #3
   1a2ec:	bdf2      	pop	{r1, r4, r5, r6, r7, pc}
   1a2ee:	2010      	movs	r0, #16
   1a2f0:	27e1      	movs	r7, #225	; 0xe1
   1a2f2:	00ff      	lsls	r7, r7, #3
   1a2f4:	4037      	ands	r7, r6
   1a2f6:	26c2      	movs	r6, #194	; 0xc2
   1a2f8:	00b6      	lsls	r6, r6, #2
   1a2fa:	42b7      	cmp	r7, r6
   1a2fc:	d11b      	bne.n	1a336 <USBPD_PE_SVDM_RequestModeEnter+0x7a>
   1a2fe:	3e98      	subs	r6, #152	; 0x98
   1a300:	19a6      	adds	r6, r4, r6
   1a302:	77b1      	strb	r1, [r6, #30]
   1a304:	2782      	movs	r7, #130	; 0x82
   1a306:	7777      	strb	r7, [r6, #29]
   1a308:	8032      	strh	r2, [r6, #0]
   1a30a:	6922      	ldr	r2, [r4, #16]
   1a30c:	26e0      	movs	r6, #224	; 0xe0
   1a30e:	43b2      	bics	r2, r6
   1a310:	015e      	lsls	r6, r3, #5
   1a312:	23e0      	movs	r3, #224	; 0xe0
   1a314:	4033      	ands	r3, r6
   1a316:	4313      	orrs	r3, r2
   1a318:	6123      	str	r3, [r4, #16]
   1a31a:	2900      	cmp	r1, #0
   1a31c:	d005      	beq.n	1a32a <USBPD_PE_SVDM_RequestModeEnter+0x6e>
   1a31e:	2902      	cmp	r1, #2
   1a320:	d000      	beq.n	1a324 <USBPD_PE_SVDM_RequestModeEnter+0x68>
   1a322:	d208      	bcs.n	1a336 <USBPD_PE_SVDM_RequestModeEnter+0x7a>
   1a324:	0b99      	lsrs	r1, r3, #14
   1a326:	400d      	ands	r5, r1
   1a328:	d005      	beq.n	1a336 <USBPD_PE_SVDM_RequestModeEnter+0x7a>
   1a32a:	4668      	mov	r0, sp
   1a32c:	7800      	ldrb	r0, [r0, #0]
   1a32e:	68a1      	ldr	r1, [r4, #8]
   1a330:	6a89      	ldr	r1, [r1, #40]	; 0x28
   1a332:	4788      	blx	r1
   1a334:	2000      	movs	r0, #0
   1a336:	bdf2      	pop	{r1, r4, r5, r6, r7, pc}

0001a338 <USBPD_PE_SVDM_RequestModeExit>:
   1a338:	b5f1      	push	{r0, r4, r5, r6, r7, lr}
   1a33a:	4838      	ldr	r0, [pc, #224]	; (1a41c <.text_46>)
   1a33c:	466c      	mov	r4, sp
   1a33e:	7824      	ldrb	r4, [r4, #0]
   1a340:	00a4      	lsls	r4, r4, #2
   1a342:	5904      	ldr	r4, [r0, r4]
   1a344:	68e0      	ldr	r0, [r4, #12]
   1a346:	2800      	cmp	r0, #0
   1a348:	d101      	bne.n	1a34e <USBPD_PE_SVDM_RequestModeExit+0x16>
   1a34a:	2002      	movs	r0, #2
   1a34c:	bdf2      	pop	{r1, r4, r5, r6, r7, pc}
   1a34e:	209c      	movs	r0, #156	; 0x9c
   1a350:	0080      	lsls	r0, r0, #2
   1a352:	1820      	adds	r0, r4, r0
   1a354:	7f40      	ldrb	r0, [r0, #29]
   1a356:	2800      	cmp	r0, #0
   1a358:	d105      	bne.n	1a366 <USBPD_PE_SVDM_RequestModeExit+0x2e>
   1a35a:	6860      	ldr	r0, [r4, #4]
   1a35c:	6806      	ldr	r6, [r0, #0]
   1a35e:	2501      	movs	r5, #1
   1a360:	0b30      	lsrs	r0, r6, #12
   1a362:	4028      	ands	r0, r5
   1a364:	d101      	bne.n	1a36a <USBPD_PE_SVDM_RequestModeExit+0x32>
   1a366:	2003      	movs	r0, #3
   1a368:	bdf2      	pop	{r1, r4, r5, r6, r7, pc}
   1a36a:	2010      	movs	r0, #16
   1a36c:	27e1      	movs	r7, #225	; 0xe1
   1a36e:	00ff      	lsls	r7, r7, #3
   1a370:	4037      	ands	r7, r6
   1a372:	26c2      	movs	r6, #194	; 0xc2
   1a374:	00b6      	lsls	r6, r6, #2
   1a376:	42b7      	cmp	r7, r6
   1a378:	d11b      	bne.n	1a3b2 <USBPD_PE_SVDM_RequestModeExit+0x7a>
   1a37a:	3e98      	subs	r6, #152	; 0x98
   1a37c:	19a6      	adds	r6, r4, r6
   1a37e:	77b1      	strb	r1, [r6, #30]
   1a380:	2783      	movs	r7, #131	; 0x83
   1a382:	7777      	strb	r7, [r6, #29]
   1a384:	8032      	strh	r2, [r6, #0]
   1a386:	6922      	ldr	r2, [r4, #16]
   1a388:	26e0      	movs	r6, #224	; 0xe0
   1a38a:	43b2      	bics	r2, r6
   1a38c:	015e      	lsls	r6, r3, #5
   1a38e:	23e0      	movs	r3, #224	; 0xe0
   1a390:	4033      	ands	r3, r6
   1a392:	4313      	orrs	r3, r2
   1a394:	6123      	str	r3, [r4, #16]
   1a396:	2900      	cmp	r1, #0
   1a398:	d005      	beq.n	1a3a6 <USBPD_PE_SVDM_RequestModeExit+0x6e>
   1a39a:	2902      	cmp	r1, #2
   1a39c:	d000      	beq.n	1a3a0 <USBPD_PE_SVDM_RequestModeExit+0x68>
   1a39e:	d208      	bcs.n	1a3b2 <USBPD_PE_SVDM_RequestModeExit+0x7a>
   1a3a0:	0b99      	lsrs	r1, r3, #14
   1a3a2:	400d      	ands	r5, r1
   1a3a4:	d005      	beq.n	1a3b2 <USBPD_PE_SVDM_RequestModeExit+0x7a>
   1a3a6:	4668      	mov	r0, sp
   1a3a8:	7800      	ldrb	r0, [r0, #0]
   1a3aa:	68a1      	ldr	r1, [r4, #8]
   1a3ac:	6a89      	ldr	r1, [r1, #40]	; 0x28
   1a3ae:	4788      	blx	r1
   1a3b0:	2000      	movs	r0, #0
   1a3b2:	bdf2      	pop	{r1, r4, r5, r6, r7, pc}

0001a3b4 <USBPD_PE_SVDM_RequestSpecific>:
   1a3b4:	b5f1      	push	{r0, r4, r5, r6, r7, lr}
   1a3b6:	4819      	ldr	r0, [pc, #100]	; (1a41c <.text_46>)
   1a3b8:	466c      	mov	r4, sp
   1a3ba:	7824      	ldrb	r4, [r4, #0]
   1a3bc:	00a4      	lsls	r4, r4, #2
   1a3be:	5904      	ldr	r4, [r0, r4]
   1a3c0:	68e0      	ldr	r0, [r4, #12]
   1a3c2:	2800      	cmp	r0, #0
   1a3c4:	d101      	bne.n	1a3ca <USBPD_PE_SVDM_RequestSpecific+0x16>
   1a3c6:	2002      	movs	r0, #2
   1a3c8:	bdf2      	pop	{r1, r4, r5, r6, r7, pc}
   1a3ca:	4828      	ldr	r0, [pc, #160]	; (1a46c <.text_48>)
   1a3cc:	1820      	adds	r0, r4, r0
   1a3ce:	7805      	ldrb	r5, [r0, #0]
   1a3d0:	2d00      	cmp	r5, #0
   1a3d2:	d105      	bne.n	1a3e0 <USBPD_PE_SVDM_RequestSpecific+0x2c>
   1a3d4:	6865      	ldr	r5, [r4, #4]
   1a3d6:	682d      	ldr	r5, [r5, #0]
   1a3d8:	2601      	movs	r6, #1
   1a3da:	0b2f      	lsrs	r7, r5, #12
   1a3dc:	4037      	ands	r7, r6
   1a3de:	d101      	bne.n	1a3e4 <USBPD_PE_SVDM_RequestSpecific+0x30>
   1a3e0:	2003      	movs	r0, #3
   1a3e2:	bdf2      	pop	{r1, r4, r5, r6, r7, pc}
   1a3e4:	6927      	ldr	r7, [r4, #16]
   1a3e6:	0bbf      	lsrs	r7, r7, #14
   1a3e8:	403e      	ands	r6, r7
   1a3ea:	d101      	bne.n	1a3f0 <USBPD_PE_SVDM_RequestSpecific+0x3c>
   1a3ec:	000e      	movs	r6, r1
   1a3ee:	d112      	bne.n	1a416 <USBPD_PE_SVDM_RequestSpecific+0x62>
   1a3f0:	056d      	lsls	r5, r5, #21
   1a3f2:	0f6d      	lsrs	r5, r5, #29
   1a3f4:	2d03      	cmp	r5, #3
   1a3f6:	d10e      	bne.n	1a416 <USBPD_PE_SVDM_RequestSpecific+0x62>
   1a3f8:	7041      	strb	r1, [r0, #1]
   1a3fa:	2185      	movs	r1, #133	; 0x85
   1a3fc:	7001      	strb	r1, [r0, #0]
   1a3fe:	209b      	movs	r0, #155	; 0x9b
   1a400:	0080      	lsls	r0, r0, #2
   1a402:	1820      	adds	r0, r4, r0
   1a404:	6002      	str	r2, [r0, #0]
   1a406:	8083      	strh	r3, [r0, #4]
   1a408:	4668      	mov	r0, sp
   1a40a:	7800      	ldrb	r0, [r0, #0]
   1a40c:	68a1      	ldr	r1, [r4, #8]
   1a40e:	6a89      	ldr	r1, [r1, #40]	; 0x28
   1a410:	4788      	blx	r1
   1a412:	2000      	movs	r0, #0
   1a414:	bdf2      	pop	{r1, r4, r5, r6, r7, pc}
   1a416:	2010      	movs	r0, #16
   1a418:	bdf2      	pop	{r1, r4, r5, r6, r7, pc}
	...

0001a41c <.text_46>:
   1a41c:	0002ff54 	.word	0x0002ff54

0001a420 <USBPD_PE_UVDM_RequestMessage>:
   1a420:	b570      	push	{r4, r5, r6, lr}
   1a422:	4aa5      	ldr	r2, [pc, #660]	; (1a6b8 <.text_54>)
   1a424:	0083      	lsls	r3, r0, #2
   1a426:	58d2      	ldr	r2, [r2, r3]
   1a428:	68d3      	ldr	r3, [r2, #12]
   1a42a:	2b00      	cmp	r3, #0
   1a42c:	d101      	bne.n	1a432 <USBPD_PE_UVDM_RequestMessage+0x12>
   1a42e:	2002      	movs	r0, #2
   1a430:	bd70      	pop	{r4, r5, r6, pc}
   1a432:	4b0e      	ldr	r3, [pc, #56]	; (1a46c <.text_48>)
   1a434:	18d3      	adds	r3, r2, r3
   1a436:	781c      	ldrb	r4, [r3, #0]
   1a438:	2c00      	cmp	r4, #0
   1a43a:	d105      	bne.n	1a448 <USBPD_PE_UVDM_RequestMessage+0x28>
   1a43c:	6854      	ldr	r4, [r2, #4]
   1a43e:	6824      	ldr	r4, [r4, #0]
   1a440:	2501      	movs	r5, #1
   1a442:	0b26      	lsrs	r6, r4, #12
   1a444:	402e      	ands	r6, r5
   1a446:	d101      	bne.n	1a44c <USBPD_PE_UVDM_RequestMessage+0x2c>
   1a448:	2003      	movs	r0, #3
   1a44a:	bd70      	pop	{r4, r5, r6, pc}
   1a44c:	0be6      	lsrs	r6, r4, #15
   1a44e:	4035      	ands	r5, r6
   1a450:	d101      	bne.n	1a456 <USBPD_PE_UVDM_RequestMessage+0x36>
   1a452:	000d      	movs	r5, r1
   1a454:	d107      	bne.n	1a466 <USBPD_PE_UVDM_RequestMessage+0x46>
   1a456:	0564      	lsls	r4, r4, #21
   1a458:	0f64      	lsrs	r4, r4, #29
   1a45a:	2c03      	cmp	r4, #3
   1a45c:	d103      	bne.n	1a466 <USBPD_PE_UVDM_RequestMessage+0x46>
   1a45e:	7059      	strb	r1, [r3, #1]
   1a460:	2186      	movs	r1, #134	; 0x86
   1a462:	7019      	strb	r1, [r3, #0]
   1a464:	e004      	b.n	1a470 <.text_49>
   1a466:	2010      	movs	r0, #16
   1a468:	bd70      	pop	{r4, r5, r6, pc}
	...

0001a46c <.text_48>:
   1a46c:	0000028d 	.word	0x0000028d

0001a470 <.text_49>:
   1a470:	6891      	ldr	r1, [r2, #8]
   1a472:	6a89      	ldr	r1, [r1, #40]	; 0x28
   1a474:	4788      	blx	r1
   1a476:	2000      	movs	r0, #0
   1a478:	bd70      	pop	{r4, r5, r6, pc}

0001a47a <USBPD_PE_Request_HardReset>:
   1a47a:	b580      	push	{r7, lr}
   1a47c:	498e      	ldr	r1, [pc, #568]	; (1a6b8 <.text_54>)
   1a47e:	0082      	lsls	r2, r0, #2
   1a480:	5889      	ldr	r1, [r1, r2]
   1a482:	220f      	movs	r2, #15
   1a484:	4bb8      	ldr	r3, [pc, #736]	; (1a768 <.text_57>)
   1a486:	54ca      	strb	r2, [r1, r3]
   1a488:	6889      	ldr	r1, [r1, #8]
   1a48a:	6a89      	ldr	r1, [r1, #40]	; 0x28
   1a48c:	4788      	blx	r1
   1a48e:	2000      	movs	r0, #0
   1a490:	bd02      	pop	{r1, pc}
	...

0001a494 <.text_51>:
   1a494:	00000704 	.word	0x00000704

0001a498 <USBPD_PE_Request_CableReset>:
   1a498:	b580      	push	{r7, lr}
   1a49a:	4987      	ldr	r1, [pc, #540]	; (1a6b8 <.text_54>)
   1a49c:	0082      	lsls	r2, r0, #2
   1a49e:	5889      	ldr	r1, [r1, r2]
   1a4a0:	684a      	ldr	r2, [r1, #4]
   1a4a2:	6812      	ldr	r2, [r2, #0]
   1a4a4:	4b85      	ldr	r3, [pc, #532]	; (1a6bc <.text_55>)
   1a4a6:	4013      	ands	r3, r2
   1a4a8:	4ab0      	ldr	r2, [pc, #704]	; (1a76c <.text_58>)
   1a4aa:	4293      	cmp	r3, r2
   1a4ac:	d105      	bne.n	1a4ba <USBPD_PE_Request_CableReset+0x22>
   1a4ae:	2299      	movs	r2, #153	; 0x99
   1a4b0:	4bad      	ldr	r3, [pc, #692]	; (1a768 <.text_57>)
   1a4b2:	54ca      	strb	r2, [r1, r3]
   1a4b4:	6889      	ldr	r1, [r1, #8]
   1a4b6:	6a89      	ldr	r1, [r1, #40]	; 0x28
   1a4b8:	4788      	blx	r1
   1a4ba:	2010      	movs	r0, #16
   1a4bc:	bd02      	pop	{r1, pc}
	...

0001a4c0 <USBPD_PE_Request_CtrlMessage>:
   1a4c0:	b5f1      	push	{r0, r4, r5, r6, r7, lr}
   1a4c2:	b082      	sub	sp, #8
   1a4c4:	487c      	ldr	r0, [pc, #496]	; (1a6b8 <.text_54>)
   1a4c6:	466b      	mov	r3, sp
   1a4c8:	7a1b      	ldrb	r3, [r3, #8]
   1a4ca:	009b      	lsls	r3, r3, #2
   1a4cc:	58c0      	ldr	r0, [r0, r3]
   1a4ce:	9001      	str	r0, [sp, #4]
   1a4d0:	2402      	movs	r4, #2
   1a4d2:	4ba5      	ldr	r3, [pc, #660]	; (1a768 <.text_57>)
   1a4d4:	18c0      	adds	r0, r0, r3
   1a4d6:	7803      	ldrb	r3, [r0, #0]
   1a4d8:	2b00      	cmp	r3, #0
   1a4da:	d105      	bne.n	1a4e8 <USBPD_PE_Request_CtrlMessage+0x28>
   1a4dc:	9b01      	ldr	r3, [sp, #4]
   1a4de:	685b      	ldr	r3, [r3, #4]
   1a4e0:	681b      	ldr	r3, [r3, #0]
   1a4e2:	04dd      	lsls	r5, r3, #19
   1a4e4:	0fed      	lsrs	r5, r5, #31
   1a4e6:	d101      	bne.n	1a4ec <USBPD_PE_Request_CtrlMessage+0x2c>
   1a4e8:	2003      	movs	r0, #3
   1a4ea:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   1a4ec:	466d      	mov	r5, sp
   1a4ee:	702a      	strb	r2, [r5, #0]
   1a4f0:	9a01      	ldr	r2, [sp, #4]
   1a4f2:	25ad      	movs	r5, #173	; 0xad
   1a4f4:	00ad      	lsls	r5, r5, #2
   1a4f6:	1955      	adds	r5, r2, r5
   1a4f8:	262e      	movs	r6, #46	; 0x2e
   1a4fa:	2200      	movs	r2, #0
   1a4fc:	1e89      	subs	r1, r1, #2
   1a4fe:	2914      	cmp	r1, #20
   1a500:	d900      	bls.n	1a504 <USBPD_PE_Request_CtrlMessage+0x44>
   1a502:	e0d6      	b.n	1a6b2 <USBPD_PE_Request_CtrlMessage+0x1f2>
   1a504:	a701      	add	r7, pc, #4	; (adr r7, 1a50c <USBPD_PE_Request_CtrlMessage+0x4c>)
   1a506:	5c7f      	ldrb	r7, [r7, r1]
   1a508:	007f      	lsls	r7, r7, #1
   1a50a:	44bf      	add	pc, r7
   1a50c:	c1d2d20a 	.word	0xc1d2d20a
   1a510:	322b1ad2 	.word	0x322b1ad2
   1a514:	54d24a39 	.word	0x54d24a39
   1a518:	59d2d2d2 	.word	0x59d2d2d2
   1a51c:	ad9d8e82 	.word	0xad9d8e82
   1a520:	006f      	.short	0x006f
   1a522:	0759      	lsls	r1, r3, #29
   1a524:	0fc9      	lsrs	r1, r1, #31
   1a526:	d00a      	beq.n	1a53e <USBPD_PE_Request_CtrlMessage+0x7e>
   1a528:	806c      	strh	r4, [r5, #2]
   1a52a:	7042      	strb	r2, [r0, #1]
   1a52c:	2196      	movs	r1, #150	; 0x96
   1a52e:	7001      	strb	r1, [r0, #0]
   1a530:	2400      	movs	r4, #0
   1a532:	4668      	mov	r0, sp
   1a534:	7a00      	ldrb	r0, [r0, #8]
   1a536:	9901      	ldr	r1, [sp, #4]
   1a538:	6889      	ldr	r1, [r1, #8]
   1a53a:	6a89      	ldr	r1, [r1, #40]	; 0x28
   1a53c:	4788      	blx	r1
   1a53e:	0020      	movs	r0, r4
   1a540:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   1a542:	0559      	lsls	r1, r3, #21
   1a544:	0f49      	lsrs	r1, r1, #29
   1a546:	2903      	cmp	r1, #3
   1a548:	d1f9      	bne.n	1a53e <USBPD_PE_Request_CtrlMessage+0x7e>
   1a54a:	2101      	movs	r1, #1
   1a54c:	9d01      	ldr	r5, [sp, #4]
   1a54e:	682d      	ldr	r5, [r5, #0]
   1a550:	686d      	ldr	r5, [r5, #4]
   1a552:	08ed      	lsrs	r5, r5, #3
   1a554:	400d      	ands	r5, r1
   1a556:	d102      	bne.n	1a55e <USBPD_PE_Request_CtrlMessage+0x9e>
   1a558:	089b      	lsrs	r3, r3, #2
   1a55a:	4019      	ands	r1, r3
   1a55c:	d1ef      	bne.n	1a53e <USBPD_PE_Request_CtrlMessage+0x7e>
   1a55e:	7042      	strb	r2, [r0, #1]
   1a560:	211a      	movs	r1, #26
   1a562:	e7e4      	b.n	1a52e <USBPD_PE_Request_CtrlMessage+0x6e>
   1a564:	0559      	lsls	r1, r3, #21
   1a566:	0f49      	lsrs	r1, r1, #29
   1a568:	2903      	cmp	r1, #3
   1a56a:	d1e8      	bne.n	1a53e <USBPD_PE_Request_CtrlMessage+0x7e>
   1a56c:	7042      	strb	r2, [r0, #1]
   1a56e:	2118      	movs	r1, #24
   1a570:	e7dd      	b.n	1a52e <USBPD_PE_Request_CtrlMessage+0x6e>
   1a572:	0559      	lsls	r1, r3, #21
   1a574:	0f49      	lsrs	r1, r1, #29
   1a576:	2903      	cmp	r1, #3
   1a578:	d1e1      	bne.n	1a53e <USBPD_PE_Request_CtrlMessage+0x7e>
   1a57a:	7042      	strb	r2, [r0, #1]
   1a57c:	2194      	movs	r1, #148	; 0x94
   1a57e:	e7d6      	b.n	1a52e <USBPD_PE_Request_CtrlMessage+0x6e>
   1a580:	0559      	lsls	r1, r3, #21
   1a582:	0f49      	lsrs	r1, r1, #29
   1a584:	2903      	cmp	r1, #3
   1a586:	d1da      	bne.n	1a53e <USBPD_PE_Request_CtrlMessage+0x7e>
   1a588:	9901      	ldr	r1, [sp, #4]
   1a58a:	6809      	ldr	r1, [r1, #0]
   1a58c:	6849      	ldr	r1, [r1, #4]
   1a58e:	070b      	lsls	r3, r1, #28
   1a590:	0fdb      	lsrs	r3, r3, #31
   1a592:	d0d4      	beq.n	1a53e <USBPD_PE_Request_CtrlMessage+0x7e>
   1a594:	210a      	movs	r1, #10
   1a596:	7029      	strb	r1, [r5, #0]
   1a598:	2108      	movs	r1, #8
   1a59a:	8069      	strh	r1, [r5, #2]
   1a59c:	7042      	strb	r2, [r0, #1]
   1a59e:	211e      	movs	r1, #30
   1a5a0:	e7c5      	b.n	1a52e <USBPD_PE_Request_CtrlMessage+0x6e>
   1a5a2:	9901      	ldr	r1, [sp, #4]
   1a5a4:	6889      	ldr	r1, [r1, #8]
   1a5a6:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
   1a5a8:	2900      	cmp	r1, #0
   1a5aa:	d0c8      	beq.n	1a53e <USBPD_PE_Request_CtrlMessage+0x7e>
   1a5ac:	2110      	movs	r1, #16
   1a5ae:	8069      	strh	r1, [r5, #2]
   1a5b0:	7042      	strb	r2, [r0, #1]
   1a5b2:	21a2      	movs	r1, #162	; 0xa2
   1a5b4:	e7bb      	b.n	1a52e <USBPD_PE_Request_CtrlMessage+0x6e>
   1a5b6:	4669      	mov	r1, sp
   1a5b8:	7809      	ldrb	r1, [r1, #0]
   1a5ba:	7041      	strb	r1, [r0, #1]
   1a5bc:	2111      	movs	r1, #17
   1a5be:	e7b6      	b.n	1a52e <USBPD_PE_Request_CtrlMessage+0x6e>
   1a5c0:	497e      	ldr	r1, [pc, #504]	; (1a7bc <.text_60>)
   1a5c2:	4019      	ands	r1, r3
   1a5c4:	4fb5      	ldr	r7, [pc, #724]	; (1a89c <.text_62>)
   1a5c6:	42b9      	cmp	r1, r7
   1a5c8:	d1b9      	bne.n	1a53e <USBPD_PE_Request_CtrlMessage+0x7e>
   1a5ca:	2101      	movs	r1, #1
   1a5cc:	9f01      	ldr	r7, [sp, #4]
   1a5ce:	683f      	ldr	r7, [r7, #0]
   1a5d0:	687f      	ldr	r7, [r7, #4]
   1a5d2:	08ff      	lsrs	r7, r7, #3
   1a5d4:	400f      	ands	r7, r1
   1a5d6:	d102      	bne.n	1a5de <USBPD_PE_Request_CtrlMessage+0x11e>
   1a5d8:	089b      	lsrs	r3, r3, #2
   1a5da:	4019      	ands	r1, r3
   1a5dc:	d1af      	bne.n	1a53e <USBPD_PE_Request_CtrlMessage+0x7e>
   1a5de:	2111      	movs	r1, #17
   1a5e0:	7029      	strb	r1, [r5, #0]
   1a5e2:	210a      	movs	r1, #10
   1a5e4:	8069      	strh	r1, [r5, #2]
   1a5e6:	7042      	strb	r2, [r0, #1]
   1a5e8:	7006      	strb	r6, [r0, #0]
   1a5ea:	e7a1      	b.n	1a530 <USBPD_PE_Request_CtrlMessage+0x70>
   1a5ec:	4973      	ldr	r1, [pc, #460]	; (1a7bc <.text_60>)
   1a5ee:	4019      	ands	r1, r3
   1a5f0:	4faa      	ldr	r7, [pc, #680]	; (1a89c <.text_62>)
   1a5f2:	42b9      	cmp	r1, r7
   1a5f4:	d1a3      	bne.n	1a53e <USBPD_PE_Request_CtrlMessage+0x7e>
   1a5f6:	2101      	movs	r1, #1
   1a5f8:	9f01      	ldr	r7, [sp, #4]
   1a5fa:	683f      	ldr	r7, [r7, #0]
   1a5fc:	687f      	ldr	r7, [r7, #4]
   1a5fe:	08ff      	lsrs	r7, r7, #3
   1a600:	400f      	ands	r7, r1
   1a602:	d102      	bne.n	1a60a <USBPD_PE_Request_CtrlMessage+0x14a>
   1a604:	089b      	lsrs	r3, r3, #2
   1a606:	4019      	ands	r1, r3
   1a608:	d099      	beq.n	1a53e <USBPD_PE_Request_CtrlMessage+0x7e>
   1a60a:	2116      	movs	r1, #22
   1a60c:	7029      	strb	r1, [r5, #0]
   1a60e:	31f9      	adds	r1, #249	; 0xf9
   1a610:	e7e8      	b.n	1a5e4 <USBPD_PE_Request_CtrlMessage+0x124>
   1a612:	496a      	ldr	r1, [pc, #424]	; (1a7bc <.text_60>)
   1a614:	4019      	ands	r1, r3
   1a616:	4ba1      	ldr	r3, [pc, #644]	; (1a89c <.text_62>)
   1a618:	4299      	cmp	r1, r3
   1a61a:	d190      	bne.n	1a53e <USBPD_PE_Request_CtrlMessage+0x7e>
   1a61c:	7006      	strb	r6, [r0, #0]
   1a61e:	2112      	movs	r1, #18
   1a620:	7029      	strb	r1, [r5, #0]
   1a622:	210b      	movs	r1, #11
   1a624:	8069      	strh	r1, [r5, #2]
   1a626:	7042      	strb	r2, [r0, #1]
   1a628:	e782      	b.n	1a530 <USBPD_PE_Request_CtrlMessage+0x70>
   1a62a:	499d      	ldr	r1, [pc, #628]	; (1a8a0 <.text_63>)
   1a62c:	4019      	ands	r1, r3
   1a62e:	4b9b      	ldr	r3, [pc, #620]	; (1a89c <.text_62>)
   1a630:	4299      	cmp	r1, r3
   1a632:	d184      	bne.n	1a53e <USBPD_PE_Request_CtrlMessage+0x7e>
   1a634:	9901      	ldr	r1, [sp, #4]
   1a636:	6809      	ldr	r1, [r1, #0]
   1a638:	8909      	ldrh	r1, [r1, #8]
   1a63a:	0849      	lsrs	r1, r1, #1
   1a63c:	07c9      	lsls	r1, r1, #31
   1a63e:	d539      	bpl.n	1a6b4 <USBPD_PE_Request_CtrlMessage+0x1f4>
   1a640:	2113      	movs	r1, #19
   1a642:	7029      	strb	r1, [r5, #0]
   1a644:	2109      	movs	r1, #9
   1a646:	e7a8      	b.n	1a59a <USBPD_PE_Request_CtrlMessage+0xda>
   1a648:	4995      	ldr	r1, [pc, #596]	; (1a8a0 <.text_63>)
   1a64a:	4019      	ands	r1, r3
   1a64c:	4b93      	ldr	r3, [pc, #588]	; (1a89c <.text_62>)
   1a64e:	4299      	cmp	r1, r3
   1a650:	d1ef      	bne.n	1a632 <USBPD_PE_Request_CtrlMessage+0x172>
   1a652:	9901      	ldr	r1, [sp, #4]
   1a654:	6809      	ldr	r1, [r1, #0]
   1a656:	8909      	ldrh	r1, [r1, #8]
   1a658:	0889      	lsrs	r1, r1, #2
   1a65a:	07c9      	lsls	r1, r1, #31
   1a65c:	d52a      	bpl.n	1a6b4 <USBPD_PE_Request_CtrlMessage+0x1f4>
   1a65e:	210b      	movs	r1, #11
   1a660:	8069      	strh	r1, [r5, #2]
   1a662:	7042      	strb	r2, [r0, #1]
   1a664:	2165      	movs	r1, #101	; 0x65
   1a666:	e762      	b.n	1a52e <USBPD_PE_Request_CtrlMessage+0x6e>
   1a668:	4954      	ldr	r1, [pc, #336]	; (1a7bc <.text_60>)
   1a66a:	4019      	ands	r1, r3
   1a66c:	4b8b      	ldr	r3, [pc, #556]	; (1a89c <.text_62>)
   1a66e:	4299      	cmp	r1, r3
   1a670:	d1df      	bne.n	1a632 <USBPD_PE_Request_CtrlMessage+0x172>
   1a672:	9901      	ldr	r1, [sp, #4]
   1a674:	6809      	ldr	r1, [r1, #0]
   1a676:	8909      	ldrh	r1, [r1, #8]
   1a678:	09c9      	lsrs	r1, r1, #7
   1a67a:	07c9      	lsls	r1, r1, #31
   1a67c:	d51a      	bpl.n	1a6b4 <USBPD_PE_Request_CtrlMessage+0x1f4>
   1a67e:	4669      	mov	r1, sp
   1a680:	7809      	ldrb	r1, [r1, #0]
   1a682:	7041      	strb	r1, [r0, #1]
   1a684:	21ff      	movs	r1, #255	; 0xff
   1a686:	310e      	adds	r1, #14
   1a688:	8069      	strh	r1, [r5, #2]
   1a68a:	2115      	movs	r1, #21
   1a68c:	7029      	strb	r1, [r5, #0]
   1a68e:	e7ab      	b.n	1a5e8 <USBPD_PE_Request_CtrlMessage+0x128>
   1a690:	0559      	lsls	r1, r3, #21
   1a692:	0f49      	lsrs	r1, r1, #29
   1a694:	2903      	cmp	r1, #3
   1a696:	d10d      	bne.n	1a6b4 <USBPD_PE_Request_CtrlMessage+0x1f4>
   1a698:	9901      	ldr	r1, [sp, #4]
   1a69a:	6809      	ldr	r1, [r1, #0]
   1a69c:	6849      	ldr	r1, [r1, #4]
   1a69e:	064b      	lsls	r3, r1, #25
   1a6a0:	0fdb      	lsrs	r3, r3, #31
   1a6a2:	d007      	beq.n	1a6b4 <USBPD_PE_Request_CtrlMessage+0x1f4>
   1a6a4:	4669      	mov	r1, sp
   1a6a6:	7809      	ldrb	r1, [r1, #0]
   1a6a8:	7041      	strb	r1, [r0, #1]
   1a6aa:	806a      	strh	r2, [r5, #2]
   1a6ac:	2105      	movs	r1, #5
   1a6ae:	7029      	strb	r1, [r5, #0]
   1a6b0:	e79a      	b.n	1a5e8 <USBPD_PE_Request_CtrlMessage+0x128>
   1a6b2:	2410      	movs	r4, #16
   1a6b4:	e743      	b.n	1a53e <USBPD_PE_Request_CtrlMessage+0x7e>
	...

0001a6b8 <.text_54>:
   1a6b8:	0002ff54 	.word	0x0002ff54

0001a6bc <.text_55>:
   1a6bc:	00008708 	.word	0x00008708

0001a6c0 <USBPD_PE_Request_DataMessage>:
   1a6c0:	b5f1      	push	{r0, r4, r5, r6, r7, lr}
   1a6c2:	b084      	sub	sp, #16
   1a6c4:	48aa      	ldr	r0, [pc, #680]	; (1a970 <.text_66>)
   1a6c6:	466b      	mov	r3, sp
   1a6c8:	7c1b      	ldrb	r3, [r3, #16]
   1a6ca:	009b      	lsls	r3, r3, #2
   1a6cc:	58c0      	ldr	r0, [r0, r3]
   1a6ce:	9001      	str	r0, [sp, #4]
   1a6d0:	2402      	movs	r4, #2
   1a6d2:	4b25      	ldr	r3, [pc, #148]	; (1a768 <.text_57>)
   1a6d4:	18c0      	adds	r0, r0, r3
   1a6d6:	7803      	ldrb	r3, [r0, #0]
   1a6d8:	2b00      	cmp	r3, #0
   1a6da:	d106      	bne.n	1a6ea <USBPD_PE_Request_DataMessage+0x2a>
   1a6dc:	9b01      	ldr	r3, [sp, #4]
   1a6de:	685b      	ldr	r3, [r3, #4]
   1a6e0:	681b      	ldr	r3, [r3, #0]
   1a6e2:	2501      	movs	r5, #1
   1a6e4:	0b1e      	lsrs	r6, r3, #12
   1a6e6:	402e      	ands	r6, r5
   1a6e8:	d101      	bne.n	1a6ee <USBPD_PE_Request_DataMessage+0x2e>
   1a6ea:	2003      	movs	r0, #3
   1a6ec:	e020      	b.n	1a730 <USBPD_PE_Request_DataMessage+0x70>
   1a6ee:	9202      	str	r2, [sp, #8]
   1a6f0:	466a      	mov	r2, sp
   1a6f2:	7011      	strb	r1, [r2, #0]
   1a6f4:	9901      	ldr	r1, [sp, #4]
   1a6f6:	22aa      	movs	r2, #170	; 0xaa
   1a6f8:	0092      	lsls	r2, r2, #2
   1a6fa:	1889      	adds	r1, r1, r2
   1a6fc:	4a2f      	ldr	r2, [pc, #188]	; (1a7bc <.text_60>)
   1a6fe:	2600      	movs	r6, #0
   1a700:	466f      	mov	r7, sp
   1a702:	783f      	ldrb	r7, [r7, #0]
   1a704:	2f01      	cmp	r7, #1
   1a706:	d004      	beq.n	1a712 <USBPD_PE_Request_DataMessage+0x52>
   1a708:	2f06      	cmp	r7, #6
   1a70a:	d013      	beq.n	1a734 <USBPD_PE_Request_DataMessage+0x74>
   1a70c:	2f07      	cmp	r7, #7
   1a70e:	d01b      	beq.n	1a748 <USBPD_PE_Request_DataMessage+0x88>
   1a710:	e027      	b.n	1a762 <USBPD_PE_Request_DataMessage+0xa2>
   1a712:	089a      	lsrs	r2, r3, #2
   1a714:	402a      	ands	r2, r5
   1a716:	d00a      	beq.n	1a72e <USBPD_PE_Request_DataMessage+0x6e>
   1a718:	81cd      	strh	r5, [r1, #14]
   1a71a:	7046      	strb	r6, [r0, #1]
   1a71c:	2107      	movs	r1, #7
   1a71e:	7001      	strb	r1, [r0, #0]
   1a720:	2400      	movs	r4, #0
   1a722:	4668      	mov	r0, sp
   1a724:	7c00      	ldrb	r0, [r0, #16]
   1a726:	9901      	ldr	r1, [sp, #4]
   1a728:	6889      	ldr	r1, [r1, #8]
   1a72a:	6a89      	ldr	r1, [r1, #40]	; 0x28
   1a72c:	4788      	blx	r1
   1a72e:	0020      	movs	r0, r4
   1a730:	b005      	add	sp, #20
   1a732:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1a734:	401a      	ands	r2, r3
   1a736:	4b59      	ldr	r3, [pc, #356]	; (1a89c <.text_62>)
   1a738:	429a      	cmp	r2, r3
   1a73a:	d1f8      	bne.n	1a72e <USBPD_PE_Request_DataMessage+0x6e>
   1a73c:	7046      	strb	r6, [r0, #1]
   1a73e:	9a02      	ldr	r2, [sp, #8]
   1a740:	6812      	ldr	r2, [r2, #0]
   1a742:	600a      	str	r2, [r1, #0]
   1a744:	212b      	movs	r1, #43	; 0x2b
   1a746:	e7ea      	b.n	1a71e <USBPD_PE_Request_DataMessage+0x5e>
   1a748:	401a      	ands	r2, r3
   1a74a:	4b54      	ldr	r3, [pc, #336]	; (1a89c <.text_62>)
   1a74c:	429a      	cmp	r2, r3
   1a74e:	d1ee      	bne.n	1a72e <USBPD_PE_Request_DataMessage+0x6e>
   1a750:	9a02      	ldr	r2, [sp, #8]
   1a752:	6812      	ldr	r2, [r2, #0]
   1a754:	600a      	str	r2, [r1, #0]
   1a756:	22ff      	movs	r2, #255	; 0xff
   1a758:	320e      	adds	r2, #14
   1a75a:	81ca      	strh	r2, [r1, #14]
   1a75c:	7046      	strb	r6, [r0, #1]
   1a75e:	2162      	movs	r1, #98	; 0x62
   1a760:	e7dd      	b.n	1a71e <USBPD_PE_Request_DataMessage+0x5e>
   1a762:	2410      	movs	r4, #16
   1a764:	e7e3      	b.n	1a72e <USBPD_PE_Request_DataMessage+0x6e>
	...

0001a768 <.text_57>:
   1a768:	0000028d 	.word	0x0000028d

0001a76c <.text_58>:
   1a76c:	00008308 	.word	0x00008308

0001a770 <USBPD_PE_Send_Request>:
   1a770:	b570      	push	{r4, r5, r6, lr}
   1a772:	4b7f      	ldr	r3, [pc, #508]	; (1a970 <.text_66>)
   1a774:	0084      	lsls	r4, r0, #2
   1a776:	591b      	ldr	r3, [r3, r4]
   1a778:	4cc5      	ldr	r4, [pc, #788]	; (1aa90 <.text_70>)
   1a77a:	191c      	adds	r4, r3, r4
   1a77c:	7825      	ldrb	r5, [r4, #0]
   1a77e:	2d00      	cmp	r5, #0
   1a780:	d104      	bne.n	1a78c <USBPD_PE_Send_Request+0x1c>
   1a782:	685d      	ldr	r5, [r3, #4]
   1a784:	682d      	ldr	r5, [r5, #0]
   1a786:	04ee      	lsls	r6, r5, #19
   1a788:	0ff6      	lsrs	r6, r6, #31
   1a78a:	d101      	bne.n	1a790 <USBPD_PE_Send_Request+0x20>
   1a78c:	2003      	movs	r0, #3
   1a78e:	bd70      	pop	{r4, r5, r6, pc}
   1a790:	4ec0      	ldr	r6, [pc, #768]	; (1aa94 <.text_71>)
   1a792:	402e      	ands	r6, r5
   1a794:	25c0      	movs	r5, #192	; 0xc0
   1a796:	00ad      	lsls	r5, r5, #2
   1a798:	42ae      	cmp	r6, r5
   1a79a:	d10d      	bne.n	1a7b8 <USBPD_PE_Send_Request+0x48>
   1a79c:	2545      	movs	r5, #69	; 0x45
   1a79e:	7025      	strb	r5, [r4, #0]
   1a7a0:	6159      	str	r1, [r3, #20]
   1a7a2:	6919      	ldr	r1, [r3, #16]
   1a7a4:	250c      	movs	r5, #12
   1a7a6:	43a9      	bics	r1, r5
   1a7a8:	0092      	lsls	r2, r2, #2
   1a7aa:	4015      	ands	r5, r2
   1a7ac:	430d      	orrs	r5, r1
   1a7ae:	611d      	str	r5, [r3, #16]
   1a7b0:	2100      	movs	r1, #0
   1a7b2:	7061      	strb	r1, [r4, #1]
   1a7b4:	6899      	ldr	r1, [r3, #8]
   1a7b6:	e65c      	b.n	1a472 <.text_49+0x2>
   1a7b8:	2002      	movs	r0, #2
   1a7ba:	bd70      	pop	{r4, r5, r6, pc}

0001a7bc <.text_60>:
   1a7bc:	00000703 	.word	0x00000703

0001a7c0 <USBPD_PE_SendExtendedMessage>:
   1a7c0:	b5f3      	push	{r0, r1, r4, r5, r6, r7, lr}
   1a7c2:	b081      	sub	sp, #4
   1a7c4:	486a      	ldr	r0, [pc, #424]	; (1a970 <.text_66>)
   1a7c6:	4669      	mov	r1, sp
   1a7c8:	7909      	ldrb	r1, [r1, #4]
   1a7ca:	0089      	lsls	r1, r1, #2
   1a7cc:	5841      	ldr	r1, [r0, r1]
   1a7ce:	48b0      	ldr	r0, [pc, #704]	; (1aa90 <.text_70>)
   1a7d0:	5c08      	ldrb	r0, [r1, r0]
   1a7d2:	2800      	cmp	r0, #0
   1a7d4:	d104      	bne.n	1a7e0 <USBPD_PE_SendExtendedMessage+0x20>
   1a7d6:	6848      	ldr	r0, [r1, #4]
   1a7d8:	6800      	ldr	r0, [r0, #0]
   1a7da:	04c4      	lsls	r4, r0, #19
   1a7dc:	0fe4      	lsrs	r4, r4, #31
   1a7de:	d101      	bne.n	1a7e4 <USBPD_PE_SendExtendedMessage+0x24>
   1a7e0:	2003      	movs	r0, #3
   1a7e2:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   1a7e4:	0544      	lsls	r4, r0, #21
   1a7e6:	0f64      	lsrs	r4, r4, #29
   1a7e8:	2c03      	cmp	r4, #3
   1a7ea:	d10a      	bne.n	1a802 <USBPD_PE_SendExtendedMessage+0x42>
   1a7ec:	0780      	lsls	r0, r0, #30
   1a7ee:	0f80      	lsrs	r0, r0, #30
   1a7f0:	2801      	cmp	r0, #1
   1a7f2:	d801      	bhi.n	1a7f8 <USBPD_PE_SendExtendedMessage+0x38>
   1a7f4:	2001      	movs	r0, #1
   1a7f6:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   1a7f8:	9808      	ldr	r0, [sp, #32]
   1a7fa:	25ff      	movs	r5, #255	; 0xff
   1a7fc:	1dad      	adds	r5, r5, #6
   1a7fe:	42a8      	cmp	r0, r5
   1a800:	d301      	bcc.n	1a806 <USBPD_PE_SendExtendedMessage+0x46>
   1a802:	2002      	movs	r0, #2
   1a804:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   1a806:	466d      	mov	r5, sp
   1a808:	702a      	strb	r2, [r5, #0]
   1a80a:	690a      	ldr	r2, [r1, #16]
   1a80c:	2510      	movs	r5, #16
   1a80e:	43aa      	bics	r2, r5
   1a810:	610a      	str	r2, [r1, #16]
   1a812:	4aa1      	ldr	r2, [pc, #644]	; (1aa98 <.text_72>)
   1a814:	188a      	adds	r2, r1, r2
   1a816:	466e      	mov	r6, sp
   1a818:	7836      	ldrb	r6, [r6, #0]
   1a81a:	1ef6      	subs	r6, r6, #3
   1a81c:	2e08      	cmp	r6, #8
   1a81e:	d825      	bhi.n	1a86c <USBPD_PE_SendExtendedMessage+0xac>
   1a820:	a701      	add	r7, pc, #4	; (adr r7, 1a828 <USBPD_PE_SendExtendedMessage+0x68>)
   1a822:	5dbf      	ldrb	r7, [r7, r6]
   1a824:	44bf      	add	pc, r7
   1a826:	bf00      	nop
   1a828:	3644320a 	.word	0x3644320a
   1a82c:	40143a44 	.word	0x40143a44
   1a830:	0014      	.short	0x0014
   1a832:	260c      	movs	r6, #12
   1a834:	8016      	strh	r6, [r2, #0]
   1a836:	690a      	ldr	r2, [r1, #16]
   1a838:	4315      	orrs	r5, r2
   1a83a:	610d      	str	r5, [r1, #16]
   1a83c:	2200      	movs	r2, #0
   1a83e:	0005      	movs	r5, r0
   1a840:	d016      	beq.n	1a870 <USBPD_PE_SendExtendedMessage+0xb0>
   1a842:	5c9d      	ldrb	r5, [r3, r2]
   1a844:	188e      	adds	r6, r1, r2
   1a846:	27af      	movs	r7, #175	; 0xaf
   1a848:	007f      	lsls	r7, r7, #1
   1a84a:	55f5      	strb	r5, [r6, r7]
   1a84c:	1c52      	adds	r2, r2, #1
   1a84e:	4282      	cmp	r2, r0
   1a850:	d3f7      	bcc.n	1a842 <USBPD_PE_SendExtendedMessage+0x82>
   1a852:	2299      	movs	r2, #153	; 0x99
   1a854:	0092      	lsls	r2, r2, #2
   1a856:	5288      	strh	r0, [r1, r2]
   1a858:	e00d      	b.n	1a876 <USBPD_PE_SendExtendedMessage+0xb6>
   1a85a:	260d      	movs	r6, #13
   1a85c:	e7ea      	b.n	1a834 <USBPD_PE_SendExtendedMessage+0x74>
   1a85e:	260e      	movs	r6, #14
   1a860:	e7e8      	b.n	1a834 <USBPD_PE_SendExtendedMessage+0x74>
   1a862:	35fb      	adds	r5, #251	; 0xfb
   1a864:	8015      	strh	r5, [r2, #0]
   1a866:	e7e9      	b.n	1a83c <USBPD_PE_SendExtendedMessage+0x7c>
   1a868:	35fc      	adds	r5, #252	; 0xfc
   1a86a:	e7fb      	b.n	1a864 <USBPD_PE_SendExtendedMessage+0xa4>
   1a86c:	2010      	movs	r0, #16
   1a86e:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   1a870:	2099      	movs	r0, #153	; 0x99
   1a872:	0080      	lsls	r0, r0, #2
   1a874:	520a      	strh	r2, [r1, r0]
   1a876:	4668      	mov	r0, sp
   1a878:	7a00      	ldrb	r0, [r0, #8]
   1a87a:	4a85      	ldr	r2, [pc, #532]	; (1aa90 <.text_70>)
   1a87c:	188a      	adds	r2, r1, r2
   1a87e:	7050      	strb	r0, [r2, #1]
   1a880:	4668      	mov	r0, sp
   1a882:	7800      	ldrb	r0, [r0, #0]
   1a884:	4b85      	ldr	r3, [pc, #532]	; (1aa9c <.text_73>)
   1a886:	54c8      	strb	r0, [r1, r3]
   1a888:	2031      	movs	r0, #49	; 0x31
   1a88a:	7010      	strb	r0, [r2, #0]
   1a88c:	4668      	mov	r0, sp
   1a88e:	7900      	ldrb	r0, [r0, #4]
   1a890:	6889      	ldr	r1, [r1, #8]
   1a892:	6a89      	ldr	r1, [r1, #40]	; 0x28
   1a894:	4788      	blx	r1
   1a896:	2000      	movs	r0, #0
   1a898:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	...

0001a89c <.text_62>:
   1a89c:	00000302 	.word	0x00000302

0001a8a0 <.text_63>:
   1a8a0:	00000707 	.word	0x00000707

0001a8a4 <PE_Send_SRCCapabilities>:
   1a8a4:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
   1a8a6:	0004      	movs	r4, r0
   1a8a8:	000d      	movs	r5, r1
   1a8aa:	2601      	movs	r6, #1
   1a8ac:	ab02      	add	r3, sp, #8
   1a8ae:	0022      	movs	r2, r4
   1a8b0:	3220      	adds	r2, #32
   1a8b2:	2100      	movs	r1, #0
   1a8b4:	6927      	ldr	r7, [r4, #16]
   1a8b6:	2001      	movs	r0, #1
   1a8b8:	4038      	ands	r0, r7
   1a8ba:	68a7      	ldr	r7, [r4, #8]
   1a8bc:	697f      	ldr	r7, [r7, #20]
   1a8be:	47b8      	blx	r7
   1a8c0:	9802      	ldr	r0, [sp, #8]
   1a8c2:	1c80      	adds	r0, r0, #2
   1a8c4:	9002      	str	r0, [sp, #8]
   1a8c6:	6860      	ldr	r0, [r4, #4]
   1a8c8:	6800      	ldr	r0, [r0, #0]
   1a8ca:	0b00      	lsrs	r0, r0, #12
   1a8cc:	4030      	ands	r0, r6
   1a8ce:	d00f      	beq.n	1a8f0 <PE_Send_SRCCapabilities+0x4c>
   1a8d0:	9501      	str	r5, [sp, #4]
   1a8d2:	9802      	ldr	r0, [sp, #8]
   1a8d4:	b280      	uxth	r0, r0
   1a8d6:	9000      	str	r0, [sp, #0]
   1a8d8:	0023      	movs	r3, r4
   1a8da:	331e      	adds	r3, #30
   1a8dc:	2201      	movs	r2, #1
   1a8de:	2100      	movs	r1, #0
   1a8e0:	6927      	ldr	r7, [r4, #16]
   1a8e2:	2001      	movs	r0, #1
   1a8e4:	4038      	ands	r0, r7
   1a8e6:	f002 fde3 	bl	1d4b0 <USBPD_PRL_SendMessage>
   1a8ea:	2803      	cmp	r0, #3
   1a8ec:	d0eb      	beq.n	1a8c6 <PE_Send_SRCCapabilities+0x22>
   1a8ee:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   1a8f0:	2010      	movs	r0, #16
   1a8f2:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

0001a8f4 <PE_Send_CtrlMessage>:
   1a8f4:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
   1a8f6:	9b08      	ldr	r3, [sp, #32]
   1a8f8:	24a4      	movs	r4, #164	; 0xa4
   1a8fa:	00a4      	lsls	r4, r4, #2
   1a8fc:	1904      	adds	r4, r0, r4
   1a8fe:	6967      	ldr	r7, [r4, #20]
   1a900:	0004      	movs	r4, r0
   1a902:	000e      	movs	r6, r1
   1a904:	0015      	movs	r5, r2
   1a906:	a808      	add	r0, sp, #32
   1a908:	7003      	strb	r3, [r0, #0]
   1a90a:	2001      	movs	r0, #1
   1a90c:	6861      	ldr	r1, [r4, #4]
   1a90e:	6809      	ldr	r1, [r1, #0]
   1a910:	0b09      	lsrs	r1, r1, #12
   1a912:	4001      	ands	r1, r0
   1a914:	d01a      	beq.n	1a94c <PE_Send_CtrlMessage+0x58>
   1a916:	21a4      	movs	r1, #164	; 0xa4
   1a918:	0089      	lsls	r1, r1, #2
   1a91a:	1861      	adds	r1, r4, r1
   1a91c:	6949      	ldr	r1, [r1, #20]
   1a91e:	1bc9      	subs	r1, r1, r7
   1a920:	4a5f      	ldr	r2, [pc, #380]	; (1aaa0 <.text_74>)
   1a922:	4291      	cmp	r1, r2
   1a924:	d218      	bcs.n	1a958 <PE_Send_CtrlMessage+0x64>
   1a926:	a908      	add	r1, sp, #32
   1a928:	7809      	ldrb	r1, [r1, #0]
   1a92a:	9101      	str	r1, [sp, #4]
   1a92c:	2102      	movs	r1, #2
   1a92e:	9100      	str	r1, [sp, #0]
   1a930:	0023      	movs	r3, r4
   1a932:	331e      	adds	r3, #30
   1a934:	002a      	movs	r2, r5
   1a936:	6921      	ldr	r1, [r4, #16]
   1a938:	4008      	ands	r0, r1
   1a93a:	0031      	movs	r1, r6
   1a93c:	f002 fdb8 	bl	1d4b0 <USBPD_PRL_SendMessage>
   1a940:	2803      	cmp	r0, #3
   1a942:	d0e2      	beq.n	1a90a <PE_Send_CtrlMessage+0x16>
   1a944:	2d0d      	cmp	r5, #13
   1a946:	d109      	bne.n	1a95c <PE_Send_CtrlMessage+0x68>
   1a948:	2201      	movs	r2, #1
   1a94a:	e008      	b.n	1a95e <PE_Send_CtrlMessage+0x6a>
   1a94c:	2000      	movs	r0, #0
   1a94e:	21a4      	movs	r1, #164	; 0xa4
   1a950:	0089      	lsls	r1, r1, #2
   1a952:	5460      	strb	r0, [r4, r1]
   1a954:	2010      	movs	r0, #16
   1a956:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   1a958:	2007      	movs	r0, #7
   1a95a:	e7f3      	b.n	1a944 <PE_Send_CtrlMessage+0x50>
   1a95c:	2200      	movs	r2, #0
   1a95e:	4669      	mov	r1, sp
   1a960:	7a09      	ldrb	r1, [r1, #8]
   1a962:	9100      	str	r1, [sp, #0]
   1a964:	0003      	movs	r3, r0
   1a966:	0031      	movs	r1, r6
   1a968:	0020      	movs	r0, r4
   1a96a:	f001 fdcc 	bl	1c506 <PE_CheckSendMessageStatus>
   1a96e:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

0001a970 <.text_66>:
   1a970:	0002ff54 	.word	0x0002ff54

0001a974 <PE_Send_DataMessage>:
   1a974:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   1a976:	b082      	sub	sp, #8
   1a978:	0004      	movs	r4, r0
   1a97a:	2000      	movs	r0, #0
   1a97c:	2620      	movs	r6, #32
   1a97e:	e00c      	b.n	1a99a <PE_Send_DataMessage+0x26>
   1a980:	2100      	movs	r1, #0
   1a982:	0082      	lsls	r2, r0, #2
   1a984:	18a2      	adds	r2, r4, r2
   1a986:	1855      	adds	r5, r2, r1
   1a988:	681a      	ldr	r2, [r3, #0]
   1a98a:	00cf      	lsls	r7, r1, #3
   1a98c:	40fa      	lsrs	r2, r7
   1a98e:	55aa      	strb	r2, [r5, r6]
   1a990:	1c49      	adds	r1, r1, #1
   1a992:	2904      	cmp	r1, #4
   1a994:	d3f5      	bcc.n	1a982 <PE_Send_DataMessage+0xe>
   1a996:	1d1b      	adds	r3, r3, #4
   1a998:	1c40      	adds	r0, r0, #1
   1a99a:	990a      	ldr	r1, [sp, #40]	; 0x28
   1a99c:	4288      	cmp	r0, r1
   1a99e:	d3ef      	bcc.n	1a980 <PE_Send_DataMessage+0xc>
   1a9a0:	2001      	movs	r0, #1
   1a9a2:	6861      	ldr	r1, [r4, #4]
   1a9a4:	6809      	ldr	r1, [r1, #0]
   1a9a6:	0b09      	lsrs	r1, r1, #12
   1a9a8:	4001      	ands	r1, r0
   1a9aa:	d01d      	beq.n	1a9e8 <PE_Send_DataMessage+0x74>
   1a9ac:	a90c      	add	r1, sp, #48	; 0x30
   1a9ae:	7809      	ldrb	r1, [r1, #0]
   1a9b0:	9101      	str	r1, [sp, #4]
   1a9b2:	990a      	ldr	r1, [sp, #40]	; 0x28
   1a9b4:	0089      	lsls	r1, r1, #2
   1a9b6:	1c89      	adds	r1, r1, #2
   1a9b8:	b289      	uxth	r1, r1
   1a9ba:	9100      	str	r1, [sp, #0]
   1a9bc:	0023      	movs	r3, r4
   1a9be:	331e      	adds	r3, #30
   1a9c0:	4669      	mov	r1, sp
   1a9c2:	7c0a      	ldrb	r2, [r1, #16]
   1a9c4:	7b09      	ldrb	r1, [r1, #12]
   1a9c6:	6925      	ldr	r5, [r4, #16]
   1a9c8:	4028      	ands	r0, r5
   1a9ca:	f002 fd71 	bl	1d4b0 <USBPD_PRL_SendMessage>
   1a9ce:	2803      	cmp	r0, #3
   1a9d0:	d0e6      	beq.n	1a9a0 <PE_Send_DataMessage+0x2c>
   1a9d2:	4669      	mov	r1, sp
   1a9d4:	7b09      	ldrb	r1, [r1, #12]
   1a9d6:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   1a9d8:	9200      	str	r2, [sp, #0]
   1a9da:	0003      	movs	r3, r0
   1a9dc:	2200      	movs	r2, #0
   1a9de:	0020      	movs	r0, r4
   1a9e0:	f001 fd91 	bl	1c506 <PE_CheckSendMessageStatus>
   1a9e4:	b005      	add	sp, #20
   1a9e6:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1a9e8:	2010      	movs	r0, #16
   1a9ea:	e7fb      	b.n	1a9e4 <PE_Send_DataMessage+0x70>

0001a9ec <PE_PerformSoftReset>:
   1a9ec:	b580      	push	{r7, lr}
   1a9ee:	0002      	movs	r2, r0
   1a9f0:	2100      	movs	r1, #0
   1a9f2:	2001      	movs	r0, #1
   1a9f4:	6853      	ldr	r3, [r2, #4]
   1a9f6:	681b      	ldr	r3, [r3, #0]
   1a9f8:	089b      	lsrs	r3, r3, #2
   1a9fa:	4003      	ands	r3, r0
   1a9fc:	d002      	beq.n	1aa04 <PE_PerformSoftReset+0x18>
   1a9fe:	7651      	strb	r1, [r2, #25]
   1aa00:	2101      	movs	r1, #1
   1aa02:	e000      	b.n	1aa06 <PE_PerformSoftReset+0x1a>
   1aa04:	7611      	strb	r1, [r2, #24]
   1aa06:	6912      	ldr	r2, [r2, #16]
   1aa08:	4010      	ands	r0, r2
   1aa0a:	f002 fce6 	bl	1d3da <USBPD_PRL_SetHeaderPowerRole>
   1aa0e:	bd01      	pop	{r0, pc}

0001aa10 <PE_Send_RESET>:
   1aa10:	b5f2      	push	{r1, r4, r5, r6, r7, lr}
   1aa12:	b082      	sub	sp, #8
   1aa14:	0005      	movs	r5, r0
   1aa16:	20a9      	movs	r0, #169	; 0xa9
   1aa18:	0080      	lsls	r0, r0, #2
   1aa1a:	5828      	ldr	r0, [r5, r0]
   1aa1c:	9001      	str	r0, [sp, #4]
   1aa1e:	4668      	mov	r0, sp
   1aa20:	7a00      	ldrb	r0, [r0, #8]
   1aa22:	2805      	cmp	r0, #5
   1aa24:	d101      	bne.n	1aa2a <PE_Send_RESET+0x1a>
   1aa26:	241f      	movs	r4, #31
   1aa28:	e000      	b.n	1aa2c <PE_Send_RESET+0x1c>
   1aa2a:	245e      	movs	r4, #94	; 0x5e
   1aa2c:	2701      	movs	r7, #1
   1aa2e:	2000      	movs	r0, #0
   1aa30:	9000      	str	r0, [sp, #0]
   1aa32:	2300      	movs	r3, #0
   1aa34:	0022      	movs	r2, r4
   1aa36:	6928      	ldr	r0, [r5, #16]
   1aa38:	2101      	movs	r1, #1
   1aa3a:	4001      	ands	r1, r0
   1aa3c:	2009      	movs	r0, #9
   1aa3e:	4e19      	ldr	r6, [pc, #100]	; (1aaa4 <.text_75>)
   1aa40:	6a36      	ldr	r6, [r6, #32]
   1aa42:	47b0      	blx	r6
   1aa44:	0021      	movs	r1, r4
   1aa46:	692a      	ldr	r2, [r5, #16]
   1aa48:	2001      	movs	r0, #1
   1aa4a:	4010      	ands	r0, r2
   1aa4c:	68aa      	ldr	r2, [r5, #8]
   1aa4e:	68d2      	ldr	r2, [r2, #12]
   1aa50:	4790      	blx	r2
   1aa52:	6929      	ldr	r1, [r5, #16]
   1aa54:	2001      	movs	r0, #1
   1aa56:	4008      	ands	r0, r1
   1aa58:	f002 fe18 	bl	1d68c <USBPD_PRL_ResetRequestReset>
   1aa5c:	002c      	movs	r4, r5
   1aa5e:	4668      	mov	r0, sp
   1aa60:	7a06      	ldrb	r6, [r0, #8]
   1aa62:	9d01      	ldr	r5, [sp, #4]
   1aa64:	20a9      	movs	r0, #169	; 0xa9
   1aa66:	0080      	lsls	r0, r0, #2
   1aa68:	5820      	ldr	r0, [r4, r0]
   1aa6a:	1b40      	subs	r0, r0, r5
   1aa6c:	49be      	ldr	r1, [pc, #760]	; (1ad68 <.text_77>)
   1aa6e:	4288      	cmp	r0, r1
   1aa70:	d20c      	bcs.n	1aa8c <PE_Send_RESET+0x7c>
   1aa72:	6860      	ldr	r0, [r4, #4]
   1aa74:	6800      	ldr	r0, [r0, #0]
   1aa76:	0b00      	lsrs	r0, r0, #12
   1aa78:	4038      	ands	r0, r7
   1aa7a:	d007      	beq.n	1aa8c <PE_Send_RESET+0x7c>
   1aa7c:	0031      	movs	r1, r6
   1aa7e:	6922      	ldr	r2, [r4, #16]
   1aa80:	2001      	movs	r0, #1
   1aa82:	4010      	ands	r0, r2
   1aa84:	f002 fe0c 	bl	1d6a0 <USBPD_PRL_ResetRequestProcess>
   1aa88:	2803      	cmp	r0, #3
   1aa8a:	d0eb      	beq.n	1aa64 <PE_Send_RESET+0x54>
   1aa8c:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
	...

0001aa90 <.text_70>:
   1aa90:	0000028d 	.word	0x0000028d

0001aa94 <.text_71>:
   1aa94:	00000704 	.word	0x00000704

0001aa98 <.text_72>:
   1aa98:	000002b6 	.word	0x000002b6

0001aa9c <.text_73>:
   1aa9c:	000002b3 	.word	0x000002b3

0001aaa0 <.text_74>:
   1aaa0:	000003e9 	.word	0x000003e9

0001aaa4 <.text_75>:
   1aaa4:	0002ff54 	.word	0x0002ff54

0001aaa8 <PE_StateMachine_VDMCable>:
   1aaa8:	b5f0      	push	{r4, r5, r6, r7, lr}
   1aaaa:	b089      	sub	sp, #36	; 0x24
   1aaac:	0004      	movs	r4, r0
   1aaae:	2502      	movs	r5, #2
   1aab0:	20a4      	movs	r0, #164	; 0xa4
   1aab2:	0080      	lsls	r0, r0, #2
   1aab4:	1826      	adds	r6, r4, r0
   1aab6:	7830      	ldrb	r0, [r6, #0]
   1aab8:	2805      	cmp	r0, #5
   1aaba:	d002      	beq.n	1aac2 <PE_StateMachine_VDMCable+0x1a>
   1aabc:	289a      	cmp	r0, #154	; 0x9a
   1aabe:	d071      	beq.n	1aba4 <PE_StateMachine_VDMCable+0xfc>
   1aac0:	e14f      	b.n	1ad62 <PE_StateMachine_VDMCable+0x2ba>
   1aac2:	2701      	movs	r7, #1
   1aac4:	6860      	ldr	r0, [r4, #4]
   1aac6:	7800      	ldrb	r0, [r0, #0]
   1aac8:	0781      	lsls	r1, r0, #30
   1aaca:	0f89      	lsrs	r1, r1, #30
   1aacc:	6922      	ldr	r2, [r4, #16]
   1aace:	2001      	movs	r0, #1
   1aad0:	4010      	ands	r0, r2
   1aad2:	f001 fbd9 	bl	1c288 <PE_ExtRevisionInteroperability_Cable>
   1aad6:	209a      	movs	r0, #154	; 0x9a
   1aad8:	0080      	lsls	r0, r0, #2
   1aada:	1820      	adds	r0, r4, r0
   1aadc:	6802      	ldr	r2, [r0, #0]
   1aade:	211f      	movs	r1, #31
   1aae0:	438a      	bics	r2, r1
   1aae2:	49a2      	ldr	r1, [pc, #648]	; (1ad6c <.text_78>)
   1aae4:	4311      	orrs	r1, r2
   1aae6:	6001      	str	r1, [r0, #0]
   1aae8:	6862      	ldr	r2, [r4, #4]
   1aaea:	9200      	str	r2, [sp, #0]
   1aaec:	6812      	ldr	r2, [r2, #0]
   1aaee:	0953      	lsrs	r3, r2, #5
   1aaf0:	403b      	ands	r3, r7
   1aaf2:	4a9f      	ldr	r2, [pc, #636]	; (1ad70 <.text_79>)
   1aaf4:	400a      	ands	r2, r1
   1aaf6:	0359      	lsls	r1, r3, #13
   1aaf8:	4311      	orrs	r1, r2
   1aafa:	22ff      	movs	r2, #255	; 0xff
   1aafc:	0612      	lsls	r2, r2, #24
   1aafe:	430a      	orrs	r2, r1
   1ab00:	6002      	str	r2, [r0, #0]
   1ab02:	9800      	ldr	r0, [sp, #0]
   1ab04:	6800      	ldr	r0, [r0, #0]
   1ab06:	0880      	lsrs	r0, r0, #2
   1ab08:	4038      	ands	r0, r7
   1ab0a:	d003      	beq.n	1ab14 <PE_StateMachine_VDMCable+0x6c>
   1ab0c:	6920      	ldr	r0, [r4, #16]
   1ab0e:	0781      	lsls	r1, r0, #30
   1ab10:	0fc8      	lsrs	r0, r1, #31
   1ab12:	e000      	b.n	1ab16 <PE_StateMachine_VDMCable+0x6e>
   1ab14:	2002      	movs	r0, #2
   1ab16:	9002      	str	r0, [sp, #8]
   1ab18:	209a      	movs	r0, #154	; 0x9a
   1ab1a:	9001      	str	r0, [sp, #4]
   1ab1c:	9700      	str	r7, [sp, #0]
   1ab1e:	0080      	lsls	r0, r0, #2
   1ab20:	1823      	adds	r3, r4, r0
   1ab22:	220f      	movs	r2, #15
   1ab24:	2101      	movs	r1, #1
   1ab26:	0020      	movs	r0, r4
   1ab28:	f7ff ff24 	bl	1a974 <PE_Send_DataMessage>
   1ab2c:	2800      	cmp	r0, #0
   1ab2e:	d10a      	bne.n	1ab46 <PE_StateMachine_VDMCable+0x9e>
   1ab30:	6920      	ldr	r0, [r4, #16]
   1ab32:	0369      	lsls	r1, r5, #13
   1ab34:	4301      	orrs	r1, r0
   1ab36:	6121      	str	r1, [r4, #16]
   1ab38:	20ff      	movs	r0, #255	; 0xff
   1ab3a:	1c80      	adds	r0, r0, #2
   1ab3c:	83a0      	strh	r0, [r4, #28]
   1ab3e:	488d      	ldr	r0, [pc, #564]	; (1ad74 <.text_80>)
   1ab40:	8130      	strh	r0, [r6, #8]
   1ab42:	251e      	movs	r5, #30
   1ab44:	e10d      	b.n	1ad62 <PE_StateMachine_VDMCable+0x2ba>
   1ab46:	2809      	cmp	r0, #9
   1ab48:	d0fc      	beq.n	1ab44 <PE_StateMachine_VDMCable+0x9c>
   1ab4a:	7ea0      	ldrb	r0, [r4, #26]
   1ab4c:	2815      	cmp	r0, #21
   1ab4e:	d202      	bcs.n	1ab56 <PE_StateMachine_VDMCable+0xae>
   1ab50:	4889      	ldr	r0, [pc, #548]	; (1ad78 <.text_81>)
   1ab52:	8130      	strh	r0, [r6, #8]
   1ab54:	e00c      	b.n	1ab70 <PE_StateMachine_VDMCable+0xc8>
   1ab56:	68e0      	ldr	r0, [r4, #12]
   1ab58:	6940      	ldr	r0, [r0, #20]
   1ab5a:	9000      	str	r0, [sp, #0]
   1ab5c:	2800      	cmp	r0, #0
   1ab5e:	d007      	beq.n	1ab70 <PE_StateMachine_VDMCable+0xc8>
   1ab60:	2300      	movs	r3, #0
   1ab62:	2205      	movs	r2, #5
   1ab64:	2101      	movs	r1, #1
   1ab66:	6920      	ldr	r0, [r4, #16]
   1ab68:	4007      	ands	r7, r0
   1ab6a:	0038      	movs	r0, r7
   1ab6c:	9f00      	ldr	r7, [sp, #0]
   1ab6e:	47b8      	blx	r7
   1ab70:	2007      	movs	r0, #7
   1ab72:	6861      	ldr	r1, [r4, #4]
   1ab74:	6809      	ldr	r1, [r1, #0]
   1ab76:	0a09      	lsrs	r1, r1, #8
   1ab78:	4001      	ands	r1, r0
   1ab7a:	2903      	cmp	r1, #3
   1ab7c:	d100      	bne.n	1ab80 <PE_StateMachine_VDMCable+0xd8>
   1ab7e:	e0c9      	b.n	1ad14 <PE_StateMachine_VDMCable+0x26c>
   1ab80:	497e      	ldr	r1, [pc, #504]	; (1ad7c <.text_82>)
   1ab82:	88b2      	ldrh	r2, [r6, #4]
   1ab84:	420a      	tst	r2, r1
   1ab86:	d00b      	beq.n	1aba0 <PE_StateMachine_VDMCable+0xf8>
   1ab88:	2008      	movs	r0, #8
   1ab8a:	7030      	strb	r0, [r6, #0]
   1ab8c:	88b0      	ldrh	r0, [r6, #4]
   1ab8e:	4008      	ands	r0, r1
   1ab90:	282d      	cmp	r0, #45	; 0x2d
   1ab92:	d203      	bcs.n	1ab9c <PE_StateMachine_VDMCable+0xf4>
   1ab94:	88b0      	ldrh	r0, [r6, #4]
   1ab96:	000d      	movs	r5, r1
   1ab98:	4005      	ands	r5, r0
   1ab9a:	e0e2      	b.n	1ad62 <PE_StateMachine_VDMCable+0x2ba>
   1ab9c:	252d      	movs	r5, #45	; 0x2d
   1ab9e:	e0e0      	b.n	1ad62 <PE_StateMachine_VDMCable+0x2ba>
   1aba0:	7030      	strb	r0, [r6, #0]
   1aba2:	e0de      	b.n	1ad62 <PE_StateMachine_VDMCable+0x2ba>
   1aba4:	9100      	str	r1, [sp, #0]
   1aba6:	2001      	movs	r0, #1
   1aba8:	f000 fd55 	bl	1b656 <PE_Get_RxEvent>
   1abac:	8a71      	ldrh	r1, [r6, #18]
   1abae:	2214      	movs	r2, #20
   1abb0:	2700      	movs	r7, #0
   1abb2:	9b00      	ldr	r3, [sp, #0]
   1abb4:	781b      	ldrb	r3, [r3, #0]
   1abb6:	4283      	cmp	r3, r0
   1abb8:	d169      	bne.n	1ac8e <PE_StateMachine_VDMCable+0x1e6>
   1abba:	0bc8      	lsrs	r0, r1, #15
   1abbc:	d167      	bne.n	1ac8e <PE_StateMachine_VDMCable+0x1e6>
   1abbe:	0b08      	lsrs	r0, r1, #12
   1abc0:	0740      	lsls	r0, r0, #29
   1abc2:	d064      	beq.n	1ac8e <PE_StateMachine_VDMCable+0x1e6>
   1abc4:	06c8      	lsls	r0, r1, #27
   1abc6:	0ec0      	lsrs	r0, r0, #27
   1abc8:	280f      	cmp	r0, #15
   1abca:	d160      	bne.n	1ac8e <PE_StateMachine_VDMCable+0x1e6>
   1abcc:	9800      	ldr	r0, [sp, #0]
   1abce:	7002      	strb	r2, [r0, #0]
   1abd0:	7c21      	ldrb	r1, [r4, #16]
   1abd2:	07c8      	lsls	r0, r1, #31
   1abd4:	0fc0      	lsrs	r0, r0, #31
   1abd6:	f002 fe00 	bl	1d7da <USBPD_PRL_EnableRX>
   1abda:	20a1      	movs	r0, #161	; 0xa1
   1abdc:	0040      	lsls	r0, r0, #1
   1abde:	5c20      	ldrb	r0, [r4, r0]
   1abe0:	9000      	str	r0, [sp, #0]
   1abe2:	06c0      	lsls	r0, r0, #27
   1abe4:	0ec0      	lsrs	r0, r0, #27
   1abe6:	2801      	cmp	r0, #1
   1abe8:	d1db      	bne.n	1aba2 <PE_StateMachine_VDMCable+0xfa>
   1abea:	9800      	ldr	r0, [sp, #0]
   1abec:	0980      	lsrs	r0, r0, #6
   1abee:	d0d8      	beq.n	1aba2 <PE_StateMachine_VDMCable+0xfa>
   1abf0:	8a70      	ldrh	r0, [r6, #18]
   1abf2:	0600      	lsls	r0, r0, #24
   1abf4:	0f81      	lsrs	r1, r0, #30
   1abf6:	7c22      	ldrb	r2, [r4, #16]
   1abf8:	07d0      	lsls	r0, r2, #31
   1abfa:	0fc0      	lsrs	r0, r0, #31
   1abfc:	f001 fb44 	bl	1c288 <PE_ExtRevisionInteroperability_Cable>
   1ac00:	68e0      	ldr	r0, [r4, #12]
   1ac02:	6940      	ldr	r0, [r0, #20]
   1ac04:	2800      	cmp	r0, #0
   1ac06:	d039      	beq.n	1ac7c <PE_StateMachine_VDMCable+0x1d4>
   1ac08:	9800      	ldr	r0, [sp, #0]
   1ac0a:	0980      	lsrs	r0, r0, #6
   1ac0c:	9000      	str	r0, [sp, #0]
   1ac0e:	2503      	movs	r5, #3
   1ac10:	4028      	ands	r0, r5
   1ac12:	2801      	cmp	r0, #1
   1ac14:	d121      	bne.n	1ac5a <PE_StateMachine_VDMCable+0x1b2>
   1ac16:	aa03      	add	r2, sp, #12
   1ac18:	20a3      	movs	r0, #163	; 0xa3
   1ac1a:	0040      	lsls	r0, r0, #1
   1ac1c:	1821      	adds	r1, r4, r0
   1ac1e:	7c23      	ldrb	r3, [r4, #16]
   1ac20:	07d8      	lsls	r0, r3, #31
   1ac22:	0fc0      	lsrs	r0, r0, #31
   1ac24:	f001 fb8c 	bl	1c340 <PE_SVDM_CheckIdentity>
   1ac28:	2800      	cmp	r0, #0
   1ac2a:	d116      	bne.n	1ac5a <PE_StateMachine_VDMCable+0x1b2>
   1ac2c:	ab03      	add	r3, sp, #12
   1ac2e:	9800      	ldr	r0, [sp, #0]
   1ac30:	4005      	ands	r5, r0
   1ac32:	002a      	movs	r2, r5
   1ac34:	2101      	movs	r1, #1
   1ac36:	7c25      	ldrb	r5, [r4, #16]
   1ac38:	07e8      	lsls	r0, r5, #31
   1ac3a:	0fc0      	lsrs	r0, r0, #31
   1ac3c:	68e5      	ldr	r5, [r4, #12]
   1ac3e:	696d      	ldr	r5, [r5, #20]
   1ac40:	47a8      	blx	r5
   1ac42:	9700      	str	r7, [sp, #0]
   1ac44:	2300      	movs	r3, #0
   1ac46:	2252      	movs	r2, #82	; 0x52
   1ac48:	7c20      	ldrb	r0, [r4, #16]
   1ac4a:	07c1      	lsls	r1, r0, #31
   1ac4c:	0fc9      	lsrs	r1, r1, #31
   1ac4e:	2009      	movs	r0, #9
   1ac50:	4d4b      	ldr	r5, [pc, #300]	; (1ad80 <.text_83>)
   1ac52:	6a2d      	ldr	r5, [r5, #32]
   1ac54:	47a8      	blx	r5
   1ac56:	2152      	movs	r1, #82	; 0x52
   1ac58:	e00a      	b.n	1ac70 <PE_StateMachine_VDMCable+0x1c8>
   1ac5a:	9700      	str	r7, [sp, #0]
   1ac5c:	2300      	movs	r3, #0
   1ac5e:	221b      	movs	r2, #27
   1ac60:	7c20      	ldrb	r0, [r4, #16]
   1ac62:	07c1      	lsls	r1, r0, #31
   1ac64:	0fc9      	lsrs	r1, r1, #31
   1ac66:	2009      	movs	r0, #9
   1ac68:	4d45      	ldr	r5, [pc, #276]	; (1ad80 <.text_83>)
   1ac6a:	6a2d      	ldr	r5, [r5, #32]
   1ac6c:	47a8      	blx	r5
   1ac6e:	211b      	movs	r1, #27
   1ac70:	7c22      	ldrb	r2, [r4, #16]
   1ac72:	07d0      	lsls	r0, r2, #31
   1ac74:	0fc0      	lsrs	r0, r0, #31
   1ac76:	68a2      	ldr	r2, [r4, #8]
   1ac78:	68d2      	ldr	r2, [r2, #12]
   1ac7a:	4790      	blx	r2
   1ac7c:	8137      	strh	r7, [r6, #8]
   1ac7e:	2007      	movs	r0, #7
   1ac80:	6861      	ldr	r1, [r4, #4]
   1ac82:	6809      	ldr	r1, [r1, #0]
   1ac84:	0a09      	lsrs	r1, r1, #8
   1ac86:	4001      	ands	r1, r0
   1ac88:	2903      	cmp	r1, #3
   1ac8a:	d043      	beq.n	1ad14 <PE_StateMachine_VDMCable+0x26c>
   1ac8c:	e066      	b.n	1ad5c <PE_StateMachine_VDMCable+0x2b4>
   1ac8e:	06c8      	lsls	r0, r1, #27
   1ac90:	0ec0      	lsrs	r0, r0, #27
   1ac92:	2810      	cmp	r0, #16
   1ac94:	d128      	bne.n	1ace8 <PE_StateMachine_VDMCable+0x240>
   1ac96:	9800      	ldr	r0, [sp, #0]
   1ac98:	7002      	strb	r2, [r0, #0]
   1ac9a:	7c21      	ldrb	r1, [r4, #16]
   1ac9c:	07c8      	lsls	r0, r1, #31
   1ac9e:	0fc0      	lsrs	r0, r0, #31
   1aca0:	f002 fd9b 	bl	1d7da <USBPD_PRL_EnableRX>
   1aca4:	8137      	strh	r7, [r6, #8]
   1aca6:	2007      	movs	r0, #7
   1aca8:	6861      	ldr	r1, [r4, #4]
   1acaa:	6809      	ldr	r1, [r1, #0]
   1acac:	0a09      	lsrs	r1, r1, #8
   1acae:	4001      	ands	r1, r0
   1acb0:	2903      	cmp	r1, #3
   1acb2:	d103      	bne.n	1acbc <PE_StateMachine_VDMCable+0x214>
   1acb4:	2003      	movs	r0, #3
   1acb6:	7030      	strb	r0, [r6, #0]
   1acb8:	2500      	movs	r5, #0
   1acba:	e002      	b.n	1acc2 <PE_StateMachine_VDMCable+0x21a>
   1acbc:	7030      	strb	r0, [r6, #0]
   1acbe:	2500      	movs	r5, #0
   1acc0:	83a7      	strh	r7, [r4, #28]
   1acc2:	2601      	movs	r6, #1
   1acc4:	9500      	str	r5, [sp, #0]
   1acc6:	2300      	movs	r3, #0
   1acc8:	2259      	movs	r2, #89	; 0x59
   1acca:	6920      	ldr	r0, [r4, #16]
   1accc:	2101      	movs	r1, #1
   1acce:	4001      	ands	r1, r0
   1acd0:	2009      	movs	r0, #9
   1acd2:	4f2b      	ldr	r7, [pc, #172]	; (1ad80 <.text_83>)
   1acd4:	6a3f      	ldr	r7, [r7, #32]
   1acd6:	47b8      	blx	r7
   1acd8:	2159      	movs	r1, #89	; 0x59
   1acda:	6920      	ldr	r0, [r4, #16]
   1acdc:	4006      	ands	r6, r0
   1acde:	0030      	movs	r0, r6
   1ace0:	68a2      	ldr	r2, [r4, #8]
   1ace2:	68d2      	ldr	r2, [r2, #12]
   1ace4:	4790      	blx	r2
   1ace6:	e03c      	b.n	1ad62 <PE_StateMachine_VDMCable+0x2ba>
   1ace8:	8930      	ldrh	r0, [r6, #8]
   1acea:	03a9      	lsls	r1, r5, #14
   1acec:	4288      	cmp	r0, r1
   1acee:	d138      	bne.n	1ad62 <PE_StateMachine_VDMCable+0x2ba>
   1acf0:	8137      	strh	r7, [r6, #8]
   1acf2:	6861      	ldr	r1, [r4, #4]
   1acf4:	680a      	ldr	r2, [r1, #0]
   1acf6:	0550      	lsls	r0, r2, #21
   1acf8:	0f40      	lsrs	r0, r0, #29
   1acfa:	2803      	cmp	r0, #3
   1acfc:	d10e      	bne.n	1ad1c <PE_StateMachine_VDMCable+0x274>
   1acfe:	68e0      	ldr	r0, [r4, #12]
   1ad00:	6945      	ldr	r5, [r0, #20]
   1ad02:	2d00      	cmp	r5, #0
   1ad04:	d006      	beq.n	1ad14 <PE_StateMachine_VDMCable+0x26c>
   1ad06:	2300      	movs	r3, #0
   1ad08:	2204      	movs	r2, #4
   1ad0a:	2101      	movs	r1, #1
   1ad0c:	7c24      	ldrb	r4, [r4, #16]
   1ad0e:	07e0      	lsls	r0, r4, #31
   1ad10:	0fc0      	lsrs	r0, r0, #31
   1ad12:	47a8      	blx	r5
   1ad14:	2003      	movs	r0, #3
   1ad16:	7030      	strb	r0, [r6, #0]
   1ad18:	2500      	movs	r5, #0
   1ad1a:	e022      	b.n	1ad62 <PE_StateMachine_VDMCable+0x2ba>
   1ad1c:	2001      	movs	r0, #1
   1ad1e:	01d3      	lsls	r3, r2, #7
   1ad20:	0f9b      	lsrs	r3, r3, #30
   1ad22:	2b02      	cmp	r3, #2
   1ad24:	d10f      	bne.n	1ad46 <PE_StateMachine_VDMCable+0x29e>
   1ad26:	4b17      	ldr	r3, [pc, #92]	; (1ad84 <.text_84>)
   1ad28:	4013      	ands	r3, r2
   1ad2a:	05c2      	lsls	r2, r0, #23
   1ad2c:	431a      	orrs	r2, r3
   1ad2e:	600a      	str	r2, [r1, #0]
   1ad30:	2101      	movs	r1, #1
   1ad32:	6922      	ldr	r2, [r4, #16]
   1ad34:	4010      	ands	r0, r2
   1ad36:	f002 fb8d 	bl	1d454 <USBPD_PRL_CBL_SetHeaderSpecification>
   1ad3a:	480f      	ldr	r0, [pc, #60]	; (1ad78 <.text_81>)
   1ad3c:	8130      	strh	r0, [r6, #8]
   1ad3e:	252d      	movs	r5, #45	; 0x2d
   1ad40:	2008      	movs	r0, #8
   1ad42:	7030      	strb	r0, [r6, #0]
   1ad44:	e00c      	b.n	1ad60 <PE_StateMachine_VDMCable+0x2b8>
   1ad46:	68e1      	ldr	r1, [r4, #12]
   1ad48:	694d      	ldr	r5, [r1, #20]
   1ad4a:	2d00      	cmp	r5, #0
   1ad4c:	d005      	beq.n	1ad5a <PE_StateMachine_VDMCable+0x2b2>
   1ad4e:	2300      	movs	r3, #0
   1ad50:	2204      	movs	r2, #4
   1ad52:	6921      	ldr	r1, [r4, #16]
   1ad54:	4008      	ands	r0, r1
   1ad56:	2101      	movs	r1, #1
   1ad58:	47a8      	blx	r5
   1ad5a:	2007      	movs	r0, #7
   1ad5c:	7030      	strb	r0, [r6, #0]
   1ad5e:	2500      	movs	r5, #0
   1ad60:	83a7      	strh	r7, [r4, #28]
   1ad62:	0028      	movs	r0, r5
   1ad64:	b009      	add	sp, #36	; 0x24
   1ad66:	bdf0      	pop	{r4, r5, r6, r7, pc}

0001ad68 <.text_77>:
   1ad68:	00001771 	.word	0x00001771

0001ad6c <.text_78>:
   1ad6c:	00008001 	.word	0x00008001

0001ad70 <.text_79>:
   1ad70:	0000983f 	.word	0x0000983f

0001ad74 <.text_80>:
   1ad74:	0000801e 	.word	0x0000801e

0001ad78 <.text_81>:
   1ad78:	0000802d 	.word	0x0000802d

0001ad7c <.text_82>:
   1ad7c:	00007fff 	.word	0x00007fff

0001ad80 <.text_83>:
   1ad80:	0002ff54 	.word	0x0002ff54

0001ad84 <.text_84>:
   1ad84:	fe7fffff 	.word	0xfe7fffff

0001ad88 <PE_StateMachine_VDM>:
   1ad88:	b5f2      	push	{r1, r4, r5, r6, r7, lr}
   1ad8a:	b090      	sub	sp, #64	; 0x40
   1ad8c:	0004      	movs	r4, r0
   1ad8e:	2702      	movs	r7, #2
   1ad90:	48c9      	ldr	r0, [pc, #804]	; (1b0b8 <PE_StateMachine_VDM+0x330>)
   1ad92:	1826      	adds	r6, r4, r0
   1ad94:	3825      	subs	r0, #37	; 0x25
   1ad96:	1825      	adds	r5, r4, r0
   1ad98:	201f      	movs	r0, #31
   1ad9a:	43c0      	mvns	r0, r0
   1ad9c:	21c0      	movs	r1, #192	; 0xc0
   1ad9e:	43c9      	mvns	r1, r1
   1ada0:	78f2      	ldrb	r2, [r6, #3]
   1ada2:	2a7f      	cmp	r2, #127	; 0x7f
   1ada4:	d01a      	beq.n	1addc <PE_StateMachine_VDM+0x54>
   1ada6:	2a81      	cmp	r2, #129	; 0x81
   1ada8:	d100      	bne.n	1adac <PE_StateMachine_VDM+0x24>
   1adaa:	e0a2      	b.n	1aef2 <PE_StateMachine_VDM+0x16a>
   1adac:	2a82      	cmp	r2, #130	; 0x82
   1adae:	d100      	bne.n	1adb2 <PE_StateMachine_VDM+0x2a>
   1adb0:	e158      	b.n	1b064 <PE_StateMachine_VDM+0x2dc>
   1adb2:	2a83      	cmp	r2, #131	; 0x83
   1adb4:	d100      	bne.n	1adb8 <PE_StateMachine_VDM+0x30>
   1adb6:	e215      	b.n	1b1e4 <PE_StateMachine_VDM+0x45c>
   1adb8:	2a85      	cmp	r2, #133	; 0x85
   1adba:	d100      	bne.n	1adbe <PE_StateMachine_VDM+0x36>
   1adbc:	e2d4      	b.n	1b368 <PE_StateMachine_VDM+0x5e0>
   1adbe:	2a89      	cmp	r2, #137	; 0x89
   1adc0:	d042      	beq.n	1ae48 <PE_StateMachine_VDM+0xc0>
   1adc2:	2a8b      	cmp	r2, #139	; 0x8b
   1adc4:	d100      	bne.n	1adc8 <PE_StateMachine_VDM+0x40>
   1adc6:	e0d0      	b.n	1af6a <PE_StateMachine_VDM+0x1e2>
   1adc8:	2a8c      	cmp	r2, #140	; 0x8c
   1adca:	d100      	bne.n	1adce <PE_StateMachine_VDM+0x46>
   1adcc:	e19a      	b.n	1b104 <PE_StateMachine_VDM+0x37c>
   1adce:	2a8d      	cmp	r2, #141	; 0x8d
   1add0:	d100      	bne.n	1add4 <PE_StateMachine_VDM+0x4c>
   1add2:	e25b      	b.n	1b28c <PE_StateMachine_VDM+0x504>
   1add4:	2a8f      	cmp	r2, #143	; 0x8f
   1add6:	d100      	bne.n	1adda <PE_StateMachine_VDM+0x52>
   1add8:	e323      	b.n	1b422 <PE_StateMachine_VDM+0x69a>
   1adda:	e3b0      	b.n	1b53e <PE_StateMachine_VDM+0x7b6>
   1addc:	682a      	ldr	r2, [r5, #0]
   1adde:	4011      	ands	r1, r2
   1ade0:	6029      	str	r1, [r5, #0]
   1ade2:	4008      	ands	r0, r1
   1ade4:	2102      	movs	r1, #2
   1ade6:	4301      	orrs	r1, r0
   1ade8:	6029      	str	r1, [r5, #0]
   1adea:	b288      	uxth	r0, r1
   1adec:	21ff      	movs	r1, #255	; 0xff
   1adee:	0609      	lsls	r1, r1, #24
   1adf0:	4301      	orrs	r1, r0
   1adf2:	6029      	str	r1, [r5, #0]
   1adf4:	03b8      	lsls	r0, r7, #14
   1adf6:	4308      	orrs	r0, r1
   1adf8:	6028      	str	r0, [r5, #0]
   1adfa:	2101      	movs	r1, #1
   1adfc:	6862      	ldr	r2, [r4, #4]
   1adfe:	6812      	ldr	r2, [r2, #0]
   1ae00:	0953      	lsrs	r3, r2, #5
   1ae02:	400b      	ands	r3, r1
   1ae04:	4aad      	ldr	r2, [pc, #692]	; (1b0bc <PE_StateMachine_VDM+0x334>)
   1ae06:	4002      	ands	r2, r0
   1ae08:	0358      	lsls	r0, r3, #13
   1ae0a:	4310      	orrs	r0, r2
   1ae0c:	6028      	str	r0, [r5, #0]
   1ae0e:	4aac      	ldr	r2, [pc, #688]	; (1b0c0 <PE_StateMachine_VDM+0x338>)
   1ae10:	4002      	ands	r2, r0
   1ae12:	602a      	str	r2, [r5, #0]
   1ae14:	6860      	ldr	r0, [r4, #4]
   1ae16:	6800      	ldr	r0, [r0, #0]
   1ae18:	0880      	lsrs	r0, r0, #2
   1ae1a:	4001      	ands	r1, r0
   1ae1c:	d003      	beq.n	1ae26 <PE_StateMachine_VDM+0x9e>
   1ae1e:	6920      	ldr	r0, [r4, #16]
   1ae20:	0781      	lsls	r1, r0, #30
   1ae22:	0fc8      	lsrs	r0, r1, #31
   1ae24:	e000      	b.n	1ae28 <PE_StateMachine_VDM+0xa0>
   1ae26:	2002      	movs	r0, #2
   1ae28:	9002      	str	r0, [sp, #8]
   1ae2a:	2089      	movs	r0, #137	; 0x89
   1ae2c:	9001      	str	r0, [sp, #4]
   1ae2e:	2001      	movs	r0, #1
   1ae30:	9000      	str	r0, [sp, #0]
   1ae32:	002b      	movs	r3, r5
   1ae34:	220f      	movs	r2, #15
   1ae36:	79b1      	ldrb	r1, [r6, #6]
   1ae38:	0020      	movs	r0, r4
   1ae3a:	f7ff fd9b 	bl	1a974 <PE_Send_DataMessage>
   1ae3e:	2800      	cmp	r0, #0
   1ae40:	d1cb      	bne.n	1adda <PE_StateMachine_VDM+0x52>
   1ae42:	2081      	movs	r0, #129	; 0x81
   1ae44:	0040      	lsls	r0, r0, #1
   1ae46:	e089      	b.n	1af5c <PE_StateMachine_VDM+0x1d4>
   1ae48:	79b0      	ldrb	r0, [r6, #6]
   1ae4a:	f000 fc04 	bl	1b656 <PE_Get_RxEvent>
   1ae4e:	251f      	movs	r5, #31
   1ae50:	9910      	ldr	r1, [sp, #64]	; 0x40
   1ae52:	7809      	ldrb	r1, [r1, #0]
   1ae54:	4281      	cmp	r1, r0
   1ae56:	d145      	bne.n	1aee4 <PE_StateMachine_VDM+0x15c>
   1ae58:	20a5      	movs	r0, #165	; 0xa5
   1ae5a:	0080      	lsls	r0, r0, #2
   1ae5c:	1820      	adds	r0, r4, r0
   1ae5e:	89c0      	ldrh	r0, [r0, #14]
   1ae60:	0bc1      	lsrs	r1, r0, #15
   1ae62:	d13f      	bne.n	1aee4 <PE_StateMachine_VDM+0x15c>
   1ae64:	0b01      	lsrs	r1, r0, #12
   1ae66:	0749      	lsls	r1, r1, #29
   1ae68:	d03c      	beq.n	1aee4 <PE_StateMachine_VDM+0x15c>
   1ae6a:	211f      	movs	r1, #31
   1ae6c:	4001      	ands	r1, r0
   1ae6e:	290f      	cmp	r1, #15
   1ae70:	d138      	bne.n	1aee4 <PE_StateMachine_VDM+0x15c>
   1ae72:	2014      	movs	r0, #20
   1ae74:	9910      	ldr	r1, [sp, #64]	; 0x40
   1ae76:	7008      	strb	r0, [r1, #0]
   1ae78:	7c21      	ldrb	r1, [r4, #16]
   1ae7a:	07c8      	lsls	r0, r1, #31
   1ae7c:	0fc0      	lsrs	r0, r0, #31
   1ae7e:	f002 fcac 	bl	1d7da <USBPD_PRL_EnableRX>
   1ae82:	20a1      	movs	r0, #161	; 0xa1
   1ae84:	0040      	lsls	r0, r0, #1
   1ae86:	5c20      	ldrb	r0, [r4, r0]
   1ae88:	9000      	str	r0, [sp, #0]
   1ae8a:	4028      	ands	r0, r5
   1ae8c:	2802      	cmp	r0, #2
   1ae8e:	d129      	bne.n	1aee4 <PE_StateMachine_VDM+0x15c>
   1ae90:	9800      	ldr	r0, [sp, #0]
   1ae92:	0980      	lsrs	r0, r0, #6
   1ae94:	d026      	beq.n	1aee4 <PE_StateMachine_VDM+0x15c>
   1ae96:	68e0      	ldr	r0, [r4, #12]
   1ae98:	6980      	ldr	r0, [r0, #24]
   1ae9a:	2800      	cmp	r0, #0
   1ae9c:	d100      	bne.n	1aea0 <PE_StateMachine_VDM+0x118>
   1ae9e:	e319      	b.n	1b4d4 <PE_StateMachine_VDM+0x74c>
   1aea0:	2501      	movs	r5, #1
   1aea2:	aa02      	add	r2, sp, #8
   1aea4:	20a3      	movs	r0, #163	; 0xa3
   1aea6:	0040      	lsls	r0, r0, #1
   1aea8:	1821      	adds	r1, r4, r0
   1aeaa:	6923      	ldr	r3, [r4, #16]
   1aeac:	2001      	movs	r0, #1
   1aeae:	4018      	ands	r0, r3
   1aeb0:	f001 fab3 	bl	1c41a <PE_SVDM_CheckSVIDs>
   1aeb4:	ab02      	add	r3, sp, #8
   1aeb6:	9800      	ldr	r0, [sp, #0]
   1aeb8:	0600      	lsls	r0, r0, #24
   1aeba:	0f82      	lsrs	r2, r0, #30
   1aebc:	79b1      	ldrb	r1, [r6, #6]
   1aebe:	6927      	ldr	r7, [r4, #16]
   1aec0:	2001      	movs	r0, #1
   1aec2:	4038      	ands	r0, r7
   1aec4:	68e7      	ldr	r7, [r4, #12]
   1aec6:	69bf      	ldr	r7, [r7, #24]
   1aec8:	47b8      	blx	r7
   1aeca:	2000      	movs	r0, #0
   1aecc:	9000      	str	r0, [sp, #0]
   1aece:	2300      	movs	r3, #0
   1aed0:	2253      	movs	r2, #83	; 0x53
   1aed2:	6920      	ldr	r0, [r4, #16]
   1aed4:	2101      	movs	r1, #1
   1aed6:	4001      	ands	r1, r0
   1aed8:	2009      	movs	r0, #9
   1aeda:	4fbf      	ldr	r7, [pc, #764]	; (1b1d8 <PE_StateMachine_VDM+0x450>)
   1aedc:	6a3f      	ldr	r7, [r7, #32]
   1aede:	47b8      	blx	r7
   1aee0:	2153      	movs	r1, #83	; 0x53
   1aee2:	e0b8      	b.n	1b056 <PE_StateMachine_VDM+0x2ce>
   1aee4:	20a5      	movs	r0, #165	; 0xa5
   1aee6:	0080      	lsls	r0, r0, #2
   1aee8:	1820      	adds	r0, r4, r0
   1aeea:	89c1      	ldrh	r1, [r0, #14]
   1aeec:	400d      	ands	r5, r1
   1aeee:	2d10      	cmp	r5, #16
   1aef0:	e233      	b.n	1b35a <PE_StateMachine_VDM+0x5d2>
   1aef2:	682a      	ldr	r2, [r5, #0]
   1aef4:	4011      	ands	r1, r2
   1aef6:	6029      	str	r1, [r5, #0]
   1aef8:	4008      	ands	r0, r1
   1aefa:	2103      	movs	r1, #3
   1aefc:	4301      	orrs	r1, r0
   1aefe:	6029      	str	r1, [r5, #0]
   1af00:	8928      	ldrh	r0, [r5, #8]
   1af02:	b28a      	uxth	r2, r1
   1af04:	0401      	lsls	r1, r0, #16
   1af06:	4311      	orrs	r1, r2
   1af08:	6029      	str	r1, [r5, #0]
   1af0a:	03b8      	lsls	r0, r7, #14
   1af0c:	4308      	orrs	r0, r1
   1af0e:	6028      	str	r0, [r5, #0]
   1af10:	2101      	movs	r1, #1
   1af12:	6862      	ldr	r2, [r4, #4]
   1af14:	6812      	ldr	r2, [r2, #0]
   1af16:	0953      	lsrs	r3, r2, #5
   1af18:	400b      	ands	r3, r1
   1af1a:	4a68      	ldr	r2, [pc, #416]	; (1b0bc <PE_StateMachine_VDM+0x334>)
   1af1c:	4002      	ands	r2, r0
   1af1e:	0358      	lsls	r0, r3, #13
   1af20:	4310      	orrs	r0, r2
   1af22:	6028      	str	r0, [r5, #0]
   1af24:	4a66      	ldr	r2, [pc, #408]	; (1b0c0 <PE_StateMachine_VDM+0x338>)
   1af26:	4002      	ands	r2, r0
   1af28:	602a      	str	r2, [r5, #0]
   1af2a:	6860      	ldr	r0, [r4, #4]
   1af2c:	6800      	ldr	r0, [r0, #0]
   1af2e:	0880      	lsrs	r0, r0, #2
   1af30:	4001      	ands	r1, r0
   1af32:	d003      	beq.n	1af3c <PE_StateMachine_VDM+0x1b4>
   1af34:	6920      	ldr	r0, [r4, #16]
   1af36:	0781      	lsls	r1, r0, #30
   1af38:	0fc8      	lsrs	r0, r1, #31
   1af3a:	e000      	b.n	1af3e <PE_StateMachine_VDM+0x1b6>
   1af3c:	2002      	movs	r0, #2
   1af3e:	9002      	str	r0, [sp, #8]
   1af40:	208b      	movs	r0, #139	; 0x8b
   1af42:	9001      	str	r0, [sp, #4]
   1af44:	2001      	movs	r0, #1
   1af46:	9000      	str	r0, [sp, #0]
   1af48:	002b      	movs	r3, r5
   1af4a:	220f      	movs	r2, #15
   1af4c:	79b1      	ldrb	r1, [r6, #6]
   1af4e:	0020      	movs	r0, r4
   1af50:	f7ff fd10 	bl	1a974 <PE_Send_DataMessage>
   1af54:	2800      	cmp	r0, #0
   1af56:	d107      	bne.n	1af68 <PE_StateMachine_VDM+0x1e0>
   1af58:	20ff      	movs	r0, #255	; 0xff
   1af5a:	1d00      	adds	r0, r0, #4
   1af5c:	83a0      	strh	r0, [r4, #28]
   1af5e:	489f      	ldr	r0, [pc, #636]	; (1b1dc <PE_StateMachine_VDM+0x454>)
   1af60:	21a5      	movs	r1, #165	; 0xa5
   1af62:	0089      	lsls	r1, r1, #2
   1af64:	5260      	strh	r0, [r4, r1]
   1af66:	271e      	movs	r7, #30
   1af68:	e2e9      	b.n	1b53e <PE_StateMachine_VDM+0x7b6>
   1af6a:	79b0      	ldrb	r0, [r6, #6]
   1af6c:	f000 fb73 	bl	1b656 <PE_Get_RxEvent>
   1af70:	9910      	ldr	r1, [sp, #64]	; 0x40
   1af72:	7809      	ldrb	r1, [r1, #0]
   1af74:	4281      	cmp	r1, r0
   1af76:	d11b      	bne.n	1afb0 <PE_StateMachine_VDM+0x228>
   1af78:	20a5      	movs	r0, #165	; 0xa5
   1af7a:	0080      	lsls	r0, r0, #2
   1af7c:	1820      	adds	r0, r4, r0
   1af7e:	89c0      	ldrh	r0, [r0, #14]
   1af80:	0bc1      	lsrs	r1, r0, #15
   1af82:	d115      	bne.n	1afb0 <PE_StateMachine_VDM+0x228>
   1af84:	0b01      	lsrs	r1, r0, #12
   1af86:	0749      	lsls	r1, r1, #29
   1af88:	d016      	beq.n	1afb8 <PE_StateMachine_VDM+0x230>
   1af8a:	06c0      	lsls	r0, r0, #27
   1af8c:	0ec0      	lsrs	r0, r0, #27
   1af8e:	280f      	cmp	r0, #15
   1af90:	d10e      	bne.n	1afb0 <PE_StateMachine_VDM+0x228>
   1af92:	2014      	movs	r0, #20
   1af94:	9910      	ldr	r1, [sp, #64]	; 0x40
   1af96:	7008      	strb	r0, [r1, #0]
   1af98:	7c21      	ldrb	r1, [r4, #16]
   1af9a:	07c8      	lsls	r0, r1, #31
   1af9c:	0fc0      	lsrs	r0, r0, #31
   1af9e:	f002 fc1c 	bl	1d7da <USBPD_PRL_EnableRX>
   1afa2:	20a1      	movs	r0, #161	; 0xa1
   1afa4:	0040      	lsls	r0, r0, #1
   1afa6:	5c20      	ldrb	r0, [r4, r0]
   1afa8:	9000      	str	r0, [sp, #0]
   1afaa:	06c0      	lsls	r0, r0, #27
   1afac:	0ec0      	lsrs	r0, r0, #27
   1afae:	2803      	cmp	r0, #3
   1afb0:	d000      	beq.n	1afb4 <PE_StateMachine_VDM+0x22c>
   1afb2:	e1cb      	b.n	1b34c <PE_StateMachine_VDM+0x5c4>
   1afb4:	9800      	ldr	r0, [sp, #0]
   1afb6:	0980      	lsrs	r0, r0, #6
   1afb8:	d100      	bne.n	1afbc <PE_StateMachine_VDM+0x234>
   1afba:	e1c7      	b.n	1b34c <PE_StateMachine_VDM+0x5c4>
   1afbc:	68e0      	ldr	r0, [r4, #12]
   1afbe:	69c0      	ldr	r0, [r0, #28]
   1afc0:	2800      	cmp	r0, #0
   1afc2:	d04e      	beq.n	1b062 <PE_StateMachine_VDM+0x2da>
   1afc4:	4884      	ldr	r0, [pc, #528]	; (1b1d8 <PE_StateMachine_VDM+0x450>)
   1afc6:	7c21      	ldrb	r1, [r4, #16]
   1afc8:	07ca      	lsls	r2, r1, #31
   1afca:	0f51      	lsrs	r1, r2, #29
   1afcc:	5840      	ldr	r0, [r0, r1]
   1afce:	4984      	ldr	r1, [pc, #528]	; (1b1e0 <PE_StateMachine_VDM+0x458>)
   1afd0:	5a40      	ldrh	r0, [r0, r1]
   1afd2:	0440      	lsls	r0, r0, #17
   1afd4:	0f40      	lsrs	r0, r0, #29
   1afd6:	1e40      	subs	r0, r0, #1
   1afd8:	0600      	lsls	r0, r0, #24
   1afda:	2100      	movs	r1, #0
   1afdc:	682a      	ldr	r2, [r5, #0]
   1afde:	0c12      	lsrs	r2, r2, #16
   1afe0:	ab02      	add	r3, sp, #8
   1afe2:	839a      	strh	r2, [r3, #28]
   1afe4:	9102      	str	r1, [sp, #8]
   1afe6:	0d82      	lsrs	r2, r0, #22
   1afe8:	1860      	adds	r0, r4, r1
   1afea:	23a3      	movs	r3, #163	; 0xa3
   1afec:	005b      	lsls	r3, r3, #1
   1afee:	18c0      	adds	r0, r0, r3
   1aff0:	7803      	ldrb	r3, [r0, #0]
   1aff2:	7845      	ldrb	r5, [r0, #1]
   1aff4:	022d      	lsls	r5, r5, #8
   1aff6:	195b      	adds	r3, r3, r5
   1aff8:	7885      	ldrb	r5, [r0, #2]
   1affa:	042d      	lsls	r5, r5, #16
   1affc:	195b      	adds	r3, r3, r5
   1affe:	78c0      	ldrb	r0, [r0, #3]
   1b000:	0600      	lsls	r0, r0, #24
   1b002:	1818      	adds	r0, r3, r0
   1b004:	ab02      	add	r3, sp, #8
   1b006:	1d1b      	adds	r3, r3, #4
   1b008:	9d02      	ldr	r5, [sp, #8]
   1b00a:	00ad      	lsls	r5, r5, #2
   1b00c:	5158      	str	r0, [r3, r5]
   1b00e:	9802      	ldr	r0, [sp, #8]
   1b010:	1c40      	adds	r0, r0, #1
   1b012:	9002      	str	r0, [sp, #8]
   1b014:	1d09      	adds	r1, r1, #4
   1b016:	b2c9      	uxtb	r1, r1
   1b018:	4291      	cmp	r1, r2
   1b01a:	d3e5      	bcc.n	1afe8 <PE_StateMachine_VDM+0x260>
   1b01c:	2503      	movs	r5, #3
   1b01e:	ab02      	add	r3, sp, #8
   1b020:	9800      	ldr	r0, [sp, #0]
   1b022:	0982      	lsrs	r2, r0, #6
   1b024:	402a      	ands	r2, r5
   1b026:	79b1      	ldrb	r1, [r6, #6]
   1b028:	7c27      	ldrb	r7, [r4, #16]
   1b02a:	07f8      	lsls	r0, r7, #31
   1b02c:	0fc0      	lsrs	r0, r0, #31
   1b02e:	68e7      	ldr	r7, [r4, #12]
   1b030:	69ff      	ldr	r7, [r7, #28]
   1b032:	47b8      	blx	r7
   1b034:	9800      	ldr	r0, [sp, #0]
   1b036:	0980      	lsrs	r0, r0, #6
   1b038:	4005      	ands	r5, r0
   1b03a:	2d01      	cmp	r5, #1
   1b03c:	d111      	bne.n	1b062 <PE_StateMachine_VDM+0x2da>
   1b03e:	2000      	movs	r0, #0
   1b040:	9000      	str	r0, [sp, #0]
   1b042:	2300      	movs	r3, #0
   1b044:	2254      	movs	r2, #84	; 0x54
   1b046:	6920      	ldr	r0, [r4, #16]
   1b048:	2101      	movs	r1, #1
   1b04a:	4001      	ands	r1, r0
   1b04c:	2009      	movs	r0, #9
   1b04e:	4f62      	ldr	r7, [pc, #392]	; (1b1d8 <PE_StateMachine_VDM+0x450>)
   1b050:	6a3f      	ldr	r7, [r7, #32]
   1b052:	47b8      	blx	r7
   1b054:	2154      	movs	r1, #84	; 0x54
   1b056:	6920      	ldr	r0, [r4, #16]
   1b058:	4005      	ands	r5, r0
   1b05a:	0028      	movs	r0, r5
   1b05c:	68a2      	ldr	r2, [r4, #8]
   1b05e:	68d2      	ldr	r2, [r2, #12]
   1b060:	4790      	blx	r2
   1b062:	e237      	b.n	1b4d4 <PE_StateMachine_VDM+0x74c>
   1b064:	682a      	ldr	r2, [r5, #0]
   1b066:	4011      	ands	r1, r2
   1b068:	6029      	str	r1, [r5, #0]
   1b06a:	4008      	ands	r0, r1
   1b06c:	2104      	movs	r1, #4
   1b06e:	4301      	orrs	r1, r0
   1b070:	6029      	str	r1, [r5, #0]
   1b072:	8928      	ldrh	r0, [r5, #8]
   1b074:	b289      	uxth	r1, r1
   1b076:	0400      	lsls	r0, r0, #16
   1b078:	4308      	orrs	r0, r1
   1b07a:	6028      	str	r0, [r5, #0]
   1b07c:	03bb      	lsls	r3, r7, #14
   1b07e:	4303      	orrs	r3, r0
   1b080:	602b      	str	r3, [r5, #0]
   1b082:	2101      	movs	r1, #1
   1b084:	6860      	ldr	r0, [r4, #4]
   1b086:	6800      	ldr	r0, [r0, #0]
   1b088:	0942      	lsrs	r2, r0, #5
   1b08a:	400a      	ands	r2, r1
   1b08c:	480b      	ldr	r0, [pc, #44]	; (1b0bc <PE_StateMachine_VDM+0x334>)
   1b08e:	4018      	ands	r0, r3
   1b090:	0352      	lsls	r2, r2, #13
   1b092:	4302      	orrs	r2, r0
   1b094:	602a      	str	r2, [r5, #0]
   1b096:	6920      	ldr	r0, [r4, #16]
   1b098:	0600      	lsls	r0, r0, #24
   1b09a:	0f43      	lsrs	r3, r0, #29
   1b09c:	4808      	ldr	r0, [pc, #32]	; (1b0c0 <PE_StateMachine_VDM+0x338>)
   1b09e:	4010      	ands	r0, r2
   1b0a0:	021a      	lsls	r2, r3, #8
   1b0a2:	4302      	orrs	r2, r0
   1b0a4:	602a      	str	r2, [r5, #0]
   1b0a6:	6860      	ldr	r0, [r4, #4]
   1b0a8:	6800      	ldr	r0, [r0, #0]
   1b0aa:	0880      	lsrs	r0, r0, #2
   1b0ac:	4001      	ands	r1, r0
   1b0ae:	d009      	beq.n	1b0c4 <PE_StateMachine_VDM+0x33c>
   1b0b0:	6920      	ldr	r0, [r4, #16]
   1b0b2:	0781      	lsls	r1, r0, #30
   1b0b4:	0fc8      	lsrs	r0, r1, #31
   1b0b6:	e006      	b.n	1b0c6 <PE_StateMachine_VDM+0x33e>
   1b0b8:	0000028d 	.word	0x0000028d
   1b0bc:	ffff9fff 	.word	0xffff9fff
   1b0c0:	fffff8ff 	.word	0xfffff8ff
   1b0c4:	2002      	movs	r0, #2
   1b0c6:	9002      	str	r0, [sp, #8]
   1b0c8:	208c      	movs	r0, #140	; 0x8c
   1b0ca:	9001      	str	r0, [sp, #4]
   1b0cc:	2001      	movs	r0, #1
   1b0ce:	9000      	str	r0, [sp, #0]
   1b0d0:	002b      	movs	r3, r5
   1b0d2:	220f      	movs	r2, #15
   1b0d4:	79b1      	ldrb	r1, [r6, #6]
   1b0d6:	0020      	movs	r0, r4
   1b0d8:	f7ff fc4c 	bl	1a974 <PE_Send_DataMessage>
   1b0dc:	2800      	cmp	r0, #0
   1b0de:	d000      	beq.n	1b0e2 <PE_StateMachine_VDM+0x35a>
   1b0e0:	e22d      	b.n	1b53e <PE_StateMachine_VDM+0x7b6>
   1b0e2:	2082      	movs	r0, #130	; 0x82
   1b0e4:	0040      	lsls	r0, r0, #1
   1b0e6:	83a0      	strh	r0, [r4, #28]
   1b0e8:	2501      	movs	r5, #1
   1b0ea:	2000      	movs	r0, #0
   1b0ec:	9000      	str	r0, [sp, #0]
   1b0ee:	2300      	movs	r3, #0
   1b0f0:	2234      	movs	r2, #52	; 0x34
   1b0f2:	6920      	ldr	r0, [r4, #16]
   1b0f4:	2101      	movs	r1, #1
   1b0f6:	4001      	ands	r1, r0
   1b0f8:	2009      	movs	r0, #9
   1b0fa:	4e37      	ldr	r6, [pc, #220]	; (1b1d8 <PE_StateMachine_VDM+0x450>)
   1b0fc:	6a36      	ldr	r6, [r6, #32]
   1b0fe:	47b0      	blx	r6
   1b100:	2134      	movs	r1, #52	; 0x34
   1b102:	e0b7      	b.n	1b274 <PE_StateMachine_VDM+0x4ec>
   1b104:	2034      	movs	r0, #52	; 0x34
   1b106:	4669      	mov	r1, sp
   1b108:	7148      	strb	r0, [r1, #5]
   1b10a:	79b0      	ldrb	r0, [r6, #6]
   1b10c:	f000 faa3 	bl	1b656 <PE_Get_RxEvent>
   1b110:	9910      	ldr	r1, [sp, #64]	; 0x40
   1b112:	7809      	ldrb	r1, [r1, #0]
   1b114:	4281      	cmp	r1, r0
   1b116:	d11c      	bne.n	1b152 <PE_StateMachine_VDM+0x3ca>
   1b118:	20a5      	movs	r0, #165	; 0xa5
   1b11a:	0080      	lsls	r0, r0, #2
   1b11c:	1820      	adds	r0, r4, r0
   1b11e:	89c0      	ldrh	r0, [r0, #14]
   1b120:	0bc1      	lsrs	r1, r0, #15
   1b122:	d116      	bne.n	1b152 <PE_StateMachine_VDM+0x3ca>
   1b124:	0b01      	lsrs	r1, r0, #12
   1b126:	0749      	lsls	r1, r1, #29
   1b128:	d018      	beq.n	1b15c <PE_StateMachine_VDM+0x3d4>
   1b12a:	06c0      	lsls	r0, r0, #27
   1b12c:	0ec0      	lsrs	r0, r0, #27
   1b12e:	280f      	cmp	r0, #15
   1b130:	d10f      	bne.n	1b152 <PE_StateMachine_VDM+0x3ca>
   1b132:	2014      	movs	r0, #20
   1b134:	9910      	ldr	r1, [sp, #64]	; 0x40
   1b136:	7008      	strb	r0, [r1, #0]
   1b138:	7c21      	ldrb	r1, [r4, #16]
   1b13a:	07c8      	lsls	r0, r1, #31
   1b13c:	0fc0      	lsrs	r0, r0, #31
   1b13e:	f002 fb4c 	bl	1d7da <USBPD_PRL_EnableRX>
   1b142:	2000      	movs	r0, #0
   1b144:	83a0      	strh	r0, [r4, #28]
   1b146:	20a1      	movs	r0, #161	; 0xa1
   1b148:	0040      	lsls	r0, r0, #1
   1b14a:	5c20      	ldrb	r0, [r4, r0]
   1b14c:	06c1      	lsls	r1, r0, #27
   1b14e:	0ec9      	lsrs	r1, r1, #27
   1b150:	2904      	cmp	r1, #4
   1b152:	d000      	beq.n	1b156 <PE_StateMachine_VDM+0x3ce>
   1b154:	e0fa      	b.n	1b34c <PE_StateMachine_VDM+0x5c4>
   1b156:	0980      	lsrs	r0, r0, #6
   1b158:	2103      	movs	r1, #3
   1b15a:	4208      	tst	r0, r1
   1b15c:	d100      	bne.n	1b160 <PE_StateMachine_VDM+0x3d8>
   1b15e:	e0f5      	b.n	1b34c <PE_StateMachine_VDM+0x5c4>
   1b160:	4001      	ands	r1, r0
   1b162:	9102      	str	r1, [sp, #8]
   1b164:	2801      	cmp	r0, #1
   1b166:	d004      	beq.n	1b172 <PE_StateMachine_VDM+0x3ea>
   1b168:	d312      	bcc.n	1b190 <PE_StateMachine_VDM+0x408>
   1b16a:	2803      	cmp	r0, #3
   1b16c:	d009      	beq.n	1b182 <PE_StateMachine_VDM+0x3fa>
   1b16e:	d302      	bcc.n	1b176 <PE_StateMachine_VDM+0x3ee>
   1b170:	e00e      	b.n	1b190 <PE_StateMachine_VDM+0x408>
   1b172:	2035      	movs	r0, #53	; 0x35
   1b174:	e00a      	b.n	1b18c <PE_StateMachine_VDM+0x404>
   1b176:	6920      	ldr	r0, [r4, #16]
   1b178:	21e0      	movs	r1, #224	; 0xe0
   1b17a:	4388      	bics	r0, r1
   1b17c:	6120      	str	r0, [r4, #16]
   1b17e:	2036      	movs	r0, #54	; 0x36
   1b180:	e004      	b.n	1b18c <PE_StateMachine_VDM+0x404>
   1b182:	6920      	ldr	r0, [r4, #16]
   1b184:	21e0      	movs	r1, #224	; 0xe0
   1b186:	4388      	bics	r0, r1
   1b188:	6120      	str	r0, [r4, #16]
   1b18a:	2037      	movs	r0, #55	; 0x37
   1b18c:	4669      	mov	r1, sp
   1b18e:	7148      	strb	r0, [r1, #5]
   1b190:	2000      	movs	r0, #0
   1b192:	9000      	str	r0, [sp, #0]
   1b194:	2300      	movs	r3, #0
   1b196:	4668      	mov	r0, sp
   1b198:	7942      	ldrb	r2, [r0, #5]
   1b19a:	7c20      	ldrb	r0, [r4, #16]
   1b19c:	07c1      	lsls	r1, r0, #31
   1b19e:	0fc9      	lsrs	r1, r1, #31
   1b1a0:	2009      	movs	r0, #9
   1b1a2:	4f0d      	ldr	r7, [pc, #52]	; (1b1d8 <PE_StateMachine_VDM+0x450>)
   1b1a4:	6a3f      	ldr	r7, [r7, #32]
   1b1a6:	47b8      	blx	r7
   1b1a8:	4668      	mov	r0, sp
   1b1aa:	7941      	ldrb	r1, [r0, #5]
   1b1ac:	7c22      	ldrb	r2, [r4, #16]
   1b1ae:	07d0      	lsls	r0, r2, #31
   1b1b0:	0fc0      	lsrs	r0, r0, #31
   1b1b2:	68a2      	ldr	r2, [r4, #8]
   1b1b4:	68d2      	ldr	r2, [r2, #12]
   1b1b6:	4790      	blx	r2
   1b1b8:	68e0      	ldr	r0, [r4, #12]
   1b1ba:	6a07      	ldr	r7, [r0, #32]
   1b1bc:	2f00      	cmp	r7, #0
   1b1be:	d00a      	beq.n	1b1d6 <PE_StateMachine_VDM+0x44e>
   1b1c0:	6828      	ldr	r0, [r5, #0]
   1b1c2:	0541      	lsls	r1, r0, #21
   1b1c4:	0f49      	lsrs	r1, r1, #29
   1b1c6:	9100      	str	r1, [sp, #0]
   1b1c8:	0c03      	lsrs	r3, r0, #16
   1b1ca:	9a02      	ldr	r2, [sp, #8]
   1b1cc:	79b1      	ldrb	r1, [r6, #6]
   1b1ce:	7c25      	ldrb	r5, [r4, #16]
   1b1d0:	07e8      	lsls	r0, r5, #31
   1b1d2:	0fc0      	lsrs	r0, r0, #31
   1b1d4:	47b8      	blx	r7
   1b1d6:	e17d      	b.n	1b4d4 <PE_StateMachine_VDM+0x74c>
   1b1d8:	0002ff54 	.word	0x0002ff54
   1b1dc:	0000801e 	.word	0x0000801e
   1b1e0:	000002a2 	.word	0x000002a2
   1b1e4:	682a      	ldr	r2, [r5, #0]
   1b1e6:	4011      	ands	r1, r2
   1b1e8:	6029      	str	r1, [r5, #0]
   1b1ea:	4008      	ands	r0, r1
   1b1ec:	2105      	movs	r1, #5
   1b1ee:	4301      	orrs	r1, r0
   1b1f0:	6029      	str	r1, [r5, #0]
   1b1f2:	8928      	ldrh	r0, [r5, #8]
   1b1f4:	b289      	uxth	r1, r1
   1b1f6:	0400      	lsls	r0, r0, #16
   1b1f8:	4308      	orrs	r0, r1
   1b1fa:	6028      	str	r0, [r5, #0]
   1b1fc:	03bb      	lsls	r3, r7, #14
   1b1fe:	4303      	orrs	r3, r0
   1b200:	602b      	str	r3, [r5, #0]
   1b202:	2101      	movs	r1, #1
   1b204:	6860      	ldr	r0, [r4, #4]
   1b206:	6800      	ldr	r0, [r0, #0]
   1b208:	0942      	lsrs	r2, r0, #5
   1b20a:	400a      	ands	r2, r1
   1b20c:	48cd      	ldr	r0, [pc, #820]	; (1b544 <.text_86>)
   1b20e:	4018      	ands	r0, r3
   1b210:	0352      	lsls	r2, r2, #13
   1b212:	4302      	orrs	r2, r0
   1b214:	602a      	str	r2, [r5, #0]
   1b216:	6920      	ldr	r0, [r4, #16]
   1b218:	0600      	lsls	r0, r0, #24
   1b21a:	0f43      	lsrs	r3, r0, #29
   1b21c:	48ca      	ldr	r0, [pc, #808]	; (1b548 <.text_87>)
   1b21e:	4010      	ands	r0, r2
   1b220:	021a      	lsls	r2, r3, #8
   1b222:	4302      	orrs	r2, r0
   1b224:	602a      	str	r2, [r5, #0]
   1b226:	6860      	ldr	r0, [r4, #4]
   1b228:	6800      	ldr	r0, [r0, #0]
   1b22a:	0880      	lsrs	r0, r0, #2
   1b22c:	4001      	ands	r1, r0
   1b22e:	d003      	beq.n	1b238 <PE_StateMachine_VDM+0x4b0>
   1b230:	6920      	ldr	r0, [r4, #16]
   1b232:	0781      	lsls	r1, r0, #30
   1b234:	0fc8      	lsrs	r0, r1, #31
   1b236:	e000      	b.n	1b23a <PE_StateMachine_VDM+0x4b2>
   1b238:	2002      	movs	r0, #2
   1b23a:	9002      	str	r0, [sp, #8]
   1b23c:	208d      	movs	r0, #141	; 0x8d
   1b23e:	9001      	str	r0, [sp, #4]
   1b240:	2001      	movs	r0, #1
   1b242:	9000      	str	r0, [sp, #0]
   1b244:	002b      	movs	r3, r5
   1b246:	220f      	movs	r2, #15
   1b248:	79b1      	ldrb	r1, [r6, #6]
   1b24a:	0020      	movs	r0, r4
   1b24c:	f7ff fb92 	bl	1a974 <PE_Send_DataMessage>
   1b250:	2800      	cmp	r0, #0
   1b252:	d11a      	bne.n	1b28a <PE_StateMachine_VDM+0x502>
   1b254:	20ff      	movs	r0, #255	; 0xff
   1b256:	1d80      	adds	r0, r0, #6
   1b258:	83a0      	strh	r0, [r4, #28]
   1b25a:	2501      	movs	r5, #1
   1b25c:	2000      	movs	r0, #0
   1b25e:	9000      	str	r0, [sp, #0]
   1b260:	2300      	movs	r3, #0
   1b262:	2255      	movs	r2, #85	; 0x55
   1b264:	6920      	ldr	r0, [r4, #16]
   1b266:	2101      	movs	r1, #1
   1b268:	4001      	ands	r1, r0
   1b26a:	2009      	movs	r0, #9
   1b26c:	4eb7      	ldr	r6, [pc, #732]	; (1b54c <.text_88>)
   1b26e:	6a36      	ldr	r6, [r6, #32]
   1b270:	47b0      	blx	r6
   1b272:	2155      	movs	r1, #85	; 0x55
   1b274:	6920      	ldr	r0, [r4, #16]
   1b276:	4005      	ands	r5, r0
   1b278:	0028      	movs	r0, r5
   1b27a:	68a2      	ldr	r2, [r4, #8]
   1b27c:	68d2      	ldr	r2, [r2, #12]
   1b27e:	4790      	blx	r2
   1b280:	48b3      	ldr	r0, [pc, #716]	; (1b550 <.text_89>)
   1b282:	21a5      	movs	r1, #165	; 0xa5
   1b284:	0089      	lsls	r1, r1, #2
   1b286:	5260      	strh	r0, [r4, r1]
   1b288:	2732      	movs	r7, #50	; 0x32
   1b28a:	e158      	b.n	1b53e <PE_StateMachine_VDM+0x7b6>
   1b28c:	2055      	movs	r0, #85	; 0x55
   1b28e:	4669      	mov	r1, sp
   1b290:	7148      	strb	r0, [r1, #5]
   1b292:	79b0      	ldrb	r0, [r6, #6]
   1b294:	f000 f9df 	bl	1b656 <PE_Get_RxEvent>
   1b298:	9910      	ldr	r1, [sp, #64]	; 0x40
   1b29a:	7809      	ldrb	r1, [r1, #0]
   1b29c:	4281      	cmp	r1, r0
   1b29e:	d155      	bne.n	1b34c <PE_StateMachine_VDM+0x5c4>
   1b2a0:	20a5      	movs	r0, #165	; 0xa5
   1b2a2:	0080      	lsls	r0, r0, #2
   1b2a4:	1820      	adds	r0, r4, r0
   1b2a6:	89c0      	ldrh	r0, [r0, #14]
   1b2a8:	0bc1      	lsrs	r1, r0, #15
   1b2aa:	d14f      	bne.n	1b34c <PE_StateMachine_VDM+0x5c4>
   1b2ac:	0b01      	lsrs	r1, r0, #12
   1b2ae:	0749      	lsls	r1, r1, #29
   1b2b0:	d04c      	beq.n	1b34c <PE_StateMachine_VDM+0x5c4>
   1b2b2:	06c0      	lsls	r0, r0, #27
   1b2b4:	0ec0      	lsrs	r0, r0, #27
   1b2b6:	280f      	cmp	r0, #15
   1b2b8:	d148      	bne.n	1b34c <PE_StateMachine_VDM+0x5c4>
   1b2ba:	2014      	movs	r0, #20
   1b2bc:	9910      	ldr	r1, [sp, #64]	; 0x40
   1b2be:	7008      	strb	r0, [r1, #0]
   1b2c0:	7c21      	ldrb	r1, [r4, #16]
   1b2c2:	07c8      	lsls	r0, r1, #31
   1b2c4:	0fc0      	lsrs	r0, r0, #31
   1b2c6:	f002 fa88 	bl	1d7da <USBPD_PRL_EnableRX>
   1b2ca:	2000      	movs	r0, #0
   1b2cc:	83a0      	strh	r0, [r4, #28]
   1b2ce:	20a1      	movs	r0, #161	; 0xa1
   1b2d0:	0040      	lsls	r0, r0, #1
   1b2d2:	5c20      	ldrb	r0, [r4, r0]
   1b2d4:	06c1      	lsls	r1, r0, #27
   1b2d6:	0ec9      	lsrs	r1, r1, #27
   1b2d8:	2905      	cmp	r1, #5
   1b2da:	d137      	bne.n	1b34c <PE_StateMachine_VDM+0x5c4>
   1b2dc:	0980      	lsrs	r0, r0, #6
   1b2de:	2103      	movs	r1, #3
   1b2e0:	4208      	tst	r0, r1
   1b2e2:	d033      	beq.n	1b34c <PE_StateMachine_VDM+0x5c4>
   1b2e4:	4001      	ands	r1, r0
   1b2e6:	9102      	str	r1, [sp, #8]
   1b2e8:	2801      	cmp	r0, #1
   1b2ea:	d004      	beq.n	1b2f6 <PE_StateMachine_VDM+0x56e>
   1b2ec:	d30a      	bcc.n	1b304 <PE_StateMachine_VDM+0x57c>
   1b2ee:	2803      	cmp	r0, #3
   1b2f0:	d005      	beq.n	1b2fe <PE_StateMachine_VDM+0x576>
   1b2f2:	d302      	bcc.n	1b2fa <PE_StateMachine_VDM+0x572>
   1b2f4:	e006      	b.n	1b304 <PE_StateMachine_VDM+0x57c>
   1b2f6:	2056      	movs	r0, #86	; 0x56
   1b2f8:	e002      	b.n	1b300 <PE_StateMachine_VDM+0x578>
   1b2fa:	2057      	movs	r0, #87	; 0x57
   1b2fc:	e000      	b.n	1b300 <PE_StateMachine_VDM+0x578>
   1b2fe:	2058      	movs	r0, #88	; 0x58
   1b300:	4669      	mov	r1, sp
   1b302:	7148      	strb	r0, [r1, #5]
   1b304:	2000      	movs	r0, #0
   1b306:	9000      	str	r0, [sp, #0]
   1b308:	2300      	movs	r3, #0
   1b30a:	4668      	mov	r0, sp
   1b30c:	7942      	ldrb	r2, [r0, #5]
   1b30e:	7c20      	ldrb	r0, [r4, #16]
   1b310:	07c1      	lsls	r1, r0, #31
   1b312:	0fc9      	lsrs	r1, r1, #31
   1b314:	2009      	movs	r0, #9
   1b316:	4f8d      	ldr	r7, [pc, #564]	; (1b54c <.text_88>)
   1b318:	6a3f      	ldr	r7, [r7, #32]
   1b31a:	47b8      	blx	r7
   1b31c:	4668      	mov	r0, sp
   1b31e:	7941      	ldrb	r1, [r0, #5]
   1b320:	7c22      	ldrb	r2, [r4, #16]
   1b322:	07d0      	lsls	r0, r2, #31
   1b324:	0fc0      	lsrs	r0, r0, #31
   1b326:	68a2      	ldr	r2, [r4, #8]
   1b328:	68d2      	ldr	r2, [r2, #12]
   1b32a:	4790      	blx	r2
   1b32c:	68e0      	ldr	r0, [r4, #12]
   1b32e:	6a47      	ldr	r7, [r0, #36]	; 0x24
   1b330:	2f00      	cmp	r7, #0
   1b332:	d00a      	beq.n	1b34a <PE_StateMachine_VDM+0x5c2>
   1b334:	6828      	ldr	r0, [r5, #0]
   1b336:	0541      	lsls	r1, r0, #21
   1b338:	0f49      	lsrs	r1, r1, #29
   1b33a:	9100      	str	r1, [sp, #0]
   1b33c:	0c03      	lsrs	r3, r0, #16
   1b33e:	9a02      	ldr	r2, [sp, #8]
   1b340:	79b1      	ldrb	r1, [r6, #6]
   1b342:	7c25      	ldrb	r5, [r4, #16]
   1b344:	07e8      	lsls	r0, r5, #31
   1b346:	0fc0      	lsrs	r0, r0, #31
   1b348:	47b8      	blx	r7
   1b34a:	e0c3      	b.n	1b4d4 <PE_StateMachine_VDM+0x74c>
   1b34c:	20a5      	movs	r0, #165	; 0xa5
   1b34e:	0080      	lsls	r0, r0, #2
   1b350:	1820      	adds	r0, r4, r0
   1b352:	7b81      	ldrb	r1, [r0, #14]
   1b354:	06c9      	lsls	r1, r1, #27
   1b356:	0ec9      	lsrs	r1, r1, #27
   1b358:	2910      	cmp	r1, #16
   1b35a:	d100      	bne.n	1b35e <PE_StateMachine_VDM+0x5d6>
   1b35c:	e0c7      	b.n	1b4ee <PE_StateMachine_VDM+0x766>
   1b35e:	8800      	ldrh	r0, [r0, #0]
   1b360:	03b9      	lsls	r1, r7, #14
   1b362:	4288      	cmp	r0, r1
   1b364:	d15c      	bne.n	1b420 <PE_StateMachine_VDM+0x698>
   1b366:	e0e7      	b.n	1b538 <PE_StateMachine_VDM+0x7b0>
   1b368:	2200      	movs	r2, #0
   1b36a:	466b      	mov	r3, sp
   1b36c:	731a      	strb	r2, [r3, #12]
   1b36e:	682a      	ldr	r2, [r5, #0]
   1b370:	4011      	ands	r1, r2
   1b372:	6029      	str	r1, [r5, #0]
   1b374:	686a      	ldr	r2, [r5, #4]
   1b376:	4008      	ands	r0, r1
   1b378:	06d1      	lsls	r1, r2, #27
   1b37a:	0ec9      	lsrs	r1, r1, #27
   1b37c:	4301      	orrs	r1, r0
   1b37e:	6029      	str	r1, [r5, #0]
   1b380:	8928      	ldrh	r0, [r5, #8]
   1b382:	b28a      	uxth	r2, r1
   1b384:	0401      	lsls	r1, r0, #16
   1b386:	4311      	orrs	r1, r2
   1b388:	6029      	str	r1, [r5, #0]
   1b38a:	03b8      	lsls	r0, r7, #14
   1b38c:	4308      	orrs	r0, r1
   1b38e:	6028      	str	r0, [r5, #0]
   1b390:	6861      	ldr	r1, [r4, #4]
   1b392:	680a      	ldr	r2, [r1, #0]
   1b394:	0691      	lsls	r1, r2, #26
   1b396:	0fc9      	lsrs	r1, r1, #31
   1b398:	4a6a      	ldr	r2, [pc, #424]	; (1b544 <.text_86>)
   1b39a:	4002      	ands	r2, r0
   1b39c:	0348      	lsls	r0, r1, #13
   1b39e:	4310      	orrs	r0, r2
   1b3a0:	6028      	str	r0, [r5, #0]
   1b3a2:	4969      	ldr	r1, [pc, #420]	; (1b548 <.text_87>)
   1b3a4:	4001      	ands	r1, r0
   1b3a6:	01f8      	lsls	r0, r7, #7
   1b3a8:	4308      	orrs	r0, r1
   1b3aa:	6028      	str	r0, [r5, #0]
   1b3ac:	9004      	str	r0, [sp, #16]
   1b3ae:	68e0      	ldr	r0, [r4, #12]
   1b3b0:	6b00      	ldr	r0, [r0, #48]	; 0x30
   1b3b2:	9001      	str	r0, [sp, #4]
   1b3b4:	2800      	cmp	r0, #0
   1b3b6:	d00c      	beq.n	1b3d2 <PE_StateMachine_VDM+0x64a>
   1b3b8:	a804      	add	r0, sp, #16
   1b3ba:	1d00      	adds	r0, r0, #4
   1b3bc:	9000      	str	r0, [sp, #0]
   1b3be:	ab03      	add	r3, sp, #12
   1b3c0:	7828      	ldrb	r0, [r5, #0]
   1b3c2:	06c2      	lsls	r2, r0, #27
   1b3c4:	0ed2      	lsrs	r2, r2, #27
   1b3c6:	79b1      	ldrb	r1, [r6, #6]
   1b3c8:	7c25      	ldrb	r5, [r4, #16]
   1b3ca:	07e8      	lsls	r0, r5, #31
   1b3cc:	0fc0      	lsrs	r0, r0, #31
   1b3ce:	9d01      	ldr	r5, [sp, #4]
   1b3d0:	47a8      	blx	r5
   1b3d2:	4668      	mov	r0, sp
   1b3d4:	7b00      	ldrb	r0, [r0, #12]
   1b3d6:	1c40      	adds	r0, r0, #1
   1b3d8:	4669      	mov	r1, sp
   1b3da:	7308      	strb	r0, [r1, #12]
   1b3dc:	6860      	ldr	r0, [r4, #4]
   1b3de:	6800      	ldr	r0, [r0, #0]
   1b3e0:	0741      	lsls	r1, r0, #29
   1b3e2:	0fc9      	lsrs	r1, r1, #31
   1b3e4:	d003      	beq.n	1b3ee <PE_StateMachine_VDM+0x666>
   1b3e6:	6920      	ldr	r0, [r4, #16]
   1b3e8:	0781      	lsls	r1, r0, #30
   1b3ea:	0fc8      	lsrs	r0, r1, #31
   1b3ec:	e000      	b.n	1b3f0 <PE_StateMachine_VDM+0x668>
   1b3ee:	2002      	movs	r0, #2
   1b3f0:	9002      	str	r0, [sp, #8]
   1b3f2:	208f      	movs	r0, #143	; 0x8f
   1b3f4:	9001      	str	r0, [sp, #4]
   1b3f6:	4668      	mov	r0, sp
   1b3f8:	7b00      	ldrb	r0, [r0, #12]
   1b3fa:	9000      	str	r0, [sp, #0]
   1b3fc:	ab04      	add	r3, sp, #16
   1b3fe:	220f      	movs	r2, #15
   1b400:	79b1      	ldrb	r1, [r6, #6]
   1b402:	0020      	movs	r0, r4
   1b404:	f7ff fab6 	bl	1a974 <PE_Send_DataMessage>
   1b408:	2800      	cmp	r0, #0
   1b40a:	d107      	bne.n	1b41c <PE_StateMachine_VDM+0x694>
   1b40c:	2085      	movs	r0, #133	; 0x85
   1b40e:	0040      	lsls	r0, r0, #1
   1b410:	83a0      	strh	r0, [r4, #28]
   1b412:	48ba      	ldr	r0, [pc, #744]	; (1b6fc <.text_96>)
   1b414:	21a5      	movs	r1, #165	; 0xa5
   1b416:	0089      	lsls	r1, r1, #2
   1b418:	5260      	strh	r0, [r4, r1]
   1b41a:	271e      	movs	r7, #30
   1b41c:	2000      	movs	r0, #0
   1b41e:	7030      	strb	r0, [r6, #0]
   1b420:	e08d      	b.n	1b53e <PE_StateMachine_VDM+0x7b6>
   1b422:	20a5      	movs	r0, #165	; 0xa5
   1b424:	0080      	lsls	r0, r0, #2
   1b426:	1820      	adds	r0, r4, r0
   1b428:	89c0      	ldrh	r0, [r0, #14]
   1b42a:	0440      	lsls	r0, r0, #17
   1b42c:	0f40      	lsrs	r0, r0, #29
   1b42e:	1e40      	subs	r0, r0, #1
   1b430:	4669      	mov	r1, sp
   1b432:	7108      	strb	r0, [r1, #4]
   1b434:	79b0      	ldrb	r0, [r6, #6]
   1b436:	f000 f90e 	bl	1b656 <PE_Get_RxEvent>
   1b43a:	9910      	ldr	r1, [sp, #64]	; 0x40
   1b43c:	7809      	ldrb	r1, [r1, #0]
   1b43e:	4281      	cmp	r1, r0
   1b440:	d14d      	bne.n	1b4de <PE_StateMachine_VDM+0x756>
   1b442:	20a5      	movs	r0, #165	; 0xa5
   1b444:	0080      	lsls	r0, r0, #2
   1b446:	1820      	adds	r0, r4, r0
   1b448:	89c0      	ldrh	r0, [r0, #14]
   1b44a:	0bc1      	lsrs	r1, r0, #15
   1b44c:	d147      	bne.n	1b4de <PE_StateMachine_VDM+0x756>
   1b44e:	0b01      	lsrs	r1, r0, #12
   1b450:	0749      	lsls	r1, r1, #29
   1b452:	d044      	beq.n	1b4de <PE_StateMachine_VDM+0x756>
   1b454:	06c0      	lsls	r0, r0, #27
   1b456:	0ec0      	lsrs	r0, r0, #27
   1b458:	280f      	cmp	r0, #15
   1b45a:	d140      	bne.n	1b4de <PE_StateMachine_VDM+0x756>
   1b45c:	2014      	movs	r0, #20
   1b45e:	9910      	ldr	r1, [sp, #64]	; 0x40
   1b460:	7008      	strb	r0, [r1, #0]
   1b462:	7c21      	ldrb	r1, [r4, #16]
   1b464:	07c8      	lsls	r0, r1, #31
   1b466:	0fc0      	lsrs	r0, r0, #31
   1b468:	f002 f9b7 	bl	1d7da <USBPD_PRL_EnableRX>
   1b46c:	20a1      	movs	r0, #161	; 0xa1
   1b46e:	0040      	lsls	r0, r0, #1
   1b470:	5c20      	ldrb	r0, [r4, r0]
   1b472:	211f      	movs	r1, #31
   1b474:	221f      	movs	r2, #31
   1b476:	4002      	ands	r2, r0
   1b478:	686b      	ldr	r3, [r5, #4]
   1b47a:	429a      	cmp	r2, r3
   1b47c:	d12f      	bne.n	1b4de <PE_StateMachine_VDM+0x756>
   1b47e:	0982      	lsrs	r2, r0, #6
   1b480:	d02d      	beq.n	1b4de <PE_StateMachine_VDM+0x756>
   1b482:	68e2      	ldr	r2, [r4, #12]
   1b484:	6b92      	ldr	r2, [r2, #56]	; 0x38
   1b486:	2a00      	cmp	r2, #0
   1b488:	d024      	beq.n	1b4d4 <PE_StateMachine_VDM+0x74c>
   1b48a:	2200      	movs	r2, #0
   1b48c:	e012      	b.n	1b4b4 <PE_StateMachine_VDM+0x72c>
   1b48e:	0093      	lsls	r3, r2, #2
   1b490:	18e3      	adds	r3, r4, r3
   1b492:	25a3      	movs	r5, #163	; 0xa3
   1b494:	006d      	lsls	r5, r5, #1
   1b496:	195b      	adds	r3, r3, r5
   1b498:	781d      	ldrb	r5, [r3, #0]
   1b49a:	785f      	ldrb	r7, [r3, #1]
   1b49c:	023f      	lsls	r7, r7, #8
   1b49e:	19ed      	adds	r5, r5, r7
   1b4a0:	789f      	ldrb	r7, [r3, #2]
   1b4a2:	043f      	lsls	r7, r7, #16
   1b4a4:	19ed      	adds	r5, r5, r7
   1b4a6:	78db      	ldrb	r3, [r3, #3]
   1b4a8:	061b      	lsls	r3, r3, #24
   1b4aa:	18eb      	adds	r3, r5, r3
   1b4ac:	ad0a      	add	r5, sp, #40	; 0x28
   1b4ae:	0097      	lsls	r7, r2, #2
   1b4b0:	51eb      	str	r3, [r5, r7]
   1b4b2:	1c52      	adds	r2, r2, #1
   1b4b4:	466b      	mov	r3, sp
   1b4b6:	791b      	ldrb	r3, [r3, #4]
   1b4b8:	429a      	cmp	r2, r3
   1b4ba:	d3e8      	bcc.n	1b48e <PE_StateMachine_VDM+0x706>
   1b4bc:	aa0a      	add	r2, sp, #40	; 0x28
   1b4be:	9200      	str	r2, [sp, #0]
   1b4c0:	ab01      	add	r3, sp, #4
   1b4c2:	4001      	ands	r1, r0
   1b4c4:	000a      	movs	r2, r1
   1b4c6:	79b1      	ldrb	r1, [r6, #6]
   1b4c8:	7c25      	ldrb	r5, [r4, #16]
   1b4ca:	07e8      	lsls	r0, r5, #31
   1b4cc:	0fc0      	lsrs	r0, r0, #31
   1b4ce:	68e5      	ldr	r5, [r4, #12]
   1b4d0:	6bad      	ldr	r5, [r5, #56]	; 0x38
   1b4d2:	47a8      	blx	r5
   1b4d4:	2000      	movs	r0, #0
   1b4d6:	21a5      	movs	r1, #165	; 0xa5
   1b4d8:	0089      	lsls	r1, r1, #2
   1b4da:	5260      	strh	r0, [r4, r1]
   1b4dc:	e02c      	b.n	1b538 <PE_StateMachine_VDM+0x7b0>
   1b4de:	20a5      	movs	r0, #165	; 0xa5
   1b4e0:	0080      	lsls	r0, r0, #2
   1b4e2:	1820      	adds	r0, r4, r0
   1b4e4:	7b81      	ldrb	r1, [r0, #14]
   1b4e6:	06c9      	lsls	r1, r1, #27
   1b4e8:	0ec9      	lsrs	r1, r1, #27
   1b4ea:	2910      	cmp	r1, #16
   1b4ec:	d120      	bne.n	1b530 <PE_StateMachine_VDM+0x7a8>
   1b4ee:	2014      	movs	r0, #20
   1b4f0:	9910      	ldr	r1, [sp, #64]	; 0x40
   1b4f2:	7008      	strb	r0, [r1, #0]
   1b4f4:	2501      	movs	r5, #1
   1b4f6:	6921      	ldr	r1, [r4, #16]
   1b4f8:	2001      	movs	r0, #1
   1b4fa:	4008      	ands	r0, r1
   1b4fc:	f002 f96d 	bl	1d7da <USBPD_PRL_EnableRX>
   1b500:	2700      	movs	r7, #0
   1b502:	21a5      	movs	r1, #165	; 0xa5
   1b504:	0089      	lsls	r1, r1, #2
   1b506:	5267      	strh	r7, [r4, r1]
   1b508:	2003      	movs	r0, #3
   1b50a:	70f0      	strb	r0, [r6, #3]
   1b50c:	9700      	str	r7, [sp, #0]
   1b50e:	2300      	movs	r3, #0
   1b510:	2259      	movs	r2, #89	; 0x59
   1b512:	6920      	ldr	r0, [r4, #16]
   1b514:	2101      	movs	r1, #1
   1b516:	4001      	ands	r1, r0
   1b518:	2009      	movs	r0, #9
   1b51a:	4e0c      	ldr	r6, [pc, #48]	; (1b54c <.text_88>)
   1b51c:	6a36      	ldr	r6, [r6, #32]
   1b51e:	47b0      	blx	r6
   1b520:	2159      	movs	r1, #89	; 0x59
   1b522:	6920      	ldr	r0, [r4, #16]
   1b524:	4005      	ands	r5, r0
   1b526:	0028      	movs	r0, r5
   1b528:	68a2      	ldr	r2, [r4, #8]
   1b52a:	68d2      	ldr	r2, [r2, #12]
   1b52c:	4790      	blx	r2
   1b52e:	e006      	b.n	1b53e <PE_StateMachine_VDM+0x7b6>
   1b530:	8800      	ldrh	r0, [r0, #0]
   1b532:	03b9      	lsls	r1, r7, #14
   1b534:	4288      	cmp	r0, r1
   1b536:	d102      	bne.n	1b53e <PE_StateMachine_VDM+0x7b6>
   1b538:	2003      	movs	r0, #3
   1b53a:	70f0      	strb	r0, [r6, #3]
   1b53c:	2700      	movs	r7, #0
   1b53e:	0038      	movs	r0, r7
   1b540:	b011      	add	sp, #68	; 0x44
   1b542:	bdf0      	pop	{r4, r5, r6, r7, pc}

0001b544 <.text_86>:
   1b544:	ffff9fff 	.word	0xffff9fff

0001b548 <.text_87>:
   1b548:	fffff8ff 	.word	0xfffff8ff

0001b54c <.text_88>:
   1b54c:	0002ff54 	.word	0x0002ff54

0001b550 <.text_89>:
   1b550:	00008032 	.word	0x00008032

0001b554 <PE_StateMachine_UVDM>:
   1b554:	2914      	cmp	r1, #20
   1b556:	d000      	beq.n	1b55a <PE_StateMachine_UVDM+0x6>
   1b558:	4770      	bx	lr
   1b55a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1b55c:	b08c      	sub	sp, #48	; 0x30
   1b55e:	0006      	movs	r6, r0
   1b560:	68f0      	ldr	r0, [r6, #12]
   1b562:	2800      	cmp	r0, #0
   1b564:	d039      	beq.n	1b5da <PE_StateMachine_UVDM+0x86>
   1b566:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
   1b568:	2800      	cmp	r0, #0
   1b56a:	d036      	beq.n	1b5da <PE_StateMachine_UVDM+0x86>
   1b56c:	2500      	movs	r5, #0
   1b56e:	4669      	mov	r1, sp
   1b570:	730d      	strb	r5, [r1, #12]
   1b572:	2401      	movs	r4, #1
   1b574:	a805      	add	r0, sp, #20
   1b576:	1d03      	adds	r3, r0, #4
   1b578:	aa03      	add	r2, sp, #12
   1b57a:	a904      	add	r1, sp, #16
   1b57c:	6937      	ldr	r7, [r6, #16]
   1b57e:	2001      	movs	r0, #1
   1b580:	4038      	ands	r0, r7
   1b582:	68f7      	ldr	r7, [r6, #12]
   1b584:	6bff      	ldr	r7, [r7, #60]	; 0x3c
   1b586:	47b8      	blx	r7
   1b588:	9804      	ldr	r0, [sp, #16]
   1b58a:	495d      	ldr	r1, [pc, #372]	; (1b700 <.text_97>)
   1b58c:	4001      	ands	r1, r0
   1b58e:	9104      	str	r1, [sp, #16]
   1b590:	4668      	mov	r0, sp
   1b592:	7b00      	ldrb	r0, [r0, #12]
   1b594:	1c40      	adds	r0, r0, #1
   1b596:	4669      	mov	r1, sp
   1b598:	7308      	strb	r0, [r1, #12]
   1b59a:	9804      	ldr	r0, [sp, #16]
   1b59c:	9005      	str	r0, [sp, #20]
   1b59e:	6870      	ldr	r0, [r6, #4]
   1b5a0:	6800      	ldr	r0, [r0, #0]
   1b5a2:	0880      	lsrs	r0, r0, #2
   1b5a4:	4004      	ands	r4, r0
   1b5a6:	d003      	beq.n	1b5b0 <PE_StateMachine_UVDM+0x5c>
   1b5a8:	6930      	ldr	r0, [r6, #16]
   1b5aa:	0781      	lsls	r1, r0, #30
   1b5ac:	0fc8      	lsrs	r0, r1, #31
   1b5ae:	e000      	b.n	1b5b2 <PE_StateMachine_UVDM+0x5e>
   1b5b0:	2002      	movs	r0, #2
   1b5b2:	4954      	ldr	r1, [pc, #336]	; (1b704 <.text_98>)
   1b5b4:	1874      	adds	r4, r6, r1
   1b5b6:	9002      	str	r0, [sp, #8]
   1b5b8:	2003      	movs	r0, #3
   1b5ba:	9001      	str	r0, [sp, #4]
   1b5bc:	4668      	mov	r0, sp
   1b5be:	7b00      	ldrb	r0, [r0, #12]
   1b5c0:	9000      	str	r0, [sp, #0]
   1b5c2:	ab05      	add	r3, sp, #20
   1b5c4:	220f      	movs	r2, #15
   1b5c6:	79a1      	ldrb	r1, [r4, #6]
   1b5c8:	0030      	movs	r0, r6
   1b5ca:	f7ff f9d3 	bl	1a974 <PE_Send_DataMessage>
   1b5ce:	2800      	cmp	r0, #0
   1b5d0:	d102      	bne.n	1b5d8 <PE_StateMachine_UVDM+0x84>
   1b5d2:	20ff      	movs	r0, #255	; 0xff
   1b5d4:	300a      	adds	r0, #10
   1b5d6:	83b0      	strh	r0, [r6, #28]
   1b5d8:	7025      	strb	r5, [r4, #0]
   1b5da:	b00d      	add	sp, #52	; 0x34
   1b5dc:	bdf0      	pop	{r4, r5, r6, r7, pc}

0001b5de <PE_Get_SpecRevision>:
   1b5de:	494a      	ldr	r1, [pc, #296]	; (1b708 <.text_99>)
   1b5e0:	0080      	lsls	r0, r0, #2
   1b5e2:	5808      	ldr	r0, [r1, r0]
   1b5e4:	6840      	ldr	r0, [r0, #4]
   1b5e6:	7800      	ldrb	r0, [r0, #0]
   1b5e8:	0780      	lsls	r0, r0, #30
   1b5ea:	0f80      	lsrs	r0, r0, #30
   1b5ec:	4770      	bx	lr

0001b5ee <PE_ChangePowerRole>:
   1b5ee:	b538      	push	{r3, r4, r5, lr}
   1b5f0:	6842      	ldr	r2, [r0, #4]
   1b5f2:	6813      	ldr	r3, [r2, #0]
   1b5f4:	2404      	movs	r4, #4
   1b5f6:	43a3      	bics	r3, r4
   1b5f8:	008c      	lsls	r4, r1, #2
   1b5fa:	2504      	movs	r5, #4
   1b5fc:	402c      	ands	r4, r5
   1b5fe:	431c      	orrs	r4, r3
   1b600:	6014      	str	r4, [r2, #0]
   1b602:	7c02      	ldrb	r2, [r0, #16]
   1b604:	07d0      	lsls	r0, r2, #31
   1b606:	0fc0      	lsrs	r0, r0, #31
   1b608:	f001 fee7 	bl	1d3da <USBPD_PRL_SetHeaderPowerRole>
   1b60c:	bd31      	pop	{r0, r4, r5, pc}

0001b60e <PE_Check_RxEvent>:
   1b60e:	b081      	sub	sp, #4
   1b610:	0001      	movs	r1, r0
   1b612:	2014      	movs	r0, #20
   1b614:	4a3d      	ldr	r2, [pc, #244]	; (1b70c <.text_100>)
   1b616:	1889      	adds	r1, r1, r2
   1b618:	780a      	ldrb	r2, [r1, #0]
   1b61a:	2a00      	cmp	r2, #0
   1b61c:	d019      	beq.n	1b652 <PE_Check_RxEvent+0x44>
   1b61e:	780a      	ldrb	r2, [r1, #0]
   1b620:	0692      	lsls	r2, r2, #26
   1b622:	d401      	bmi.n	1b628 <PE_Check_RxEvent+0x1a>
   1b624:	2003      	movs	r0, #3
   1b626:	e014      	b.n	1b652 <PE_Check_RxEvent+0x44>
   1b628:	2200      	movs	r2, #0
   1b62a:	780b      	ldrb	r3, [r1, #0]
   1b62c:	06db      	lsls	r3, r3, #27
   1b62e:	0edb      	lsrs	r3, r3, #27
   1b630:	2b01      	cmp	r3, #1
   1b632:	d004      	beq.n	1b63e <PE_Check_RxEvent+0x30>
   1b634:	2b02      	cmp	r3, #2
   1b636:	d005      	beq.n	1b644 <PE_Check_RxEvent+0x36>
   1b638:	2b04      	cmp	r3, #4
   1b63a:	d006      	beq.n	1b64a <PE_Check_RxEvent+0x3c>
   1b63c:	e008      	b.n	1b650 <PE_Check_RxEvent+0x42>
   1b63e:	2011      	movs	r0, #17
   1b640:	70ca      	strb	r2, [r1, #3]
   1b642:	e005      	b.n	1b650 <PE_Check_RxEvent+0x42>
   1b644:	2012      	movs	r0, #18
   1b646:	2301      	movs	r3, #1
   1b648:	e001      	b.n	1b64e <PE_Check_RxEvent+0x40>
   1b64a:	2013      	movs	r0, #19
   1b64c:	2302      	movs	r3, #2
   1b64e:	70cb      	strb	r3, [r1, #3]
   1b650:	700a      	strb	r2, [r1, #0]
   1b652:	b001      	add	sp, #4
   1b654:	4770      	bx	lr

0001b656 <PE_Get_RxEvent>:
   1b656:	0001      	movs	r1, r0
   1b658:	2014      	movs	r0, #20
   1b65a:	2900      	cmp	r1, #0
   1b65c:	d003      	beq.n	1b666 <PE_Get_RxEvent+0x10>
   1b65e:	2902      	cmp	r1, #2
   1b660:	d005      	beq.n	1b66e <PE_Get_RxEvent+0x18>
   1b662:	d302      	bcc.n	1b66a <PE_Get_RxEvent+0x14>
   1b664:	4770      	bx	lr
   1b666:	2011      	movs	r0, #17
   1b668:	4770      	bx	lr
   1b66a:	2012      	movs	r0, #18
   1b66c:	4770      	bx	lr
   1b66e:	2013      	movs	r0, #19
   1b670:	4770      	bx	lr

0001b672 <PE_Check_AMSConflict>:
   1b672:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1b674:	0005      	movs	r5, r0
   1b676:	2400      	movs	r4, #0
   1b678:	20a4      	movs	r0, #164	; 0xa4
   1b67a:	0080      	lsls	r0, r0, #2
   1b67c:	182e      	adds	r6, r5, r0
   1b67e:	8a70      	ldrh	r0, [r6, #18]
   1b680:	4923      	ldr	r1, [pc, #140]	; (1b710 <.text_101>)
   1b682:	4001      	ands	r1, r0
   1b684:	290d      	cmp	r1, #13
   1b686:	d103      	bne.n	1b690 <PE_Check_AMSConflict+0x1e>
   1b688:	2010      	movs	r0, #16
   1b68a:	7030      	strb	r0, [r6, #0]
   1b68c:	2015      	movs	r0, #21
   1b68e:	bdf2      	pop	{r1, r4, r5, r6, r7, pc}
   1b690:	201c      	movs	r0, #28
   1b692:	5e28      	ldrsh	r0, [r5, r0]
   1b694:	2800      	cmp	r0, #0
   1b696:	d028      	beq.n	1b6ea <PE_Check_AMSConflict+0x78>
   1b698:	1e40      	subs	r0, r0, #1
   1b69a:	2801      	cmp	r0, #1
   1b69c:	d90a      	bls.n	1b6b4 <PE_Check_AMSConflict+0x42>
   1b69e:	1e80      	subs	r0, r0, #2
   1b6a0:	d026      	beq.n	1b6f0 <PE_Check_AMSConflict+0x7e>
   1b6a2:	1e40      	subs	r0, r0, #1
   1b6a4:	d026      	beq.n	1b6f4 <PE_Check_AMSConflict+0x82>
   1b6a6:	1e40      	subs	r0, r0, #1
   1b6a8:	280b      	cmp	r0, #11
   1b6aa:	d903      	bls.n	1b6b4 <PE_Check_AMSConflict+0x42>
   1b6ac:	380c      	subs	r0, #12
   1b6ae:	d01c      	beq.n	1b6ea <PE_Check_AMSConflict+0x78>
   1b6b0:	38fe      	subs	r0, #254	; 0xfe
   1b6b2:	d101      	bne.n	1b6b8 <PE_Check_AMSConflict+0x46>
   1b6b4:	2011      	movs	r0, #17
   1b6b6:	e01c      	b.n	1b6f2 <PE_Check_AMSConflict+0x80>
   1b6b8:	9400      	str	r4, [sp, #0]
   1b6ba:	2300      	movs	r3, #0
   1b6bc:	225c      	movs	r2, #92	; 0x5c
   1b6be:	7c28      	ldrb	r0, [r5, #16]
   1b6c0:	07c1      	lsls	r1, r0, #31
   1b6c2:	0fc9      	lsrs	r1, r1, #31
   1b6c4:	2009      	movs	r0, #9
   1b6c6:	4f10      	ldr	r7, [pc, #64]	; (1b708 <.text_99>)
   1b6c8:	6a3f      	ldr	r7, [r7, #32]
   1b6ca:	47b8      	blx	r7
   1b6cc:	215c      	movs	r1, #92	; 0x5c
   1b6ce:	7c2a      	ldrb	r2, [r5, #16]
   1b6d0:	07d0      	lsls	r0, r2, #31
   1b6d2:	0fc0      	lsrs	r0, r0, #31
   1b6d4:	68aa      	ldr	r2, [r5, #8]
   1b6d6:	68d2      	ldr	r2, [r2, #12]
   1b6d8:	4790      	blx	r2
   1b6da:	6868      	ldr	r0, [r5, #4]
   1b6dc:	6800      	ldr	r0, [r0, #0]
   1b6de:	490d      	ldr	r1, [pc, #52]	; (1b714 <.text_102>)
   1b6e0:	4001      	ands	r1, r0
   1b6e2:	20c0      	movs	r0, #192	; 0xc0
   1b6e4:	0080      	lsls	r0, r0, #2
   1b6e6:	4281      	cmp	r1, r0
   1b6e8:	d102      	bne.n	1b6f0 <PE_Check_AMSConflict+0x7e>
   1b6ea:	2003      	movs	r0, #3
   1b6ec:	7030      	strb	r0, [r6, #0]
   1b6ee:	e002      	b.n	1b6f6 <PE_Check_AMSConflict+0x84>
   1b6f0:	200f      	movs	r0, #15
   1b6f2:	7030      	strb	r0, [r6, #0]
   1b6f4:	2415      	movs	r4, #21
   1b6f6:	0020      	movs	r0, r4
   1b6f8:	bdf2      	pop	{r1, r4, r5, r6, r7, pc}
	...

0001b6fc <.text_96>:
   1b6fc:	0000801e 	.word	0x0000801e

0001b700 <.text_97>:
   1b700:	ffff7fff 	.word	0xffff7fff

0001b704 <.text_98>:
   1b704:	0000028d 	.word	0x0000028d

0001b708 <.text_99>:
   1b708:	0002ff54 	.word	0x0002ff54

0001b70c <.text_100>:
   1b70c:	0000028f 	.word	0x0000028f

0001b710 <.text_101>:
   1b710:	0000f01f 	.word	0x0000f01f

0001b714 <.text_102>:
   1b714:	00000704 	.word	0x00000704

0001b718 <PE_Check_ControlMessage>:
   1b718:	b5f3      	push	{r0, r1, r4, r5, r6, r7, lr}
   1b71a:	b081      	sub	sp, #4
   1b71c:	0004      	movs	r4, r0
   1b71e:	20a4      	movs	r0, #164	; 0xa4
   1b720:	0080      	lsls	r0, r0, #2
   1b722:	1826      	adds	r6, r4, r0
   1b724:	202a      	movs	r0, #42	; 0x2a
   1b726:	2103      	movs	r1, #3
   1b728:	2501      	movs	r5, #1
   1b72a:	220b      	movs	r2, #11
   1b72c:	7cb3      	ldrb	r3, [r6, #18]
   1b72e:	06db      	lsls	r3, r3, #27
   1b730:	0edb      	lsrs	r3, r3, #27
   1b732:	1e5b      	subs	r3, r3, #1
   1b734:	2b15      	cmp	r3, #21
   1b736:	d900      	bls.n	1b73a <PE_Check_ControlMessage+0x22>
   1b738:	e19c      	b.n	1ba74 <PE_Check_ControlMessage+0x35c>
   1b73a:	a702      	add	r7, pc, #8	; (adr r7, 1b744 <PE_Check_ControlMessage+0x2c>)
   1b73c:	005b      	lsls	r3, r3, #1
   1b73e:	5aff      	ldrh	r7, [r7, r3]
   1b740:	44bf      	add	pc, r7
   1b742:	bf00      	nop
   1b744:	002c033c 	.word	0x002c033c
   1b748:	032a032a 	.word	0x032a032a
   1b74c:	032a008e 	.word	0x032a008e
   1b750:	01d200a8 	.word	0x01d200a8
   1b754:	016801bc 	.word	0x016801bc
   1b758:	032a01a6 	.word	0x032a01a6
   1b75c:	03300064 	.word	0x03300064
   1b760:	03040330 	.word	0x03040330
   1b764:	028e0218 	.word	0x028e0218
   1b768:	02b802fe 	.word	0x02b802fe
   1b76c:	025602f0 	.word	0x025602f0
   1b770:	6860      	ldr	r0, [r4, #4]
   1b772:	6800      	ldr	r0, [r0, #0]
   1b774:	0880      	lsrs	r0, r0, #2
   1b776:	4028      	ands	r0, r5
   1b778:	d000      	beq.n	1b77c <PE_Check_ControlMessage+0x64>
   1b77a:	e181      	b.n	1ba80 <PE_Check_ControlMessage+0x368>
   1b77c:	2002      	movs	r0, #2
   1b77e:	83a0      	strh	r0, [r4, #28]
   1b780:	2000      	movs	r0, #0
   1b782:	9000      	str	r0, [sp, #0]
   1b784:	2300      	movs	r3, #0
   1b786:	222b      	movs	r2, #43	; 0x2b
   1b788:	6920      	ldr	r0, [r4, #16]
   1b78a:	2101      	movs	r1, #1
   1b78c:	4001      	ands	r1, r0
   1b78e:	2009      	movs	r0, #9
   1b790:	4fbc      	ldr	r7, [pc, #752]	; (1ba84 <.text_104>)
   1b792:	6a3f      	ldr	r7, [r7, #32]
   1b794:	47b8      	blx	r7
   1b796:	212b      	movs	r1, #43	; 0x2b
   1b798:	6920      	ldr	r0, [r4, #16]
   1b79a:	4005      	ands	r5, r0
   1b79c:	0028      	movs	r0, r5
   1b79e:	68a2      	ldr	r2, [r4, #8]
   1b7a0:	68d2      	ldr	r2, [r2, #12]
   1b7a2:	4790      	blx	r2
   1b7a4:	2098      	movs	r0, #152	; 0x98
   1b7a6:	e163      	b.n	1ba70 <PE_Check_ControlMessage+0x358>
   1b7a8:	83a1      	strh	r1, [r4, #28]
   1b7aa:	2000      	movs	r0, #0
   1b7ac:	9000      	str	r0, [sp, #0]
   1b7ae:	2300      	movs	r3, #0
   1b7b0:	2232      	movs	r2, #50	; 0x32
   1b7b2:	6920      	ldr	r0, [r4, #16]
   1b7b4:	2101      	movs	r1, #1
   1b7b6:	4001      	ands	r1, r0
   1b7b8:	2009      	movs	r0, #9
   1b7ba:	4fb2      	ldr	r7, [pc, #712]	; (1ba84 <.text_104>)
   1b7bc:	6a3f      	ldr	r7, [r7, #32]
   1b7be:	47b8      	blx	r7
   1b7c0:	2132      	movs	r1, #50	; 0x32
   1b7c2:	6920      	ldr	r0, [r4, #16]
   1b7c4:	4005      	ands	r5, r0
   1b7c6:	0028      	movs	r0, r5
   1b7c8:	68a2      	ldr	r2, [r4, #8]
   1b7ca:	68d2      	ldr	r2, [r2, #12]
   1b7cc:	4790      	blx	r2
   1b7ce:	2010      	movs	r0, #16
   1b7d0:	e14e      	b.n	1ba70 <PE_Check_ControlMessage+0x358>
   1b7d2:	2000      	movs	r0, #0
   1b7d4:	9000      	str	r0, [sp, #0]
   1b7d6:	2300      	movs	r3, #0
   1b7d8:	2233      	movs	r2, #51	; 0x33
   1b7da:	6920      	ldr	r0, [r4, #16]
   1b7dc:	2101      	movs	r1, #1
   1b7de:	4001      	ands	r1, r0
   1b7e0:	2009      	movs	r0, #9
   1b7e2:	4ea8      	ldr	r6, [pc, #672]	; (1ba84 <.text_104>)
   1b7e4:	6a36      	ldr	r6, [r6, #32]
   1b7e6:	47b0      	blx	r6
   1b7e8:	2133      	movs	r1, #51	; 0x33
   1b7ea:	e139      	b.n	1ba60 <PE_Check_ControlMessage+0x348>
   1b7ec:	2206      	movs	r2, #6
   1b7ee:	83a2      	strh	r2, [r4, #28]
   1b7f0:	6862      	ldr	r2, [r4, #4]
   1b7f2:	6812      	ldr	r2, [r2, #0]
   1b7f4:	0893      	lsrs	r3, r2, #2
   1b7f6:	402b      	ands	r3, r5
   1b7f8:	d051      	beq.n	1b89e <PE_Check_ControlMessage+0x186>
   1b7fa:	2000      	movs	r0, #0
   1b7fc:	9000      	str	r0, [sp, #0]
   1b7fe:	2300      	movs	r3, #0
   1b800:	220c      	movs	r2, #12
   1b802:	6920      	ldr	r0, [r4, #16]
   1b804:	2101      	movs	r1, #1
   1b806:	4001      	ands	r1, r0
   1b808:	2009      	movs	r0, #9
   1b80a:	4f9e      	ldr	r7, [pc, #632]	; (1ba84 <.text_104>)
   1b80c:	6a3f      	ldr	r7, [r7, #32]
   1b80e:	47b8      	blx	r7
   1b810:	210c      	movs	r1, #12
   1b812:	6922      	ldr	r2, [r4, #16]
   1b814:	2001      	movs	r0, #1
   1b816:	4010      	ands	r0, r2
   1b818:	68a2      	ldr	r2, [r4, #8]
   1b81a:	68d2      	ldr	r2, [r2, #12]
   1b81c:	4790      	blx	r2
   1b81e:	2014      	movs	r0, #20
   1b820:	9902      	ldr	r1, [sp, #8]
   1b822:	7008      	strb	r0, [r1, #0]
   1b824:	6921      	ldr	r1, [r4, #16]
   1b826:	2001      	movs	r0, #1
   1b828:	4008      	ands	r0, r1
   1b82a:	f001 ffd6 	bl	1d7da <USBPD_PRL_EnableRX>
   1b82e:	2100      	movs	r1, #0
   1b830:	0020      	movs	r0, r4
   1b832:	f7ff f837 	bl	1a8a4 <PE_Send_SRCCapabilities>
   1b836:	2805      	cmp	r0, #5
   1b838:	d12e      	bne.n	1b898 <PE_Check_ControlMessage+0x180>
   1b83a:	6860      	ldr	r0, [r4, #4]
   1b83c:	6801      	ldr	r1, [r0, #0]
   1b83e:	054a      	lsls	r2, r1, #21
   1b840:	0f52      	lsrs	r2, r2, #29
   1b842:	2a04      	cmp	r2, #4
   1b844:	d016      	beq.n	1b874 <PE_Check_ControlMessage+0x15c>
   1b846:	4a90      	ldr	r2, [pc, #576]	; (1ba88 <.text_105>)
   1b848:	400a      	ands	r2, r1
   1b84a:	02a9      	lsls	r1, r5, #10
   1b84c:	4311      	orrs	r1, r2
   1b84e:	6001      	str	r1, [r0, #0]
   1b850:	2000      	movs	r0, #0
   1b852:	9000      	str	r0, [sp, #0]
   1b854:	2300      	movs	r3, #0
   1b856:	225a      	movs	r2, #90	; 0x5a
   1b858:	6920      	ldr	r0, [r4, #16]
   1b85a:	2101      	movs	r1, #1
   1b85c:	4001      	ands	r1, r0
   1b85e:	2009      	movs	r0, #9
   1b860:	4f88      	ldr	r7, [pc, #544]	; (1ba84 <.text_104>)
   1b862:	6a3f      	ldr	r7, [r7, #32]
   1b864:	47b8      	blx	r7
   1b866:	215a      	movs	r1, #90	; 0x5a
   1b868:	6922      	ldr	r2, [r4, #16]
   1b86a:	2001      	movs	r0, #1
   1b86c:	4010      	ands	r0, r2
   1b86e:	68a2      	ldr	r2, [r4, #8]
   1b870:	68d2      	ldr	r2, [r2, #12]
   1b872:	4790      	blx	r2
   1b874:	83a5      	strh	r5, [r4, #28]
   1b876:	4885      	ldr	r0, [pc, #532]	; (1ba8c <.text_106>)
   1b878:	80b0      	strh	r0, [r6, #4]
   1b87a:	2016      	movs	r0, #22
   1b87c:	7030      	strb	r0, [r6, #0]
   1b87e:	2000      	movs	r0, #0
   1b880:	9000      	str	r0, [sp, #0]
   1b882:	2300      	movs	r3, #0
   1b884:	220f      	movs	r2, #15
   1b886:	6920      	ldr	r0, [r4, #16]
   1b888:	2101      	movs	r1, #1
   1b88a:	4001      	ands	r1, r0
   1b88c:	2009      	movs	r0, #9
   1b88e:	4e7d      	ldr	r6, [pc, #500]	; (1ba84 <.text_104>)
   1b890:	6a36      	ldr	r6, [r6, #32]
   1b892:	47b0      	blx	r6
   1b894:	210f      	movs	r1, #15
   1b896:	e0e3      	b.n	1ba60 <PE_Check_ControlMessage+0x348>
   1b898:	2000      	movs	r0, #0
   1b89a:	83a0      	strh	r0, [r4, #28]
   1b89c:	e0e7      	b.n	1ba6e <PE_Check_ControlMessage+0x356>
   1b89e:	6823      	ldr	r3, [r4, #0]
   1b8a0:	685b      	ldr	r3, [r3, #4]
   1b8a2:	08db      	lsrs	r3, r3, #3
   1b8a4:	402b      	ands	r3, r5
   1b8a6:	d055      	beq.n	1b954 <PE_Check_ControlMessage+0x23c>
   1b8a8:	204c      	movs	r0, #76	; 0x4c
   1b8aa:	e0e1      	b.n	1ba70 <PE_Check_ControlMessage+0x358>
   1b8ac:	6822      	ldr	r2, [r4, #0]
   1b8ae:	6852      	ldr	r2, [r2, #4]
   1b8b0:	08d2      	lsrs	r2, r2, #3
   1b8b2:	402a      	ands	r2, r5
   1b8b4:	d016      	beq.n	1b8e4 <PE_Check_ControlMessage+0x1cc>
   1b8b6:	2022      	movs	r0, #34	; 0x22
   1b8b8:	7030      	strb	r0, [r6, #0]
   1b8ba:	2000      	movs	r0, #0
   1b8bc:	9000      	str	r0, [sp, #0]
   1b8be:	2300      	movs	r3, #0
   1b8c0:	223c      	movs	r2, #60	; 0x3c
   1b8c2:	6920      	ldr	r0, [r4, #16]
   1b8c4:	2101      	movs	r1, #1
   1b8c6:	4001      	ands	r1, r0
   1b8c8:	2009      	movs	r0, #9
   1b8ca:	4e6e      	ldr	r6, [pc, #440]	; (1ba84 <.text_104>)
   1b8cc:	6a36      	ldr	r6, [r6, #32]
   1b8ce:	47b0      	blx	r6
   1b8d0:	213c      	movs	r1, #60	; 0x3c
   1b8d2:	6920      	ldr	r0, [r4, #16]
   1b8d4:	4005      	ands	r5, r0
   1b8d6:	0028      	movs	r0, r5
   1b8d8:	68a2      	ldr	r2, [r4, #8]
   1b8da:	68d2      	ldr	r2, [r2, #12]
   1b8dc:	4790      	blx	r2
   1b8de:	2008      	movs	r0, #8
   1b8e0:	83a0      	strh	r0, [r4, #28]
   1b8e2:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
   1b8e4:	6862      	ldr	r2, [r4, #4]
   1b8e6:	6812      	ldr	r2, [r2, #0]
   1b8e8:	e034      	b.n	1b954 <PE_Check_ControlMessage+0x23c>
   1b8ea:	68a2      	ldr	r2, [r4, #8]
   1b8ec:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
   1b8ee:	2a00      	cmp	r2, #0
   1b8f0:	d003      	beq.n	1b8fa <PE_Check_ControlMessage+0x1e2>
   1b8f2:	2010      	movs	r0, #16
   1b8f4:	83a0      	strh	r0, [r4, #28]
   1b8f6:	209d      	movs	r0, #157	; 0x9d
   1b8f8:	e0ba      	b.n	1ba70 <PE_Check_ControlMessage+0x358>
   1b8fa:	6862      	ldr	r2, [r4, #4]
   1b8fc:	6812      	ldr	r2, [r2, #0]
   1b8fe:	e029      	b.n	1b954 <PE_Check_ControlMessage+0x23c>
   1b900:	68a2      	ldr	r2, [r4, #8]
   1b902:	6b92      	ldr	r2, [r2, #56]	; 0x38
   1b904:	2a00      	cmp	r2, #0
   1b906:	d102      	bne.n	1b90e <PE_Check_ControlMessage+0x1f6>
   1b908:	6862      	ldr	r2, [r4, #4]
   1b90a:	6812      	ldr	r2, [r2, #0]
   1b90c:	e022      	b.n	1b954 <PE_Check_ControlMessage+0x23c>
   1b90e:	200f      	movs	r0, #15
   1b910:	83a0      	strh	r0, [r4, #28]
   1b912:	2093      	movs	r0, #147	; 0x93
   1b914:	e0ac      	b.n	1ba70 <PE_Check_ControlMessage+0x358>
   1b916:	6862      	ldr	r2, [r4, #4]
   1b918:	6812      	ldr	r2, [r2, #0]
   1b91a:	2307      	movs	r3, #7
   1b91c:	0a17      	lsrs	r7, r2, #8
   1b91e:	401f      	ands	r7, r3
   1b920:	2f03      	cmp	r7, #3
   1b922:	d117      	bne.n	1b954 <PE_Check_ControlMessage+0x23c>
   1b924:	0897      	lsrs	r7, r2, #2
   1b926:	402f      	ands	r7, r5
   1b928:	d004      	beq.n	1b934 <PE_Check_ControlMessage+0x21c>
   1b92a:	6827      	ldr	r7, [r4, #0]
   1b92c:	687f      	ldr	r7, [r7, #4]
   1b92e:	08ff      	lsrs	r7, r7, #3
   1b930:	402f      	ands	r7, r5
   1b932:	d00f      	beq.n	1b954 <PE_Check_ControlMessage+0x23c>
   1b934:	83a3      	strh	r3, [r4, #28]
   1b936:	201d      	movs	r0, #29
   1b938:	7030      	strb	r0, [r6, #0]
   1b93a:	2000      	movs	r0, #0
   1b93c:	9000      	str	r0, [sp, #0]
   1b93e:	2300      	movs	r3, #0
   1b940:	2206      	movs	r2, #6
   1b942:	6920      	ldr	r0, [r4, #16]
   1b944:	2101      	movs	r1, #1
   1b946:	4001      	ands	r1, r0
   1b948:	2009      	movs	r0, #9
   1b94a:	4e4e      	ldr	r6, [pc, #312]	; (1ba84 <.text_104>)
   1b94c:	6a36      	ldr	r6, [r6, #32]
   1b94e:	47b0      	blx	r6
   1b950:	2106      	movs	r1, #6
   1b952:	e085      	b.n	1ba60 <PE_Check_ControlMessage+0x348>
   1b954:	4011      	ands	r1, r2
   1b956:	2902      	cmp	r1, #2
   1b958:	d1dc      	bne.n	1b914 <PE_Check_ControlMessage+0x1fc>
   1b95a:	e090      	b.n	1ba7e <PE_Check_ControlMessage+0x366>
   1b95c:	6820      	ldr	r0, [r4, #0]
   1b95e:	8901      	ldrh	r1, [r0, #8]
   1b960:	08c9      	lsrs	r1, r1, #3
   1b962:	4229      	tst	r1, r5
   1b964:	d0f9      	beq.n	1b95a <PE_Check_ControlMessage+0x242>
   1b966:	6861      	ldr	r1, [r4, #4]
   1b968:	6809      	ldr	r1, [r1, #0]
   1b96a:	0889      	lsrs	r1, r1, #2
   1b96c:	4029      	ands	r1, r5
   1b96e:	d103      	bne.n	1b978 <PE_Check_ControlMessage+0x260>
   1b970:	6840      	ldr	r0, [r0, #4]
   1b972:	08c0      	lsrs	r0, r0, #3
   1b974:	4028      	ands	r0, r5
   1b976:	d0f0      	beq.n	1b95a <PE_Check_ControlMessage+0x242>
   1b978:	200a      	movs	r0, #10
   1b97a:	83a0      	strh	r0, [r4, #28]
   1b97c:	2063      	movs	r0, #99	; 0x63
   1b97e:	7030      	strb	r0, [r6, #0]
   1b980:	2000      	movs	r0, #0
   1b982:	9000      	str	r0, [sp, #0]
   1b984:	2300      	movs	r3, #0
   1b986:	2246      	movs	r2, #70	; 0x46
   1b988:	6920      	ldr	r0, [r4, #16]
   1b98a:	2101      	movs	r1, #1
   1b98c:	4001      	ands	r1, r0
   1b98e:	2009      	movs	r0, #9
   1b990:	4e3c      	ldr	r6, [pc, #240]	; (1ba84 <.text_104>)
   1b992:	6a36      	ldr	r6, [r6, #32]
   1b994:	47b0      	blx	r6
   1b996:	2146      	movs	r1, #70	; 0x46
   1b998:	e062      	b.n	1ba60 <PE_Check_ControlMessage+0x348>
   1b99a:	6860      	ldr	r0, [r4, #4]
   1b99c:	6800      	ldr	r0, [r0, #0]
   1b99e:	0880      	lsrs	r0, r0, #2
   1b9a0:	4028      	ands	r0, r5
   1b9a2:	d004      	beq.n	1b9ae <PE_Check_ControlMessage+0x296>
   1b9a4:	6820      	ldr	r0, [r4, #0]
   1b9a6:	6840      	ldr	r0, [r0, #4]
   1b9a8:	08c0      	lsrs	r0, r0, #3
   1b9aa:	4028      	ands	r0, r5
   1b9ac:	d067      	beq.n	1ba7e <PE_Check_ControlMessage+0x366>
   1b9ae:	20ff      	movs	r0, #255	; 0xff
   1b9b0:	3010      	adds	r0, #16
   1b9b2:	83a0      	strh	r0, [r4, #28]
   1b9b4:	2064      	movs	r0, #100	; 0x64
   1b9b6:	7030      	strb	r0, [r6, #0]
   1b9b8:	2000      	movs	r0, #0
   1b9ba:	9000      	str	r0, [sp, #0]
   1b9bc:	2300      	movs	r3, #0
   1b9be:	2260      	movs	r2, #96	; 0x60
   1b9c0:	6920      	ldr	r0, [r4, #16]
   1b9c2:	2101      	movs	r1, #1
   1b9c4:	4001      	ands	r1, r0
   1b9c6:	2009      	movs	r0, #9
   1b9c8:	4e2e      	ldr	r6, [pc, #184]	; (1ba84 <.text_104>)
   1b9ca:	6a36      	ldr	r6, [r6, #32]
   1b9cc:	47b0      	blx	r6
   1b9ce:	2160      	movs	r1, #96	; 0x60
   1b9d0:	e046      	b.n	1ba60 <PE_Check_ControlMessage+0x348>
   1b9d2:	6820      	ldr	r0, [r4, #0]
   1b9d4:	8900      	ldrh	r0, [r0, #8]
   1b9d6:	0940      	lsrs	r0, r0, #5
   1b9d8:	4228      	tst	r0, r5
   1b9da:	d050      	beq.n	1ba7e <PE_Check_ControlMessage+0x366>
   1b9dc:	83a2      	strh	r2, [r4, #28]
   1b9de:	2030      	movs	r0, #48	; 0x30
   1b9e0:	7030      	strb	r0, [r6, #0]
   1b9e2:	2000      	movs	r0, #0
   1b9e4:	9000      	str	r0, [sp, #0]
   1b9e6:	2300      	movs	r3, #0
   1b9e8:	224d      	movs	r2, #77	; 0x4d
   1b9ea:	6920      	ldr	r0, [r4, #16]
   1b9ec:	2101      	movs	r1, #1
   1b9ee:	4001      	ands	r1, r0
   1b9f0:	2009      	movs	r0, #9
   1b9f2:	4e24      	ldr	r6, [pc, #144]	; (1ba84 <.text_104>)
   1b9f4:	6a36      	ldr	r6, [r6, #32]
   1b9f6:	47b0      	blx	r6
   1b9f8:	214d      	movs	r1, #77	; 0x4d
   1b9fa:	e031      	b.n	1ba60 <PE_Check_ControlMessage+0x348>
   1b9fc:	6820      	ldr	r0, [r4, #0]
   1b9fe:	8900      	ldrh	r0, [r0, #8]
   1ba00:	0880      	lsrs	r0, r0, #2
   1ba02:	4228      	tst	r0, r5
   1ba04:	d03b      	beq.n	1ba7e <PE_Check_ControlMessage+0x366>
   1ba06:	83a2      	strh	r2, [r4, #28]
   1ba08:	6860      	ldr	r0, [r4, #4]
   1ba0a:	6800      	ldr	r0, [r0, #0]
   1ba0c:	0880      	lsrs	r0, r0, #2
   1ba0e:	4028      	ands	r0, r5
   1ba10:	d001      	beq.n	1ba16 <PE_Check_ControlMessage+0x2fe>
   1ba12:	202d      	movs	r0, #45	; 0x2d
   1ba14:	e000      	b.n	1ba18 <PE_Check_ControlMessage+0x300>
   1ba16:	2011      	movs	r0, #17
   1ba18:	7030      	strb	r0, [r6, #0]
   1ba1a:	2000      	movs	r0, #0
   1ba1c:	9000      	str	r0, [sp, #0]
   1ba1e:	2300      	movs	r3, #0
   1ba20:	2249      	movs	r2, #73	; 0x49
   1ba22:	6920      	ldr	r0, [r4, #16]
   1ba24:	2101      	movs	r1, #1
   1ba26:	4001      	ands	r1, r0
   1ba28:	2009      	movs	r0, #9
   1ba2a:	4e16      	ldr	r6, [pc, #88]	; (1ba84 <.text_104>)
   1ba2c:	6a36      	ldr	r6, [r6, #32]
   1ba2e:	47b0      	blx	r6
   1ba30:	2149      	movs	r1, #73	; 0x49
   1ba32:	e015      	b.n	1ba60 <PE_Check_ControlMessage+0x348>
   1ba34:	6820      	ldr	r0, [r4, #0]
   1ba36:	8900      	ldrh	r0, [r0, #8]
   1ba38:	09c0      	lsrs	r0, r0, #7
   1ba3a:	4228      	tst	r0, r5
   1ba3c:	d01f      	beq.n	1ba7e <PE_Check_ControlMessage+0x366>
   1ba3e:	202f      	movs	r0, #47	; 0x2f
   1ba40:	e016      	b.n	1ba70 <PE_Check_ControlMessage+0x358>
   1ba42:	2009      	movs	r0, #9
   1ba44:	83a0      	strh	r0, [r4, #28]
   1ba46:	e01a      	b.n	1ba7e <PE_Check_ControlMessage+0x366>
   1ba48:	2000      	movs	r0, #0
   1ba4a:	9000      	str	r0, [sp, #0]
   1ba4c:	2300      	movs	r3, #0
   1ba4e:	2259      	movs	r2, #89	; 0x59
   1ba50:	6920      	ldr	r0, [r4, #16]
   1ba52:	2101      	movs	r1, #1
   1ba54:	4001      	ands	r1, r0
   1ba56:	2009      	movs	r0, #9
   1ba58:	4e0a      	ldr	r6, [pc, #40]	; (1ba84 <.text_104>)
   1ba5a:	6a36      	ldr	r6, [r6, #32]
   1ba5c:	47b0      	blx	r6
   1ba5e:	2159      	movs	r1, #89	; 0x59
   1ba60:	6920      	ldr	r0, [r4, #16]
   1ba62:	4005      	ands	r5, r0
   1ba64:	0028      	movs	r0, r5
   1ba66:	68a2      	ldr	r2, [r4, #8]
   1ba68:	68d2      	ldr	r2, [r2, #12]
   1ba6a:	4790      	blx	r2
   1ba6c:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
   1ba6e:	2011      	movs	r0, #17
   1ba70:	7030      	strb	r0, [r6, #0]
   1ba72:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
   1ba74:	6860      	ldr	r0, [r4, #4]
   1ba76:	6800      	ldr	r0, [r0, #0]
   1ba78:	4001      	ands	r1, r0
   1ba7a:	2902      	cmp	r1, #2
   1ba7c:	d100      	bne.n	1ba80 <PE_Check_ControlMessage+0x368>
   1ba7e:	7035      	strb	r5, [r6, #0]
   1ba80:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
	...

0001ba84 <.text_104>:
   1ba84:	0002ff54 	.word	0x0002ff54

0001ba88 <.text_105>:
   1ba88:	fffff8ff 	.word	0xfffff8ff

0001ba8c <.text_106>:
   1ba8c:	00008018 	.word	0x00008018

0001ba90 <PE_Check_DataMessage>:
   1ba90:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
   1ba92:	0004      	movs	r4, r0
   1ba94:	2002      	movs	r0, #2
   1ba96:	9002      	str	r0, [sp, #8]
   1ba98:	20a4      	movs	r0, #164	; 0xa4
   1ba9a:	0080      	lsls	r0, r0, #2
   1ba9c:	1826      	adds	r6, r4, r0
   1ba9e:	8a70      	ldrh	r0, [r6, #18]
   1baa0:	21a1      	movs	r1, #161	; 0xa1
   1baa2:	0049      	lsls	r1, r1, #1
   1baa4:	1867      	adds	r7, r4, r1
   1baa6:	2501      	movs	r5, #1
   1baa8:	06c1      	lsls	r1, r0, #27
   1baaa:	0ec9      	lsrs	r1, r1, #27
   1baac:	2901      	cmp	r1, #1
   1baae:	d02c      	beq.n	1bb0a <PE_Check_DataMessage+0x7a>
   1bab0:	2902      	cmp	r1, #2
   1bab2:	d009      	beq.n	1bac8 <PE_Check_DataMessage+0x38>
   1bab4:	2903      	cmp	r1, #3
   1bab6:	d043      	beq.n	1bb40 <PE_Check_DataMessage+0xb0>
   1bab8:	2906      	cmp	r1, #6
   1baba:	d077      	beq.n	1bbac <PE_Check_DataMessage+0x11c>
   1babc:	2907      	cmp	r1, #7
   1babe:	d100      	bne.n	1bac2 <PE_Check_DataMessage+0x32>
   1bac0:	e084      	b.n	1bbcc <PE_Check_DataMessage+0x13c>
   1bac2:	290f      	cmp	r1, #15
   1bac4:	d06d      	beq.n	1bba2 <PE_Check_DataMessage+0x112>
   1bac6:	e08a      	b.n	1bbde <PE_Check_DataMessage+0x14e>
   1bac8:	7838      	ldrb	r0, [r7, #0]
   1baca:	7879      	ldrb	r1, [r7, #1]
   1bacc:	0209      	lsls	r1, r1, #8
   1bace:	1840      	adds	r0, r0, r1
   1bad0:	78b9      	ldrb	r1, [r7, #2]
   1bad2:	0409      	lsls	r1, r1, #16
   1bad4:	1840      	adds	r0, r0, r1
   1bad6:	78f9      	ldrb	r1, [r7, #3]
   1bad8:	0609      	lsls	r1, r1, #24
   1bada:	1840      	adds	r0, r0, r1
   1badc:	9000      	str	r0, [sp, #0]
   1bade:	6860      	ldr	r0, [r4, #4]
   1bae0:	6800      	ldr	r0, [r0, #0]
   1bae2:	0880      	lsrs	r0, r0, #2
   1bae4:	4028      	ands	r0, r5
   1bae6:	d07c      	beq.n	1bbe2 <PE_Check_DataMessage+0x152>
   1bae8:	2304      	movs	r3, #4
   1baea:	466a      	mov	r2, sp
   1baec:	2106      	movs	r1, #6
   1baee:	6927      	ldr	r7, [r4, #16]
   1baf0:	2001      	movs	r0, #1
   1baf2:	4038      	ands	r0, r7
   1baf4:	68a7      	ldr	r7, [r4, #8]
   1baf6:	69bf      	ldr	r7, [r7, #24]
   1baf8:	47b8      	blx	r7
   1bafa:	83a5      	strh	r5, [r4, #28]
   1bafc:	8a30      	ldrh	r0, [r6, #16]
   1bafe:	0440      	lsls	r0, r0, #17
   1bb00:	d001      	beq.n	1bb06 <PE_Check_DataMessage+0x76>
   1bb02:	2000      	movs	r0, #0
   1bb04:	8230      	strh	r0, [r6, #16]
   1bb06:	2009      	movs	r0, #9
   1bb08:	e06a      	b.n	1bbe0 <PE_Check_DataMessage+0x150>
   1bb0a:	6861      	ldr	r1, [r4, #4]
   1bb0c:	6809      	ldr	r1, [r1, #0]
   1bb0e:	0889      	lsrs	r1, r1, #2
   1bb10:	4029      	ands	r1, r5
   1bb12:	d166      	bne.n	1bbe2 <PE_Check_DataMessage+0x152>
   1bb14:	0600      	lsls	r0, r0, #24
   1bb16:	0f81      	lsrs	r1, r0, #30
   1bb18:	6922      	ldr	r2, [r4, #16]
   1bb1a:	2001      	movs	r0, #1
   1bb1c:	4010      	ands	r0, r2
   1bb1e:	f000 fb6b 	bl	1c1f8 <PE_ExtRevisionInteroperability>
   1bb22:	8a70      	ldrh	r0, [r6, #18]
   1bb24:	0440      	lsls	r0, r0, #17
   1bb26:	0f40      	lsrs	r0, r0, #29
   1bb28:	0083      	lsls	r3, r0, #2
   1bb2a:	003a      	movs	r2, r7
   1bb2c:	2104      	movs	r1, #4
   1bb2e:	6927      	ldr	r7, [r4, #16]
   1bb30:	2001      	movs	r0, #1
   1bb32:	4038      	ands	r0, r7
   1bb34:	68a7      	ldr	r7, [r4, #8]
   1bb36:	69bf      	ldr	r7, [r7, #24]
   1bb38:	47b8      	blx	r7
   1bb3a:	83a5      	strh	r5, [r4, #28]
   1bb3c:	2044      	movs	r0, #68	; 0x44
   1bb3e:	e04f      	b.n	1bbe0 <PE_Check_DataMessage+0x150>
   1bb40:	2000      	movs	r0, #0
   1bb42:	9001      	str	r0, [sp, #4]
   1bb44:	9000      	str	r0, [sp, #0]
   1bb46:	7838      	ldrb	r0, [r7, #0]
   1bb48:	7879      	ldrb	r1, [r7, #1]
   1bb4a:	0209      	lsls	r1, r1, #8
   1bb4c:	1840      	adds	r0, r0, r1
   1bb4e:	78b9      	ldrb	r1, [r7, #2]
   1bb50:	0409      	lsls	r1, r1, #16
   1bb52:	1840      	adds	r0, r0, r1
   1bb54:	78f9      	ldrb	r1, [r7, #3]
   1bb56:	0609      	lsls	r1, r1, #24
   1bb58:	1847      	adds	r7, r0, r1
   1bb5a:	466b      	mov	r3, sp
   1bb5c:	aa01      	add	r2, sp, #4
   1bb5e:	2103      	movs	r1, #3
   1bb60:	6920      	ldr	r0, [r4, #16]
   1bb62:	4005      	ands	r5, r0
   1bb64:	0028      	movs	r0, r5
   1bb66:	68a5      	ldr	r5, [r4, #8]
   1bb68:	696d      	ldr	r5, [r5, #20]
   1bb6a:	47a8      	blx	r5
   1bb6c:	9800      	ldr	r0, [sp, #0]
   1bb6e:	2804      	cmp	r0, #4
   1bb70:	d115      	bne.n	1bb9e <PE_Check_DataMessage+0x10e>
   1bb72:	6860      	ldr	r0, [r4, #4]
   1bb74:	6800      	ldr	r0, [r0, #0]
   1bb76:	0540      	lsls	r0, r0, #21
   1bb78:	0f40      	lsrs	r0, r0, #29
   1bb7a:	2803      	cmp	r0, #3
   1bb7c:	d10f      	bne.n	1bb9e <PE_Check_DataMessage+0x10e>
   1bb7e:	9801      	ldr	r0, [sp, #4]
   1bb80:	4919      	ldr	r1, [pc, #100]	; (1bbe8 <.text_108>)
   1bb82:	4288      	cmp	r0, r1
   1bb84:	d10b      	bne.n	1bb9e <PE_Check_DataMessage+0x10e>
   1bb86:	0f38      	lsrs	r0, r7, #28
   1bb88:	d003      	beq.n	1bb92 <PE_Check_DataMessage+0x102>
   1bb8a:	2805      	cmp	r0, #5
   1bb8c:	d003      	beq.n	1bb96 <PE_Check_DataMessage+0x106>
   1bb8e:	2808      	cmp	r0, #8
   1bb90:	d103      	bne.n	1bb9a <PE_Check_DataMessage+0x10a>
   1bb92:	2029      	movs	r0, #41	; 0x29
   1bb94:	e024      	b.n	1bbe0 <PE_Check_DataMessage+0x150>
   1bb96:	2027      	movs	r0, #39	; 0x27
   1bb98:	e022      	b.n	1bbe0 <PE_Check_DataMessage+0x150>
   1bb9a:	202a      	movs	r0, #42	; 0x2a
   1bb9c:	e020      	b.n	1bbe0 <PE_Check_DataMessage+0x150>
   1bb9e:	2003      	movs	r0, #3
   1bba0:	e01e      	b.n	1bbe0 <PE_Check_DataMessage+0x150>
   1bba2:	0020      	movs	r0, r4
   1bba4:	f000 f822 	bl	1bbec <PE_Check_DataMessageVDM>
   1bba8:	9002      	str	r0, [sp, #8]
   1bbaa:	e01a      	b.n	1bbe2 <PE_Check_DataMessage+0x152>
   1bbac:	6820      	ldr	r0, [r4, #0]
   1bbae:	8900      	ldrh	r0, [r0, #8]
   1bbb0:	0900      	lsrs	r0, r0, #4
   1bbb2:	4228      	tst	r0, r5
   1bbb4:	d011      	beq.n	1bbda <PE_Check_DataMessage+0x14a>
   1bbb6:	2304      	movs	r3, #4
   1bbb8:	003a      	movs	r2, r7
   1bbba:	210b      	movs	r1, #11
   1bbbc:	6920      	ldr	r0, [r4, #16]
   1bbbe:	4005      	ands	r5, r0
   1bbc0:	0028      	movs	r0, r5
   1bbc2:	68a4      	ldr	r4, [r4, #8]
   1bbc4:	69a4      	ldr	r4, [r4, #24]
   1bbc6:	47a0      	blx	r4
   1bbc8:	202c      	movs	r0, #44	; 0x2c
   1bbca:	e009      	b.n	1bbe0 <PE_Check_DataMessage+0x150>
   1bbcc:	6820      	ldr	r0, [r4, #0]
   1bbce:	8900      	ldrh	r0, [r0, #8]
   1bbd0:	0a00      	lsrs	r0, r0, #8
   1bbd2:	4228      	tst	r0, r5
   1bbd4:	d001      	beq.n	1bbda <PE_Check_DataMessage+0x14a>
   1bbd6:	203d      	movs	r0, #61	; 0x3d
   1bbd8:	e002      	b.n	1bbe0 <PE_Check_DataMessage+0x150>
   1bbda:	7035      	strb	r5, [r6, #0]
   1bbdc:	e001      	b.n	1bbe2 <PE_Check_DataMessage+0x152>
   1bbde:	2011      	movs	r0, #17
   1bbe0:	7030      	strb	r0, [r6, #0]
   1bbe2:	9802      	ldr	r0, [sp, #8]
   1bbe4:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	...

0001bbe8 <.text_108>:
   1bbe8:	00001388 	.word	0x00001388

0001bbec <PE_Check_DataMessageVDM>:
   1bbec:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
   1bbee:	2102      	movs	r1, #2
   1bbf0:	9101      	str	r1, [sp, #4]
   1bbf2:	21a3      	movs	r1, #163	; 0xa3
   1bbf4:	0089      	lsls	r1, r1, #2
   1bbf6:	1844      	adds	r4, r0, r1
   1bbf8:	2501      	movs	r5, #1
   1bbfa:	6841      	ldr	r1, [r0, #4]
   1bbfc:	7809      	ldrb	r1, [r1, #0]
   1bbfe:	0789      	lsls	r1, r1, #30
   1bc00:	0f89      	lsrs	r1, r1, #30
   1bc02:	2902      	cmp	r1, #2
   1bc04:	d100      	bne.n	1bc08 <PE_Check_DataMessageVDM+0x1c>
   1bc06:	7125      	strb	r5, [r4, #4]
   1bc08:	21a1      	movs	r1, #161	; 0xa1
   1bc0a:	0049      	lsls	r1, r1, #1
   1bc0c:	1841      	adds	r1, r0, r1
   1bc0e:	780a      	ldrb	r2, [r1, #0]
   1bc10:	784b      	ldrb	r3, [r1, #1]
   1bc12:	021b      	lsls	r3, r3, #8
   1bc14:	18d2      	adds	r2, r2, r3
   1bc16:	788b      	ldrb	r3, [r1, #2]
   1bc18:	041b      	lsls	r3, r3, #16
   1bc1a:	18d2      	adds	r2, r2, r3
   1bc1c:	78c9      	ldrb	r1, [r1, #3]
   1bc1e:	0609      	lsls	r1, r1, #24
   1bc20:	1851      	adds	r1, r2, r1
   1bc22:	9100      	str	r1, [sp, #0]
   1bc24:	0bc9      	lsrs	r1, r1, #15
   1bc26:	4029      	ands	r1, r5
   1bc28:	d135      	bne.n	1bc96 <PE_Check_DataMessageVDM+0xaa>
   1bc2a:	68c1      	ldr	r1, [r0, #12]
   1bc2c:	2900      	cmp	r1, #0
   1bc2e:	d031      	beq.n	1bc94 <PE_Check_DataMessageVDM+0xa8>
   1bc30:	6c09      	ldr	r1, [r1, #64]	; 0x40
   1bc32:	2900      	cmp	r1, #0
   1bc34:	d02e      	beq.n	1bc94 <PE_Check_DataMessageVDM+0xa8>
   1bc36:	8ae1      	ldrh	r1, [r4, #22]
   1bc38:	0449      	lsls	r1, r1, #17
   1bc3a:	0f49      	lsrs	r1, r1, #29
   1bc3c:	1e49      	subs	r1, r1, #1
   1bc3e:	7021      	strb	r1, [r4, #0]
   1bc40:	0006      	movs	r6, r0
   1bc42:	2000      	movs	r0, #0
   1bc44:	e011      	b.n	1bc6a <PE_Check_DataMessageVDM+0x7e>
   1bc46:	0081      	lsls	r1, r0, #2
   1bc48:	1871      	adds	r1, r6, r1
   1bc4a:	22a3      	movs	r2, #163	; 0xa3
   1bc4c:	0052      	lsls	r2, r2, #1
   1bc4e:	1889      	adds	r1, r1, r2
   1bc50:	780a      	ldrb	r2, [r1, #0]
   1bc52:	784f      	ldrb	r7, [r1, #1]
   1bc54:	023f      	lsls	r7, r7, #8
   1bc56:	19d2      	adds	r2, r2, r7
   1bc58:	788f      	ldrb	r7, [r1, #2]
   1bc5a:	043f      	lsls	r7, r7, #16
   1bc5c:	19d2      	adds	r2, r2, r7
   1bc5e:	78c9      	ldrb	r1, [r1, #3]
   1bc60:	0609      	lsls	r1, r1, #24
   1bc62:	1851      	adds	r1, r2, r1
   1bc64:	0082      	lsls	r2, r0, #2
   1bc66:	5099      	str	r1, [r3, r2]
   1bc68:	1c40      	adds	r0, r0, #1
   1bc6a:	219d      	movs	r1, #157	; 0x9d
   1bc6c:	0089      	lsls	r1, r1, #2
   1bc6e:	1873      	adds	r3, r6, r1
   1bc70:	7821      	ldrb	r1, [r4, #0]
   1bc72:	4288      	cmp	r0, r1
   1bc74:	d3e7      	bcc.n	1bc46 <PE_Check_DataMessageVDM+0x5a>
   1bc76:	9900      	ldr	r1, [sp, #0]
   1bc78:	0022      	movs	r2, r4
   1bc7a:	6937      	ldr	r7, [r6, #16]
   1bc7c:	2001      	movs	r0, #1
   1bc7e:	4038      	ands	r0, r7
   1bc80:	68f6      	ldr	r6, [r6, #12]
   1bc82:	6c36      	ldr	r6, [r6, #64]	; 0x40
   1bc84:	47b0      	blx	r6
   1bc86:	2800      	cmp	r0, #0
   1bc88:	d104      	bne.n	1bc94 <PE_Check_DataMessageVDM+0xa8>
   1bc8a:	2003      	movs	r0, #3
   1bc8c:	7120      	strb	r0, [r4, #4]
   1bc8e:	2000      	movs	r0, #0
   1bc90:	9001      	str	r0, [sp, #4]
   1bc92:	e000      	b.n	1bc96 <PE_Check_DataMessageVDM+0xaa>
   1bc94:	7125      	strb	r5, [r4, #4]
   1bc96:	9801      	ldr	r0, [sp, #4]
   1bc98:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	...

0001bc9c <PE_Check_ExtendedMessage>:
   1bc9c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1bc9e:	0004      	movs	r4, r0
   1bca0:	20a1      	movs	r0, #161	; 0xa1
   1bca2:	0040      	lsls	r0, r0, #1
   1bca4:	1820      	adds	r0, r4, r0
   1bca6:	7801      	ldrb	r1, [r0, #0]
   1bca8:	7840      	ldrb	r0, [r0, #1]
   1bcaa:	0200      	lsls	r0, r0, #8
   1bcac:	1808      	adds	r0, r1, r0
   1bcae:	21a4      	movs	r1, #164	; 0xa4
   1bcb0:	0089      	lsls	r1, r1, #2
   1bcb2:	1866      	adds	r6, r4, r1
   1bcb4:	8430      	strh	r0, [r6, #32]
   1bcb6:	7cb1      	ldrb	r1, [r6, #18]
   1bcb8:	06c9      	lsls	r1, r1, #27
   1bcba:	0ec9      	lsrs	r1, r1, #27
   1bcbc:	4a9f      	ldr	r2, [pc, #636]	; (1bf3c <.text_112>)
   1bcbe:	54a1      	strb	r1, [r4, r2]
   1bcc0:	2501      	movs	r5, #1
   1bcc2:	0401      	lsls	r1, r0, #16
   1bcc4:	0e89      	lsrs	r1, r1, #26
   1bcc6:	2201      	movs	r2, #1
   1bcc8:	400a      	ands	r2, r1
   1bcca:	0401      	lsls	r1, r0, #16
   1bccc:	0ec9      	lsrs	r1, r1, #27
   1bcce:	0709      	lsls	r1, r1, #28
   1bcd0:	d003      	beq.n	1bcda <PE_Check_ExtendedMessage+0x3e>
   1bcd2:	0011      	movs	r1, r2
   1bcd4:	d001      	beq.n	1bcda <PE_Check_ExtendedMessage+0x3e>
   1bcd6:	2034      	movs	r0, #52	; 0x34
   1bcd8:	e0cd      	b.n	1be76 <PE_Check_ExtendedMessage+0x1da>
   1bcda:	05c3      	lsls	r3, r0, #23
   1bcdc:	0ddb      	lsrs	r3, r3, #23
   1bcde:	2100      	movs	r1, #0
   1bce0:	0407      	lsls	r7, r0, #16
   1bce2:	0fff      	lsrs	r7, r7, #31
   1bce4:	d10d      	bne.n	1bd02 <PE_Check_ExtendedMessage+0x66>
   1bce6:	4896      	ldr	r0, [pc, #600]	; (1bf40 <.text_113>)
   1bce8:	1822      	adds	r2, r4, r0
   1bcea:	8013      	strh	r3, [r2, #0]
   1bcec:	273c      	movs	r7, #60	; 0x3c
   1bcee:	8810      	ldrh	r0, [r2, #0]
   1bcf0:	4281      	cmp	r1, r0
   1bcf2:	d218      	bcs.n	1bd26 <PE_Check_ExtendedMessage+0x8a>
   1bcf4:	1860      	adds	r0, r4, r1
   1bcf6:	23a2      	movs	r3, #162	; 0xa2
   1bcf8:	005b      	lsls	r3, r3, #1
   1bcfa:	5cc3      	ldrb	r3, [r0, r3]
   1bcfc:	55c3      	strb	r3, [r0, r7]
   1bcfe:	1c49      	adds	r1, r1, #1
   1bd00:	e7f5      	b.n	1bcee <PE_Check_ExtendedMessage+0x52>
   1bd02:	27f8      	movs	r7, #248	; 0xf8
   1bd04:	01ff      	lsls	r7, r7, #7
   1bd06:	4007      	ands	r7, r0
   1bd08:	d107      	bne.n	1bd1a <PE_Check_ExtendedMessage+0x7e>
   1bd0a:	8a70      	ldrh	r0, [r6, #18]
   1bd0c:	0440      	lsls	r0, r0, #17
   1bd0e:	0f40      	lsrs	r0, r0, #29
   1bd10:	2806      	cmp	r0, #6
   1bd12:	d800      	bhi.n	1bd16 <PE_Check_ExtendedMessage+0x7a>
   1bd14:	e0b3      	b.n	1be7e <PE_Check_ExtendedMessage+0x1e2>
   1bd16:	2b1b      	cmp	r3, #27
   1bd18:	d3fb      	bcc.n	1bd12 <PE_Check_ExtendedMessage+0x76>
   1bd1a:	2a00      	cmp	r2, #0
   1bd1c:	d000      	beq.n	1bd20 <PE_Check_ExtendedMessage+0x84>
   1bd1e:	e0ae      	b.n	1be7e <PE_Check_ExtendedMessage+0x1e2>
   1bd20:	4887      	ldr	r0, [pc, #540]	; (1bf40 <.text_113>)
   1bd22:	5a20      	ldrh	r0, [r4, r0]
   1bd24:	4298      	cmp	r0, r3
   1bd26:	d300      	bcc.n	1bd2a <PE_Check_ExtendedMessage+0x8e>
   1bd28:	e0a9      	b.n	1be7e <PE_Check_ExtendedMessage+0x1e2>
   1bd2a:	80b1      	strh	r1, [r6, #4]
   1bd2c:	2037      	movs	r0, #55	; 0x37
   1bd2e:	e0a2      	b.n	1be76 <PE_Check_ExtendedMessage+0x1da>
   1bd30:	2318      	movs	r3, #24
   1bd32:	2113      	movs	r1, #19
   1bd34:	6927      	ldr	r7, [r4, #16]
   1bd36:	2001      	movs	r0, #1
   1bd38:	4038      	ands	r0, r7
   1bd3a:	68a7      	ldr	r7, [r4, #8]
   1bd3c:	69bf      	ldr	r7, [r7, #24]
   1bd3e:	47b8      	blx	r7
   1bd40:	2003      	movs	r0, #3
   1bd42:	7030      	strb	r0, [r6, #0]
   1bd44:	2000      	movs	r0, #0
   1bd46:	9000      	str	r0, [sp, #0]
   1bd48:	2300      	movs	r3, #0
   1bd4a:	2262      	movs	r2, #98	; 0x62
   1bd4c:	6920      	ldr	r0, [r4, #16]
   1bd4e:	2101      	movs	r1, #1
   1bd50:	4001      	ands	r1, r0
   1bd52:	2009      	movs	r0, #9
   1bd54:	4e7b      	ldr	r6, [pc, #492]	; (1bf44 <.text_114>)
   1bd56:	6a36      	ldr	r6, [r6, #32]
   1bd58:	47b0      	blx	r6
   1bd5a:	2162      	movs	r1, #98	; 0x62
   1bd5c:	e0c1      	b.n	1bee2 <PE_Check_ExtendedMessage+0x246>
   1bd5e:	2306      	movs	r3, #6
   1bd60:	2109      	movs	r1, #9
   1bd62:	6927      	ldr	r7, [r4, #16]
   1bd64:	2001      	movs	r0, #1
   1bd66:	4038      	ands	r0, r7
   1bd68:	68a7      	ldr	r7, [r4, #8]
   1bd6a:	69bf      	ldr	r7, [r7, #24]
   1bd6c:	47b8      	blx	r7
   1bd6e:	2003      	movs	r0, #3
   1bd70:	7030      	strb	r0, [r6, #0]
   1bd72:	2000      	movs	r0, #0
   1bd74:	9000      	str	r0, [sp, #0]
   1bd76:	2300      	movs	r3, #0
   1bd78:	224e      	movs	r2, #78	; 0x4e
   1bd7a:	6920      	ldr	r0, [r4, #16]
   1bd7c:	2101      	movs	r1, #1
   1bd7e:	4001      	ands	r1, r0
   1bd80:	2009      	movs	r0, #9
   1bd82:	4e70      	ldr	r6, [pc, #448]	; (1bf44 <.text_114>)
   1bd84:	6a36      	ldr	r6, [r6, #32]
   1bd86:	47b0      	blx	r6
   1bd88:	214e      	movs	r1, #78	; 0x4e
   1bd8a:	e0aa      	b.n	1bee2 <PE_Check_ExtendedMessage+0x246>
   1bd8c:	68a2      	ldr	r2, [r4, #8]
   1bd8e:	6917      	ldr	r7, [r2, #16]
   1bd90:	2f00      	cmp	r7, #0
   1bd92:	d072      	beq.n	1be7a <PE_Check_ExtendedMessage+0x1de>
   1bd94:	8803      	ldrh	r3, [r0, #0]
   1bd96:	0022      	movs	r2, r4
   1bd98:	323c      	adds	r2, #60	; 0x3c
   1bd9a:	6920      	ldr	r0, [r4, #16]
   1bd9c:	4005      	ands	r5, r0
   1bd9e:	0028      	movs	r0, r5
   1bda0:	47b8      	blx	r7
   1bda2:	2038      	movs	r0, #56	; 0x38
   1bda4:	e067      	b.n	1be76 <PE_Check_ExtendedMessage+0x1da>
   1bda6:	22a2      	movs	r2, #162	; 0xa2
   1bda8:	0052      	lsls	r2, r2, #1
   1bdaa:	18a2      	adds	r2, r4, r2
   1bdac:	1ecb      	subs	r3, r1, #3
   1bdae:	2b08      	cmp	r3, #8
   1bdb0:	d863      	bhi.n	1be7a <PE_Check_ExtendedMessage+0x1de>
   1bdb2:	a701      	add	r7, pc, #4	; (adr r7, 1bdb8 <PE_Check_ExtendedMessage+0x11c>)
   1bdb4:	5cff      	ldrb	r7, [r7, r3]
   1bdb6:	44bf      	add	pc, r7
   1bdb8:	44c02608 	.word	0x44c02608
   1bdbc:	629682c0 	.word	0x629682c0
   1bdc0:	006a      	.short	0x006a
   1bdc2:	6820      	ldr	r0, [r4, #0]
   1bdc4:	8900      	ldrh	r0, [r0, #8]
   1bdc6:	0b00      	lsrs	r0, r0, #12
   1bdc8:	4228      	tst	r0, r5
   1bdca:	d056      	beq.n	1be7a <PE_Check_ExtendedMessage+0x1de>
   1bdcc:	2301      	movs	r3, #1
   1bdce:	2110      	movs	r1, #16
   1bdd0:	6920      	ldr	r0, [r4, #16]
   1bdd2:	4005      	ands	r5, r0
   1bdd4:	0028      	movs	r0, r5
   1bdd6:	68a4      	ldr	r4, [r4, #8]
   1bdd8:	69a4      	ldr	r4, [r4, #24]
   1bdda:	47a0      	blx	r4
   1bddc:	203a      	movs	r0, #58	; 0x3a
   1bdde:	e04a      	b.n	1be76 <PE_Check_ExtendedMessage+0x1da>
   1bde0:	6820      	ldr	r0, [r4, #0]
   1bde2:	8900      	ldrh	r0, [r0, #8]
   1bde4:	0b00      	lsrs	r0, r0, #12
   1bde6:	4228      	tst	r0, r5
   1bde8:	d047      	beq.n	1be7a <PE_Check_ExtendedMessage+0x1de>
   1bdea:	2301      	movs	r3, #1
   1bdec:	210e      	movs	r1, #14
   1bdee:	6920      	ldr	r0, [r4, #16]
   1bdf0:	4005      	ands	r5, r0
   1bdf2:	0028      	movs	r0, r5
   1bdf4:	68a4      	ldr	r4, [r4, #8]
   1bdf6:	69a4      	ldr	r4, [r4, #24]
   1bdf8:	47a0      	blx	r4
   1bdfa:	203b      	movs	r0, #59	; 0x3b
   1bdfc:	e03b      	b.n	1be76 <PE_Check_ExtendedMessage+0x1da>
   1bdfe:	6820      	ldr	r0, [r4, #0]
   1be00:	8900      	ldrh	r0, [r0, #8]
   1be02:	0980      	lsrs	r0, r0, #6
   1be04:	4228      	tst	r0, r5
   1be06:	d038      	beq.n	1be7a <PE_Check_ExtendedMessage+0x1de>
   1be08:	2302      	movs	r3, #2
   1be0a:	210c      	movs	r1, #12
   1be0c:	6920      	ldr	r0, [r4, #16]
   1be0e:	4005      	ands	r5, r0
   1be10:	0028      	movs	r0, r5
   1be12:	68a4      	ldr	r4, [r4, #8]
   1be14:	69a4      	ldr	r4, [r4, #24]
   1be16:	47a0      	blx	r4
   1be18:	203c      	movs	r0, #60	; 0x3c
   1be1a:	e02c      	b.n	1be76 <PE_Check_ExtendedMessage+0x1da>
   1be1c:	6822      	ldr	r2, [r4, #0]
   1be1e:	8912      	ldrh	r2, [r2, #8]
   1be20:	0a92      	lsrs	r2, r2, #10
   1be22:	e00e      	b.n	1be42 <PE_Check_ExtendedMessage+0x1a6>
   1be24:	68a2      	ldr	r2, [r4, #8]
   1be26:	6916      	ldr	r6, [r2, #16]
   1be28:	2e00      	cmp	r6, #0
   1be2a:	d027      	beq.n	1be7c <PE_Check_ExtendedMessage+0x1e0>
   1be2c:	8803      	ldrh	r3, [r0, #0]
   1be2e:	0022      	movs	r2, r4
   1be30:	323c      	adds	r2, #60	; 0x3c
   1be32:	6920      	ldr	r0, [r4, #16]
   1be34:	4005      	ands	r5, r0
   1be36:	0028      	movs	r0, r5
   1be38:	47b0      	blx	r6
   1be3a:	bdf1      	pop	{r0, r4, r5, r6, r7, pc}
   1be3c:	6822      	ldr	r2, [r4, #0]
   1be3e:	8912      	ldrh	r2, [r2, #8]
   1be40:	0a52      	lsrs	r2, r2, #9
   1be42:	422a      	tst	r2, r5
   1be44:	d019      	beq.n	1be7a <PE_Check_ExtendedMessage+0x1de>
   1be46:	68a2      	ldr	r2, [r4, #8]
   1be48:	6912      	ldr	r2, [r2, #16]
   1be4a:	2a00      	cmp	r2, #0
   1be4c:	d109      	bne.n	1be62 <PE_Check_ExtendedMessage+0x1c6>
   1be4e:	e014      	b.n	1be7a <PE_Check_ExtendedMessage+0x1de>
   1be50:	6822      	ldr	r2, [r4, #0]
   1be52:	8912      	ldrh	r2, [r2, #8]
   1be54:	0a52      	lsrs	r2, r2, #9
   1be56:	422a      	tst	r2, r5
   1be58:	d010      	beq.n	1be7c <PE_Check_ExtendedMessage+0x1e0>
   1be5a:	68a2      	ldr	r2, [r4, #8]
   1be5c:	6912      	ldr	r2, [r2, #16]
   1be5e:	2a00      	cmp	r2, #0
   1be60:	d00c      	beq.n	1be7c <PE_Check_ExtendedMessage+0x1e0>
   1be62:	8803      	ldrh	r3, [r0, #0]
   1be64:	0022      	movs	r2, r4
   1be66:	323c      	adds	r2, #60	; 0x3c
   1be68:	6920      	ldr	r0, [r4, #16]
   1be6a:	4005      	ands	r5, r0
   1be6c:	0028      	movs	r0, r5
   1be6e:	68a4      	ldr	r4, [r4, #8]
   1be70:	6924      	ldr	r4, [r4, #16]
   1be72:	47a0      	blx	r4
   1be74:	2003      	movs	r0, #3
   1be76:	7030      	strb	r0, [r6, #0]
   1be78:	bdf1      	pop	{r0, r4, r5, r6, r7, pc}
   1be7a:	7035      	strb	r5, [r6, #0]
   1be7c:	bdf1      	pop	{r0, r4, r5, r6, r7, pc}
   1be7e:	482f      	ldr	r0, [pc, #188]	; (1bf3c <.text_112>)
   1be80:	5c21      	ldrb	r1, [r4, r0]
   1be82:	3850      	subs	r0, #80	; 0x50
   1be84:	1820      	adds	r0, r4, r0
   1be86:	221c      	movs	r2, #28
   1be88:	5ea2      	ldrsh	r2, [r4, r2]
   1be8a:	2a00      	cmp	r2, #0
   1be8c:	d08b      	beq.n	1bda6 <PE_Check_ExtendedMessage+0x10a>
   1be8e:	22a2      	movs	r2, #162	; 0xa2
   1be90:	0052      	lsls	r2, r2, #1
   1be92:	18a2      	adds	r2, r4, r2
   1be94:	1e4b      	subs	r3, r1, #1
   1be96:	d00e      	beq.n	1beb6 <PE_Check_ExtendedMessage+0x21a>
   1be98:	1e5b      	subs	r3, r3, #1
   1be9a:	d100      	bne.n	1be9e <PE_Check_ExtendedMessage+0x202>
   1be9c:	e75f      	b.n	1bd5e <PE_Check_ExtendedMessage+0xc2>
   1be9e:	1edb      	subs	r3, r3, #3
   1bea0:	d003      	beq.n	1beaa <PE_Check_ExtendedMessage+0x20e>
   1bea2:	1e9b      	subs	r3, r3, #2
   1bea4:	d001      	beq.n	1beaa <PE_Check_ExtendedMessage+0x20e>
   1bea6:	1f9b      	subs	r3, r3, #6
   1bea8:	2b01      	cmp	r3, #1
   1beaa:	d800      	bhi.n	1beae <PE_Check_ExtendedMessage+0x212>
   1beac:	e76e      	b.n	1bd8c <PE_Check_ExtendedMessage+0xf0>
   1beae:	1e9b      	subs	r3, r3, #2
   1beb0:	d100      	bne.n	1beb4 <PE_Check_ExtendedMessage+0x218>
   1beb2:	e73d      	b.n	1bd30 <PE_Check_ExtendedMessage+0x94>
   1beb4:	e7e1      	b.n	1be7a <PE_Check_ExtendedMessage+0x1de>
   1beb6:	2318      	movs	r3, #24
   1beb8:	2108      	movs	r1, #8
   1beba:	6927      	ldr	r7, [r4, #16]
   1bebc:	2001      	movs	r0, #1
   1bebe:	4038      	ands	r0, r7
   1bec0:	68a7      	ldr	r7, [r4, #8]
   1bec2:	69bf      	ldr	r7, [r7, #24]
   1bec4:	47b8      	blx	r7
   1bec6:	2003      	movs	r0, #3
   1bec8:	7030      	strb	r0, [r6, #0]
   1beca:	2000      	movs	r0, #0
   1becc:	9000      	str	r0, [sp, #0]
   1bece:	2300      	movs	r3, #0
   1bed0:	2247      	movs	r2, #71	; 0x47
   1bed2:	6920      	ldr	r0, [r4, #16]
   1bed4:	2101      	movs	r1, #1
   1bed6:	4001      	ands	r1, r0
   1bed8:	2009      	movs	r0, #9
   1beda:	4e1a      	ldr	r6, [pc, #104]	; (1bf44 <.text_114>)
   1bedc:	6a36      	ldr	r6, [r6, #32]
   1bede:	47b0      	blx	r6
   1bee0:	2147      	movs	r1, #71	; 0x47
   1bee2:	6920      	ldr	r0, [r4, #16]
   1bee4:	4005      	ands	r5, r0
   1bee6:	0028      	movs	r0, r5
   1bee8:	68a2      	ldr	r2, [r4, #8]
   1beea:	68d2      	ldr	r2, [r2, #12]
   1beec:	4790      	blx	r2
   1beee:	bdf1      	pop	{r0, r4, r5, r6, r7, pc}

0001bef0 <PE_PRL_HardResetReceived>:
   1bef0:	b57c      	push	{r2, r3, r4, r5, r6, lr}
   1bef2:	0004      	movs	r4, r0
   1bef4:	4813      	ldr	r0, [pc, #76]	; (1bf44 <.text_114>)
   1bef6:	00a1      	lsls	r1, r4, #2
   1bef8:	5845      	ldr	r5, [r0, r1]
   1befa:	6868      	ldr	r0, [r5, #4]
   1befc:	6801      	ldr	r1, [r0, #0]
   1befe:	2210      	movs	r2, #16
   1bf00:	4391      	bics	r1, r2
   1bf02:	6001      	str	r1, [r0, #0]
   1bf04:	48ba      	ldr	r0, [pc, #744]	; (1c1f0 <.text_119>)
   1bf06:	182e      	adds	r6, r5, r0
   1bf08:	2000      	movs	r0, #0
   1bf0a:	7030      	strb	r0, [r6, #0]
   1bf0c:	6928      	ldr	r0, [r5, #16]
   1bf0e:	49dc      	ldr	r1, [pc, #880]	; (1c280 <.text_122>)
   1bf10:	4001      	ands	r1, r0
   1bf12:	0110      	lsls	r0, r2, #4
   1bf14:	4308      	orrs	r0, r1
   1bf16:	6128      	str	r0, [r5, #16]
   1bf18:	0020      	movs	r0, r4
   1bf1a:	68a9      	ldr	r1, [r5, #8]
   1bf1c:	6a89      	ldr	r1, [r1, #40]	; 0x28
   1bf1e:	4788      	blx	r1
   1bf20:	6868      	ldr	r0, [r5, #4]
   1bf22:	6800      	ldr	r0, [r0, #0]
   1bf24:	0741      	lsls	r1, r0, #29
   1bf26:	0fc9      	lsrs	r1, r1, #31
   1bf28:	d001      	beq.n	1bf2e <PE_PRL_HardResetReceived+0x3e>
   1bf2a:	2014      	movs	r0, #20
   1bf2c:	e000      	b.n	1bf30 <PE_PRL_HardResetReceived+0x40>
   1bf2e:	203f      	movs	r0, #63	; 0x3f
   1bf30:	7070      	strb	r0, [r6, #1]
   1bf32:	0020      	movs	r0, r4
   1bf34:	f001 fc25 	bl	1d782 <USBPD_PRL_Reset>
   1bf38:	bd73      	pop	{r0, r1, r4, r5, r6, pc}
	...

0001bf3c <.text_112>:
   1bf3c:	000002b2 	.word	0x000002b2

0001bf40 <.text_113>:
   1bf40:	00000262 	.word	0x00000262

0001bf44 <.text_114>:
   1bf44:	0002ff54 	.word	0x0002ff54

0001bf48 <PE_PRL_BistCompleted>:
   1bf48:	4770      	bx	lr

0001bf4a <PE_Reset>:
   1bf4a:	b5f3      	push	{r0, r1, r4, r5, r6, r7, lr}
   1bf4c:	b083      	sub	sp, #12
   1bf4e:	48a9      	ldr	r0, [pc, #676]	; (1c1f4 <.text_120>)
   1bf50:	4669      	mov	r1, sp
   1bf52:	7b09      	ldrb	r1, [r1, #12]
   1bf54:	0089      	lsls	r1, r1, #2
   1bf56:	5844      	ldr	r4, [r0, r1]
   1bf58:	2500      	movs	r5, #0
   1bf5a:	9502      	str	r5, [sp, #8]
   1bf5c:	6860      	ldr	r0, [r4, #4]
   1bf5e:	6801      	ldr	r1, [r0, #0]
   1bf60:	2210      	movs	r2, #16
   1bf62:	4391      	bics	r1, r2
   1bf64:	6001      	str	r1, [r0, #0]
   1bf66:	6860      	ldr	r0, [r4, #4]
   1bf68:	6801      	ldr	r1, [r0, #0]
   1bf6a:	054a      	lsls	r2, r1, #21
   1bf6c:	0f52      	lsrs	r2, r2, #29
   1bf6e:	d014      	beq.n	1bf9a <PE_Reset+0x50>
   1bf70:	4ac4      	ldr	r2, [pc, #784]	; (1c284 <.text_123>)
   1bf72:	400a      	ands	r2, r1
   1bf74:	6002      	str	r2, [r0, #0]
   1bf76:	2601      	movs	r6, #1
   1bf78:	9500      	str	r5, [sp, #0]
   1bf7a:	2300      	movs	r3, #0
   1bf7c:	225a      	movs	r2, #90	; 0x5a
   1bf7e:	6920      	ldr	r0, [r4, #16]
   1bf80:	2101      	movs	r1, #1
   1bf82:	4001      	ands	r1, r0
   1bf84:	2009      	movs	r0, #9
   1bf86:	4f9b      	ldr	r7, [pc, #620]	; (1c1f4 <.text_120>)
   1bf88:	6a3f      	ldr	r7, [r7, #32]
   1bf8a:	47b8      	blx	r7
   1bf8c:	215a      	movs	r1, #90	; 0x5a
   1bf8e:	6920      	ldr	r0, [r4, #16]
   1bf90:	4006      	ands	r6, r0
   1bf92:	0030      	movs	r0, r6
   1bf94:	68a2      	ldr	r2, [r4, #8]
   1bf96:	68d2      	ldr	r2, [r2, #12]
   1bf98:	4790      	blx	r2
   1bf9a:	6920      	ldr	r0, [r4, #16]
   1bf9c:	2102      	movs	r1, #2
   1bf9e:	4388      	bics	r0, r1
   1bfa0:	6120      	str	r0, [r4, #16]
   1bfa2:	83a5      	strh	r5, [r4, #28]
   1bfa4:	49c8      	ldr	r1, [pc, #800]	; (1c2c8 <.text_125>)
   1bfa6:	1866      	adds	r6, r4, r1
   1bfa8:	7831      	ldrb	r1, [r6, #0]
   1bfaa:	2900      	cmp	r1, #0
   1bfac:	d010      	beq.n	1bfd0 <PE_Reset+0x86>
   1bfae:	7035      	strb	r5, [r6, #0]
   1bfb0:	9500      	str	r5, [sp, #0]
   1bfb2:	2300      	movs	r3, #0
   1bfb4:	225b      	movs	r2, #91	; 0x5b
   1bfb6:	07c1      	lsls	r1, r0, #31
   1bfb8:	0fc9      	lsrs	r1, r1, #31
   1bfba:	2009      	movs	r0, #9
   1bfbc:	4f8d      	ldr	r7, [pc, #564]	; (1c1f4 <.text_120>)
   1bfbe:	6a3f      	ldr	r7, [r7, #32]
   1bfc0:	47b8      	blx	r7
   1bfc2:	215b      	movs	r1, #91	; 0x5b
   1bfc4:	7c22      	ldrb	r2, [r4, #16]
   1bfc6:	07d0      	lsls	r0, r2, #31
   1bfc8:	0fc0      	lsrs	r0, r0, #31
   1bfca:	68a2      	ldr	r2, [r4, #8]
   1bfcc:	68d2      	ldr	r2, [r2, #12]
   1bfce:	4790      	blx	r2
   1bfd0:	4668      	mov	r0, sp
   1bfd2:	7c07      	ldrb	r7, [r0, #16]
   1bfd4:	0038      	movs	r0, r7
   1bfd6:	d105      	bne.n	1bfe4 <PE_Reset+0x9a>
   1bfd8:	7625      	strb	r5, [r4, #24]
   1bfda:	76a5      	strb	r5, [r4, #26]
   1bfdc:	6920      	ldr	r0, [r4, #16]
   1bfde:	49bb      	ldr	r1, [pc, #748]	; (1c2cc <.text_126>)
   1bfe0:	4001      	ands	r1, r0
   1bfe2:	6121      	str	r1, [r4, #16]
   1bfe4:	70b5      	strb	r5, [r6, #2]
   1bfe6:	71b5      	strb	r5, [r6, #6]
   1bfe8:	7075      	strb	r5, [r6, #1]
   1bfea:	6920      	ldr	r0, [r4, #16]
   1bfec:	49b8      	ldr	r1, [pc, #736]	; (1c2d0 <.text_127>)
   1bfee:	4001      	ands	r1, r0
   1bff0:	6121      	str	r1, [r4, #16]
   1bff2:	6860      	ldr	r0, [r4, #4]
   1bff4:	6800      	ldr	r0, [r0, #0]
   1bff6:	0741      	lsls	r1, r0, #29
   1bff8:	0fc9      	lsrs	r1, r1, #31
   1bffa:	d015      	beq.n	1c028 <PE_Reset+0xde>
   1bffc:	6820      	ldr	r0, [r4, #0]
   1bffe:	7900      	ldrb	r0, [r0, #4]
   1c000:	0783      	lsls	r3, r0, #30
   1c002:	0f9b      	lsrs	r3, r3, #30
   1c004:	2201      	movs	r2, #1
   1c006:	2101      	movs	r1, #1
   1c008:	4668      	mov	r0, sp
   1c00a:	7b00      	ldrb	r0, [r0, #12]
   1c00c:	f001 f9c7 	bl	1d39e <USBPD_PRL_SetHeader>
   1c010:	6860      	ldr	r0, [r4, #4]
   1c012:	6801      	ldr	r1, [r0, #0]
   1c014:	2208      	movs	r2, #8
   1c016:	430a      	orrs	r2, r1
   1c018:	6002      	str	r2, [r0, #0]
   1c01a:	2002      	movs	r0, #2
   1c01c:	70f0      	strb	r0, [r6, #3]
   1c01e:	6860      	ldr	r0, [r4, #4]
   1c020:	6800      	ldr	r0, [r0, #0]
   1c022:	0741      	lsls	r1, r0, #29
   1c024:	0fc9      	lsrs	r1, r1, #31
   1c026:	d112      	bne.n	1c04e <PE_Reset+0x104>
   1c028:	6820      	ldr	r0, [r4, #0]
   1c02a:	7900      	ldrb	r0, [r0, #4]
   1c02c:	0783      	lsls	r3, r0, #30
   1c02e:	0f9b      	lsrs	r3, r3, #30
   1c030:	2200      	movs	r2, #0
   1c032:	2100      	movs	r1, #0
   1c034:	4668      	mov	r0, sp
   1c036:	7b00      	ldrb	r0, [r0, #12]
   1c038:	f001 f9b1 	bl	1d39e <USBPD_PRL_SetHeader>
   1c03c:	6860      	ldr	r0, [r4, #4]
   1c03e:	6801      	ldr	r1, [r0, #0]
   1c040:	2208      	movs	r2, #8
   1c042:	4391      	bics	r1, r2
   1c044:	6001      	str	r1, [r0, #0]
   1c046:	2f00      	cmp	r7, #0
   1c048:	d101      	bne.n	1c04e <PE_Reset+0x104>
   1c04a:	203e      	movs	r0, #62	; 0x3e
   1c04c:	70f0      	strb	r0, [r6, #3]
   1c04e:	2304      	movs	r3, #4
   1c050:	aa02      	add	r2, sp, #8
   1c052:	2102      	movs	r1, #2
   1c054:	4668      	mov	r0, sp
   1c056:	7b00      	ldrb	r0, [r0, #12]
   1c058:	68a7      	ldr	r7, [r4, #8]
   1c05a:	69bf      	ldr	r7, [r7, #24]
   1c05c:	47b8      	blx	r7
   1c05e:	2080      	movs	r0, #128	; 0x80
   1c060:	0440      	lsls	r0, r0, #17
   1c062:	9001      	str	r0, [sp, #4]
   1c064:	2304      	movs	r3, #4
   1c066:	aa01      	add	r2, sp, #4
   1c068:	2106      	movs	r1, #6
   1c06a:	4668      	mov	r0, sp
   1c06c:	7b00      	ldrb	r0, [r0, #12]
   1c06e:	68a7      	ldr	r7, [r4, #8]
   1c070:	69bf      	ldr	r7, [r7, #24]
   1c072:	47b8      	blx	r7
   1c074:	2703      	movs	r7, #3
   1c076:	6820      	ldr	r0, [r4, #0]
   1c078:	6840      	ldr	r0, [r0, #4]
   1c07a:	4038      	ands	r0, r7
   1c07c:	6861      	ldr	r1, [r4, #4]
   1c07e:	680a      	ldr	r2, [r1, #0]
   1c080:	43ba      	bics	r2, r7
   1c082:	4310      	orrs	r0, r2
   1c084:	6008      	str	r0, [r1, #0]
   1c086:	6820      	ldr	r0, [r4, #0]
   1c088:	6841      	ldr	r1, [r0, #4]
   1c08a:	4039      	ands	r1, r7
   1c08c:	4668      	mov	r0, sp
   1c08e:	7b00      	ldrb	r0, [r0, #12]
   1c090:	f001 f9e0 	bl	1d454 <USBPD_PRL_CBL_SetHeaderSpecification>
   1c094:	6820      	ldr	r0, [r4, #0]
   1c096:	6840      	ldr	r0, [r0, #4]
   1c098:	4007      	ands	r7, r0
   1c09a:	6860      	ldr	r0, [r4, #4]
   1c09c:	6801      	ldr	r1, [r0, #0]
   1c09e:	4aa6      	ldr	r2, [pc, #664]	; (1c338 <.text_130>)
   1c0a0:	400a      	ands	r2, r1
   1c0a2:	05f9      	lsls	r1, r7, #23
   1c0a4:	4311      	orrs	r1, r2
   1c0a6:	6001      	str	r1, [r0, #0]
   1c0a8:	48a4      	ldr	r0, [pc, #656]	; (1c33c <.text_131>)
   1c0aa:	1820      	adds	r0, r4, r0
   1c0ac:	8005      	strh	r5, [r0, #0]
   1c0ae:	8045      	strh	r5, [r0, #2]
   1c0b0:	210e      	movs	r1, #14
   1c0b2:	20a5      	movs	r0, #165	; 0xa5
   1c0b4:	0080      	lsls	r0, r0, #2
   1c0b6:	1820      	adds	r0, r4, r0
   1c0b8:	f002 faae 	bl	1e618 <__aeabi_memclr>
   1c0bc:	78f2      	ldrb	r2, [r6, #3]
   1c0be:	7930      	ldrb	r0, [r6, #4]
   1c0c0:	4290      	cmp	r0, r2
   1c0c2:	d009      	beq.n	1c0d8 <PE_Reset+0x18e>
   1c0c4:	7132      	strb	r2, [r6, #4]
   1c0c6:	9500      	str	r5, [sp, #0]
   1c0c8:	2300      	movs	r3, #0
   1c0ca:	7c20      	ldrb	r0, [r4, #16]
   1c0cc:	07c1      	lsls	r1, r0, #31
   1c0ce:	0fc9      	lsrs	r1, r1, #31
   1c0d0:	2004      	movs	r0, #4
   1c0d2:	4c48      	ldr	r4, [pc, #288]	; (1c1f4 <.text_120>)
   1c0d4:	6a24      	ldr	r4, [r4, #32]
   1c0d6:	47a0      	blx	r4
   1c0d8:	4668      	mov	r0, sp
   1c0da:	7b00      	ldrb	r0, [r0, #12]
   1c0dc:	e084      	b.n	1c1e8 <.text_118>

0001c0de <PE_ResetDuringSwap>:
   1c0de:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1c0e0:	b084      	sub	sp, #16
   1c0e2:	0004      	movs	r4, r0
   1c0e4:	2700      	movs	r7, #0
   1c0e6:	9703      	str	r7, [sp, #12]
   1c0e8:	9701      	str	r7, [sp, #4]
   1c0ea:	6860      	ldr	r0, [r4, #4]
   1c0ec:	6801      	ldr	r1, [r0, #0]
   1c0ee:	2601      	movs	r6, #1
   1c0f0:	054a      	lsls	r2, r1, #21
   1c0f2:	0f52      	lsrs	r2, r2, #29
   1c0f4:	2a01      	cmp	r2, #1
   1c0f6:	d015      	beq.n	1c124 <PE_ResetDuringSwap+0x46>
   1c0f8:	4a62      	ldr	r2, [pc, #392]	; (1c284 <.text_123>)
   1c0fa:	400a      	ands	r2, r1
   1c0fc:	0231      	lsls	r1, r6, #8
   1c0fe:	4311      	orrs	r1, r2
   1c100:	6001      	str	r1, [r0, #0]
   1c102:	9700      	str	r7, [sp, #0]
   1c104:	2300      	movs	r3, #0
   1c106:	225a      	movs	r2, #90	; 0x5a
   1c108:	6920      	ldr	r0, [r4, #16]
   1c10a:	2101      	movs	r1, #1
   1c10c:	4001      	ands	r1, r0
   1c10e:	2009      	movs	r0, #9
   1c110:	4d38      	ldr	r5, [pc, #224]	; (1c1f4 <.text_120>)
   1c112:	6a2d      	ldr	r5, [r5, #32]
   1c114:	47a8      	blx	r5
   1c116:	215a      	movs	r1, #90	; 0x5a
   1c118:	6922      	ldr	r2, [r4, #16]
   1c11a:	2001      	movs	r0, #1
   1c11c:	4010      	ands	r0, r2
   1c11e:	68a2      	ldr	r2, [r4, #8]
   1c120:	68d2      	ldr	r2, [r2, #12]
   1c122:	4790      	blx	r2
   1c124:	4868      	ldr	r0, [pc, #416]	; (1c2c8 <.text_125>)
   1c126:	1825      	adds	r5, r4, r0
   1c128:	71af      	strb	r7, [r5, #6]
   1c12a:	7828      	ldrb	r0, [r5, #0]
   1c12c:	2800      	cmp	r0, #0
   1c12e:	d011      	beq.n	1c154 <PE_ResetDuringSwap+0x76>
   1c130:	702f      	strb	r7, [r5, #0]
   1c132:	9700      	str	r7, [sp, #0]
   1c134:	2300      	movs	r3, #0
   1c136:	225b      	movs	r2, #91	; 0x5b
   1c138:	6920      	ldr	r0, [r4, #16]
   1c13a:	2101      	movs	r1, #1
   1c13c:	4001      	ands	r1, r0
   1c13e:	2009      	movs	r0, #9
   1c140:	4f2c      	ldr	r7, [pc, #176]	; (1c1f4 <.text_120>)
   1c142:	6a3f      	ldr	r7, [r7, #32]
   1c144:	47b8      	blx	r7
   1c146:	215b      	movs	r1, #91	; 0x5b
   1c148:	6922      	ldr	r2, [r4, #16]
   1c14a:	2001      	movs	r0, #1
   1c14c:	4010      	ands	r0, r2
   1c14e:	68a2      	ldr	r2, [r4, #8]
   1c150:	68d2      	ldr	r2, [r2, #12]
   1c152:	4790      	blx	r2
   1c154:	6920      	ldr	r0, [r4, #16]
   1c156:	495e      	ldr	r1, [pc, #376]	; (1c2d0 <.text_127>)
   1c158:	4001      	ands	r1, r0
   1c15a:	6121      	str	r1, [r4, #16]
   1c15c:	6860      	ldr	r0, [r4, #4]
   1c15e:	6801      	ldr	r1, [r0, #0]
   1c160:	2210      	movs	r2, #16
   1c162:	4391      	bics	r1, r2
   1c164:	6001      	str	r1, [r0, #0]
   1c166:	6860      	ldr	r0, [r4, #4]
   1c168:	6801      	ldr	r1, [r0, #0]
   1c16a:	08ca      	lsrs	r2, r1, #3
   1c16c:	4032      	ands	r2, r6
   1c16e:	6923      	ldr	r3, [r4, #16]
   1c170:	2001      	movs	r0, #1
   1c172:	4018      	ands	r0, r3
   1c174:	078b      	lsls	r3, r1, #30
   1c176:	0f9b      	lsrs	r3, r3, #30
   1c178:	0889      	lsrs	r1, r1, #2
   1c17a:	4031      	ands	r1, r6
   1c17c:	d003      	beq.n	1c186 <PE_ResetDuringSwap+0xa8>
   1c17e:	f001 f90e 	bl	1d39e <USBPD_PRL_SetHeader>
   1c182:	2002      	movs	r0, #2
   1c184:	e002      	b.n	1c18c <PE_ResetDuringSwap+0xae>
   1c186:	f001 f90a 	bl	1d39e <USBPD_PRL_SetHeader>
   1c18a:	203e      	movs	r0, #62	; 0x3e
   1c18c:	70e8      	strb	r0, [r5, #3]
   1c18e:	0630      	lsls	r0, r6, #24
   1c190:	9002      	str	r0, [sp, #8]
   1c192:	2304      	movs	r3, #4
   1c194:	aa02      	add	r2, sp, #8
   1c196:	2106      	movs	r1, #6
   1c198:	6925      	ldr	r5, [r4, #16]
   1c19a:	2001      	movs	r0, #1
   1c19c:	4028      	ands	r0, r5
   1c19e:	68a5      	ldr	r5, [r4, #8]
   1c1a0:	69ad      	ldr	r5, [r5, #24]
   1c1a2:	47a8      	blx	r5
   1c1a4:	2304      	movs	r3, #4
   1c1a6:	aa03      	add	r2, sp, #12
   1c1a8:	2102      	movs	r1, #2
   1c1aa:	6925      	ldr	r5, [r4, #16]
   1c1ac:	2001      	movs	r0, #1
   1c1ae:	4028      	ands	r0, r5
   1c1b0:	68a5      	ldr	r5, [r4, #8]
   1c1b2:	69ad      	ldr	r5, [r5, #24]
   1c1b4:	47a8      	blx	r5
   1c1b6:	20a6      	movs	r0, #166	; 0xa6
   1c1b8:	0080      	lsls	r0, r0, #2
   1c1ba:	1825      	adds	r5, r4, r0
   1c1bc:	48b6      	ldr	r0, [pc, #728]	; (1c498 <.text_134>)
   1c1be:	8829      	ldrh	r1, [r5, #0]
   1c1c0:	4201      	tst	r1, r0
   1c1c2:	d002      	beq.n	1c1ca <PE_ResetDuringSwap+0xec>
   1c1c4:	8829      	ldrh	r1, [r5, #0]
   1c1c6:	4008      	ands	r0, r1
   1c1c8:	9001      	str	r0, [sp, #4]
   1c1ca:	210e      	movs	r1, #14
   1c1cc:	20a5      	movs	r0, #165	; 0xa5
   1c1ce:	0080      	lsls	r0, r0, #2
   1c1d0:	1820      	adds	r0, r4, r0
   1c1d2:	f002 fa21 	bl	1e618 <__aeabi_memclr>
   1c1d6:	9801      	ldr	r0, [sp, #4]
   1c1d8:	2800      	cmp	r0, #0
   1c1da:	d002      	beq.n	1c1e2 <PE_ResetDuringSwap+0x104>
   1c1dc:	03f1      	lsls	r1, r6, #15
   1c1de:	4301      	orrs	r1, r0
   1c1e0:	8029      	strh	r1, [r5, #0]
   1c1e2:	6920      	ldr	r0, [r4, #16]
   1c1e4:	4006      	ands	r6, r0
   1c1e6:	0030      	movs	r0, r6

0001c1e8 <.text_118>:
   1c1e8:	f001 facb 	bl	1d782 <USBPD_PRL_Reset>
   1c1ec:	b005      	add	sp, #20
   1c1ee:	bdf0      	pop	{r4, r5, r6, r7, pc}

0001c1f0 <.text_119>:
   1c1f0:	0000028f 	.word	0x0000028f

0001c1f4 <.text_120>:
   1c1f4:	0002ff54 	.word	0x0002ff54

0001c1f8 <PE_ExtRevisionInteroperability>:
   1c1f8:	b5f1      	push	{r0, r4, r5, r6, r7, lr}
   1c1fa:	b082      	sub	sp, #8
   1c1fc:	0008      	movs	r0, r1
   1c1fe:	4ca7      	ldr	r4, [pc, #668]	; (1c49c <.text_135>)
   1c200:	4669      	mov	r1, sp
   1c202:	7a09      	ldrb	r1, [r1, #8]
   1c204:	0089      	lsls	r1, r1, #2
   1c206:	1861      	adds	r1, r4, r1
   1c208:	9101      	str	r1, [sp, #4]
   1c20a:	680a      	ldr	r2, [r1, #0]
   1c20c:	6853      	ldr	r3, [r2, #4]
   1c20e:	681d      	ldr	r5, [r3, #0]
   1c210:	2103      	movs	r1, #3
   1c212:	2603      	movs	r6, #3
   1c214:	402e      	ands	r6, r5
   1c216:	4286      	cmp	r6, r0
   1c218:	d031      	beq.n	1c27e <PE_ExtRevisionInteroperability+0x86>
   1c21a:	42b0      	cmp	r0, r6
   1c21c:	db00      	blt.n	1c220 <PE_ExtRevisionInteroperability+0x28>
   1c21e:	0030      	movs	r0, r6
   1c220:	2603      	movs	r6, #3
   1c222:	43b5      	bics	r5, r6
   1c224:	4008      	ands	r0, r1
   1c226:	4328      	orrs	r0, r5
   1c228:	6018      	str	r0, [r3, #0]
   1c22a:	6850      	ldr	r0, [r2, #4]
   1c22c:	6803      	ldr	r3, [r0, #0]
   1c22e:	2501      	movs	r5, #1
   1c230:	401e      	ands	r6, r3
   1c232:	2e01      	cmp	r6, #1
   1c234:	d101      	bne.n	1c23a <PE_ExtRevisionInteroperability+0x42>
   1c236:	2600      	movs	r6, #0
   1c238:	e000      	b.n	1c23c <PE_ExtRevisionInteroperability+0x44>
   1c23a:	2601      	movs	r6, #1
   1c23c:	2720      	movs	r7, #32
   1c23e:	43bb      	bics	r3, r7
   1c240:	0176      	lsls	r6, r6, #5
   1c242:	431e      	orrs	r6, r3
   1c244:	6006      	str	r6, [r0, #0]
   1c246:	6850      	ldr	r0, [r2, #4]
   1c248:	6800      	ldr	r0, [r0, #0]
   1c24a:	4001      	ands	r1, r0
   1c24c:	4668      	mov	r0, sp
   1c24e:	7a00      	ldrb	r0, [r0, #8]
   1c250:	f001 f8eb 	bl	1d42a <USBPD_PRL_SetHeaderSpecification>
   1c254:	2000      	movs	r0, #0
   1c256:	9000      	str	r0, [sp, #0]
   1c258:	2300      	movs	r3, #0
   1c25a:	2238      	movs	r2, #56	; 0x38
   1c25c:	9801      	ldr	r0, [sp, #4]
   1c25e:	6800      	ldr	r0, [r0, #0]
   1c260:	6900      	ldr	r0, [r0, #16]
   1c262:	2101      	movs	r1, #1
   1c264:	4001      	ands	r1, r0
   1c266:	2009      	movs	r0, #9
   1c268:	6a24      	ldr	r4, [r4, #32]
   1c26a:	47a0      	blx	r4
   1c26c:	9801      	ldr	r0, [sp, #4]
   1c26e:	6802      	ldr	r2, [r0, #0]
   1c270:	2138      	movs	r1, #56	; 0x38
   1c272:	6910      	ldr	r0, [r2, #16]
   1c274:	4005      	ands	r5, r0
   1c276:	0028      	movs	r0, r5
   1c278:	6892      	ldr	r2, [r2, #8]
   1c27a:	68d2      	ldr	r2, [r2, #12]
   1c27c:	4790      	blx	r2
   1c27e:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}

0001c280 <.text_122>:
   1c280:	fffffcff 	.word	0xfffffcff

0001c284 <.text_123>:
   1c284:	fffff8ff 	.word	0xfffff8ff

0001c288 <PE_ExtRevisionInteroperability_Cable>:
   1c288:	b570      	push	{r4, r5, r6, lr}
   1c28a:	4a84      	ldr	r2, [pc, #528]	; (1c49c <.text_135>)
   1c28c:	0083      	lsls	r3, r0, #2
   1c28e:	58d3      	ldr	r3, [r2, r3]
   1c290:	685c      	ldr	r4, [r3, #4]
   1c292:	6826      	ldr	r6, [r4, #0]
   1c294:	2203      	movs	r2, #3
   1c296:	0df5      	lsrs	r5, r6, #23
   1c298:	4015      	ands	r5, r2
   1c29a:	428d      	cmp	r5, r1
   1c29c:	d012      	beq.n	1c2c4 <PE_ExtRevisionInteroperability_Cable+0x3c>
   1c29e:	2503      	movs	r5, #3
   1c2a0:	4035      	ands	r5, r6
   1c2a2:	42a9      	cmp	r1, r5
   1c2a4:	da00      	bge.n	1c2a8 <PE_ExtRevisionInteroperability_Cable+0x20>
   1c2a6:	000d      	movs	r5, r1
   1c2a8:	4923      	ldr	r1, [pc, #140]	; (1c338 <.text_130>)
   1c2aa:	4031      	ands	r1, r6
   1c2ac:	05ed      	lsls	r5, r5, #23
   1c2ae:	05d6      	lsls	r6, r2, #23
   1c2b0:	402e      	ands	r6, r5
   1c2b2:	430e      	orrs	r6, r1
   1c2b4:	6026      	str	r6, [r4, #0]
   1c2b6:	6859      	ldr	r1, [r3, #4]
   1c2b8:	6809      	ldr	r1, [r1, #0]
   1c2ba:	0dcb      	lsrs	r3, r1, #23
   1c2bc:	2103      	movs	r1, #3
   1c2be:	4019      	ands	r1, r3
   1c2c0:	f001 f8c8 	bl	1d454 <USBPD_PRL_CBL_SetHeaderSpecification>
   1c2c4:	bd70      	pop	{r4, r5, r6, pc}
	...

0001c2c8 <.text_125>:
   1c2c8:	0000028d 	.word	0x0000028d

0001c2cc <.text_126>:
   1c2cc:	ffffbfff 	.word	0xffffbfff

0001c2d0 <.text_127>:
   1c2d0:	ffff7fff 	.word	0xffff7fff

0001c2d4 <PE_PRL_PostReceiveEvent>:
   1c2d4:	b538      	push	{r3, r4, r5, lr}
   1c2d6:	4c71      	ldr	r4, [pc, #452]	; (1c49c <.text_135>)
   1c2d8:	0085      	lsls	r5, r0, #2
   1c2da:	5964      	ldr	r4, [r4, r5]
   1c2dc:	4da5      	ldr	r5, [pc, #660]	; (1c574 <.text_138>)
   1c2de:	1965      	adds	r5, r4, r5
   1c2e0:	2900      	cmp	r1, #0
   1c2e2:	d006      	beq.n	1c2f2 <PE_PRL_PostReceiveEvent+0x1e>
   1c2e4:	2902      	cmp	r1, #2
   1c2e6:	d008      	beq.n	1c2fa <PE_PRL_PostReceiveEvent+0x26>
   1c2e8:	d305      	bcc.n	1c2f6 <PE_PRL_PostReceiveEvent+0x22>
   1c2ea:	2904      	cmp	r1, #4
   1c2ec:	d009      	beq.n	1c302 <PE_PRL_PostReceiveEvent+0x2e>
   1c2ee:	d306      	bcc.n	1c2fe <PE_PRL_PostReceiveEvent+0x2a>
   1c2f0:	e009      	b.n	1c306 <PE_PRL_PostReceiveEvent+0x32>
   1c2f2:	2101      	movs	r1, #1
   1c2f4:	e008      	b.n	1c308 <PE_PRL_PostReceiveEvent+0x34>
   1c2f6:	2102      	movs	r1, #2
   1c2f8:	e006      	b.n	1c308 <PE_PRL_PostReceiveEvent+0x34>
   1c2fa:	2104      	movs	r1, #4
   1c2fc:	e004      	b.n	1c308 <PE_PRL_PostReceiveEvent+0x34>
   1c2fe:	2108      	movs	r1, #8
   1c300:	e002      	b.n	1c308 <PE_PRL_PostReceiveEvent+0x34>
   1c302:	2110      	movs	r1, #16
   1c304:	e000      	b.n	1c308 <PE_PRL_PostReceiveEvent+0x34>
   1c306:	2100      	movs	r1, #0
   1c308:	7029      	strb	r1, [r5, #0]
   1c30a:	8811      	ldrh	r1, [r2, #0]
   1c30c:	4a9a      	ldr	r2, [pc, #616]	; (1c578 <.text_139>)
   1c30e:	52a1      	strh	r1, [r4, r2]
   1c310:	2b00      	cmp	r3, #0
   1c312:	d101      	bne.n	1c318 <PE_PRL_PostReceiveEvent+0x44>
   1c314:	f001 fa67 	bl	1d7e6 <USBPD_PRL_DisableRX>
   1c318:	bd31      	pop	{r0, r4, r5, pc}

0001c31a <PE_PRL_PostReceiveEventComplete>:
   1c31a:	b510      	push	{r4, lr}
   1c31c:	495f      	ldr	r1, [pc, #380]	; (1c49c <.text_135>)
   1c31e:	0082      	lsls	r2, r0, #2
   1c320:	5889      	ldr	r1, [r1, r2]
   1c322:	4a94      	ldr	r2, [pc, #592]	; (1c574 <.text_138>)
   1c324:	188a      	adds	r2, r1, r2
   1c326:	7813      	ldrb	r3, [r2, #0]
   1c328:	2420      	movs	r4, #32
   1c32a:	431c      	orrs	r4, r3
   1c32c:	7014      	strb	r4, [r2, #0]
   1c32e:	6889      	ldr	r1, [r1, #8]
   1c330:	6a89      	ldr	r1, [r1, #40]	; 0x28
   1c332:	4788      	blx	r1
   1c334:	bd10      	pop	{r4, pc}
	...

0001c338 <.text_130>:
   1c338:	fe7fffff 	.word	0xfe7fffff

0001c33c <.text_131>:
   1c33c:	00000262 	.word	0x00000262

0001c340 <PE_SVDM_CheckIdentity>:
   1c340:	b578      	push	{r3, r4, r5, r6, lr}
   1c342:	0003      	movs	r3, r0
   1c344:	2000      	movs	r0, #0
   1c346:	4c55      	ldr	r4, [pc, #340]	; (1c49c <.text_135>)
   1c348:	009b      	lsls	r3, r3, #2
   1c34a:	58e3      	ldr	r3, [r4, r3]
   1c34c:	9300      	str	r3, [sp, #0]
   1c34e:	4c8a      	ldr	r4, [pc, #552]	; (1c578 <.text_139>)
   1c350:	5b1b      	ldrh	r3, [r3, r4]
   1c352:	045b      	lsls	r3, r3, #17
   1c354:	0f5b      	lsrs	r3, r3, #29
   1c356:	1e5b      	subs	r3, r3, #1
   1c358:	b2db      	uxtb	r3, r3
   1c35a:	2b02      	cmp	r3, #2
   1c35c:	d95b      	bls.n	1c416 <PE_SVDM_CheckIdentity+0xd6>
   1c35e:	780c      	ldrb	r4, [r1, #0]
   1c360:	784d      	ldrb	r5, [r1, #1]
   1c362:	022d      	lsls	r5, r5, #8
   1c364:	1964      	adds	r4, r4, r5
   1c366:	788d      	ldrb	r5, [r1, #2]
   1c368:	042d      	lsls	r5, r5, #16
   1c36a:	1964      	adds	r4, r4, r5
   1c36c:	78cd      	ldrb	r5, [r1, #3]
   1c36e:	062d      	lsls	r5, r5, #24
   1c370:	1964      	adds	r4, r4, r5
   1c372:	6014      	str	r4, [r2, #0]
   1c374:	790d      	ldrb	r5, [r1, #4]
   1c376:	794e      	ldrb	r6, [r1, #5]
   1c378:	0236      	lsls	r6, r6, #8
   1c37a:	19ad      	adds	r5, r5, r6
   1c37c:	798e      	ldrb	r6, [r1, #6]
   1c37e:	0436      	lsls	r6, r6, #16
   1c380:	19ad      	adds	r5, r5, r6
   1c382:	79ce      	ldrb	r6, [r1, #7]
   1c384:	0636      	lsls	r6, r6, #24
   1c386:	19ad      	adds	r5, r5, r6
   1c388:	6055      	str	r5, [r2, #4]
   1c38a:	7a0d      	ldrb	r5, [r1, #8]
   1c38c:	7a4e      	ldrb	r6, [r1, #9]
   1c38e:	0236      	lsls	r6, r6, #8
   1c390:	19ad      	adds	r5, r5, r6
   1c392:	7a8e      	ldrb	r6, [r1, #10]
   1c394:	0436      	lsls	r6, r6, #16
   1c396:	19ad      	adds	r5, r5, r6
   1c398:	7ace      	ldrb	r6, [r1, #11]
   1c39a:	0636      	lsls	r6, r6, #24
   1c39c:	19ad      	adds	r5, r5, r6
   1c39e:	6095      	str	r5, [r2, #8]
   1c3a0:	1edb      	subs	r3, r3, #3
   1c3a2:	061b      	lsls	r3, r3, #24
   1c3a4:	d038      	beq.n	1c418 <PE_SVDM_CheckIdentity+0xd8>
   1c3a6:	7d15      	ldrb	r5, [r2, #20]
   1c3a8:	23fc      	movs	r3, #252	; 0xfc
   1c3aa:	402b      	ands	r3, r5
   1c3ac:	7513      	strb	r3, [r2, #20]
   1c3ae:	2502      	movs	r5, #2
   1c3b0:	00a6      	lsls	r6, r4, #2
   1c3b2:	0f76      	lsrs	r6, r6, #29
   1c3b4:	2e02      	cmp	r6, #2
   1c3b6:	d923      	bls.n	1c400 <PE_SVDM_CheckIdentity+0xc0>
   1c3b8:	1ef6      	subs	r6, r6, #3
   1c3ba:	2e01      	cmp	r6, #1
   1c3bc:	d902      	bls.n	1c3c4 <PE_SVDM_CheckIdentity+0x84>
   1c3be:	1eb6      	subs	r6, r6, #2
   1c3c0:	d00f      	beq.n	1c3e2 <PE_SVDM_CheckIdentity+0xa2>
   1c3c2:	e01c      	b.n	1c3fe <PE_SVDM_CheckIdentity+0xbe>
   1c3c4:	2501      	movs	r5, #1
   1c3c6:	431d      	orrs	r5, r3
   1c3c8:	7515      	strb	r5, [r2, #20]
   1c3ca:	7b0b      	ldrb	r3, [r1, #12]
   1c3cc:	7b4d      	ldrb	r5, [r1, #13]
   1c3ce:	022d      	lsls	r5, r5, #8
   1c3d0:	195b      	adds	r3, r3, r5
   1c3d2:	7b8d      	ldrb	r5, [r1, #14]
   1c3d4:	042d      	lsls	r5, r5, #16
   1c3d6:	195b      	adds	r3, r3, r5
   1c3d8:	7bc9      	ldrb	r1, [r1, #15]
   1c3da:	0609      	lsls	r1, r1, #24
   1c3dc:	1859      	adds	r1, r3, r1
   1c3de:	60d1      	str	r1, [r2, #12]
   1c3e0:	e00e      	b.n	1c400 <PE_SVDM_CheckIdentity+0xc0>
   1c3e2:	431d      	orrs	r5, r3
   1c3e4:	7515      	strb	r5, [r2, #20]
   1c3e6:	7b0b      	ldrb	r3, [r1, #12]
   1c3e8:	7b4d      	ldrb	r5, [r1, #13]
   1c3ea:	022d      	lsls	r5, r5, #8
   1c3ec:	195b      	adds	r3, r3, r5
   1c3ee:	7b8d      	ldrb	r5, [r1, #14]
   1c3f0:	042d      	lsls	r5, r5, #16
   1c3f2:	195b      	adds	r3, r3, r5
   1c3f4:	7bc9      	ldrb	r1, [r1, #15]
   1c3f6:	0609      	lsls	r1, r1, #24
   1c3f8:	1859      	adds	r1, r3, r1
   1c3fa:	6111      	str	r1, [r2, #16]
   1c3fc:	e000      	b.n	1c400 <PE_SVDM_CheckIdentity+0xc0>
   1c3fe:	2002      	movs	r0, #2
   1c400:	9900      	ldr	r1, [sp, #0]
   1c402:	4a5d      	ldr	r2, [pc, #372]	; (1c578 <.text_139>)
   1c404:	5a89      	ldrh	r1, [r1, r2]
   1c406:	0609      	lsls	r1, r1, #24
   1c408:	0f89      	lsrs	r1, r1, #30
   1c40a:	2902      	cmp	r1, #2
   1c40c:	d304      	bcc.n	1c418 <PE_SVDM_CheckIdentity+0xd8>
   1c40e:	01a1      	lsls	r1, r4, #6
   1c410:	0f49      	lsrs	r1, r1, #29
   1c412:	2904      	cmp	r1, #4
   1c414:	d900      	bls.n	1c418 <PE_SVDM_CheckIdentity+0xd8>
   1c416:	2002      	movs	r0, #2
   1c418:	bd72      	pop	{r1, r4, r5, r6, pc}

0001c41a <PE_SVDM_CheckSVIDs>:
   1c41a:	b5f0      	push	{r4, r5, r6, r7, lr}
   1c41c:	4b1f      	ldr	r3, [pc, #124]	; (1c49c <.text_135>)
   1c41e:	0080      	lsls	r0, r0, #2
   1c420:	5818      	ldr	r0, [r3, r0]
   1c422:	4b55      	ldr	r3, [pc, #340]	; (1c578 <.text_139>)
   1c424:	5ac0      	ldrh	r0, [r0, r3]
   1c426:	0440      	lsls	r0, r0, #17
   1c428:	0f40      	lsrs	r0, r0, #29
   1c42a:	1e43      	subs	r3, r0, #1
   1c42c:	061b      	lsls	r3, r3, #24
   1c42e:	2000      	movs	r0, #0
   1c430:	2500      	movs	r5, #0
   1c432:	7610      	strb	r0, [r2, #24]
   1c434:	7650      	strb	r0, [r2, #25]
   1c436:	0d9c      	lsrs	r4, r3, #22
   1c438:	000b      	movs	r3, r1
   1c43a:	5c19      	ldrb	r1, [r3, r0]
   1c43c:	1c5e      	adds	r6, r3, #1
   1c43e:	5c36      	ldrb	r6, [r6, r0]
   1c440:	0236      	lsls	r6, r6, #8
   1c442:	1989      	adds	r1, r1, r6
   1c444:	7e16      	ldrb	r6, [r2, #24]
   1c446:	0076      	lsls	r6, r6, #1
   1c448:	5391      	strh	r1, [r2, r6]
   1c44a:	7e16      	ldrb	r6, [r2, #24]
   1c44c:	2101      	movs	r1, #1
   1c44e:	0077      	lsls	r7, r6, #1
   1c450:	5bd7      	ldrh	r7, [r2, r7]
   1c452:	2f00      	cmp	r7, #0
   1c454:	d002      	beq.n	1c45c <PE_SVDM_CheckSVIDs+0x42>
   1c456:	1c76      	adds	r6, r6, #1
   1c458:	7616      	strb	r6, [r2, #24]
   1c45a:	e001      	b.n	1c460 <PE_SVDM_CheckSVIDs+0x46>
   1c45c:	2501      	movs	r5, #1
   1c45e:	7651      	strb	r1, [r2, #25]
   1c460:	1c80      	adds	r0, r0, #2
   1c462:	b2c0      	uxtb	r0, r0
   1c464:	5c1e      	ldrb	r6, [r3, r0]
   1c466:	1c5f      	adds	r7, r3, #1
   1c468:	5c3f      	ldrb	r7, [r7, r0]
   1c46a:	023f      	lsls	r7, r7, #8
   1c46c:	19f6      	adds	r6, r6, r7
   1c46e:	7e17      	ldrb	r7, [r2, #24]
   1c470:	007f      	lsls	r7, r7, #1
   1c472:	53d6      	strh	r6, [r2, r7]
   1c474:	7e16      	ldrb	r6, [r2, #24]
   1c476:	0077      	lsls	r7, r6, #1
   1c478:	5bd7      	ldrh	r7, [r2, r7]
   1c47a:	2f00      	cmp	r7, #0
   1c47c:	d002      	beq.n	1c484 <PE_SVDM_CheckSVIDs+0x6a>
   1c47e:	1c76      	adds	r6, r6, #1
   1c480:	7616      	strb	r6, [r2, #24]
   1c482:	e001      	b.n	1c488 <PE_SVDM_CheckSVIDs+0x6e>
   1c484:	2501      	movs	r5, #1
   1c486:	7651      	strb	r1, [r2, #25]
   1c488:	1c80      	adds	r0, r0, #2
   1c48a:	b2c0      	uxtb	r0, r0
   1c48c:	42a0      	cmp	r0, r4
   1c48e:	d201      	bcs.n	1c494 <PE_SVDM_CheckSVIDs+0x7a>
   1c490:	0029      	movs	r1, r5
   1c492:	d0d2      	beq.n	1c43a <PE_SVDM_CheckSVIDs+0x20>
   1c494:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

0001c498 <.text_134>:
   1c498:	00007fff 	.word	0x00007fff

0001c49c <.text_135>:
   1c49c:	0002ff54 	.word	0x0002ff54

0001c4a0 <PE_Send_ExtendedMessage>:
   1c4a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1c4a2:	b084      	sub	sp, #16
   1c4a4:	0014      	movs	r4, r2
   1c4a6:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   1c4a8:	9f0c      	ldr	r7, [sp, #48]	; 0x30
   1c4aa:	466d      	mov	r5, sp
   1c4ac:	2680      	movs	r6, #128	; 0x80
   1c4ae:	4326      	orrs	r6, r4
   1c4b0:	722e      	strb	r6, [r5, #8]
   1c4b2:	2601      	movs	r6, #1
   1c4b4:	0004      	movs	r4, r0
   1c4b6:	000d      	movs	r5, r1
   1c4b8:	9303      	str	r3, [sp, #12]
   1c4ba:	4668      	mov	r0, sp
   1c4bc:	8502      	strh	r2, [r0, #40]	; 0x28
   1c4be:	6860      	ldr	r0, [r4, #4]
   1c4c0:	6800      	ldr	r0, [r0, #0]
   1c4c2:	0b00      	lsrs	r0, r0, #12
   1c4c4:	4030      	ands	r0, r6
   1c4c6:	d018      	beq.n	1c4fa <PE_Send_ExtendedMessage+0x5a>
   1c4c8:	9701      	str	r7, [sp, #4]
   1c4ca:	4668      	mov	r0, sp
   1c4cc:	8d00      	ldrh	r0, [r0, #40]	; 0x28
   1c4ce:	9000      	str	r0, [sp, #0]
   1c4d0:	9b03      	ldr	r3, [sp, #12]
   1c4d2:	4668      	mov	r0, sp
   1c4d4:	7a02      	ldrb	r2, [r0, #8]
   1c4d6:	6921      	ldr	r1, [r4, #16]
   1c4d8:	2001      	movs	r0, #1
   1c4da:	4008      	ands	r0, r1
   1c4dc:	0029      	movs	r1, r5
   1c4de:	f000 ffe7 	bl	1d4b0 <USBPD_PRL_SendMessage>
   1c4e2:	2803      	cmp	r0, #3
   1c4e4:	d0eb      	beq.n	1c4be <PE_Send_ExtendedMessage+0x1e>
   1c4e6:	0029      	movs	r1, r5
   1c4e8:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   1c4ea:	9200      	str	r2, [sp, #0]
   1c4ec:	0003      	movs	r3, r0
   1c4ee:	2200      	movs	r2, #0
   1c4f0:	0020      	movs	r0, r4
   1c4f2:	f000 f808 	bl	1c506 <PE_CheckSendMessageStatus>
   1c4f6:	b005      	add	sp, #20
   1c4f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1c4fa:	2011      	movs	r0, #17
   1c4fc:	21a4      	movs	r1, #164	; 0xa4
   1c4fe:	0089      	lsls	r1, r1, #2
   1c500:	5460      	strb	r0, [r4, r1]
   1c502:	2010      	movs	r0, #16
   1c504:	e7f7      	b.n	1c4f6 <PE_Send_ExtendedMessage+0x56>

0001c506 <PE_CheckSendMessageStatus>:
   1c506:	b578      	push	{r3, r4, r5, r6, lr}
   1c508:	001c      	movs	r4, r3
   1c50a:	2310      	movs	r3, #16
   1c50c:	6905      	ldr	r5, [r0, #16]
   1c50e:	4e95      	ldr	r6, [pc, #596]	; (1c764 <.text_141>)
   1c510:	402e      	ands	r6, r5
   1c512:	6106      	str	r6, [r0, #16]
   1c514:	25a4      	movs	r5, #164	; 0xa4
   1c516:	00ad      	lsls	r5, r5, #2
   1c518:	1945      	adds	r5, r0, r5
   1c51a:	2c05      	cmp	r4, #5
   1c51c:	d006      	beq.n	1c52c <PE_CheckSendMessageStatus+0x26>
   1c51e:	2c06      	cmp	r4, #6
   1c520:	d00d      	beq.n	1c53e <PE_CheckSendMessageStatus+0x38>
   1c522:	2c07      	cmp	r4, #7
   1c524:	d010      	beq.n	1c548 <PE_CheckSendMessageStatus+0x42>
   1c526:	2c09      	cmp	r4, #9
   1c528:	d008      	beq.n	1c53c <PE_CheckSendMessageStatus+0x36>
   1c52a:	e021      	b.n	1c570 <PE_CheckSendMessageStatus+0x6a>
   1c52c:	9905      	ldr	r1, [sp, #20]
   1c52e:	7029      	strb	r1, [r5, #0]
   1c530:	6901      	ldr	r1, [r0, #16]
   1c532:	4a8d      	ldr	r2, [pc, #564]	; (1c768 <.text_142>)
   1c534:	400a      	ands	r2, r1
   1c536:	6102      	str	r2, [r0, #16]
   1c538:	2300      	movs	r3, #0
   1c53a:	e019      	b.n	1c570 <PE_CheckSendMessageStatus+0x6a>
   1c53c:	2309      	movs	r3, #9
   1c53e:	2180      	movs	r1, #128	; 0x80
   1c540:	0149      	lsls	r1, r1, #5
   1c542:	4331      	orrs	r1, r6
   1c544:	6101      	str	r1, [r0, #16]
   1c546:	e013      	b.n	1c570 <PE_CheckSendMessageStatus+0x6a>
   1c548:	2900      	cmp	r1, #0
   1c54a:	d005      	beq.n	1c558 <PE_CheckSendMessageStatus+0x52>
   1c54c:	2a01      	cmp	r2, #1
   1c54e:	d101      	bne.n	1c554 <PE_CheckSendMessageStatus+0x4e>
   1c550:	2099      	movs	r0, #153	; 0x99
   1c552:	e00c      	b.n	1c56e <PE_CheckSendMessageStatus+0x68>
   1c554:	2307      	movs	r3, #7
   1c556:	e00b      	b.n	1c570 <PE_CheckSendMessageStatus+0x6a>
   1c558:	6840      	ldr	r0, [r0, #4]
   1c55a:	6800      	ldr	r0, [r0, #0]
   1c55c:	0a00      	lsrs	r0, r0, #8
   1c55e:	4004      	ands	r4, r0
   1c560:	2c04      	cmp	r4, #4
   1c562:	d001      	beq.n	1c568 <PE_CheckSendMessageStatus+0x62>
   1c564:	2a01      	cmp	r2, #1
   1c566:	d101      	bne.n	1c56c <PE_CheckSendMessageStatus+0x66>
   1c568:	200f      	movs	r0, #15
   1c56a:	e000      	b.n	1c56e <PE_CheckSendMessageStatus+0x68>
   1c56c:	2011      	movs	r0, #17
   1c56e:	7028      	strb	r0, [r5, #0]
   1c570:	0018      	movs	r0, r3
   1c572:	bd72      	pop	{r1, r4, r5, r6, pc}

0001c574 <.text_138>:
   1c574:	0000028f 	.word	0x0000028f

0001c578 <.text_139>:
   1c578:	000002a2 	.word	0x000002a2

0001c57c <PE_SubStateMachine_ExtendedMessages>:
   1c57c:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
   1c57e:	0005      	movs	r5, r0
   1c580:	2702      	movs	r7, #2
   1c582:	487a      	ldr	r0, [pc, #488]	; (1c76c <.text_143>)
   1c584:	182c      	adds	r4, r5, r0
   1c586:	2039      	movs	r0, #57	; 0x39
   1c588:	2103      	movs	r1, #3
   1c58a:	4a79      	ldr	r2, [pc, #484]	; (1c770 <.text_144>)
   1c58c:	2600      	movs	r6, #0
   1c58e:	78a3      	ldrb	r3, [r4, #2]
   1c590:	2b31      	cmp	r3, #49	; 0x31
   1c592:	d010      	beq.n	1c5b6 <PE_SubStateMachine_ExtendedMessages+0x3a>
   1c594:	2b33      	cmp	r3, #51	; 0x33
   1c596:	d055      	beq.n	1c644 <PE_SubStateMachine_ExtendedMessages+0xc8>
   1c598:	2b34      	cmp	r3, #52	; 0x34
   1c59a:	d05c      	beq.n	1c656 <PE_SubStateMachine_ExtendedMessages+0xda>
   1c59c:	2b35      	cmp	r3, #53	; 0x35
   1c59e:	d100      	bne.n	1c5a2 <PE_SubStateMachine_ExtendedMessages+0x26>
   1c5a0:	e08b      	b.n	1c6ba <PE_SubStateMachine_ExtendedMessages+0x13e>
   1c5a2:	2b36      	cmp	r3, #54	; 0x36
   1c5a4:	d100      	bne.n	1c5a8 <PE_SubStateMachine_ExtendedMessages+0x2c>
   1c5a6:	e09d      	b.n	1c6e4 <PE_SubStateMachine_ExtendedMessages+0x168>
   1c5a8:	2b37      	cmp	r3, #55	; 0x37
   1c5aa:	d100      	bne.n	1c5ae <PE_SubStateMachine_ExtendedMessages+0x32>
   1c5ac:	e09d      	b.n	1c6ea <PE_SubStateMachine_ExtendedMessages+0x16e>
   1c5ae:	2b38      	cmp	r3, #56	; 0x38
   1c5b0:	d100      	bne.n	1c5b4 <PE_SubStateMachine_ExtendedMessages+0x38>
   1c5b2:	e0d1      	b.n	1c758 <PE_SubStateMachine_ExtendedMessages+0x1dc>
   1c5b4:	e0d4      	b.n	1c760 <PE_SubStateMachine_ExtendedMessages+0x1e4>
   1c5b6:	2000      	movs	r0, #0
   1c5b8:	4b6e      	ldr	r3, [pc, #440]	; (1c774 <.text_145>)
   1c5ba:	52ee      	strh	r6, [r5, r3]
   1c5bc:	2321      	movs	r3, #33	; 0x21
   1c5be:	54ee      	strb	r6, [r5, r3]
   1c5c0:	2320      	movs	r3, #32
   1c5c2:	54ee      	strb	r6, [r5, r3]
   1c5c4:	4a6b      	ldr	r2, [pc, #428]	; (1c774 <.text_145>)
   1c5c6:	18aa      	adds	r2, r5, r2
   1c5c8:	8852      	ldrh	r2, [r2, #2]
   1c5ca:	2a1a      	cmp	r2, #26
   1c5cc:	d914      	bls.n	1c5f8 <PE_SubStateMachine_ExtendedMessages+0x7c>
   1c5ce:	22af      	movs	r2, #175	; 0xaf
   1c5d0:	0052      	lsls	r2, r2, #1
   1c5d2:	18aa      	adds	r2, r5, r2
   1c5d4:	5d92      	ldrb	r2, [r2, r6]
   1c5d6:	002b      	movs	r3, r5
   1c5d8:	3322      	adds	r3, #34	; 0x22
   1c5da:	559a      	strb	r2, [r3, r6]
   1c5dc:	1c76      	adds	r6, r6, #1
   1c5de:	2e1a      	cmp	r6, #26
   1c5e0:	d3f5      	bcc.n	1c5ce <PE_SubStateMachine_ExtendedMessages+0x52>
   1c5e2:	2201      	movs	r2, #1
   1c5e4:	692b      	ldr	r3, [r5, #16]
   1c5e6:	091b      	lsrs	r3, r3, #4
   1c5e8:	4013      	ands	r3, r2
   1c5ea:	d015      	beq.n	1c618 <PE_SubStateMachine_ExtendedMessages+0x9c>
   1c5ec:	6868      	ldr	r0, [r5, #4]
   1c5ee:	6800      	ldr	r0, [r0, #0]
   1c5f0:	0880      	lsrs	r0, r0, #2
   1c5f2:	4010      	ands	r0, r2
   1c5f4:	d00e      	beq.n	1c614 <PE_SubStateMachine_ExtendedMessages+0x98>
   1c5f6:	e00e      	b.n	1c616 <PE_SubStateMachine_ExtendedMessages+0x9a>
   1c5f8:	4a5e      	ldr	r2, [pc, #376]	; (1c774 <.text_145>)
   1c5fa:	18aa      	adds	r2, r5, r2
   1c5fc:	8852      	ldrh	r2, [r2, #2]
   1c5fe:	4296      	cmp	r6, r2
   1c600:	d2ef      	bcs.n	1c5e2 <PE_SubStateMachine_ExtendedMessages+0x66>
   1c602:	22af      	movs	r2, #175	; 0xaf
   1c604:	0052      	lsls	r2, r2, #1
   1c606:	18aa      	adds	r2, r5, r2
   1c608:	5d92      	ldrb	r2, [r2, r6]
   1c60a:	002b      	movs	r3, r5
   1c60c:	3322      	adds	r3, #34	; 0x22
   1c60e:	559a      	strb	r2, [r3, r6]
   1c610:	1c76      	adds	r6, r6, #1
   1c612:	e7f1      	b.n	1c5f8 <PE_SubStateMachine_ExtendedMessages+0x7c>
   1c614:	2002      	movs	r0, #2
   1c616:	2133      	movs	r1, #51	; 0x33
   1c618:	4a57      	ldr	r2, [pc, #348]	; (1c778 <.text_146>)
   1c61a:	18ae      	adds	r6, r5, r2
   1c61c:	9002      	str	r0, [sp, #8]
   1c61e:	9101      	str	r1, [sp, #4]
   1c620:	4854      	ldr	r0, [pc, #336]	; (1c774 <.text_145>)
   1c622:	1828      	adds	r0, r5, r0
   1c624:	8840      	ldrh	r0, [r0, #2]
   1c626:	1d00      	adds	r0, r0, #4
   1c628:	b280      	uxth	r0, r0
   1c62a:	9000      	str	r0, [sp, #0]
   1c62c:	002b      	movs	r3, r5
   1c62e:	331e      	adds	r3, #30
   1c630:	7872      	ldrb	r2, [r6, #1]
   1c632:	7821      	ldrb	r1, [r4, #0]
   1c634:	0028      	movs	r0, r5
   1c636:	f7ff ff33 	bl	1c4a0 <PE_Send_ExtendedMessage>
   1c63a:	2800      	cmp	r0, #0
   1c63c:	d101      	bne.n	1c642 <PE_SubStateMachine_ExtendedMessages+0xc6>
   1c63e:	88b0      	ldrh	r0, [r6, #4]
   1c640:	83a8      	strh	r0, [r5, #28]
   1c642:	e08d      	b.n	1c760 <PE_SubStateMachine_ExtendedMessages+0x1e4>
   1c644:	80e2      	strh	r2, [r4, #6]
   1c646:	2718      	movs	r7, #24
   1c648:	494b      	ldr	r1, [pc, #300]	; (1c778 <.text_146>)
   1c64a:	1869      	adds	r1, r5, r1
   1c64c:	7849      	ldrb	r1, [r1, #1]
   1c64e:	2904      	cmp	r1, #4
   1c650:	d150      	bne.n	1c6f4 <PE_SubStateMachine_ExtendedMessages+0x178>
   1c652:	2074      	movs	r0, #116	; 0x74
   1c654:	e04e      	b.n	1c6f4 <PE_SubStateMachine_ExtendedMessages+0x178>
   1c656:	8c60      	ldrh	r0, [r4, #34]	; 0x22
   1c658:	0440      	lsls	r0, r0, #17
   1c65a:	0f03      	lsrs	r3, r0, #28
   1c65c:	201a      	movs	r0, #26
   1c65e:	4358      	muls	r0, r3
   1c660:	4a44      	ldr	r2, [pc, #272]	; (1c774 <.text_145>)
   1c662:	18aa      	adds	r2, r5, r2
   1c664:	8852      	ldrh	r2, [r2, #2]
   1c666:	4290      	cmp	r0, r2
   1c668:	da01      	bge.n	1c66e <PE_SubStateMachine_ExtendedMessages+0xf2>
   1c66a:	2b0a      	cmp	r3, #10
   1c66c:	d301      	bcc.n	1c672 <PE_SubStateMachine_ExtendedMessages+0xf6>
   1c66e:	70a1      	strb	r1, [r4, #2]
   1c670:	e021      	b.n	1c6b6 <PE_SubStateMachine_ExtendedMessages+0x13a>
   1c672:	1a11      	subs	r1, r2, r0
   1c674:	291a      	cmp	r1, #26
   1c676:	d201      	bcs.n	1c67c <PE_SubStateMachine_ExtendedMessages+0x100>
   1c678:	b2c9      	uxtb	r1, r1
   1c67a:	e000      	b.n	1c67e <PE_SubStateMachine_ExtendedMessages+0x102>
   1c67c:	211a      	movs	r1, #26
   1c67e:	2200      	movs	r2, #0
   1c680:	e008      	b.n	1c694 <PE_SubStateMachine_ExtendedMessages+0x118>
   1c682:	23af      	movs	r3, #175	; 0xaf
   1c684:	005b      	lsls	r3, r3, #1
   1c686:	18eb      	adds	r3, r5, r3
   1c688:	1887      	adds	r7, r0, r2
   1c68a:	5ddb      	ldrb	r3, [r3, r7]
   1c68c:	002f      	movs	r7, r5
   1c68e:	3722      	adds	r7, #34	; 0x22
   1c690:	54bb      	strb	r3, [r7, r2]
   1c692:	1c52      	adds	r2, r2, #1
   1c694:	428a      	cmp	r2, r1
   1c696:	d3f4      	bcc.n	1c682 <PE_SubStateMachine_ExtendedMessages+0x106>
   1c698:	002b      	movs	r3, r5
   1c69a:	331e      	adds	r3, #30
   1c69c:	4835      	ldr	r0, [pc, #212]	; (1c774 <.text_145>)
   1c69e:	1828      	adds	r0, r5, r0
   1c6a0:	8842      	ldrh	r2, [r0, #2]
   1c6a2:	8c60      	ldrh	r0, [r4, #34]	; 0x22
   1c6a4:	0440      	lsls	r0, r0, #17
   1c6a6:	0f01      	lsrs	r1, r0, #28
   1c6a8:	7c2d      	ldrb	r5, [r5, #16]
   1c6aa:	07e8      	lsls	r0, r5, #31
   1c6ac:	0fc0      	lsrs	r0, r0, #31
   1c6ae:	f001 fb21 	bl	1dcf4 <USBPD_PRL_PrepareExtendedTxChunkSending>
   1c6b2:	2035      	movs	r0, #53	; 0x35
   1c6b4:	70a0      	strb	r0, [r4, #2]
   1c6b6:	2700      	movs	r7, #0
   1c6b8:	e052      	b.n	1c760 <PE_SubStateMachine_ExtendedMessages+0x1e4>
   1c6ba:	6928      	ldr	r0, [r5, #16]
   1c6bc:	06c2      	lsls	r2, r0, #27
   1c6be:	0fd2      	lsrs	r2, r2, #31
   1c6c0:	d000      	beq.n	1c6c4 <PE_SubStateMachine_ExtendedMessages+0x148>
   1c6c2:	2136      	movs	r1, #54	; 0x36
   1c6c4:	9602      	str	r6, [sp, #8]
   1c6c6:	9101      	str	r1, [sp, #4]
   1c6c8:	482a      	ldr	r0, [pc, #168]	; (1c774 <.text_145>)
   1c6ca:	1828      	adds	r0, r5, r0
   1c6cc:	8840      	ldrh	r0, [r0, #2]
   1c6ce:	9000      	str	r0, [sp, #0]
   1c6d0:	002b      	movs	r3, r5
   1c6d2:	331e      	adds	r3, #30
   1c6d4:	4828      	ldr	r0, [pc, #160]	; (1c778 <.text_146>)
   1c6d6:	1828      	adds	r0, r5, r0
   1c6d8:	7842      	ldrb	r2, [r0, #1]
   1c6da:	7921      	ldrb	r1, [r4, #4]
   1c6dc:	0028      	movs	r0, r5
   1c6de:	f7ff fedf 	bl	1c4a0 <PE_Send_ExtendedMessage>
   1c6e2:	e03b      	b.n	1c75c <PE_SubStateMachine_ExtendedMessages+0x1e0>
   1c6e4:	80e2      	strh	r2, [r4, #6]
   1c6e6:	2718      	movs	r7, #24
   1c6e8:	e004      	b.n	1c6f4 <PE_SubStateMachine_ExtendedMessages+0x178>
   1c6ea:	88e0      	ldrh	r0, [r4, #6]
   1c6ec:	03b9      	lsls	r1, r7, #14
   1c6ee:	4288      	cmp	r0, r1
   1c6f0:	d102      	bne.n	1c6f8 <PE_SubStateMachine_ExtendedMessages+0x17c>
   1c6f2:	200f      	movs	r0, #15
   1c6f4:	70a0      	strb	r0, [r4, #2]
   1c6f6:	e033      	b.n	1c760 <PE_SubStateMachine_ExtendedMessages+0x1e4>
   1c6f8:	80e2      	strh	r2, [r4, #6]
   1c6fa:	2718      	movs	r7, #24
   1c6fc:	0029      	movs	r1, r5
   1c6fe:	311e      	adds	r1, #30
   1c700:	7c2a      	ldrb	r2, [r5, #16]
   1c702:	07d0      	lsls	r0, r2, #31
   1c704:	0fc0      	lsrs	r0, r0, #31
   1c706:	f001 fb1f 	bl	1dd48 <USBPD_PRL_PrepareChunkRequest>
   1c70a:	481b      	ldr	r0, [pc, #108]	; (1c778 <.text_146>)
   1c70c:	1828      	adds	r0, r5, r0
   1c70e:	9002      	str	r0, [sp, #8]
   1c710:	2001      	movs	r0, #1
   1c712:	6869      	ldr	r1, [r5, #4]
   1c714:	6809      	ldr	r1, [r1, #0]
   1c716:	0b09      	lsrs	r1, r1, #12
   1c718:	4001      	ands	r1, r0
   1c71a:	d019      	beq.n	1c750 <PE_SubStateMachine_ExtendedMessages+0x1d4>
   1c71c:	2100      	movs	r1, #0
   1c71e:	9101      	str	r1, [sp, #4]
   1c720:	2106      	movs	r1, #6
   1c722:	9100      	str	r1, [sp, #0]
   1c724:	002b      	movs	r3, r5
   1c726:	331e      	adds	r3, #30
   1c728:	9902      	ldr	r1, [sp, #8]
   1c72a:	7809      	ldrb	r1, [r1, #0]
   1c72c:	2280      	movs	r2, #128	; 0x80
   1c72e:	430a      	orrs	r2, r1
   1c730:	7921      	ldrb	r1, [r4, #4]
   1c732:	692e      	ldr	r6, [r5, #16]
   1c734:	4030      	ands	r0, r6
   1c736:	f000 febb 	bl	1d4b0 <USBPD_PRL_SendMessage>
   1c73a:	0003      	movs	r3, r0
   1c73c:	2803      	cmp	r0, #3
   1c73e:	d0e7      	beq.n	1c710 <PE_SubStateMachine_ExtendedMessages+0x194>
   1c740:	0028      	movs	r0, r5
   1c742:	2139      	movs	r1, #57	; 0x39
   1c744:	9100      	str	r1, [sp, #0]
   1c746:	2200      	movs	r2, #0
   1c748:	7921      	ldrb	r1, [r4, #4]
   1c74a:	f7ff fedc 	bl	1c506 <PE_CheckSendMessageStatus>
   1c74e:	e007      	b.n	1c760 <PE_SubStateMachine_ExtendedMessages+0x1e4>
   1c750:	2011      	movs	r0, #17
   1c752:	70a0      	strb	r0, [r4, #2]
   1c754:	2018      	movs	r0, #24
   1c756:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   1c758:	70a1      	strb	r1, [r4, #2]
   1c75a:	2700      	movs	r7, #0
   1c75c:	4805      	ldr	r0, [pc, #20]	; (1c774 <.text_145>)
   1c75e:	522e      	strh	r6, [r5, r0]
   1c760:	0038      	movs	r0, r7
   1c762:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

0001c764 <.text_141>:
   1c764:	ffffefff 	.word	0xffffefff

0001c768 <.text_142>:
   1c768:	ffffdfff 	.word	0xffffdfff

0001c76c <.text_143>:
   1c76c:	0000028e 	.word	0x0000028e

0001c770 <.text_144>:
   1c770:	00008018 	.word	0x00008018

0001c774 <.text_145>:
   1c774:	00000262 	.word	0x00000262

0001c778 <.text_146>:
   1c778:	000002b2 	.word	0x000002b2

0001c77c <PE_SubStateMachine_Generic>:
   1c77c:	b5f3      	push	{r0, r1, r4, r5, r6, r7, lr}
   1c77e:	b08b      	sub	sp, #44	; 0x2c
   1c780:	0004      	movs	r4, r0
   1c782:	2002      	movs	r0, #2
   1c784:	2602      	movs	r6, #2
   1c786:	2711      	movs	r7, #17
   1c788:	2501      	movs	r5, #1
   1c78a:	21a4      	movs	r1, #164	; 0xa4
   1c78c:	0089      	lsls	r1, r1, #2
   1c78e:	5c61      	ldrb	r1, [r4, r1]
   1c790:	2901      	cmp	r1, #1
   1c792:	d100      	bne.n	1c796 <PE_SubStateMachine_Generic+0x1a>
   1c794:	e210      	b.n	1cbb8 <PE_SubStateMachine_Generic+0x43c>
   1c796:	2918      	cmp	r1, #24
   1c798:	d04f      	beq.n	1c83a <PE_SubStateMachine_Generic+0xbe>
   1c79a:	2919      	cmp	r1, #25
   1c79c:	d074      	beq.n	1c888 <PE_SubStateMachine_Generic+0x10c>
   1c79e:	291d      	cmp	r1, #29
   1c7a0:	d100      	bne.n	1c7a4 <PE_SubStateMachine_Generic+0x28>
   1c7a2:	e0de      	b.n	1c962 <PE_SubStateMachine_Generic+0x1e6>
   1c7a4:	2927      	cmp	r1, #39	; 0x27
   1c7a6:	d100      	bne.n	1c7aa <PE_SubStateMachine_Generic+0x2e>
   1c7a8:	e0ff      	b.n	1c9aa <PE_SubStateMachine_Generic+0x22e>
   1c7aa:	2928      	cmp	r1, #40	; 0x28
   1c7ac:	d100      	bne.n	1c7b0 <PE_SubStateMachine_Generic+0x34>
   1c7ae:	e10c      	b.n	1c9ca <PE_SubStateMachine_Generic+0x24e>
   1c7b0:	2929      	cmp	r1, #41	; 0x29
   1c7b2:	d100      	bne.n	1c7b6 <PE_SubStateMachine_Generic+0x3a>
   1c7b4:	e119      	b.n	1c9ea <PE_SubStateMachine_Generic+0x26e>
   1c7b6:	292c      	cmp	r1, #44	; 0x2c
   1c7b8:	d100      	bne.n	1c7bc <PE_SubStateMachine_Generic+0x40>
   1c7ba:	e350      	b.n	1ce5e <PE_SubStateMachine_Generic+0x6e2>
   1c7bc:	2930      	cmp	r1, #48	; 0x30
   1c7be:	d100      	bne.n	1c7c2 <PE_SubStateMachine_Generic+0x46>
   1c7c0:	e268      	b.n	1cc94 <PE_SubStateMachine_Generic+0x518>
   1c7c2:	293a      	cmp	r1, #58	; 0x3a
   1c7c4:	d100      	bne.n	1c7c8 <PE_SubStateMachine_Generic+0x4c>
   1c7c6:	e329      	b.n	1ce1c <PE_SubStateMachine_Generic+0x6a0>
   1c7c8:	293b      	cmp	r1, #59	; 0x3b
   1c7ca:	d100      	bne.n	1c7ce <PE_SubStateMachine_Generic+0x52>
   1c7cc:	e30c      	b.n	1cde8 <PE_SubStateMachine_Generic+0x66c>
   1c7ce:	293c      	cmp	r1, #60	; 0x3c
   1c7d0:	d100      	bne.n	1c7d4 <PE_SubStateMachine_Generic+0x58>
   1c7d2:	e2ef      	b.n	1cdb4 <PE_SubStateMachine_Generic+0x638>
   1c7d4:	2963      	cmp	r1, #99	; 0x63
   1c7d6:	d100      	bne.n	1c7da <PE_SubStateMachine_Generic+0x5e>
   1c7d8:	e204      	b.n	1cbe4 <PE_SubStateMachine_Generic+0x468>
   1c7da:	2964      	cmp	r1, #100	; 0x64
   1c7dc:	d100      	bne.n	1c7e0 <PE_SubStateMachine_Generic+0x64>
   1c7de:	e22d      	b.n	1cc3c <PE_SubStateMachine_Generic+0x4c0>
   1c7e0:	2974      	cmp	r1, #116	; 0x74
   1c7e2:	d100      	bne.n	1c7e6 <PE_SubStateMachine_Generic+0x6a>
   1c7e4:	e288      	b.n	1ccf8 <PE_SubStateMachine_Generic+0x57c>
   1c7e6:	2993      	cmp	r1, #147	; 0x93
   1c7e8:	d100      	bne.n	1c7ec <PE_SubStateMachine_Generic+0x70>
   1c7ea:	e119      	b.n	1ca20 <PE_SubStateMachine_Generic+0x2a4>
   1c7ec:	2994      	cmp	r1, #148	; 0x94
   1c7ee:	d100      	bne.n	1c7f2 <PE_SubStateMachine_Generic+0x76>
   1c7f0:	e11b      	b.n	1ca2a <PE_SubStateMachine_Generic+0x2ae>
   1c7f2:	2995      	cmp	r1, #149	; 0x95
   1c7f4:	d100      	bne.n	1c7f8 <PE_SubStateMachine_Generic+0x7c>
   1c7f6:	e13e      	b.n	1ca76 <PE_SubStateMachine_Generic+0x2fa>
   1c7f8:	2999      	cmp	r1, #153	; 0x99
   1c7fa:	d000      	beq.n	1c7fe <PE_SubStateMachine_Generic+0x82>
   1c7fc:	e342      	b.n	1ce84 <PE_SubStateMachine_Generic+0x708>
   1c7fe:	6860      	ldr	r0, [r4, #4]
   1c800:	6800      	ldr	r0, [r0, #0]
   1c802:	49c6      	ldr	r1, [pc, #792]	; (1cb1c <PE_SubStateMachine_Generic+0x3a0>)
   1c804:	4001      	ands	r1, r0
   1c806:	48c6      	ldr	r0, [pc, #792]	; (1cb20 <PE_SubStateMachine_Generic+0x3a4>)
   1c808:	4281      	cmp	r1, r0
   1c80a:	d109      	bne.n	1c820 <PE_SubStateMachine_Generic+0xa4>
   1c80c:	2106      	movs	r1, #6
   1c80e:	0020      	movs	r0, r4
   1c810:	f7fe f8fe 	bl	1aa10 <PE_Send_RESET>
   1c814:	6920      	ldr	r0, [r4, #16]
   1c816:	4005      	ands	r5, r0
   1c818:	0028      	movs	r0, r5
   1c81a:	f000 ffde 	bl	1d7da <USBPD_PRL_EnableRX>
   1c81e:	e2c3      	b.n	1cda8 <PE_SubStateMachine_Generic+0x62c>
   1c820:	2000      	movs	r0, #0
   1c822:	9000      	str	r0, [sp, #0]
   1c824:	2300      	movs	r3, #0
   1c826:	221a      	movs	r2, #26
   1c828:	6920      	ldr	r0, [r4, #16]
   1c82a:	2101      	movs	r1, #1
   1c82c:	4001      	ands	r1, r0
   1c82e:	2009      	movs	r0, #9
   1c830:	4ebc      	ldr	r6, [pc, #752]	; (1cb24 <PE_SubStateMachine_Generic+0x3a8>)
   1c832:	6a36      	ldr	r6, [r6, #32]
   1c834:	47b0      	blx	r6
   1c836:	211a      	movs	r1, #26
   1c838:	e31d      	b.n	1ce76 <PE_SubStateMachine_Generic+0x6fa>
   1c83a:	6861      	ldr	r1, [r4, #4]
   1c83c:	6809      	ldr	r1, [r1, #0]
   1c83e:	0889      	lsrs	r1, r1, #2
   1c840:	4029      	ands	r1, r5
   1c842:	d002      	beq.n	1c84a <PE_SubStateMachine_Generic+0xce>
   1c844:	6920      	ldr	r0, [r4, #16]
   1c846:	0781      	lsls	r1, r0, #30
   1c848:	0fc8      	lsrs	r0, r1, #31
   1c84a:	9000      	str	r0, [sp, #0]
   1c84c:	2319      	movs	r3, #25
   1c84e:	2208      	movs	r2, #8
   1c850:	2100      	movs	r1, #0
   1c852:	0020      	movs	r0, r4
   1c854:	f7fe f84e 	bl	1a8f4 <PE_Send_CtrlMessage>
   1c858:	2800      	cmp	r0, #0
   1c85a:	d000      	beq.n	1c85e <PE_SubStateMachine_Generic+0xe2>
   1c85c:	e315      	b.n	1ce8a <PE_SubStateMachine_Generic+0x70e>
   1c85e:	2007      	movs	r0, #7
   1c860:	83a0      	strh	r0, [r4, #28]
   1c862:	48b1      	ldr	r0, [pc, #708]	; (1cb28 <PE_SubStateMachine_Generic+0x3ac>)
   1c864:	21a4      	movs	r1, #164	; 0xa4
   1c866:	0089      	lsls	r1, r1, #2
   1c868:	1861      	adds	r1, r4, r1
   1c86a:	8088      	strh	r0, [r1, #4]
   1c86c:	2618      	movs	r6, #24
   1c86e:	2000      	movs	r0, #0
   1c870:	9000      	str	r0, [sp, #0]
   1c872:	2300      	movs	r3, #0
   1c874:	2205      	movs	r2, #5
   1c876:	6920      	ldr	r0, [r4, #16]
   1c878:	2101      	movs	r1, #1
   1c87a:	4001      	ands	r1, r0
   1c87c:	2009      	movs	r0, #9
   1c87e:	4fa9      	ldr	r7, [pc, #676]	; (1cb24 <PE_SubStateMachine_Generic+0x3a8>)
   1c880:	6a3f      	ldr	r7, [r7, #32]
   1c882:	47b8      	blx	r7
   1c884:	2105      	movs	r1, #5
   1c886:	e230      	b.n	1ccea <PE_SubStateMachine_Generic+0x56e>
   1c888:	980c      	ldr	r0, [sp, #48]	; 0x30
   1c88a:	7800      	ldrb	r0, [r0, #0]
   1c88c:	2811      	cmp	r0, #17
   1c88e:	d15f      	bne.n	1c950 <PE_SubStateMachine_Generic+0x1d4>
   1c890:	20a4      	movs	r0, #164	; 0xa4
   1c892:	0080      	lsls	r0, r0, #2
   1c894:	1820      	adds	r0, r4, r0
   1c896:	8a40      	ldrh	r0, [r0, #18]
   1c898:	0bc1      	lsrs	r1, r0, #15
   1c89a:	d12f      	bne.n	1c8fc <PE_SubStateMachine_Generic+0x180>
   1c89c:	0441      	lsls	r1, r0, #17
   1c89e:	0f49      	lsrs	r1, r1, #29
   1c8a0:	d02c      	beq.n	1c8fc <PE_SubStateMachine_Generic+0x180>
   1c8a2:	06c0      	lsls	r0, r0, #27
   1c8a4:	0ec0      	lsrs	r0, r0, #27
   1c8a6:	2804      	cmp	r0, #4
   1c8a8:	d128      	bne.n	1c8fc <PE_SubStateMachine_Generic+0x180>
   1c8aa:	008b      	lsls	r3, r1, #2
   1c8ac:	20a1      	movs	r0, #161	; 0xa1
   1c8ae:	0040      	lsls	r0, r0, #1
   1c8b0:	1822      	adds	r2, r4, r0
   1c8b2:	2105      	movs	r1, #5
   1c8b4:	6926      	ldr	r6, [r4, #16]
   1c8b6:	2001      	movs	r0, #1
   1c8b8:	4030      	ands	r0, r6
   1c8ba:	68a6      	ldr	r6, [r4, #8]
   1c8bc:	69b6      	ldr	r6, [r6, #24]
   1c8be:	47b0      	blx	r6
   1c8c0:	2014      	movs	r0, #20
   1c8c2:	990c      	ldr	r1, [sp, #48]	; 0x30
   1c8c4:	7008      	strb	r0, [r1, #0]
   1c8c6:	6921      	ldr	r1, [r4, #16]
   1c8c8:	2001      	movs	r0, #1
   1c8ca:	4008      	ands	r0, r1
   1c8cc:	f000 ff85 	bl	1d7da <USBPD_PRL_EnableRX>
   1c8d0:	2003      	movs	r0, #3
   1c8d2:	21a4      	movs	r1, #164	; 0xa4
   1c8d4:	0089      	lsls	r1, r1, #2
   1c8d6:	5460      	strb	r0, [r4, r1]
   1c8d8:	2600      	movs	r6, #0
   1c8da:	9600      	str	r6, [sp, #0]
   1c8dc:	2300      	movs	r3, #0
   1c8de:	2207      	movs	r2, #7
   1c8e0:	6920      	ldr	r0, [r4, #16]
   1c8e2:	2101      	movs	r1, #1
   1c8e4:	4001      	ands	r1, r0
   1c8e6:	2009      	movs	r0, #9
   1c8e8:	4f8e      	ldr	r7, [pc, #568]	; (1cb24 <PE_SubStateMachine_Generic+0x3a8>)
   1c8ea:	6a3f      	ldr	r7, [r7, #32]
   1c8ec:	47b8      	blx	r7
   1c8ee:	2107      	movs	r1, #7
   1c8f0:	6922      	ldr	r2, [r4, #16]
   1c8f2:	2001      	movs	r0, #1
   1c8f4:	4010      	ands	r0, r2
   1c8f6:	68a2      	ldr	r2, [r4, #8]
   1c8f8:	68d2      	ldr	r2, [r2, #12]
   1c8fa:	4790      	blx	r2
   1c8fc:	20a4      	movs	r0, #164	; 0xa4
   1c8fe:	0080      	lsls	r0, r0, #2
   1c900:	1827      	adds	r7, r4, r0
   1c902:	8a78      	ldrh	r0, [r7, #18]
   1c904:	21f0      	movs	r1, #240	; 0xf0
   1c906:	0209      	lsls	r1, r1, #8
   1c908:	4001      	ands	r1, r0
   1c90a:	d121      	bne.n	1c950 <PE_SubStateMachine_Generic+0x1d4>
   1c90c:	06c1      	lsls	r1, r0, #27
   1c90e:	0ec9      	lsrs	r1, r1, #27
   1c910:	2904      	cmp	r1, #4
   1c912:	d001      	beq.n	1c918 <PE_SubStateMachine_Generic+0x19c>
   1c914:	2910      	cmp	r1, #16
   1c916:	d11b      	bne.n	1c950 <PE_SubStateMachine_Generic+0x1d4>
   1c918:	2014      	movs	r0, #20
   1c91a:	990c      	ldr	r1, [sp, #48]	; 0x30
   1c91c:	7008      	strb	r0, [r1, #0]
   1c91e:	6921      	ldr	r1, [r4, #16]
   1c920:	2001      	movs	r0, #1
   1c922:	4008      	ands	r0, r1
   1c924:	f000 ff59 	bl	1d7da <USBPD_PRL_EnableRX>
   1c928:	2003      	movs	r0, #3
   1c92a:	7038      	strb	r0, [r7, #0]
   1c92c:	2600      	movs	r6, #0
   1c92e:	9600      	str	r6, [sp, #0]
   1c930:	2300      	movs	r3, #0
   1c932:	2208      	movs	r2, #8
   1c934:	6920      	ldr	r0, [r4, #16]
   1c936:	2101      	movs	r1, #1
   1c938:	4001      	ands	r1, r0
   1c93a:	2009      	movs	r0, #9
   1c93c:	4f79      	ldr	r7, [pc, #484]	; (1cb24 <PE_SubStateMachine_Generic+0x3a8>)
   1c93e:	6a3f      	ldr	r7, [r7, #32]
   1c940:	47b8      	blx	r7
   1c942:	2108      	movs	r1, #8
   1c944:	6920      	ldr	r0, [r4, #16]
   1c946:	4005      	ands	r5, r0
   1c948:	0028      	movs	r0, r5
   1c94a:	68a2      	ldr	r2, [r4, #8]
   1c94c:	68d2      	ldr	r2, [r2, #12]
   1c94e:	4790      	blx	r2
   1c950:	20a4      	movs	r0, #164	; 0xa4
   1c952:	0080      	lsls	r0, r0, #2
   1c954:	1820      	adds	r0, r4, r0
   1c956:	8880      	ldrh	r0, [r0, #4]
   1c958:	2180      	movs	r1, #128	; 0x80
   1c95a:	0209      	lsls	r1, r1, #8
   1c95c:	4288      	cmp	r0, r1
   1c95e:	d133      	bne.n	1c9c8 <PE_SubStateMachine_Generic+0x24c>
   1c960:	e222      	b.n	1cda8 <PE_SubStateMachine_Generic+0x62c>
   1c962:	ab03      	add	r3, sp, #12
   1c964:	aa04      	add	r2, sp, #16
   1c966:	2101      	movs	r1, #1
   1c968:	6927      	ldr	r7, [r4, #16]
   1c96a:	2001      	movs	r0, #1
   1c96c:	4038      	ands	r0, r7
   1c96e:	68a7      	ldr	r7, [r4, #8]
   1c970:	697f      	ldr	r7, [r7, #20]
   1c972:	47b8      	blx	r7
   1c974:	2000      	movs	r0, #0
   1c976:	9002      	str	r0, [sp, #8]
   1c978:	2003      	movs	r0, #3
   1c97a:	9001      	str	r0, [sp, #4]
   1c97c:	9803      	ldr	r0, [sp, #12]
   1c97e:	0880      	lsrs	r0, r0, #2
   1c980:	9000      	str	r0, [sp, #0]
   1c982:	ab04      	add	r3, sp, #16
   1c984:	2204      	movs	r2, #4
   1c986:	2100      	movs	r1, #0
   1c988:	0020      	movs	r0, r4
   1c98a:	f7fd fff3 	bl	1a974 <PE_Send_DataMessage>
   1c98e:	2800      	cmp	r0, #0
   1c990:	d11a      	bne.n	1c9c8 <PE_SubStateMachine_Generic+0x24c>
   1c992:	9000      	str	r0, [sp, #0]
   1c994:	2300      	movs	r3, #0
   1c996:	220a      	movs	r2, #10
   1c998:	6920      	ldr	r0, [r4, #16]
   1c99a:	2101      	movs	r1, #1
   1c99c:	4001      	ands	r1, r0
   1c99e:	2009      	movs	r0, #9
   1c9a0:	4f60      	ldr	r7, [pc, #384]	; (1cb24 <PE_SubStateMachine_Generic+0x3a8>)
   1c9a2:	6a3f      	ldr	r7, [r7, #32]
   1c9a4:	47b8      	blx	r7
   1c9a6:	210a      	movs	r1, #10
   1c9a8:	e19f      	b.n	1ccea <PE_SubStateMachine_Generic+0x56e>
   1c9aa:	83a7      	strh	r7, [r4, #28]
   1c9ac:	2105      	movs	r1, #5
   1c9ae:	6920      	ldr	r0, [r4, #16]
   1c9b0:	4005      	ands	r5, r0
   1c9b2:	0028      	movs	r0, r5
   1c9b4:	f000 fec9 	bl	1d74a <USBDPD_PRL_BistCarrierEyeMode>
   1c9b8:	20a4      	movs	r0, #164	; 0xa4
   1c9ba:	0080      	lsls	r0, r0, #2
   1c9bc:	1820      	adds	r0, r4, r0
   1c9be:	2128      	movs	r1, #40	; 0x28
   1c9c0:	7001      	strb	r1, [r0, #0]
   1c9c2:	495a      	ldr	r1, [pc, #360]	; (1cb2c <PE_SubStateMachine_Generic+0x3b0>)
   1c9c4:	8181      	strh	r1, [r0, #12]
   1c9c6:	263a      	movs	r6, #58	; 0x3a
   1c9c8:	e25f      	b.n	1ce8a <PE_SubStateMachine_Generic+0x70e>
   1c9ca:	20a4      	movs	r0, #164	; 0xa4
   1c9cc:	0080      	lsls	r0, r0, #2
   1c9ce:	1827      	adds	r7, r4, r0
   1c9d0:	89b8      	ldrh	r0, [r7, #12]
   1c9d2:	03e9      	lsls	r1, r5, #15
   1c9d4:	4288      	cmp	r0, r1
   1c9d6:	d1f7      	bne.n	1c9c8 <PE_SubStateMachine_Generic+0x24c>
   1c9d8:	2105      	movs	r1, #5
   1c9da:	6920      	ldr	r0, [r4, #16]
   1c9dc:	4005      	ands	r5, r0
   1c9de:	0028      	movs	r0, r5
   1c9e0:	f000 febb 	bl	1d75a <USBDPD_PRL_BistCarrierEyeModeExit>
   1c9e4:	2000      	movs	r0, #0
   1c9e6:	81b8      	strh	r0, [r7, #12]
   1c9e8:	e1de      	b.n	1cda8 <PE_SubStateMachine_Generic+0x62c>
   1c9ea:	980c      	ldr	r0, [sp, #48]	; 0x30
   1c9ec:	7800      	ldrb	r0, [r0, #0]
   1c9ee:	2811      	cmp	r0, #17
   1c9f0:	d114      	bne.n	1ca1c <PE_SubStateMachine_Generic+0x2a0>
   1c9f2:	20a4      	movs	r0, #164	; 0xa4
   1c9f4:	0080      	lsls	r0, r0, #2
   1c9f6:	1820      	adds	r0, r4, r0
   1c9f8:	8a40      	ldrh	r0, [r0, #18]
   1c9fa:	0bc1      	lsrs	r1, r0, #15
   1c9fc:	d10e      	bne.n	1ca1c <PE_SubStateMachine_Generic+0x2a0>
   1c9fe:	0441      	lsls	r1, r0, #17
   1ca00:	0f49      	lsrs	r1, r1, #29
   1ca02:	d00b      	beq.n	1ca1c <PE_SubStateMachine_Generic+0x2a0>
   1ca04:	06c0      	lsls	r0, r0, #27
   1ca06:	0ec0      	lsrs	r0, r0, #27
   1ca08:	2803      	cmp	r0, #3
   1ca0a:	d107      	bne.n	1ca1c <PE_SubStateMachine_Generic+0x2a0>
   1ca0c:	2014      	movs	r0, #20
   1ca0e:	990c      	ldr	r1, [sp, #48]	; 0x30
   1ca10:	7008      	strb	r0, [r1, #0]
   1ca12:	6920      	ldr	r0, [r4, #16]
   1ca14:	4005      	ands	r5, r0
   1ca16:	0028      	movs	r0, r5
   1ca18:	f000 fedf 	bl	1d7da <USBPD_PRL_EnableRX>
   1ca1c:	83a7      	strh	r7, [r4, #28]
   1ca1e:	e234      	b.n	1ce8a <PE_SubStateMachine_Generic+0x70e>
   1ca20:	0020      	movs	r0, r4
   1ca22:	f000 fa37 	bl	1ce94 <PE_SubStateMachine_ReceiveDRS>
   1ca26:	0006      	movs	r6, r0
   1ca28:	e22f      	b.n	1ce8a <PE_SubStateMachine_Generic+0x70e>
   1ca2a:	6861      	ldr	r1, [r4, #4]
   1ca2c:	6809      	ldr	r1, [r1, #0]
   1ca2e:	0889      	lsrs	r1, r1, #2
   1ca30:	4029      	ands	r1, r5
   1ca32:	d002      	beq.n	1ca3a <PE_SubStateMachine_Generic+0x2be>
   1ca34:	6920      	ldr	r0, [r4, #16]
   1ca36:	0781      	lsls	r1, r0, #30
   1ca38:	0fc8      	lsrs	r0, r1, #31
   1ca3a:	9000      	str	r0, [sp, #0]
   1ca3c:	2395      	movs	r3, #149	; 0x95
   1ca3e:	2209      	movs	r2, #9
   1ca40:	2100      	movs	r1, #0
   1ca42:	0020      	movs	r0, r4
   1ca44:	f7fd ff56 	bl	1a8f4 <PE_Send_CtrlMessage>
   1ca48:	2800      	cmp	r0, #0
   1ca4a:	d1ed      	bne.n	1ca28 <PE_SubStateMachine_Generic+0x2ac>
   1ca4c:	200f      	movs	r0, #15
   1ca4e:	83a0      	strh	r0, [r4, #28]
   1ca50:	4835      	ldr	r0, [pc, #212]	; (1cb28 <PE_SubStateMachine_Generic+0x3ac>)
   1ca52:	21a4      	movs	r1, #164	; 0xa4
   1ca54:	0089      	lsls	r1, r1, #2
   1ca56:	1861      	adds	r1, r4, r1
   1ca58:	8088      	strh	r0, [r1, #4]
   1ca5a:	2618      	movs	r6, #24
   1ca5c:	2000      	movs	r0, #0
   1ca5e:	9000      	str	r0, [sp, #0]
   1ca60:	2300      	movs	r3, #0
   1ca62:	2222      	movs	r2, #34	; 0x22
   1ca64:	6920      	ldr	r0, [r4, #16]
   1ca66:	2101      	movs	r1, #1
   1ca68:	4001      	ands	r1, r0
   1ca6a:	2009      	movs	r0, #9
   1ca6c:	4f2d      	ldr	r7, [pc, #180]	; (1cb24 <PE_SubStateMachine_Generic+0x3a8>)
   1ca6e:	6a3f      	ldr	r7, [r7, #32]
   1ca70:	47b8      	blx	r7
   1ca72:	2122      	movs	r1, #34	; 0x22
   1ca74:	e139      	b.n	1ccea <PE_SubStateMachine_Generic+0x56e>
   1ca76:	20a4      	movs	r0, #164	; 0xa4
   1ca78:	0080      	lsls	r0, r0, #2
   1ca7a:	1820      	adds	r0, r4, r0
   1ca7c:	8880      	ldrh	r0, [r0, #4]
   1ca7e:	03e9      	lsls	r1, r5, #15
   1ca80:	4288      	cmp	r0, r1
   1ca82:	d0b1      	beq.n	1c9e8 <PE_SubStateMachine_Generic+0x26c>
   1ca84:	980c      	ldr	r0, [sp, #48]	; 0x30
   1ca86:	7800      	ldrb	r0, [r0, #0]
   1ca88:	2814      	cmp	r0, #20
   1ca8a:	d012      	beq.n	1cab2 <PE_SubStateMachine_Generic+0x336>
   1ca8c:	20a4      	movs	r0, #164	; 0xa4
   1ca8e:	0080      	lsls	r0, r0, #2
   1ca90:	1820      	adds	r0, r4, r0
   1ca92:	8a40      	ldrh	r0, [r0, #18]
   1ca94:	21f0      	movs	r1, #240	; 0xf0
   1ca96:	0209      	lsls	r1, r1, #8
   1ca98:	4001      	ands	r1, r0
   1ca9a:	d10a      	bne.n	1cab2 <PE_SubStateMachine_Generic+0x336>
   1ca9c:	2714      	movs	r7, #20
   1ca9e:	06c1      	lsls	r1, r0, #27
   1caa0:	0ec9      	lsrs	r1, r1, #27
   1caa2:	2903      	cmp	r1, #3
   1caa4:	d006      	beq.n	1cab4 <PE_SubStateMachine_Generic+0x338>
   1caa6:	2904      	cmp	r1, #4
   1caa8:	d042      	beq.n	1cb30 <PE_SubStateMachine_Generic+0x3b4>
   1caaa:	290c      	cmp	r1, #12
   1caac:	d040      	beq.n	1cb30 <PE_SubStateMachine_Generic+0x3b4>
   1caae:	2910      	cmp	r1, #16
   1cab0:	d063      	beq.n	1cb7a <PE_SubStateMachine_Generic+0x3fe>
   1cab2:	e1ea      	b.n	1ce8a <PE_SubStateMachine_Generic+0x70e>
   1cab4:	6860      	ldr	r0, [r4, #4]
   1cab6:	6801      	ldr	r1, [r0, #0]
   1cab8:	08ca      	lsrs	r2, r1, #3
   1caba:	402a      	ands	r2, r5
   1cabc:	d10f      	bne.n	1cade <PE_SubStateMachine_Generic+0x362>
   1cabe:	2208      	movs	r2, #8
   1cac0:	430a      	orrs	r2, r1
   1cac2:	6002      	str	r2, [r0, #0]
   1cac4:	2000      	movs	r0, #0
   1cac6:	9000      	str	r0, [sp, #0]
   1cac8:	2300      	movs	r3, #0
   1caca:	2225      	movs	r2, #37	; 0x25
   1cacc:	6920      	ldr	r0, [r4, #16]
   1cace:	2101      	movs	r1, #1
   1cad0:	4001      	ands	r1, r0
   1cad2:	2009      	movs	r0, #9
   1cad4:	4e13      	ldr	r6, [pc, #76]	; (1cb24 <PE_SubStateMachine_Generic+0x3a8>)
   1cad6:	6a36      	ldr	r6, [r6, #32]
   1cad8:	47b0      	blx	r6
   1cada:	2125      	movs	r1, #37	; 0x25
   1cadc:	e00e      	b.n	1cafc <PE_SubStateMachine_Generic+0x380>
   1cade:	2208      	movs	r2, #8
   1cae0:	4391      	bics	r1, r2
   1cae2:	6001      	str	r1, [r0, #0]
   1cae4:	2000      	movs	r0, #0
   1cae6:	9000      	str	r0, [sp, #0]
   1cae8:	2300      	movs	r3, #0
   1caea:	2224      	movs	r2, #36	; 0x24
   1caec:	6920      	ldr	r0, [r4, #16]
   1caee:	2101      	movs	r1, #1
   1caf0:	4001      	ands	r1, r0
   1caf2:	2009      	movs	r0, #9
   1caf4:	4e0b      	ldr	r6, [pc, #44]	; (1cb24 <PE_SubStateMachine_Generic+0x3a8>)
   1caf6:	6a36      	ldr	r6, [r6, #32]
   1caf8:	47b0      	blx	r6
   1cafa:	2124      	movs	r1, #36	; 0x24
   1cafc:	6922      	ldr	r2, [r4, #16]
   1cafe:	2001      	movs	r0, #1
   1cb00:	4010      	ands	r0, r2
   1cb02:	68a2      	ldr	r2, [r4, #8]
   1cb04:	68d2      	ldr	r2, [r2, #12]
   1cb06:	4790      	blx	r2
   1cb08:	6860      	ldr	r0, [r4, #4]
   1cb0a:	6800      	ldr	r0, [r0, #0]
   1cb0c:	08c1      	lsrs	r1, r0, #3
   1cb0e:	4029      	ands	r1, r5
   1cb10:	6922      	ldr	r2, [r4, #16]
   1cb12:	2001      	movs	r0, #1
   1cb14:	4010      	ands	r0, r2
   1cb16:	f000 fc74 	bl	1d402 <USBPD_PRL_SetHeaderDataRole>
   1cb1a:	e040      	b.n	1cb9e <PE_SubStateMachine_Generic+0x422>
   1cb1c:	00008708 	.word	0x00008708
   1cb20:	00008308 	.word	0x00008308
   1cb24:	0002ff54 	.word	0x0002ff54
   1cb28:	00008018 	.word	0x00008018
   1cb2c:	0000803a 	.word	0x0000803a
   1cb30:	06c0      	lsls	r0, r0, #27
   1cb32:	0ec0      	lsrs	r0, r0, #27
   1cb34:	280c      	cmp	r0, #12
   1cb36:	d101      	bne.n	1cb3c <PE_SubStateMachine_Generic+0x3c0>
   1cb38:	2226      	movs	r2, #38	; 0x26
   1cb3a:	e000      	b.n	1cb3e <PE_SubStateMachine_Generic+0x3c2>
   1cb3c:	2227      	movs	r2, #39	; 0x27
   1cb3e:	2000      	movs	r0, #0
   1cb40:	9000      	str	r0, [sp, #0]
   1cb42:	2300      	movs	r3, #0
   1cb44:	6920      	ldr	r0, [r4, #16]
   1cb46:	2101      	movs	r1, #1
   1cb48:	4001      	ands	r1, r0
   1cb4a:	2009      	movs	r0, #9
   1cb4c:	4ed0      	ldr	r6, [pc, #832]	; (1ce90 <.text_148>)
   1cb4e:	6a36      	ldr	r6, [r6, #32]
   1cb50:	47b0      	blx	r6
   1cb52:	20a4      	movs	r0, #164	; 0xa4
   1cb54:	0080      	lsls	r0, r0, #2
   1cb56:	1826      	adds	r6, r4, r0
   1cb58:	7cb0      	ldrb	r0, [r6, #18]
   1cb5a:	06c0      	lsls	r0, r0, #27
   1cb5c:	0ec0      	lsrs	r0, r0, #27
   1cb5e:	280c      	cmp	r0, #12
   1cb60:	d101      	bne.n	1cb66 <PE_SubStateMachine_Generic+0x3ea>
   1cb62:	2126      	movs	r1, #38	; 0x26
   1cb64:	e000      	b.n	1cb68 <PE_SubStateMachine_Generic+0x3ec>
   1cb66:	2127      	movs	r1, #39	; 0x27
   1cb68:	6922      	ldr	r2, [r4, #16]
   1cb6a:	2001      	movs	r0, #1
   1cb6c:	4010      	ands	r0, r2
   1cb6e:	68a2      	ldr	r2, [r4, #8]
   1cb70:	68d2      	ldr	r2, [r2, #12]
   1cb72:	4790      	blx	r2
   1cb74:	2003      	movs	r0, #3
   1cb76:	7030      	strb	r0, [r6, #0]
   1cb78:	e015      	b.n	1cba6 <PE_SubStateMachine_Generic+0x42a>
   1cb7a:	2000      	movs	r0, #0
   1cb7c:	9000      	str	r0, [sp, #0]
   1cb7e:	2300      	movs	r3, #0
   1cb80:	2228      	movs	r2, #40	; 0x28
   1cb82:	6920      	ldr	r0, [r4, #16]
   1cb84:	2101      	movs	r1, #1
   1cb86:	4001      	ands	r1, r0
   1cb88:	2009      	movs	r0, #9
   1cb8a:	4ec1      	ldr	r6, [pc, #772]	; (1ce90 <.text_148>)
   1cb8c:	6a36      	ldr	r6, [r6, #32]
   1cb8e:	47b0      	blx	r6
   1cb90:	2128      	movs	r1, #40	; 0x28
   1cb92:	6922      	ldr	r2, [r4, #16]
   1cb94:	2001      	movs	r0, #1
   1cb96:	4010      	ands	r0, r2
   1cb98:	68a2      	ldr	r2, [r4, #8]
   1cb9a:	68d2      	ldr	r2, [r2, #12]
   1cb9c:	4790      	blx	r2
   1cb9e:	2003      	movs	r0, #3
   1cba0:	21a4      	movs	r1, #164	; 0xa4
   1cba2:	0089      	lsls	r1, r1, #2
   1cba4:	5460      	strb	r0, [r4, r1]
   1cba6:	2600      	movs	r6, #0
   1cba8:	980c      	ldr	r0, [sp, #48]	; 0x30
   1cbaa:	7007      	strb	r7, [r0, #0]
   1cbac:	6920      	ldr	r0, [r4, #16]
   1cbae:	4005      	ands	r5, r0
   1cbb0:	0028      	movs	r0, r5
   1cbb2:	f000 fe12 	bl	1d7da <USBPD_PRL_EnableRX>
   1cbb6:	e168      	b.n	1ce8a <PE_SubStateMachine_Generic+0x70e>
   1cbb8:	2000      	movs	r0, #0
   1cbba:	9000      	str	r0, [sp, #0]
   1cbbc:	2303      	movs	r3, #3
   1cbbe:	2210      	movs	r2, #16
   1cbc0:	2100      	movs	r1, #0
   1cbc2:	0020      	movs	r0, r4
   1cbc4:	f7fd fe96 	bl	1a8f4 <PE_Send_CtrlMessage>
   1cbc8:	2800      	cmp	r0, #0
   1cbca:	d1f4      	bne.n	1cbb6 <PE_SubStateMachine_Generic+0x43a>
   1cbcc:	9000      	str	r0, [sp, #0]
   1cbce:	2300      	movs	r3, #0
   1cbd0:	2259      	movs	r2, #89	; 0x59
   1cbd2:	6920      	ldr	r0, [r4, #16]
   1cbd4:	2101      	movs	r1, #1
   1cbd6:	4001      	ands	r1, r0
   1cbd8:	2009      	movs	r0, #9
   1cbda:	4fad      	ldr	r7, [pc, #692]	; (1ce90 <.text_148>)
   1cbdc:	6a3f      	ldr	r7, [r7, #32]
   1cbde:	47b8      	blx	r7
   1cbe0:	2159      	movs	r1, #89	; 0x59
   1cbe2:	e082      	b.n	1ccea <PE_SubStateMachine_Generic+0x56e>
   1cbe4:	2000      	movs	r0, #0
   1cbe6:	9003      	str	r0, [sp, #12]
   1cbe8:	ab03      	add	r3, sp, #12
   1cbea:	0022      	movs	r2, r4
   1cbec:	3222      	adds	r2, #34	; 0x22
   1cbee:	2108      	movs	r1, #8
   1cbf0:	6927      	ldr	r7, [r4, #16]
   1cbf2:	2001      	movs	r0, #1
   1cbf4:	4038      	ands	r0, r7
   1cbf6:	68a7      	ldr	r7, [r4, #8]
   1cbf8:	697f      	ldr	r7, [r7, #20]
   1cbfa:	47b8      	blx	r7
   1cbfc:	2000      	movs	r0, #0
   1cbfe:	2121      	movs	r1, #33	; 0x21
   1cc00:	5460      	strb	r0, [r4, r1]
   1cc02:	2120      	movs	r1, #32
   1cc04:	5460      	strb	r0, [r4, r1]
   1cc06:	9002      	str	r0, [sp, #8]
   1cc08:	2003      	movs	r0, #3
   1cc0a:	9001      	str	r0, [sp, #4]
   1cc0c:	9803      	ldr	r0, [sp, #12]
   1cc0e:	1d00      	adds	r0, r0, #4
   1cc10:	b280      	uxth	r0, r0
   1cc12:	9000      	str	r0, [sp, #0]
   1cc14:	0023      	movs	r3, r4
   1cc16:	331e      	adds	r3, #30
   1cc18:	2201      	movs	r2, #1
   1cc1a:	2100      	movs	r1, #0
   1cc1c:	0020      	movs	r0, r4
   1cc1e:	f7ff fc3f 	bl	1c4a0 <PE_Send_ExtendedMessage>
   1cc22:	2000      	movs	r0, #0
   1cc24:	9000      	str	r0, [sp, #0]
   1cc26:	2300      	movs	r3, #0
   1cc28:	2248      	movs	r2, #72	; 0x48
   1cc2a:	6920      	ldr	r0, [r4, #16]
   1cc2c:	2101      	movs	r1, #1
   1cc2e:	4001      	ands	r1, r0
   1cc30:	2009      	movs	r0, #9
   1cc32:	4f97      	ldr	r7, [pc, #604]	; (1ce90 <.text_148>)
   1cc34:	6a3f      	ldr	r7, [r7, #32]
   1cc36:	47b8      	blx	r7
   1cc38:	2148      	movs	r1, #72	; 0x48
   1cc3a:	e056      	b.n	1ccea <PE_SubStateMachine_Generic+0x56e>
   1cc3c:	2000      	movs	r0, #0
   1cc3e:	9003      	str	r0, [sp, #12]
   1cc40:	ab03      	add	r3, sp, #12
   1cc42:	0022      	movs	r2, r4
   1cc44:	3222      	adds	r2, #34	; 0x22
   1cc46:	2113      	movs	r1, #19
   1cc48:	6927      	ldr	r7, [r4, #16]
   1cc4a:	2001      	movs	r0, #1
   1cc4c:	4038      	ands	r0, r7
   1cc4e:	68a7      	ldr	r7, [r4, #8]
   1cc50:	697f      	ldr	r7, [r7, #20]
   1cc52:	47b8      	blx	r7
   1cc54:	2000      	movs	r0, #0
   1cc56:	2121      	movs	r1, #33	; 0x21
   1cc58:	5460      	strb	r0, [r4, r1]
   1cc5a:	2120      	movs	r1, #32
   1cc5c:	5460      	strb	r0, [r4, r1]
   1cc5e:	9002      	str	r0, [sp, #8]
   1cc60:	2003      	movs	r0, #3
   1cc62:	9001      	str	r0, [sp, #4]
   1cc64:	9803      	ldr	r0, [sp, #12]
   1cc66:	1d00      	adds	r0, r0, #4
   1cc68:	b280      	uxth	r0, r0
   1cc6a:	9000      	str	r0, [sp, #0]
   1cc6c:	0023      	movs	r3, r4
   1cc6e:	331e      	adds	r3, #30
   1cc70:	220f      	movs	r2, #15
   1cc72:	2100      	movs	r1, #0
   1cc74:	0020      	movs	r0, r4
   1cc76:	f7ff fc13 	bl	1c4a0 <PE_Send_ExtendedMessage>
   1cc7a:	2000      	movs	r0, #0
   1cc7c:	9000      	str	r0, [sp, #0]
   1cc7e:	2300      	movs	r3, #0
   1cc80:	2261      	movs	r2, #97	; 0x61
   1cc82:	6920      	ldr	r0, [r4, #16]
   1cc84:	2101      	movs	r1, #1
   1cc86:	4001      	ands	r1, r0
   1cc88:	2009      	movs	r0, #9
   1cc8a:	4f81      	ldr	r7, [pc, #516]	; (1ce90 <.text_148>)
   1cc8c:	6a3f      	ldr	r7, [r7, #32]
   1cc8e:	47b8      	blx	r7
   1cc90:	2161      	movs	r1, #97	; 0x61
   1cc92:	e02a      	b.n	1ccea <PE_SubStateMachine_Generic+0x56e>
   1cc94:	2000      	movs	r0, #0
   1cc96:	9003      	str	r0, [sp, #12]
   1cc98:	ab03      	add	r3, sp, #12
   1cc9a:	0022      	movs	r2, r4
   1cc9c:	3222      	adds	r2, #34	; 0x22
   1cc9e:	2109      	movs	r1, #9
   1cca0:	6927      	ldr	r7, [r4, #16]
   1cca2:	2001      	movs	r0, #1
   1cca4:	4038      	ands	r0, r7
   1cca6:	68a7      	ldr	r7, [r4, #8]
   1cca8:	697f      	ldr	r7, [r7, #20]
   1ccaa:	47b8      	blx	r7
   1ccac:	2000      	movs	r0, #0
   1ccae:	2121      	movs	r1, #33	; 0x21
   1ccb0:	5460      	strb	r0, [r4, r1]
   1ccb2:	2120      	movs	r1, #32
   1ccb4:	5460      	strb	r0, [r4, r1]
   1ccb6:	9002      	str	r0, [sp, #8]
   1ccb8:	2003      	movs	r0, #3
   1ccba:	9001      	str	r0, [sp, #4]
   1ccbc:	9803      	ldr	r0, [sp, #12]
   1ccbe:	1d00      	adds	r0, r0, #4
   1ccc0:	b280      	uxth	r0, r0
   1ccc2:	9000      	str	r0, [sp, #0]
   1ccc4:	0023      	movs	r3, r4
   1ccc6:	331e      	adds	r3, #30
   1ccc8:	2202      	movs	r2, #2
   1ccca:	2100      	movs	r1, #0
   1cccc:	0020      	movs	r0, r4
   1ccce:	f7ff fbe7 	bl	1c4a0 <PE_Send_ExtendedMessage>
   1ccd2:	2000      	movs	r0, #0
   1ccd4:	9000      	str	r0, [sp, #0]
   1ccd6:	2300      	movs	r3, #0
   1ccd8:	224f      	movs	r2, #79	; 0x4f
   1ccda:	6920      	ldr	r0, [r4, #16]
   1ccdc:	2101      	movs	r1, #1
   1ccde:	4001      	ands	r1, r0
   1cce0:	2009      	movs	r0, #9
   1cce2:	4f6b      	ldr	r7, [pc, #428]	; (1ce90 <.text_148>)
   1cce4:	6a3f      	ldr	r7, [r7, #32]
   1cce6:	47b8      	blx	r7
   1cce8:	214f      	movs	r1, #79	; 0x4f
   1ccea:	6920      	ldr	r0, [r4, #16]
   1ccec:	4005      	ands	r5, r0
   1ccee:	0028      	movs	r0, r5
   1ccf0:	68a2      	ldr	r2, [r4, #8]
   1ccf2:	68d2      	ldr	r2, [r2, #12]
   1ccf4:	4790      	blx	r2
   1ccf6:	e0c8      	b.n	1ce8a <PE_SubStateMachine_Generic+0x70e>
   1ccf8:	980c      	ldr	r0, [sp, #48]	; 0x30
   1ccfa:	7800      	ldrb	r0, [r0, #0]
   1ccfc:	2814      	cmp	r0, #20
   1ccfe:	d04b      	beq.n	1cd98 <PE_SubStateMachine_Generic+0x61c>
   1cd00:	20a4      	movs	r0, #164	; 0xa4
   1cd02:	0080      	lsls	r0, r0, #2
   1cd04:	1820      	adds	r0, r4, r0
   1cd06:	8a40      	ldrh	r0, [r0, #18]
   1cd08:	2714      	movs	r7, #20
   1cd0a:	0bc1      	lsrs	r1, r0, #15
   1cd0c:	d11d      	bne.n	1cd4a <PE_SubStateMachine_Generic+0x5ce>
   1cd0e:	0441      	lsls	r1, r0, #17
   1cd10:	0f49      	lsrs	r1, r1, #29
   1cd12:	d01a      	beq.n	1cd4a <PE_SubStateMachine_Generic+0x5ce>
   1cd14:	06c0      	lsls	r0, r0, #27
   1cd16:	0ec0      	lsrs	r0, r0, #27
   1cd18:	2805      	cmp	r0, #5
   1cd1a:	d116      	bne.n	1cd4a <PE_SubStateMachine_Generic+0x5ce>
   1cd1c:	2304      	movs	r3, #4
   1cd1e:	20a2      	movs	r0, #162	; 0xa2
   1cd20:	0040      	lsls	r0, r0, #1
   1cd22:	1822      	adds	r2, r4, r0
   1cd24:	210f      	movs	r1, #15
   1cd26:	6926      	ldr	r6, [r4, #16]
   1cd28:	2001      	movs	r0, #1
   1cd2a:	4030      	ands	r0, r6
   1cd2c:	68a6      	ldr	r6, [r4, #8]
   1cd2e:	69b6      	ldr	r6, [r6, #24]
   1cd30:	47b0      	blx	r6
   1cd32:	2003      	movs	r0, #3
   1cd34:	21a4      	movs	r1, #164	; 0xa4
   1cd36:	0089      	lsls	r1, r1, #2
   1cd38:	5460      	strb	r0, [r4, r1]
   1cd3a:	2600      	movs	r6, #0
   1cd3c:	990c      	ldr	r1, [sp, #48]	; 0x30
   1cd3e:	700f      	strb	r7, [r1, #0]
   1cd40:	6921      	ldr	r1, [r4, #16]
   1cd42:	2001      	movs	r0, #1
   1cd44:	4008      	ands	r0, r1
   1cd46:	f000 fd48 	bl	1d7da <USBPD_PRL_EnableRX>
   1cd4a:	20a4      	movs	r0, #164	; 0xa4
   1cd4c:	0080      	lsls	r0, r0, #2
   1cd4e:	1820      	adds	r0, r4, r0
   1cd50:	7c80      	ldrb	r0, [r0, #18]
   1cd52:	06c0      	lsls	r0, r0, #27
   1cd54:	0ec0      	lsrs	r0, r0, #27
   1cd56:	2810      	cmp	r0, #16
   1cd58:	d11e      	bne.n	1cd98 <PE_SubStateMachine_Generic+0x61c>
   1cd5a:	980c      	ldr	r0, [sp, #48]	; 0x30
   1cd5c:	7007      	strb	r7, [r0, #0]
   1cd5e:	6921      	ldr	r1, [r4, #16]
   1cd60:	2001      	movs	r0, #1
   1cd62:	4008      	ands	r0, r1
   1cd64:	f000 fd39 	bl	1d7da <USBPD_PRL_EnableRX>
   1cd68:	20a4      	movs	r0, #164	; 0xa4
   1cd6a:	0080      	lsls	r0, r0, #2
   1cd6c:	1820      	adds	r0, r4, r0
   1cd6e:	2600      	movs	r6, #0
   1cd70:	8086      	strh	r6, [r0, #4]
   1cd72:	2103      	movs	r1, #3
   1cd74:	7001      	strb	r1, [r0, #0]
   1cd76:	9600      	str	r6, [sp, #0]
   1cd78:	2300      	movs	r3, #0
   1cd7a:	2259      	movs	r2, #89	; 0x59
   1cd7c:	6920      	ldr	r0, [r4, #16]
   1cd7e:	2101      	movs	r1, #1
   1cd80:	4001      	ands	r1, r0
   1cd82:	2009      	movs	r0, #9
   1cd84:	4f42      	ldr	r7, [pc, #264]	; (1ce90 <.text_148>)
   1cd86:	6a3f      	ldr	r7, [r7, #32]
   1cd88:	47b8      	blx	r7
   1cd8a:	2159      	movs	r1, #89	; 0x59
   1cd8c:	6920      	ldr	r0, [r4, #16]
   1cd8e:	4005      	ands	r5, r0
   1cd90:	0028      	movs	r0, r5
   1cd92:	68a2      	ldr	r2, [r4, #8]
   1cd94:	68d2      	ldr	r2, [r2, #12]
   1cd96:	4790      	blx	r2
   1cd98:	20a4      	movs	r0, #164	; 0xa4
   1cd9a:	0080      	lsls	r0, r0, #2
   1cd9c:	1820      	adds	r0, r4, r0
   1cd9e:	8880      	ldrh	r0, [r0, #4]
   1cda0:	2180      	movs	r1, #128	; 0x80
   1cda2:	0209      	lsls	r1, r1, #8
   1cda4:	4288      	cmp	r0, r1
   1cda6:	d170      	bne.n	1ce8a <PE_SubStateMachine_Generic+0x70e>
   1cda8:	2003      	movs	r0, #3
   1cdaa:	21a4      	movs	r1, #164	; 0xa4
   1cdac:	0089      	lsls	r1, r1, #2
   1cdae:	5460      	strb	r0, [r4, r1]
   1cdb0:	2600      	movs	r6, #0
   1cdb2:	e06a      	b.n	1ce8a <PE_SubStateMachine_Generic+0x70e>
   1cdb4:	ab03      	add	r3, sp, #12
   1cdb6:	0022      	movs	r2, r4
   1cdb8:	3222      	adds	r2, #34	; 0x22
   1cdba:	210d      	movs	r1, #13
   1cdbc:	6920      	ldr	r0, [r4, #16]
   1cdbe:	4005      	ands	r5, r0
   1cdc0:	0028      	movs	r0, r5
   1cdc2:	68a5      	ldr	r5, [r4, #8]
   1cdc4:	696d      	ldr	r5, [r5, #20]
   1cdc6:	47a8      	blx	r5
   1cdc8:	2000      	movs	r0, #0
   1cdca:	2221      	movs	r2, #33	; 0x21
   1cdcc:	54a0      	strb	r0, [r4, r2]
   1cdce:	2120      	movs	r1, #32
   1cdd0:	5460      	strb	r0, [r4, r1]
   1cdd2:	9002      	str	r0, [sp, #8]
   1cdd4:	2003      	movs	r0, #3
   1cdd6:	9001      	str	r0, [sp, #4]
   1cdd8:	9803      	ldr	r0, [sp, #12]
   1cdda:	1d00      	adds	r0, r0, #4
   1cddc:	b280      	uxth	r0, r0
   1cdde:	9000      	str	r0, [sp, #0]
   1cde0:	0023      	movs	r3, r4
   1cde2:	331e      	adds	r3, #30
   1cde4:	2207      	movs	r2, #7
   1cde6:	e035      	b.n	1ce54 <PE_SubStateMachine_Generic+0x6d8>
   1cde8:	2000      	movs	r0, #0
   1cdea:	9003      	str	r0, [sp, #12]
   1cdec:	ab04      	add	r3, sp, #16
   1cdee:	aa03      	add	r2, sp, #12
   1cdf0:	210f      	movs	r1, #15
   1cdf2:	6927      	ldr	r7, [r4, #16]
   1cdf4:	2001      	movs	r0, #1
   1cdf6:	4038      	ands	r0, r7
   1cdf8:	68a7      	ldr	r7, [r4, #8]
   1cdfa:	697f      	ldr	r7, [r7, #20]
   1cdfc:	47b8      	blx	r7
   1cdfe:	9804      	ldr	r0, [sp, #16]
   1ce00:	2800      	cmp	r0, #0
   1ce02:	d03f      	beq.n	1ce84 <PE_SubStateMachine_Generic+0x708>
   1ce04:	2000      	movs	r0, #0
   1ce06:	9002      	str	r0, [sp, #8]
   1ce08:	2003      	movs	r0, #3
   1ce0a:	9001      	str	r0, [sp, #4]
   1ce0c:	9500      	str	r5, [sp, #0]
   1ce0e:	ab03      	add	r3, sp, #12
   1ce10:	2205      	movs	r2, #5
   1ce12:	2100      	movs	r1, #0
   1ce14:	0020      	movs	r0, r4
   1ce16:	f7fd fdad 	bl	1a974 <PE_Send_DataMessage>
   1ce1a:	e036      	b.n	1ce8a <PE_SubStateMachine_Generic+0x70e>
   1ce1c:	ab03      	add	r3, sp, #12
   1ce1e:	0022      	movs	r2, r4
   1ce20:	3222      	adds	r2, #34	; 0x22
   1ce22:	2111      	movs	r1, #17
   1ce24:	6927      	ldr	r7, [r4, #16]
   1ce26:	2001      	movs	r0, #1
   1ce28:	4038      	ands	r0, r7
   1ce2a:	68a7      	ldr	r7, [r4, #8]
   1ce2c:	697f      	ldr	r7, [r7, #20]
   1ce2e:	47b8      	blx	r7
   1ce30:	9803      	ldr	r0, [sp, #12]
   1ce32:	2800      	cmp	r0, #0
   1ce34:	d026      	beq.n	1ce84 <PE_SubStateMachine_Generic+0x708>
   1ce36:	2000      	movs	r0, #0
   1ce38:	2221      	movs	r2, #33	; 0x21
   1ce3a:	54a0      	strb	r0, [r4, r2]
   1ce3c:	2120      	movs	r1, #32
   1ce3e:	5460      	strb	r0, [r4, r1]
   1ce40:	9002      	str	r0, [sp, #8]
   1ce42:	2003      	movs	r0, #3
   1ce44:	9001      	str	r0, [sp, #4]
   1ce46:	9803      	ldr	r0, [sp, #12]
   1ce48:	1d00      	adds	r0, r0, #4
   1ce4a:	b280      	uxth	r0, r0
   1ce4c:	9000      	str	r0, [sp, #0]
   1ce4e:	0023      	movs	r3, r4
   1ce50:	331e      	adds	r3, #30
   1ce52:	2205      	movs	r2, #5
   1ce54:	2100      	movs	r1, #0
   1ce56:	0020      	movs	r0, r4
   1ce58:	f7ff fb22 	bl	1c4a0 <PE_Send_ExtendedMessage>
   1ce5c:	e015      	b.n	1ce8a <PE_SubStateMachine_Generic+0x70e>
   1ce5e:	2000      	movs	r0, #0
   1ce60:	9000      	str	r0, [sp, #0]
   1ce62:	2300      	movs	r3, #0
   1ce64:	2250      	movs	r2, #80	; 0x50
   1ce66:	6920      	ldr	r0, [r4, #16]
   1ce68:	2101      	movs	r1, #1
   1ce6a:	4001      	ands	r1, r0
   1ce6c:	2009      	movs	r0, #9
   1ce6e:	4e08      	ldr	r6, [pc, #32]	; (1ce90 <.text_148>)
   1ce70:	6a36      	ldr	r6, [r6, #32]
   1ce72:	47b0      	blx	r6
   1ce74:	2150      	movs	r1, #80	; 0x50
   1ce76:	6920      	ldr	r0, [r4, #16]
   1ce78:	4005      	ands	r5, r0
   1ce7a:	0028      	movs	r0, r5
   1ce7c:	68a2      	ldr	r2, [r4, #8]
   1ce7e:	68d2      	ldr	r2, [r2, #12]
   1ce80:	4790      	blx	r2
   1ce82:	e791      	b.n	1cda8 <PE_SubStateMachine_Generic+0x62c>
   1ce84:	20a4      	movs	r0, #164	; 0xa4
   1ce86:	0080      	lsls	r0, r0, #2
   1ce88:	5425      	strb	r5, [r4, r0]
   1ce8a:	0030      	movs	r0, r6
   1ce8c:	b00d      	add	sp, #52	; 0x34
   1ce8e:	bdf0      	pop	{r4, r5, r6, r7, pc}

0001ce90 <.text_148>:
   1ce90:	0002ff54 	.word	0x0002ff54

0001ce94 <PE_SubStateMachine_ReceiveDRS>:
   1ce94:	b57c      	push	{r2, r3, r4, r5, r6, lr}
   1ce96:	0004      	movs	r4, r0
   1ce98:	2501      	movs	r5, #1
   1ce9a:	6921      	ldr	r1, [r4, #16]
   1ce9c:	2001      	movs	r0, #1
   1ce9e:	4008      	ands	r0, r1
   1cea0:	68a1      	ldr	r1, [r4, #8]
   1cea2:	6b89      	ldr	r1, [r1, #56]	; 0x38
   1cea4:	4788      	blx	r1
   1cea6:	280a      	cmp	r0, #10
   1cea8:	d13c      	bne.n	1cf24 <PE_SubStateMachine_ReceiveDRS+0x90>
   1ceaa:	2000      	movs	r0, #0
   1ceac:	9000      	str	r0, [sp, #0]
   1ceae:	2303      	movs	r3, #3
   1ceb0:	2203      	movs	r2, #3
   1ceb2:	2100      	movs	r1, #0
   1ceb4:	0020      	movs	r0, r4
   1ceb6:	f7fd fd1d 	bl	1a8f4 <PE_Send_CtrlMessage>
   1ceba:	2800      	cmp	r0, #0
   1cebc:	d13f      	bne.n	1cf3e <PE_SubStateMachine_ReceiveDRS+0xaa>
   1cebe:	6860      	ldr	r0, [r4, #4]
   1cec0:	6801      	ldr	r1, [r0, #0]
   1cec2:	4e20      	ldr	r6, [pc, #128]	; (1cf44 <.text_150>)
   1cec4:	08ca      	lsrs	r2, r1, #3
   1cec6:	402a      	ands	r2, r5
   1cec8:	d10e      	bne.n	1cee8 <PE_SubStateMachine_ReceiveDRS+0x54>
   1ceca:	2208      	movs	r2, #8
   1cecc:	430a      	orrs	r2, r1
   1cece:	6002      	str	r2, [r0, #0]
   1ced0:	2000      	movs	r0, #0
   1ced2:	9000      	str	r0, [sp, #0]
   1ced4:	2300      	movs	r3, #0
   1ced6:	2225      	movs	r2, #37	; 0x25
   1ced8:	6920      	ldr	r0, [r4, #16]
   1ceda:	2101      	movs	r1, #1
   1cedc:	4001      	ands	r1, r0
   1cede:	2009      	movs	r0, #9
   1cee0:	6a36      	ldr	r6, [r6, #32]
   1cee2:	47b0      	blx	r6
   1cee4:	2125      	movs	r1, #37	; 0x25
   1cee6:	e00d      	b.n	1cf04 <PE_SubStateMachine_ReceiveDRS+0x70>
   1cee8:	2208      	movs	r2, #8
   1ceea:	4391      	bics	r1, r2
   1ceec:	6001      	str	r1, [r0, #0]
   1ceee:	2000      	movs	r0, #0
   1cef0:	9000      	str	r0, [sp, #0]
   1cef2:	2300      	movs	r3, #0
   1cef4:	2224      	movs	r2, #36	; 0x24
   1cef6:	6920      	ldr	r0, [r4, #16]
   1cef8:	2101      	movs	r1, #1
   1cefa:	4001      	ands	r1, r0
   1cefc:	2009      	movs	r0, #9
   1cefe:	6a36      	ldr	r6, [r6, #32]
   1cf00:	47b0      	blx	r6
   1cf02:	2124      	movs	r1, #36	; 0x24
   1cf04:	6922      	ldr	r2, [r4, #16]
   1cf06:	2001      	movs	r0, #1
   1cf08:	4010      	ands	r0, r2
   1cf0a:	68a2      	ldr	r2, [r4, #8]
   1cf0c:	68d2      	ldr	r2, [r2, #12]
   1cf0e:	4790      	blx	r2
   1cf10:	6860      	ldr	r0, [r4, #4]
   1cf12:	6800      	ldr	r0, [r0, #0]
   1cf14:	08c1      	lsrs	r1, r0, #3
   1cf16:	4029      	ands	r1, r5
   1cf18:	6920      	ldr	r0, [r4, #16]
   1cf1a:	4005      	ands	r5, r0
   1cf1c:	0028      	movs	r0, r5
   1cf1e:	f000 fa70 	bl	1d402 <USBPD_PRL_SetHeaderDataRole>
   1cf22:	e00c      	b.n	1cf3e <PE_SubStateMachine_ReceiveDRS+0xaa>
   1cf24:	20a4      	movs	r0, #164	; 0xa4
   1cf26:	0080      	lsls	r0, r0, #2
   1cf28:	1820      	adds	r0, r4, r0
   1cf2a:	6861      	ldr	r1, [r4, #4]
   1cf2c:	7809      	ldrb	r1, [r1, #0]
   1cf2e:	0789      	lsls	r1, r1, #30
   1cf30:	0f89      	lsrs	r1, r1, #30
   1cf32:	2902      	cmp	r1, #2
   1cf34:	d101      	bne.n	1cf3a <PE_SubStateMachine_ReceiveDRS+0xa6>
   1cf36:	7005      	strb	r5, [r0, #0]
   1cf38:	e001      	b.n	1cf3e <PE_SubStateMachine_ReceiveDRS+0xaa>
   1cf3a:	212a      	movs	r1, #42	; 0x2a
   1cf3c:	7001      	strb	r1, [r0, #0]
   1cf3e:	2002      	movs	r0, #2
   1cf40:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
	...

0001cf44 <.text_150>:
   1cf44:	0002ff54 	.word	0x0002ff54

0001cf48 <PE_SubStateMachine_VconnSwap>:
   1cf48:	b5f3      	push	{r0, r1, r4, r5, r6, r7, lr}
   1cf4a:	b081      	sub	sp, #4
   1cf4c:	0004      	movs	r4, r0
   1cf4e:	2502      	movs	r5, #2
   1cf50:	20a4      	movs	r0, #164	; 0xa4
   1cf52:	0080      	lsls	r0, r0, #2
   1cf54:	1826      	adds	r6, r4, r0
   1cf56:	2014      	movs	r0, #20
   1cf58:	7831      	ldrb	r1, [r6, #0]
   1cf5a:	299d      	cmp	r1, #157	; 0x9d
   1cf5c:	d011      	beq.n	1cf82 <PE_SubStateMachine_VconnSwap+0x3a>
   1cf5e:	d30f      	bcc.n	1cf80 <PE_SubStateMachine_VconnSwap+0x38>
   1cf60:	299f      	cmp	r1, #159	; 0x9f
   1cf62:	d06a      	beq.n	1d03a <PE_SubStateMachine_VconnSwap+0xf2>
   1cf64:	d341      	bcc.n	1cfea <PE_SubStateMachine_VconnSwap+0xa2>
   1cf66:	29a1      	cmp	r1, #161	; 0xa1
   1cf68:	d100      	bne.n	1cf6c <PE_SubStateMachine_VconnSwap+0x24>
   1cf6a:	e0ac      	b.n	1d0c6 <PE_SubStateMachine_VconnSwap+0x17e>
   1cf6c:	d200      	bcs.n	1cf70 <PE_SubStateMachine_VconnSwap+0x28>
   1cf6e:	e09c      	b.n	1d0aa <PE_SubStateMachine_VconnSwap+0x162>
   1cf70:	29a3      	cmp	r1, #163	; 0xa3
   1cf72:	d100      	bne.n	1cf76 <PE_SubStateMachine_VconnSwap+0x2e>
   1cf74:	e0e0      	b.n	1d138 <PE_SubStateMachine_VconnSwap+0x1f0>
   1cf76:	d200      	bcs.n	1cf7a <PE_SubStateMachine_VconnSwap+0x32>
   1cf78:	e0c0      	b.n	1d0fc <PE_SubStateMachine_VconnSwap+0x1b4>
   1cf7a:	29a4      	cmp	r1, #164	; 0xa4
   1cf7c:	d100      	bne.n	1cf80 <PE_SubStateMachine_VconnSwap+0x38>
   1cf7e:	e181      	b.n	1d284 <PE_SubStateMachine_VconnSwap+0x33c>
   1cf80:	e192      	b.n	1d2a8 <PE_SubStateMachine_VconnSwap+0x360>
   1cf82:	6921      	ldr	r1, [r4, #16]
   1cf84:	2703      	movs	r7, #3
   1cf86:	6860      	ldr	r0, [r4, #4]
   1cf88:	6800      	ldr	r0, [r0, #0]
   1cf8a:	22b8      	movs	r2, #184	; 0xb8
   1cf8c:	0152      	lsls	r2, r2, #5
   1cf8e:	4002      	ands	r2, r0
   1cf90:	2098      	movs	r0, #152	; 0x98
   1cf92:	0140      	lsls	r0, r0, #5
   1cf94:	4282      	cmp	r2, r0
   1cf96:	d122      	bne.n	1cfde <PE_SubStateMachine_VconnSwap+0x96>
   1cf98:	07c8      	lsls	r0, r1, #31
   1cf9a:	0fc0      	lsrs	r0, r0, #31
   1cf9c:	68a1      	ldr	r1, [r4, #8]
   1cf9e:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
   1cfa0:	4788      	blx	r1
   1cfa2:	280a      	cmp	r0, #10
   1cfa4:	d002      	beq.n	1cfac <PE_SubStateMachine_VconnSwap+0x64>
   1cfa6:	280d      	cmp	r0, #13
   1cfa8:	d007      	beq.n	1cfba <PE_SubStateMachine_VconnSwap+0x72>
   1cfaa:	e00f      	b.n	1cfcc <PE_SubStateMachine_VconnSwap+0x84>
   1cfac:	209e      	movs	r0, #158	; 0x9e
   1cfae:	7030      	strb	r0, [r6, #0]
   1cfb0:	6920      	ldr	r0, [r4, #16]
   1cfb2:	02a9      	lsls	r1, r5, #10
   1cfb4:	4301      	orrs	r1, r0
   1cfb6:	6121      	str	r1, [r4, #16]
   1cfb8:	e176      	b.n	1d2a8 <PE_SubStateMachine_VconnSwap+0x360>
   1cfba:	2000      	movs	r0, #0
   1cfbc:	9000      	str	r0, [sp, #0]
   1cfbe:	2303      	movs	r3, #3
   1cfc0:	220c      	movs	r2, #12
   1cfc2:	2100      	movs	r1, #0
   1cfc4:	0020      	movs	r0, r4
   1cfc6:	f7fd fc95 	bl	1a8f4 <PE_Send_CtrlMessage>
   1cfca:	e16d      	b.n	1d2a8 <PE_SubStateMachine_VconnSwap+0x360>
   1cfcc:	2000      	movs	r0, #0
   1cfce:	9000      	str	r0, [sp, #0]
   1cfd0:	2303      	movs	r3, #3
   1cfd2:	2204      	movs	r2, #4
   1cfd4:	2100      	movs	r1, #0
   1cfd6:	0020      	movs	r0, r4
   1cfd8:	f7fd fc8c 	bl	1a8f4 <PE_Send_CtrlMessage>
   1cfdc:	e002      	b.n	1cfe4 <PE_SubStateMachine_VconnSwap+0x9c>
   1cfde:	48b3      	ldr	r0, [pc, #716]	; (1d2ac <.text_152>)
   1cfe0:	4008      	ands	r0, r1
   1cfe2:	6120      	str	r0, [r4, #16]
   1cfe4:	7037      	strb	r7, [r6, #0]
   1cfe6:	2500      	movs	r5, #0
   1cfe8:	e15e      	b.n	1d2a8 <PE_SubStateMachine_VconnSwap+0x360>
   1cfea:	2000      	movs	r0, #0
   1cfec:	9000      	str	r0, [sp, #0]
   1cfee:	239e      	movs	r3, #158	; 0x9e
   1cff0:	2203      	movs	r2, #3
   1cff2:	2100      	movs	r1, #0
   1cff4:	0020      	movs	r0, r4
   1cff6:	f7fd fc7d 	bl	1a8f4 <PE_Send_CtrlMessage>
   1cffa:	2800      	cmp	r0, #0
   1cffc:	d1f4      	bne.n	1cfe8 <PE_SubStateMachine_VconnSwap+0xa0>
   1cffe:	2701      	movs	r7, #1
   1d000:	6860      	ldr	r0, [r4, #4]
   1d002:	6800      	ldr	r0, [r0, #0]
   1d004:	0bc0      	lsrs	r0, r0, #15
   1d006:	4038      	ands	r0, r7
   1d008:	d005      	beq.n	1d016 <PE_SubStateMachine_VconnSwap+0xce>
   1d00a:	209f      	movs	r0, #159	; 0x9f
   1d00c:	7030      	strb	r0, [r6, #0]
   1d00e:	48a8      	ldr	r0, [pc, #672]	; (1d2b0 <.text_153>)
   1d010:	80b0      	strh	r0, [r6, #4]
   1d012:	2596      	movs	r5, #150	; 0x96
   1d014:	e001      	b.n	1d01a <PE_SubStateMachine_VconnSwap+0xd2>
   1d016:	20a0      	movs	r0, #160	; 0xa0
   1d018:	7030      	strb	r0, [r6, #0]
   1d01a:	2000      	movs	r0, #0
   1d01c:	9000      	str	r0, [sp, #0]
   1d01e:	2300      	movs	r3, #0
   1d020:	223f      	movs	r2, #63	; 0x3f
   1d022:	6920      	ldr	r0, [r4, #16]
   1d024:	2101      	movs	r1, #1
   1d026:	4001      	ands	r1, r0
   1d028:	2009      	movs	r0, #9
   1d02a:	4ea2      	ldr	r6, [pc, #648]	; (1d2b4 <.text_154>)
   1d02c:	6a36      	ldr	r6, [r6, #32]
   1d02e:	47b0      	blx	r6
   1d030:	213f      	movs	r1, #63	; 0x3f
   1d032:	6920      	ldr	r0, [r4, #16]
   1d034:	4007      	ands	r7, r0
   1d036:	0038      	movs	r0, r7
   1d038:	e120      	b.n	1d27c <PE_SubStateMachine_VconnSwap+0x334>
   1d03a:	88b1      	ldrh	r1, [r6, #4]
   1d03c:	03aa      	lsls	r2, r5, #14
   1d03e:	4291      	cmp	r1, r2
   1d040:	d100      	bne.n	1d044 <PE_SubStateMachine_VconnSwap+0xfc>
   1d042:	e106      	b.n	1d252 <PE_SubStateMachine_VconnSwap+0x30a>
   1d044:	9902      	ldr	r1, [sp, #8]
   1d046:	7809      	ldrb	r1, [r1, #0]
   1d048:	2911      	cmp	r1, #17
   1d04a:	d12d      	bne.n	1d0a8 <PE_SubStateMachine_VconnSwap+0x160>
   1d04c:	8a71      	ldrh	r1, [r6, #18]
   1d04e:	4a9a      	ldr	r2, [pc, #616]	; (1d2b8 <.text_155>)
   1d050:	400a      	ands	r2, r1
   1d052:	2a06      	cmp	r2, #6
   1d054:	d128      	bne.n	1d0a8 <PE_SubStateMachine_VconnSwap+0x160>
   1d056:	9902      	ldr	r1, [sp, #8]
   1d058:	7008      	strb	r0, [r1, #0]
   1d05a:	7c21      	ldrb	r1, [r4, #16]
   1d05c:	07c8      	lsls	r0, r1, #31
   1d05e:	0fc0      	lsrs	r0, r0, #31
   1d060:	f000 fbbb 	bl	1d7da <USBPD_PRL_EnableRX>
   1d064:	68a0      	ldr	r0, [r4, #8]
   1d066:	6b02      	ldr	r2, [r0, #48]	; 0x30
   1d068:	2a00      	cmp	r2, #0
   1d06a:	d004      	beq.n	1d076 <PE_SubStateMachine_VconnSwap+0x12e>
   1d06c:	2100      	movs	r1, #0
   1d06e:	7c23      	ldrb	r3, [r4, #16]
   1d070:	07d8      	lsls	r0, r3, #31
   1d072:	0fc0      	lsrs	r0, r0, #31
   1d074:	4790      	blx	r2
   1d076:	6921      	ldr	r1, [r4, #16]
   1d078:	488c      	ldr	r0, [pc, #560]	; (1d2ac <.text_152>)
   1d07a:	4008      	ands	r0, r1
   1d07c:	6120      	str	r0, [r4, #16]
   1d07e:	2103      	movs	r1, #3
   1d080:	7031      	strb	r1, [r6, #0]
   1d082:	2500      	movs	r5, #0
   1d084:	9500      	str	r5, [sp, #0]
   1d086:	2300      	movs	r3, #0
   1d088:	2242      	movs	r2, #66	; 0x42
   1d08a:	07c1      	lsls	r1, r0, #31
   1d08c:	0fc9      	lsrs	r1, r1, #31
   1d08e:	4889      	ldr	r0, [pc, #548]	; (1d2b4 <.text_154>)
   1d090:	6a07      	ldr	r7, [r0, #32]
   1d092:	2009      	movs	r0, #9
   1d094:	47b8      	blx	r7
   1d096:	2142      	movs	r1, #66	; 0x42
   1d098:	7c22      	ldrb	r2, [r4, #16]
   1d09a:	07d0      	lsls	r0, r2, #31
   1d09c:	0fc0      	lsrs	r0, r0, #31
   1d09e:	68a2      	ldr	r2, [r4, #8]
   1d0a0:	68d2      	ldr	r2, [r2, #12]
   1d0a2:	4790      	blx	r2
   1d0a4:	8135      	strh	r5, [r6, #8]
   1d0a6:	76a5      	strb	r5, [r4, #26]
   1d0a8:	e0fe      	b.n	1d2a8 <PE_SubStateMachine_VconnSwap+0x360>
   1d0aa:	68a0      	ldr	r0, [r4, #8]
   1d0ac:	6b02      	ldr	r2, [r0, #48]	; 0x30
   1d0ae:	2a00      	cmp	r2, #0
   1d0b0:	d004      	beq.n	1d0bc <PE_SubStateMachine_VconnSwap+0x174>
   1d0b2:	2101      	movs	r1, #1
   1d0b4:	7c23      	ldrb	r3, [r4, #16]
   1d0b6:	07d8      	lsls	r0, r3, #31
   1d0b8:	0fc0      	lsrs	r0, r0, #31
   1d0ba:	4790      	blx	r2
   1d0bc:	20a1      	movs	r0, #161	; 0xa1
   1d0be:	7030      	strb	r0, [r6, #0]
   1d0c0:	2000      	movs	r0, #0
   1d0c2:	76a0      	strb	r0, [r4, #26]
   1d0c4:	e0f0      	b.n	1d2a8 <PE_SubStateMachine_VconnSwap+0x360>
   1d0c6:	2000      	movs	r0, #0
   1d0c8:	9000      	str	r0, [sp, #0]
   1d0ca:	2303      	movs	r3, #3
   1d0cc:	2206      	movs	r2, #6
   1d0ce:	2100      	movs	r1, #0
   1d0d0:	0020      	movs	r0, r4
   1d0d2:	f7fd fc0f 	bl	1a8f4 <PE_Send_CtrlMessage>
   1d0d6:	2800      	cmp	r0, #0
   1d0d8:	d1f4      	bne.n	1d0c4 <PE_SubStateMachine_VconnSwap+0x17c>
   1d0da:	6921      	ldr	r1, [r4, #16]
   1d0dc:	4873      	ldr	r0, [pc, #460]	; (1d2ac <.text_152>)
   1d0de:	4008      	ands	r0, r1
   1d0e0:	6120      	str	r0, [r4, #16]
   1d0e2:	2601      	movs	r6, #1
   1d0e4:	2100      	movs	r1, #0
   1d0e6:	9100      	str	r1, [sp, #0]
   1d0e8:	2300      	movs	r3, #0
   1d0ea:	2242      	movs	r2, #66	; 0x42
   1d0ec:	2101      	movs	r1, #1
   1d0ee:	4001      	ands	r1, r0
   1d0f0:	2009      	movs	r0, #9
   1d0f2:	4f70      	ldr	r7, [pc, #448]	; (1d2b4 <.text_154>)
   1d0f4:	6a3f      	ldr	r7, [r7, #32]
   1d0f6:	47b8      	blx	r7
   1d0f8:	2142      	movs	r1, #66	; 0x42
   1d0fa:	e0bc      	b.n	1d276 <PE_SubStateMachine_VconnSwap+0x32e>
   1d0fc:	2000      	movs	r0, #0
   1d0fe:	9000      	str	r0, [sp, #0]
   1d100:	23a3      	movs	r3, #163	; 0xa3
   1d102:	220b      	movs	r2, #11
   1d104:	2100      	movs	r1, #0
   1d106:	0020      	movs	r0, r4
   1d108:	f7fd fbf4 	bl	1a8f4 <PE_Send_CtrlMessage>
   1d10c:	2800      	cmp	r0, #0
   1d10e:	d1d9      	bne.n	1d0c4 <PE_SubStateMachine_VconnSwap+0x17c>
   1d110:	6921      	ldr	r1, [r4, #16]
   1d112:	02a8      	lsls	r0, r5, #10
   1d114:	4308      	orrs	r0, r1
   1d116:	6120      	str	r0, [r4, #16]
   1d118:	4968      	ldr	r1, [pc, #416]	; (1d2bc <.text_156>)
   1d11a:	80b1      	strh	r1, [r6, #4]
   1d11c:	2518      	movs	r5, #24
   1d11e:	2601      	movs	r6, #1
   1d120:	2100      	movs	r1, #0
   1d122:	9100      	str	r1, [sp, #0]
   1d124:	2300      	movs	r3, #0
   1d126:	223e      	movs	r2, #62	; 0x3e
   1d128:	2101      	movs	r1, #1
   1d12a:	4001      	ands	r1, r0
   1d12c:	2009      	movs	r0, #9
   1d12e:	4f61      	ldr	r7, [pc, #388]	; (1d2b4 <.text_154>)
   1d130:	6a3f      	ldr	r7, [r7, #32]
   1d132:	47b8      	blx	r7
   1d134:	213e      	movs	r1, #62	; 0x3e
   1d136:	e09e      	b.n	1d276 <PE_SubStateMachine_VconnSwap+0x32e>
   1d138:	9902      	ldr	r1, [sp, #8]
   1d13a:	7809      	ldrb	r1, [r1, #0]
   1d13c:	2911      	cmp	r1, #17
   1d13e:	d110      	bne.n	1d162 <PE_SubStateMachine_VconnSwap+0x21a>
   1d140:	8a71      	ldrh	r1, [r6, #18]
   1d142:	22f0      	movs	r2, #240	; 0xf0
   1d144:	0212      	lsls	r2, r2, #8
   1d146:	400a      	ands	r2, r1
   1d148:	d10b      	bne.n	1d162 <PE_SubStateMachine_VconnSwap+0x21a>
   1d14a:	4f5a      	ldr	r7, [pc, #360]	; (1d2b4 <.text_154>)
   1d14c:	2203      	movs	r2, #3
   1d14e:	06c9      	lsls	r1, r1, #27
   1d150:	0ec9      	lsrs	r1, r1, #27
   1d152:	2903      	cmp	r1, #3
   1d154:	d006      	beq.n	1d164 <PE_SubStateMachine_VconnSwap+0x21c>
   1d156:	2904      	cmp	r1, #4
   1d158:	d038      	beq.n	1d1cc <PE_SubStateMachine_VconnSwap+0x284>
   1d15a:	290c      	cmp	r1, #12
   1d15c:	d01e      	beq.n	1d19c <PE_SubStateMachine_VconnSwap+0x254>
   1d15e:	2910      	cmp	r1, #16
   1d160:	d04c      	beq.n	1d1fc <PE_SubStateMachine_VconnSwap+0x2b4>
   1d162:	e071      	b.n	1d248 <PE_SubStateMachine_VconnSwap+0x300>
   1d164:	6861      	ldr	r1, [r4, #4]
   1d166:	6809      	ldr	r1, [r1, #0]
   1d168:	040a      	lsls	r2, r1, #16
   1d16a:	0fd2      	lsrs	r2, r2, #31
   1d16c:	d001      	beq.n	1d172 <PE_SubStateMachine_VconnSwap+0x22a>
   1d16e:	219f      	movs	r1, #159	; 0x9f
   1d170:	e000      	b.n	1d174 <PE_SubStateMachine_VconnSwap+0x22c>
   1d172:	21a0      	movs	r1, #160	; 0xa0
   1d174:	7031      	strb	r1, [r6, #0]
   1d176:	9902      	ldr	r1, [sp, #8]
   1d178:	7008      	strb	r0, [r1, #0]
   1d17a:	7c21      	ldrb	r1, [r4, #16]
   1d17c:	07c8      	lsls	r0, r1, #31
   1d17e:	0fc0      	lsrs	r0, r0, #31
   1d180:	f000 fb2b 	bl	1d7da <USBPD_PRL_EnableRX>
   1d184:	2000      	movs	r0, #0
   1d186:	9000      	str	r0, [sp, #0]
   1d188:	2300      	movs	r3, #0
   1d18a:	223f      	movs	r2, #63	; 0x3f
   1d18c:	7c20      	ldrb	r0, [r4, #16]
   1d18e:	07c1      	lsls	r1, r0, #31
   1d190:	0fc9      	lsrs	r1, r1, #31
   1d192:	2009      	movs	r0, #9
   1d194:	6a3f      	ldr	r7, [r7, #32]
   1d196:	47b8      	blx	r7
   1d198:	213f      	movs	r1, #63	; 0x3f
   1d19a:	e04f      	b.n	1d23c <PE_SubStateMachine_VconnSwap+0x2f4>
   1d19c:	6921      	ldr	r1, [r4, #16]
   1d19e:	4b43      	ldr	r3, [pc, #268]	; (1d2ac <.text_152>)
   1d1a0:	400b      	ands	r3, r1
   1d1a2:	6123      	str	r3, [r4, #16]
   1d1a4:	7032      	strb	r2, [r6, #0]
   1d1a6:	2500      	movs	r5, #0
   1d1a8:	9902      	ldr	r1, [sp, #8]
   1d1aa:	7008      	strb	r0, [r1, #0]
   1d1ac:	7c21      	ldrb	r1, [r4, #16]
   1d1ae:	07c8      	lsls	r0, r1, #31
   1d1b0:	0fc0      	lsrs	r0, r0, #31
   1d1b2:	f000 fb12 	bl	1d7da <USBPD_PRL_EnableRX>
   1d1b6:	9500      	str	r5, [sp, #0]
   1d1b8:	2300      	movs	r3, #0
   1d1ba:	2240      	movs	r2, #64	; 0x40
   1d1bc:	7c20      	ldrb	r0, [r4, #16]
   1d1be:	07c1      	lsls	r1, r0, #31
   1d1c0:	0fc9      	lsrs	r1, r1, #31
   1d1c2:	2009      	movs	r0, #9
   1d1c4:	6a3f      	ldr	r7, [r7, #32]
   1d1c6:	47b8      	blx	r7
   1d1c8:	2140      	movs	r1, #64	; 0x40
   1d1ca:	e037      	b.n	1d23c <PE_SubStateMachine_VconnSwap+0x2f4>
   1d1cc:	6921      	ldr	r1, [r4, #16]
   1d1ce:	4b37      	ldr	r3, [pc, #220]	; (1d2ac <.text_152>)
   1d1d0:	400b      	ands	r3, r1
   1d1d2:	6123      	str	r3, [r4, #16]
   1d1d4:	7032      	strb	r2, [r6, #0]
   1d1d6:	2500      	movs	r5, #0
   1d1d8:	9902      	ldr	r1, [sp, #8]
   1d1da:	7008      	strb	r0, [r1, #0]
   1d1dc:	7c21      	ldrb	r1, [r4, #16]
   1d1de:	07c8      	lsls	r0, r1, #31
   1d1e0:	0fc0      	lsrs	r0, r0, #31
   1d1e2:	f000 fafa 	bl	1d7da <USBPD_PRL_EnableRX>
   1d1e6:	9500      	str	r5, [sp, #0]
   1d1e8:	2300      	movs	r3, #0
   1d1ea:	2241      	movs	r2, #65	; 0x41
   1d1ec:	7c20      	ldrb	r0, [r4, #16]
   1d1ee:	07c1      	lsls	r1, r0, #31
   1d1f0:	0fc9      	lsrs	r1, r1, #31
   1d1f2:	2009      	movs	r0, #9
   1d1f4:	6a3f      	ldr	r7, [r7, #32]
   1d1f6:	47b8      	blx	r7
   1d1f8:	2141      	movs	r1, #65	; 0x41
   1d1fa:	e01f      	b.n	1d23c <PE_SubStateMachine_VconnSwap+0x2f4>
   1d1fc:	6861      	ldr	r1, [r4, #4]
   1d1fe:	6809      	ldr	r1, [r1, #0]
   1d200:	040b      	lsls	r3, r1, #16
   1d202:	0fdb      	lsrs	r3, r3, #31
   1d204:	d102      	bne.n	1d20c <PE_SubStateMachine_VconnSwap+0x2c4>
   1d206:	21a4      	movs	r1, #164	; 0xa4
   1d208:	7031      	strb	r1, [r6, #0]
   1d20a:	e005      	b.n	1d218 <PE_SubStateMachine_VconnSwap+0x2d0>
   1d20c:	6921      	ldr	r1, [r4, #16]
   1d20e:	4b27      	ldr	r3, [pc, #156]	; (1d2ac <.text_152>)
   1d210:	400b      	ands	r3, r1
   1d212:	6123      	str	r3, [r4, #16]
   1d214:	7032      	strb	r2, [r6, #0]
   1d216:	2500      	movs	r5, #0
   1d218:	9902      	ldr	r1, [sp, #8]
   1d21a:	7008      	strb	r0, [r1, #0]
   1d21c:	7c21      	ldrb	r1, [r4, #16]
   1d21e:	07c8      	lsls	r0, r1, #31
   1d220:	0fc0      	lsrs	r0, r0, #31
   1d222:	f000 fada 	bl	1d7da <USBPD_PRL_EnableRX>
   1d226:	2000      	movs	r0, #0
   1d228:	9000      	str	r0, [sp, #0]
   1d22a:	2300      	movs	r3, #0
   1d22c:	2243      	movs	r2, #67	; 0x43
   1d22e:	7c20      	ldrb	r0, [r4, #16]
   1d230:	07c1      	lsls	r1, r0, #31
   1d232:	0fc9      	lsrs	r1, r1, #31
   1d234:	2009      	movs	r0, #9
   1d236:	6a3f      	ldr	r7, [r7, #32]
   1d238:	47b8      	blx	r7
   1d23a:	2143      	movs	r1, #67	; 0x43
   1d23c:	7c22      	ldrb	r2, [r4, #16]
   1d23e:	07d0      	lsls	r0, r2, #31
   1d240:	0fc0      	lsrs	r0, r0, #31
   1d242:	68a2      	ldr	r2, [r4, #8]
   1d244:	68d2      	ldr	r2, [r2, #12]
   1d246:	4790      	blx	r2
   1d248:	88b0      	ldrh	r0, [r6, #4]
   1d24a:	2180      	movs	r1, #128	; 0x80
   1d24c:	0209      	lsls	r1, r1, #8
   1d24e:	4288      	cmp	r0, r1
   1d250:	d12a      	bne.n	1d2a8 <PE_SubStateMachine_VconnSwap+0x360>
   1d252:	6921      	ldr	r1, [r4, #16]
   1d254:	4815      	ldr	r0, [pc, #84]	; (1d2ac <.text_152>)
   1d256:	4008      	ands	r0, r1
   1d258:	6120      	str	r0, [r4, #16]
   1d25a:	2103      	movs	r1, #3
   1d25c:	7031      	strb	r1, [r6, #0]
   1d25e:	2500      	movs	r5, #0
   1d260:	2601      	movs	r6, #1
   1d262:	9500      	str	r5, [sp, #0]
   1d264:	2300      	movs	r3, #0
   1d266:	221c      	movs	r2, #28
   1d268:	2101      	movs	r1, #1
   1d26a:	4001      	ands	r1, r0
   1d26c:	2009      	movs	r0, #9
   1d26e:	4f11      	ldr	r7, [pc, #68]	; (1d2b4 <.text_154>)
   1d270:	6a3f      	ldr	r7, [r7, #32]
   1d272:	47b8      	blx	r7
   1d274:	211c      	movs	r1, #28
   1d276:	6920      	ldr	r0, [r4, #16]
   1d278:	4006      	ands	r6, r0
   1d27a:	0030      	movs	r0, r6
   1d27c:	68a2      	ldr	r2, [r4, #8]
   1d27e:	68d2      	ldr	r2, [r2, #12]
   1d280:	4790      	blx	r2
   1d282:	e011      	b.n	1d2a8 <PE_SubStateMachine_VconnSwap+0x360>
   1d284:	68a0      	ldr	r0, [r4, #8]
   1d286:	6b02      	ldr	r2, [r0, #48]	; 0x30
   1d288:	2a00      	cmp	r2, #0
   1d28a:	d004      	beq.n	1d296 <PE_SubStateMachine_VconnSwap+0x34e>
   1d28c:	2101      	movs	r1, #1
   1d28e:	7c23      	ldrb	r3, [r4, #16]
   1d290:	07d8      	lsls	r0, r3, #31
   1d292:	0fc0      	lsrs	r0, r0, #31
   1d294:	4790      	blx	r2
   1d296:	6920      	ldr	r0, [r4, #16]
   1d298:	4904      	ldr	r1, [pc, #16]	; (1d2ac <.text_152>)
   1d29a:	4001      	ands	r1, r0
   1d29c:	6121      	str	r1, [r4, #16]
   1d29e:	2003      	movs	r0, #3
   1d2a0:	7030      	strb	r0, [r6, #0]
   1d2a2:	4807      	ldr	r0, [pc, #28]	; (1d2c0 <.text_157>)
   1d2a4:	8130      	strh	r0, [r6, #8]
   1d2a6:	252d      	movs	r5, #45	; 0x2d
   1d2a8:	0028      	movs	r0, r5
   1d2aa:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

0001d2ac <.text_152>:
   1d2ac:	fffff7ff 	.word	0xfffff7ff

0001d2b0 <.text_153>:
   1d2b0:	00008096 	.word	0x00008096

0001d2b4 <.text_154>:
   1d2b4:	0002ff54 	.word	0x0002ff54

0001d2b8 <.text_155>:
   1d2b8:	0000f01f 	.word	0x0000f01f

0001d2bc <.text_156>:
   1d2bc:	00008018 	.word	0x00008018

0001d2c0 <.text_157>:
   1d2c0:	0000802d 	.word	0x0000802d

0001d2c4 <PE_Trace_Empty>:
   1d2c4:	4770      	bx	lr

0001d2c6 <USBPD_PE_ExecFastRoleSwapSignalling>:
   1d2c6:	b580      	push	{r7, lr}
   1d2c8:	f000 f8ea 	bl	1d4a0 <USBPD_PRL_FastRoleSwapSignalling>
   1d2cc:	bd01      	pop	{r0, pc}
	...

0001d2d0 <USBPD_PRL_TimerCounter>:
   1d2d0:	b081      	sub	sp, #4
   1d2d2:	496f      	ldr	r1, [pc, #444]	; (1d490 <.text_14>)
   1d2d4:	0080      	lsls	r0, r0, #2
   1d2d6:	1808      	adds	r0, r1, r0
   1d2d8:	6801      	ldr	r1, [r0, #0]
   1d2da:	7c0a      	ldrb	r2, [r1, #16]
   1d2dc:	2a00      	cmp	r2, #0
   1d2de:	d001      	beq.n	1d2e4 <USBPD_PRL_TimerCounter+0x14>
   1d2e0:	1e52      	subs	r2, r2, #1
   1d2e2:	740a      	strb	r2, [r1, #16]
   1d2e4:	6800      	ldr	r0, [r0, #0]
   1d2e6:	8f81      	ldrh	r1, [r0, #60]	; 0x3c
   1d2e8:	2900      	cmp	r1, #0
   1d2ea:	d001      	beq.n	1d2f0 <USBPD_PRL_TimerCounter+0x20>
   1d2ec:	1e49      	subs	r1, r1, #1
   1d2ee:	8781      	strh	r1, [r0, #60]	; 0x3c
   1d2f0:	b001      	add	sp, #4
   1d2f2:	4770      	bx	lr

0001d2f4 <USBPD_PRL_Init>:
   1d2f4:	b5f1      	push	{r0, r4, r5, r6, r7, lr}
   1d2f6:	b082      	sub	sp, #8
   1d2f8:	000c      	movs	r4, r1
   1d2fa:	0015      	movs	r5, r2
   1d2fc:	001e      	movs	r6, r3
   1d2fe:	4668      	mov	r0, sp
   1d300:	7a00      	ldrb	r0, [r0, #8]
   1d302:	2808      	cmp	r0, #8
   1d304:	d23c      	bcs.n	1d380 <USBPD_PRL_Init+0x8c>
   1d306:	2040      	movs	r0, #64	; 0x40
   1d308:	f001 f9ba 	bl	1e680 <malloc>
   1d30c:	4960      	ldr	r1, [pc, #384]	; (1d490 <.text_14>)
   1d30e:	466a      	mov	r2, sp
   1d310:	7a12      	ldrb	r2, [r2, #8]
   1d312:	0092      	lsls	r2, r2, #2
   1d314:	1889      	adds	r1, r1, r2
   1d316:	9100      	str	r1, [sp, #0]
   1d318:	6008      	str	r0, [r1, #0]
   1d31a:	2800      	cmp	r0, #0
   1d31c:	d101      	bne.n	1d322 <USBPD_PRL_Init+0x2e>
   1d31e:	2016      	movs	r0, #22
   1d320:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   1d322:	9f08      	ldr	r7, [sp, #32]
   1d324:	2140      	movs	r1, #64	; 0x40
   1d326:	f001 f977 	bl	1e618 <__aeabi_memclr>
   1d32a:	9800      	ldr	r0, [sp, #0]
   1d32c:	6800      	ldr	r0, [r0, #0]
   1d32e:	6829      	ldr	r1, [r5, #0]
   1d330:	6001      	str	r1, [r0, #0]
   1d332:	2100      	movs	r1, #0
   1d334:	7401      	strb	r1, [r0, #16]
   1d336:	220f      	movs	r2, #15
   1d338:	2103      	movs	r1, #3
   1d33a:	9800      	ldr	r0, [sp, #0]
   1d33c:	6800      	ldr	r0, [r0, #0]
   1d33e:	1d80      	adds	r0, r0, #6
   1d340:	f001 f973 	bl	1e62a <__aeabi_memset>
   1d344:	9800      	ldr	r0, [sp, #0]
   1d346:	6800      	ldr	r0, [r0, #0]
   1d348:	6384      	str	r4, [r0, #56]	; 0x38
   1d34a:	4952      	ldr	r1, [pc, #328]	; (1d494 <.text_15>)
   1d34c:	8bc2      	ldrh	r2, [r0, #30]
   1d34e:	400a      	ands	r2, r1
   1d350:	83c2      	strh	r2, [r0, #30]
   1d352:	4bcd      	ldr	r3, [pc, #820]	; (1d688 <.text_20>)
   1d354:	401a      	ands	r2, r3
   1d356:	83c2      	strh	r2, [r0, #30]
   1d358:	8c02      	ldrh	r2, [r0, #32]
   1d35a:	4011      	ands	r1, r2
   1d35c:	8401      	strh	r1, [r0, #32]
   1d35e:	400b      	ands	r3, r1
   1d360:	8403      	strh	r3, [r0, #32]
   1d362:	6346      	str	r6, [r0, #52]	; 0x34
   1d364:	6307      	str	r7, [r0, #48]	; 0x30
   1d366:	2101      	movs	r1, #1
   1d368:	9100      	str	r1, [sp, #0]
   1d36a:	6869      	ldr	r1, [r5, #4]
   1d36c:	074b      	lsls	r3, r1, #29
   1d36e:	0fdb      	lsrs	r3, r3, #31
   1d370:	6b82      	ldr	r2, [r0, #56]	; 0x38
   1d372:	bf00      	nop
   1d374:	a103      	add	r1, pc, #12	; (adr r1, 1d384 <USBPD_PRL_Init::PRL_PhyCallbacks>)
   1d376:	4668      	mov	r0, sp
   1d378:	7a00      	ldrb	r0, [r0, #8]
   1d37a:	f000 ff3f 	bl	1e1fc <USBPD_PHY_Init>
   1d37e:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   1d380:	2017      	movs	r0, #23
   1d382:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

0001d384 <USBPD_PRL_Init::PRL_PhyCallbacks>:
   1d384:	d9a9 0001 dc29 0001 dc79 0001 dc89 0001     ....)...y.......
   1d394:	dc91 0001                                   ....

0001d398 <USBPD_PRL_GetMemoryConsumption>:
   1d398:	2080      	movs	r0, #128	; 0x80
   1d39a:	0080      	lsls	r0, r0, #2
   1d39c:	4770      	bx	lr

0001d39e <USBPD_PRL_SetHeader>:
   1d39e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1d3a0:	4c3b      	ldr	r4, [pc, #236]	; (1d490 <.text_14>)
   1d3a2:	0085      	lsls	r5, r0, #2
   1d3a4:	5964      	ldr	r4, [r4, r5]
   1d3a6:	8ba6      	ldrh	r6, [r4, #28]
   1d3a8:	4d3a      	ldr	r5, [pc, #232]	; (1d494 <.text_15>)
   1d3aa:	4035      	ands	r5, r6
   1d3ac:	020e      	lsls	r6, r1, #8
   1d3ae:	2780      	movs	r7, #128	; 0x80
   1d3b0:	007f      	lsls	r7, r7, #1
   1d3b2:	403e      	ands	r6, r7
   1d3b4:	432e      	orrs	r6, r5
   1d3b6:	83a6      	strh	r6, [r4, #28]
   1d3b8:	4db3      	ldr	r5, [pc, #716]	; (1d688 <.text_20>)
   1d3ba:	4035      	ands	r5, r6
   1d3bc:	0156      	lsls	r6, r2, #5
   1d3be:	2720      	movs	r7, #32
   1d3c0:	403e      	ands	r6, r7
   1d3c2:	432e      	orrs	r6, r5
   1d3c4:	83a6      	strh	r6, [r4, #28]
   1d3c6:	4db4      	ldr	r5, [pc, #720]	; (1d698 <.text_22>)
   1d3c8:	4035      	ands	r5, r6
   1d3ca:	019e      	lsls	r6, r3, #6
   1d3cc:	27c0      	movs	r7, #192	; 0xc0
   1d3ce:	4037      	ands	r7, r6
   1d3d0:	432f      	orrs	r7, r5
   1d3d2:	83a7      	strh	r7, [r4, #28]
   1d3d4:	f000 ff5f 	bl	1e296 <USBPD_TCPM_set_msg_header>
   1d3d8:	bdf1      	pop	{r0, r4, r5, r6, r7, pc}

0001d3da <USBPD_PRL_SetHeaderPowerRole>:
   1d3da:	b538      	push	{r3, r4, r5, lr}
   1d3dc:	4a2c      	ldr	r2, [pc, #176]	; (1d490 <.text_14>)
   1d3de:	0083      	lsls	r3, r0, #2
   1d3e0:	58d2      	ldr	r2, [r2, r3]
   1d3e2:	8b93      	ldrh	r3, [r2, #28]
   1d3e4:	4d2b      	ldr	r5, [pc, #172]	; (1d494 <.text_15>)
   1d3e6:	401d      	ands	r5, r3
   1d3e8:	020c      	lsls	r4, r1, #8
   1d3ea:	2380      	movs	r3, #128	; 0x80
   1d3ec:	005b      	lsls	r3, r3, #1
   1d3ee:	401c      	ands	r4, r3
   1d3f0:	432c      	orrs	r4, r5
   1d3f2:	8394      	strh	r4, [r2, #28]
   1d3f4:	0622      	lsls	r2, r4, #24
   1d3f6:	0f93      	lsrs	r3, r2, #30
   1d3f8:	06a4      	lsls	r4, r4, #26
   1d3fa:	0fe2      	lsrs	r2, r4, #31
   1d3fc:	f000 ff4b 	bl	1e296 <USBPD_TCPM_set_msg_header>
   1d400:	bd31      	pop	{r0, r4, r5, pc}

0001d402 <USBPD_PRL_SetHeaderDataRole>:
   1d402:	b538      	push	{r3, r4, r5, lr}
   1d404:	000a      	movs	r2, r1
   1d406:	4922      	ldr	r1, [pc, #136]	; (1d490 <.text_14>)
   1d408:	0083      	lsls	r3, r0, #2
   1d40a:	58c9      	ldr	r1, [r1, r3]
   1d40c:	8b8b      	ldrh	r3, [r1, #28]
   1d40e:	4ca3      	ldr	r4, [pc, #652]	; (1d69c <.text_23>)
   1d410:	401c      	ands	r4, r3
   1d412:	0155      	lsls	r5, r2, #5
   1d414:	2320      	movs	r3, #32
   1d416:	401d      	ands	r5, r3
   1d418:	4325      	orrs	r5, r4
   1d41a:	838d      	strh	r5, [r1, #28]
   1d41c:	0629      	lsls	r1, r5, #24
   1d41e:	0f8b      	lsrs	r3, r1, #30
   1d420:	05ec      	lsls	r4, r5, #23
   1d422:	0fe1      	lsrs	r1, r4, #31
   1d424:	f000 ff37 	bl	1e296 <USBPD_TCPM_set_msg_header>
   1d428:	bd31      	pop	{r0, r4, r5, pc}

0001d42a <USBPD_PRL_SetHeaderSpecification>:
   1d42a:	b538      	push	{r3, r4, r5, lr}
   1d42c:	000b      	movs	r3, r1
   1d42e:	4918      	ldr	r1, [pc, #96]	; (1d490 <.text_14>)
   1d430:	0082      	lsls	r2, r0, #2
   1d432:	5889      	ldr	r1, [r1, r2]
   1d434:	8b8a      	ldrh	r2, [r1, #28]
   1d436:	4d98      	ldr	r5, [pc, #608]	; (1d698 <.text_22>)
   1d438:	4015      	ands	r5, r2
   1d43a:	019a      	lsls	r2, r3, #6
   1d43c:	24c0      	movs	r4, #192	; 0xc0
   1d43e:	4014      	ands	r4, r2
   1d440:	432c      	orrs	r4, r5
   1d442:	838c      	strh	r4, [r1, #28]
   1d444:	2101      	movs	r1, #1
   1d446:	0962      	lsrs	r2, r4, #5
   1d448:	400a      	ands	r2, r1
   1d44a:	0a24      	lsrs	r4, r4, #8
   1d44c:	4021      	ands	r1, r4
   1d44e:	f000 ff22 	bl	1e296 <USBPD_TCPM_set_msg_header>
   1d452:	bd31      	pop	{r0, r4, r5, pc}

0001d454 <USBPD_PRL_CBL_SetHeaderSpecification>:
   1d454:	4a0e      	ldr	r2, [pc, #56]	; (1d490 <.text_14>)
   1d456:	0080      	lsls	r0, r0, #2
   1d458:	5810      	ldr	r0, [r2, r0]
   1d45a:	018a      	lsls	r2, r1, #6
   1d45c:	21c0      	movs	r1, #192	; 0xc0
   1d45e:	4011      	ands	r1, r2
   1d460:	4a8d      	ldr	r2, [pc, #564]	; (1d698 <.text_22>)
   1d462:	8bc3      	ldrh	r3, [r0, #30]
   1d464:	4013      	ands	r3, r2
   1d466:	430b      	orrs	r3, r1
   1d468:	83c3      	strh	r3, [r0, #30]
   1d46a:	8c03      	ldrh	r3, [r0, #32]
   1d46c:	401a      	ands	r2, r3
   1d46e:	4311      	orrs	r1, r2
   1d470:	8401      	strh	r1, [r0, #32]
   1d472:	4770      	bx	lr

0001d474 <USBPD_PRL_SRCSetSinkNG>:
   1d474:	b580      	push	{r7, lr}
   1d476:	f000 ff6a 	bl	1e34e <USBPD_PHY_SetResistor_SinkTxNG>
   1d47a:	bd01      	pop	{r0, pc}

0001d47c <USBPD_PRL_SRCReleaseSinkNG>:
   1d47c:	b510      	push	{r4, lr}
   1d47e:	0004      	movs	r4, r0
   1d480:	f000 ff71 	bl	1e366 <USBPD_PHY_SetResistor_SinkTxOK>
   1d484:	2006      	movs	r0, #6
   1d486:	4902      	ldr	r1, [pc, #8]	; (1d490 <.text_14>)
   1d488:	00a2      	lsls	r2, r4, #2
   1d48a:	5889      	ldr	r1, [r1, r2]
   1d48c:	7108      	strb	r0, [r1, #4]
   1d48e:	bd10      	pop	{r4, pc}

0001d490 <.text_14>:
   1d490:	000320ec 	.word	0x000320ec

0001d494 <.text_15>:
   1d494:	0000feff 	.word	0x0000feff

0001d498 <USBPD_PRL_IsResistor_SinkTxOK>:
   1d498:	b580      	push	{r7, lr}
   1d49a:	f000 ff70 	bl	1e37e <USBPD_PHY_IsResistor_SinkTxOk>
   1d49e:	bd02      	pop	{r1, pc}

0001d4a0 <USBPD_PRL_FastRoleSwapSignalling>:
   1d4a0:	b580      	push	{r7, lr}
   1d4a2:	f000 ff7b 	bl	1e39c <USBPD_PHY_FastRoleSwapSignalling>
   1d4a6:	bd01      	pop	{r0, pc}

0001d4a8 <USBPD_PRL_SOPCapability>:
   1d4a8:	b580      	push	{r7, lr}
   1d4aa:	f000 fec5 	bl	1e238 <USBPD_PHY_SOPSupported>
   1d4ae:	bd01      	pop	{r0, pc}

0001d4b0 <USBPD_PRL_SendMessage>:
   1d4b0:	b5ff      	push	{r0, r1, r2, r3, r4, r5, r6, r7, lr}
   1d4b2:	b083      	sub	sp, #12
   1d4b4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   1d4b6:	9e0d      	ldr	r6, [sp, #52]	; 0x34
   1d4b8:	2403      	movs	r4, #3
   1d4ba:	48c6      	ldr	r0, [pc, #792]	; (1d7d4 <.text_28>)
   1d4bc:	4669      	mov	r1, sp
   1d4be:	7b09      	ldrb	r1, [r1, #12]
   1d4c0:	0089      	lsls	r1, r1, #2
   1d4c2:	1840      	adds	r0, r0, r1
   1d4c4:	9000      	str	r0, [sp, #0]
   1d4c6:	6801      	ldr	r1, [r0, #0]
   1d4c8:	790a      	ldrb	r2, [r1, #4]
   1d4ca:	4668      	mov	r0, sp
   1d4cc:	7c00      	ldrb	r0, [r0, #16]
   1d4ce:	9002      	str	r0, [sp, #8]
   1d4d0:	0040      	lsls	r0, r0, #1
   1d4d2:	9001      	str	r0, [sp, #4]
   1d4d4:	2000      	movs	r0, #0
   1d4d6:	2506      	movs	r5, #6
   1d4d8:	2a0f      	cmp	r2, #15
   1d4da:	d900      	bls.n	1d4de <USBPD_PRL_SendMessage+0x2e>
   1d4dc:	e0cf      	b.n	1d67e <USBPD_PRL_SendMessage+0x1ce>
   1d4de:	a702      	add	r7, pc, #8	; (adr r7, 1d4e8 <USBPD_PRL_SendMessage+0x38>)
   1d4e0:	5cbf      	ldrb	r7, [r7, r2]
   1d4e2:	007f      	lsls	r7, r7, #1
   1d4e4:	44bf      	add	pc, r7
   1d4e6:	bf00      	nop
   1d4e8:	cb1b1008 	.word	0xcb1b1008
   1d4ec:	912c3b22 	.word	0x912c3b22
   1d4f0:	a8cbcda0 	.word	0xa8cbcda0
   1d4f4:	bec8cbbb 	.word	0xbec8cbbb
   1d4f8:	4668      	mov	r0, sp
   1d4fa:	7b00      	ldrb	r0, [r0, #12]
   1d4fc:	f000 fe9b 	bl	1e236 <USBPD_PHY_Reset>
   1d500:	9800      	ldr	r0, [sp, #0]
   1d502:	6800      	ldr	r0, [r0, #0]
   1d504:	7105      	strb	r5, [r0, #4]
   1d506:	e0bc      	b.n	1d682 <USBPD_PRL_SendMessage+0x1d2>
   1d508:	4668      	mov	r0, sp
   1d50a:	7b00      	ldrb	r0, [r0, #12]
   1d50c:	f000 ff1f 	bl	1e34e <USBPD_PHY_SetResistor_SinkTxNG>
   1d510:	9800      	ldr	r0, [sp, #0]
   1d512:	6800      	ldr	r0, [r0, #0]
   1d514:	2102      	movs	r1, #2
   1d516:	7101      	strb	r1, [r0, #4]
   1d518:	2111      	movs	r1, #17
   1d51a:	8781      	strh	r1, [r0, #60]	; 0x3c
   1d51c:	e0b1      	b.n	1d682 <USBPD_PRL_SendMessage+0x1d2>
   1d51e:	2e01      	cmp	r6, #1
   1d520:	d1ee      	bne.n	1d500 <USBPD_PRL_SendMessage+0x50>
   1d522:	8f88      	ldrh	r0, [r1, #60]	; 0x3c
   1d524:	2800      	cmp	r0, #0
   1d526:	d109      	bne.n	1d53c <USBPD_PRL_SendMessage+0x8c>
   1d528:	2005      	movs	r0, #5
   1d52a:	e079      	b.n	1d620 <USBPD_PRL_SendMessage+0x170>
   1d52c:	2e02      	cmp	r6, #2
   1d52e:	d1e7      	bne.n	1d500 <USBPD_PRL_SendMessage+0x50>
   1d530:	4668      	mov	r0, sp
   1d532:	7b00      	ldrb	r0, [r0, #12]
   1d534:	f000 ff23 	bl	1e37e <USBPD_PHY_IsResistor_SinkTxOk>
   1d538:	2801      	cmp	r0, #1
   1d53a:	d0f5      	beq.n	1d528 <USBPD_PRL_SendMessage+0x78>
   1d53c:	2009      	movs	r0, #9
   1d53e:	e0a1      	b.n	1d684 <USBPD_PRL_SendMessage+0x1d4>
   1d540:	9801      	ldr	r0, [sp, #4]
   1d542:	1808      	adds	r0, r1, r0
   1d544:	8b80      	ldrh	r0, [r0, #28]
   1d546:	0600      	lsls	r0, r0, #24
   1d548:	0f80      	lsrs	r0, r0, #30
   1d54a:	2802      	cmp	r0, #2
   1d54c:	d1ec      	bne.n	1d528 <USBPD_PRL_SendMessage+0x78>
   1d54e:	2e01      	cmp	r6, #1
   1d550:	d101      	bne.n	1d556 <USBPD_PRL_SendMessage+0xa6>
   1d552:	2001      	movs	r0, #1
   1d554:	e066      	b.n	1d624 <USBPD_PRL_SendMessage+0x174>
   1d556:	2e02      	cmp	r6, #2
   1d558:	d1e6      	bne.n	1d528 <USBPD_PRL_SendMessage+0x78>
   1d55a:	2004      	movs	r0, #4
   1d55c:	e062      	b.n	1d624 <USBPD_PRL_SendMessage+0x174>
   1d55e:	466a      	mov	r2, sp
   1d560:	7d12      	ldrb	r2, [r2, #20]
   1d562:	25ff      	movs	r5, #255	; 0xff
   1d564:	724d      	strb	r5, [r1, #9]
   1d566:	466d      	mov	r5, sp
   1d568:	7c2d      	ldrb	r5, [r5, #16]
   1d56a:	728d      	strb	r5, [r1, #10]
   1d56c:	9d01      	ldr	r5, [sp, #4]
   1d56e:	194d      	adds	r5, r1, r5
   1d570:	8baf      	ldrh	r7, [r5, #28]
   1d572:	4ea2      	ldr	r6, [pc, #648]	; (1d7fc <.text_33>)
   1d574:	403e      	ands	r6, r7
   1d576:	06d7      	lsls	r7, r2, #27
   1d578:	0eff      	lsrs	r7, r7, #27
   1d57a:	4337      	orrs	r7, r6
   1d57c:	83af      	strh	r7, [r5, #28]
   1d57e:	047e      	lsls	r6, r7, #17
   1d580:	0c76      	lsrs	r6, r6, #17
   1d582:	09d7      	lsrs	r7, r2, #7
   1d584:	03ff      	lsls	r7, r7, #15
   1d586:	4337      	orrs	r7, r6
   1d588:	83af      	strh	r7, [r5, #28]
   1d58a:	7508      	strb	r0, [r1, #20]
   1d58c:	9900      	ldr	r1, [sp, #0]
   1d58e:	6809      	ldr	r1, [r1, #0]
   1d590:	9d01      	ldr	r5, [sp, #4]
   1d592:	194d      	adds	r5, r1, r5
   1d594:	8bae      	ldrh	r6, [r5, #28]
   1d596:	0bf7      	lsrs	r7, r6, #15
   1d598:	d021      	beq.n	1d5de <USBPD_PRL_SendMessage+0x12e>
   1d59a:	9e06      	ldr	r6, [sp, #24]
   1d59c:	78b6      	ldrb	r6, [r6, #2]
   1d59e:	9f06      	ldr	r7, [sp, #24]
   1d5a0:	78ff      	ldrb	r7, [r7, #3]
   1d5a2:	023f      	lsls	r7, r7, #8
   1d5a4:	19f6      	adds	r6, r6, r7
   1d5a6:	84ce      	strh	r6, [r1, #38]	; 0x26
   1d5a8:	8cce      	ldrh	r6, [r1, #38]	; 0x26
   1d5aa:	0ab7      	lsrs	r7, r6, #10
   1d5ac:	07ff      	lsls	r7, r7, #31
   1d5ae:	d40d      	bmi.n	1d5cc <USBPD_PRL_SendMessage+0x11c>
   1d5b0:	0470      	lsls	r0, r6, #17
   1d5b2:	0f00      	lsrs	r0, r0, #28
   1d5b4:	d11e      	bne.n	1d5f4 <USBPD_PRL_SendMessage+0x144>
   1d5b6:	1f18      	subs	r0, r3, #4
   1d5b8:	8588      	strh	r0, [r1, #44]	; 0x2c
   1d5ba:	05c0      	lsls	r0, r0, #23
   1d5bc:	0dc0      	lsrs	r0, r0, #23
   1d5be:	8ccb      	ldrh	r3, [r1, #38]	; 0x26
   1d5c0:	26fe      	movs	r6, #254	; 0xfe
   1d5c2:	0236      	lsls	r6, r6, #8
   1d5c4:	401e      	ands	r6, r3
   1d5c6:	4330      	orrs	r0, r6
   1d5c8:	84c8      	strh	r0, [r1, #38]	; 0x26
   1d5ca:	e013      	b.n	1d5f4 <USBPD_PRL_SendMessage+0x144>
   1d5cc:	8588      	strh	r0, [r1, #44]	; 0x2c
   1d5ce:	8ba8      	ldrh	r0, [r5, #28]
   1d5d0:	4bc8      	ldr	r3, [pc, #800]	; (1d8f4 <PRL_StateTXConstructMessage+0xec>)
   1d5d2:	4003      	ands	r3, r0
   1d5d4:	2080      	movs	r0, #128	; 0x80
   1d5d6:	0140      	lsls	r0, r0, #5
   1d5d8:	4318      	orrs	r0, r3
   1d5da:	83a8      	strh	r0, [r5, #28]
   1d5dc:	e00a      	b.n	1d5f4 <USBPD_PRL_SendMessage+0x144>
   1d5de:	4fc5      	ldr	r7, [pc, #788]	; (1d8f4 <PRL_StateTXConstructMessage+0xec>)
   1d5e0:	4037      	ands	r7, r6
   1d5e2:	1e9b      	subs	r3, r3, #2
   1d5e4:	089b      	lsrs	r3, r3, #2
   1d5e6:	031b      	lsls	r3, r3, #12
   1d5e8:	26e0      	movs	r6, #224	; 0xe0
   1d5ea:	01f6      	lsls	r6, r6, #7
   1d5ec:	401e      	ands	r6, r3
   1d5ee:	433e      	orrs	r6, r7
   1d5f0:	83ae      	strh	r6, [r5, #28]
   1d5f2:	8588      	strh	r0, [r1, #44]	; 0x2c
   1d5f4:	2a0d      	cmp	r2, #13
   1d5f6:	d106      	bne.n	1d606 <USBPD_PRL_SendMessage+0x156>
   1d5f8:	8ba8      	ldrh	r0, [r5, #28]
   1d5fa:	22f0      	movs	r2, #240	; 0xf0
   1d5fc:	0212      	lsls	r2, r2, #8
   1d5fe:	4002      	ands	r2, r0
   1d600:	d101      	bne.n	1d606 <USBPD_PRL_SendMessage+0x156>
   1d602:	2007      	movs	r0, #7
   1d604:	e00e      	b.n	1d624 <USBPD_PRL_SendMessage+0x174>
   1d606:	2008      	movs	r0, #8
   1d608:	e00c      	b.n	1d624 <USBPD_PRL_SendMessage+0x174>
   1d60a:	9a02      	ldr	r2, [sp, #8]
   1d60c:	1889      	adds	r1, r1, r2
   1d60e:	7448      	strb	r0, [r1, #17]
   1d610:	220f      	movs	r2, #15
   1d612:	2103      	movs	r1, #3
   1d614:	9800      	ldr	r0, [sp, #0]
   1d616:	6800      	ldr	r0, [r0, #0]
   1d618:	1d80      	adds	r0, r0, #6
   1d61a:	f001 f806 	bl	1e62a <__aeabi_memset>
   1d61e:	2008      	movs	r0, #8
   1d620:	9900      	ldr	r1, [sp, #0]
   1d622:	6809      	ldr	r1, [r1, #0]
   1d624:	7108      	strb	r0, [r1, #4]
   1d626:	e02c      	b.n	1d682 <USBPD_PRL_SendMessage+0x1d2>
   1d628:	9a06      	ldr	r2, [sp, #24]
   1d62a:	4668      	mov	r0, sp
   1d62c:	7c01      	ldrb	r1, [r0, #16]
   1d62e:	7b00      	ldrb	r0, [r0, #12]
   1d630:	f000 f8ea 	bl	1d808 <PRL_StateTXConstructMessage>
   1d634:	0004      	movs	r4, r0
   1d636:	e024      	b.n	1d682 <USBPD_PRL_SendMessage+0x1d2>
   1d638:	9802      	ldr	r0, [sp, #8]
   1d63a:	1808      	adds	r0, r1, r0
   1d63c:	7c41      	ldrb	r1, [r0, #17]
   1d63e:	1c49      	adds	r1, r1, #1
   1d640:	0749      	lsls	r1, r1, #29
   1d642:	0f49      	lsrs	r1, r1, #29
   1d644:	7441      	strb	r1, [r0, #17]
   1d646:	9800      	ldr	r0, [sp, #0]
   1d648:	6800      	ldr	r0, [r0, #0]
   1d64a:	7105      	strb	r5, [r0, #4]
   1d64c:	8cc2      	ldrh	r2, [r0, #38]	; 0x26
   1d64e:	496c      	ldr	r1, [pc, #432]	; (1d800 <.text_34>)
   1d650:	4011      	ands	r1, r2
   1d652:	84c1      	strh	r1, [r0, #38]	; 0x26
   1d654:	4a6b      	ldr	r2, [pc, #428]	; (1d804 <.text_35>)
   1d656:	400a      	ands	r2, r1
   1d658:	84c2      	strh	r2, [r0, #38]	; 0x26
   1d65a:	2405      	movs	r4, #5
   1d65c:	e011      	b.n	1d682 <USBPD_PRL_SendMessage+0x1d2>
   1d65e:	710d      	strb	r5, [r1, #4]
   1d660:	2407      	movs	r4, #7
   1d662:	e00e      	b.n	1d682 <USBPD_PRL_SendMessage+0x1d2>
   1d664:	9300      	str	r3, [sp, #0]
   1d666:	9b06      	ldr	r3, [sp, #24]
   1d668:	4668      	mov	r0, sp
   1d66a:	7c02      	ldrb	r2, [r0, #16]
   1d66c:	7b01      	ldrb	r1, [r0, #12]
   1d66e:	2002      	movs	r0, #2
   1d670:	4dcb      	ldr	r5, [pc, #812]	; (1d9a0 <.text_37>)
   1d672:	682d      	ldr	r5, [r5, #0]
   1d674:	47a8      	blx	r5
   1d676:	e004      	b.n	1d682 <USBPD_PRL_SendMessage+0x1d2>
   1d678:	710d      	strb	r5, [r1, #4]
   1d67a:	2406      	movs	r4, #6
   1d67c:	e001      	b.n	1d682 <USBPD_PRL_SendMessage+0x1d2>
   1d67e:	710d      	strb	r5, [r1, #4]
   1d680:	2410      	movs	r4, #16
   1d682:	0020      	movs	r0, r4
   1d684:	b007      	add	sp, #28
   1d686:	bdf0      	pop	{r4, r5, r6, r7, pc}

0001d688 <.text_20>:
   1d688:	0000ffdf 	.word	0x0000ffdf

0001d68c <USBPD_PRL_ResetRequestReset>:
   1d68c:	2100      	movs	r1, #0
   1d68e:	4ac5      	ldr	r2, [pc, #788]	; (1d9a4 <.text_38>)
   1d690:	0080      	lsls	r0, r0, #2
   1d692:	5810      	ldr	r0, [r2, r0]
   1d694:	7141      	strb	r1, [r0, #5]
   1d696:	4770      	bx	lr

0001d698 <.text_22>:
   1d698:	0000ff3f 	.word	0x0000ff3f

0001d69c <.text_23>:
   1d69c:	0000ffdf 	.word	0x0000ffdf

0001d6a0 <USBPD_PRL_ResetRequestProcess>:
   1d6a0:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
   1d6a2:	0005      	movs	r5, r0
   1d6a4:	2403      	movs	r4, #3
   1d6a6:	484b      	ldr	r0, [pc, #300]	; (1d7d4 <.text_28>)
   1d6a8:	00aa      	lsls	r2, r5, #2
   1d6aa:	1886      	adds	r6, r0, r2
   1d6ac:	6830      	ldr	r0, [r6, #0]
   1d6ae:	2200      	movs	r2, #0
   1d6b0:	2302      	movs	r3, #2
   1d6b2:	7947      	ldrb	r7, [r0, #5]
   1d6b4:	2f00      	cmp	r7, #0
   1d6b6:	d003      	beq.n	1d6c0 <USBPD_PRL_ResetRequestProcess+0x20>
   1d6b8:	2f02      	cmp	r7, #2
   1d6ba:	d03f      	beq.n	1d73c <USBPD_PRL_ResetRequestProcess+0x9c>
   1d6bc:	d332      	bcc.n	1d724 <USBPD_PRL_ResetRequestProcess+0x84>
   1d6be:	e040      	b.n	1d742 <USBPD_PRL_ResetRequestProcess+0xa2>
   1d6c0:	466b      	mov	r3, sp
   1d6c2:	7119      	strb	r1, [r3, #4]
   1d6c4:	7542      	strb	r2, [r0, #21]
   1d6c6:	6831      	ldr	r1, [r6, #0]
   1d6c8:	744a      	strb	r2, [r1, #17]
   1d6ca:	6831      	ldr	r1, [r6, #0]
   1d6cc:	748a      	strb	r2, [r1, #18]
   1d6ce:	6830      	ldr	r0, [r6, #0]
   1d6d0:	74c2      	strb	r2, [r0, #19]
   1d6d2:	220f      	movs	r2, #15
   1d6d4:	2103      	movs	r1, #3
   1d6d6:	6830      	ldr	r0, [r6, #0]
   1d6d8:	1d80      	adds	r0, r0, #6
   1d6da:	f000 ffa6 	bl	1e62a <__aeabi_memset>
   1d6de:	2006      	movs	r0, #6
   1d6e0:	6831      	ldr	r1, [r6, #0]
   1d6e2:	7108      	strb	r0, [r1, #4]
   1d6e4:	48ae      	ldr	r0, [pc, #696]	; (1d9a0 <.text_37>)
   1d6e6:	6807      	ldr	r7, [r0, #0]
   1d6e8:	4668      	mov	r0, sp
   1d6ea:	7900      	ldrb	r0, [r0, #4]
   1d6ec:	2805      	cmp	r0, #5
   1d6ee:	d104      	bne.n	1d6fa <USBPD_PRL_ResetRequestProcess+0x5a>
   1d6f0:	2000      	movs	r0, #0
   1d6f2:	9000      	str	r0, [sp, #0]
   1d6f4:	2300      	movs	r3, #0
   1d6f6:	2205      	movs	r2, #5
   1d6f8:	e003      	b.n	1d702 <USBPD_PRL_ResetRequestProcess+0x62>
   1d6fa:	2000      	movs	r0, #0
   1d6fc:	9000      	str	r0, [sp, #0]
   1d6fe:	2300      	movs	r3, #0
   1d700:	2206      	movs	r2, #6
   1d702:	0029      	movs	r1, r5
   1d704:	2002      	movs	r0, #2
   1d706:	47b8      	blx	r7
   1d708:	4668      	mov	r0, sp
   1d70a:	7901      	ldrb	r1, [r0, #4]
   1d70c:	0028      	movs	r0, r5
   1d70e:	f000 fdf2 	bl	1e2f6 <USBPD_PHY_ResetRequest>
   1d712:	0028      	movs	r0, r5
   1d714:	f000 f867 	bl	1d7e6 <USBPD_PRL_DisableRX>
   1d718:	6830      	ldr	r0, [r6, #0]
   1d71a:	2101      	movs	r1, #1
   1d71c:	7141      	strb	r1, [r0, #5]
   1d71e:	2105      	movs	r1, #5
   1d720:	7401      	strb	r1, [r0, #16]
   1d722:	e010      	b.n	1d746 <USBPD_PRL_ResetRequestProcess+0xa6>
   1d724:	7d41      	ldrb	r1, [r0, #21]
   1d726:	2901      	cmp	r1, #1
   1d728:	d102      	bne.n	1d730 <USBPD_PRL_ResetRequestProcess+0x90>
   1d72a:	7143      	strb	r3, [r0, #5]
   1d72c:	7542      	strb	r2, [r0, #21]
   1d72e:	e00a      	b.n	1d746 <USBPD_PRL_ResetRequestProcess+0xa6>
   1d730:	7c01      	ldrb	r1, [r0, #16]
   1d732:	2900      	cmp	r1, #0
   1d734:	d107      	bne.n	1d746 <USBPD_PRL_ResetRequestProcess+0xa6>
   1d736:	7142      	strb	r2, [r0, #5]
   1d738:	2404      	movs	r4, #4
   1d73a:	e004      	b.n	1d746 <USBPD_PRL_ResetRequestProcess+0xa6>
   1d73c:	7142      	strb	r2, [r0, #5]
   1d73e:	2400      	movs	r4, #0
   1d740:	e001      	b.n	1d746 <USBPD_PRL_ResetRequestProcess+0xa6>
   1d742:	7142      	strb	r2, [r0, #5]
   1d744:	2402      	movs	r4, #2
   1d746:	0020      	movs	r0, r4
   1d748:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

0001d74a <USBDPD_PRL_BistCarrierEyeMode>:
   1d74a:	b580      	push	{r7, lr}
   1d74c:	2905      	cmp	r1, #5
   1d74e:	d102      	bne.n	1d756 <USBDPD_PRL_BistCarrierEyeMode+0xc>
   1d750:	f000 fde1 	bl	1e316 <USBPD_PHY_Send_BIST_Pattern>
   1d754:	bd02      	pop	{r1, pc}
   1d756:	2010      	movs	r0, #16
   1d758:	bd02      	pop	{r1, pc}

0001d75a <USBDPD_PRL_BistCarrierEyeModeExit>:
   1d75a:	b510      	push	{r4, lr}
   1d75c:	2303      	movs	r3, #3
   1d75e:	4a91      	ldr	r2, [pc, #580]	; (1d9a4 <.text_38>)
   1d760:	0084      	lsls	r4, r0, #2
   1d762:	5912      	ldr	r2, [r2, r4]
   1d764:	8b92      	ldrh	r2, [r2, #28]
   1d766:	0992      	lsrs	r2, r2, #6
   1d768:	401a      	ands	r2, r3
   1d76a:	2a01      	cmp	r2, #1
   1d76c:	d000      	beq.n	1d770 <USBDPD_PRL_BistCarrierEyeModeExit+0x16>
   1d76e:	2302      	movs	r3, #2
   1d770:	2905      	cmp	r1, #5
   1d772:	d104      	bne.n	1d77e <USBDPD_PRL_BistCarrierEyeModeExit+0x24>
   1d774:	2200      	movs	r2, #0
   1d776:	2107      	movs	r1, #7
   1d778:	f000 fdaa 	bl	1e2d0 <USBPD_TCPM_transmit>
   1d77c:	bd10      	pop	{r4, pc}
   1d77e:	2010      	movs	r0, #16
   1d780:	bd10      	pop	{r4, pc}

0001d782 <USBPD_PRL_Reset>:
   1d782:	b570      	push	{r4, r5, r6, lr}
   1d784:	0004      	movs	r4, r0
   1d786:	4813      	ldr	r0, [pc, #76]	; (1d7d4 <.text_28>)
   1d788:	00a1      	lsls	r1, r4, #2
   1d78a:	1846      	adds	r6, r0, r1
   1d78c:	6830      	ldr	r0, [r6, #0]
   1d78e:	2500      	movs	r5, #0
   1d790:	7105      	strb	r5, [r0, #4]
   1d792:	7145      	strb	r5, [r0, #5]
   1d794:	7405      	strb	r5, [r0, #16]
   1d796:	6830      	ldr	r0, [r6, #0]
   1d798:	7445      	strb	r5, [r0, #17]
   1d79a:	6830      	ldr	r0, [r6, #0]
   1d79c:	7485      	strb	r5, [r0, #18]
   1d79e:	6830      	ldr	r0, [r6, #0]
   1d7a0:	74c5      	strb	r5, [r0, #19]
   1d7a2:	220f      	movs	r2, #15
   1d7a4:	2103      	movs	r1, #3
   1d7a6:	6830      	ldr	r0, [r6, #0]
   1d7a8:	1d80      	adds	r0, r0, #6
   1d7aa:	f000 ff3e 	bl	1e62a <__aeabi_memset>
   1d7ae:	6830      	ldr	r0, [r6, #0]
   1d7b0:	7505      	strb	r5, [r0, #20]
   1d7b2:	6830      	ldr	r0, [r6, #0]
   1d7b4:	7545      	strb	r5, [r0, #21]
   1d7b6:	6830      	ldr	r0, [r6, #0]
   1d7b8:	7585      	strb	r5, [r0, #22]
   1d7ba:	6830      	ldr	r0, [r6, #0]
   1d7bc:	21ff      	movs	r1, #255	; 0xff
   1d7be:	7241      	strb	r1, [r0, #9]
   1d7c0:	212f      	movs	r1, #47	; 0x2f
   1d7c2:	5445      	strb	r5, [r0, r1]
   1d7c4:	0020      	movs	r0, r4
   1d7c6:	f000 fd36 	bl	1e236 <USBPD_PHY_Reset>
   1d7ca:	0020      	movs	r0, r4
   1d7cc:	f000 f805 	bl	1d7da <USBPD_PRL_EnableRX>
   1d7d0:	bd70      	pop	{r4, r5, r6, pc}
	...

0001d7d4 <.text_28>:
   1d7d4:	000320ec 	.word	0x000320ec

0001d7d8 <USBPD_PRL_DeInit>:
   1d7d8:	4770      	bx	lr

0001d7da <USBPD_PRL_EnableRX>:
   1d7da:	b510      	push	{r4, lr}
   1d7dc:	0004      	movs	r4, r0
   1d7de:	f000 fdde 	bl	1e39e <USBPD_PHY_EnableRX>
   1d7e2:	2000      	movs	r0, #0
   1d7e4:	e004      	b.n	1d7f0 <.text_32>

0001d7e6 <USBPD_PRL_DisableRX>:
   1d7e6:	b510      	push	{r4, lr}
   1d7e8:	0004      	movs	r4, r0
   1d7ea:	f000 fde4 	bl	1e3b6 <USBPD_PHY_DisableRX>
   1d7ee:	2001      	movs	r0, #1

0001d7f0 <.text_32>:
   1d7f0:	496c      	ldr	r1, [pc, #432]	; (1d9a4 <.text_38>)
   1d7f2:	00a2      	lsls	r2, r4, #2
   1d7f4:	5889      	ldr	r1, [r1, r2]
   1d7f6:	7588      	strb	r0, [r1, #22]
   1d7f8:	bd10      	pop	{r4, pc}
	...

0001d7fc <.text_33>:
   1d7fc:	0000ffe0 	.word	0x0000ffe0

0001d800 <.text_34>:
   1d800:	000087ff 	.word	0x000087ff

0001d804 <.text_35>:
   1d804:	0000fbff 	.word	0x0000fbff

0001d808 <PRL_StateTXConstructMessage>:
   1d808:	b5f2      	push	{r1, r4, r5, r6, r7, lr}
   1d80a:	b084      	sub	sp, #16
   1d80c:	0005      	movs	r5, r0
   1d80e:	0014      	movs	r4, r2
   1d810:	2003      	movs	r0, #3
   1d812:	4669      	mov	r1, sp
   1d814:	7108      	strb	r0, [r1, #4]
   1d816:	4863      	ldr	r0, [pc, #396]	; (1d9a4 <.text_38>)
   1d818:	00a9      	lsls	r1, r5, #2
   1d81a:	1840      	adds	r0, r0, r1
   1d81c:	9002      	str	r0, [sp, #8]
   1d81e:	6801      	ldr	r1, [r0, #0]
   1d820:	4668      	mov	r0, sp
   1d822:	7c00      	ldrb	r0, [r0, #16]
   1d824:	9000      	str	r0, [sp, #0]
   1d826:	0040      	lsls	r0, r0, #1
   1d828:	9003      	str	r0, [sp, #12]
   1d82a:	0008      	movs	r0, r1
   1d82c:	301c      	adds	r0, #28
   1d82e:	9a03      	ldr	r2, [sp, #12]
   1d830:	1886      	adds	r6, r0, r2
   1d832:	8830      	ldrh	r0, [r6, #0]
   1d834:	0bc0      	lsrs	r0, r0, #15
   1d836:	d071      	beq.n	1d91c <PRL_StateTXConstructMessage+0x114>
   1d838:	8cca      	ldrh	r2, [r1, #38]	; 0x26
   1d83a:	2080      	movs	r0, #128	; 0x80
   1d83c:	0200      	lsls	r0, r0, #8
   1d83e:	4310      	orrs	r0, r2
   1d840:	84c8      	strh	r0, [r1, #38]	; 0x26
   1d842:	0a80      	lsrs	r0, r0, #10
   1d844:	07c0      	lsls	r0, r0, #31
   1d846:	d460      	bmi.n	1d90a <PRL_StateTXConstructMessage+0x102>
   1d848:	8d8a      	ldrh	r2, [r1, #44]	; 0x2c
   1d84a:	2a1b      	cmp	r2, #27
   1d84c:	d302      	bcc.n	1d854 <PRL_StateTXConstructMessage+0x4c>
   1d84e:	8cc8      	ldrh	r0, [r1, #38]	; 0x26
   1d850:	0bc0      	lsrs	r0, r0, #15
   1d852:	d151      	bne.n	1d8f8 <PRL_StateTXConstructMessage+0xf0>
   1d854:	4853      	ldr	r0, [pc, #332]	; (1d9a4 <.text_38>)
   1d856:	00af      	lsls	r7, r5, #2
   1d858:	59c0      	ldr	r0, [r0, r7]
   1d85a:	8cc0      	ldrh	r0, [r0, #38]	; 0x26
   1d85c:	0447      	lsls	r7, r0, #17
   1d85e:	0f3f      	lsrs	r7, r7, #28
   1d860:	d106      	bne.n	1d870 <PRL_StateTXConstructMessage+0x68>
   1d862:	27fe      	movs	r7, #254	; 0xfe
   1d864:	023f      	lsls	r7, r7, #8
   1d866:	4007      	ands	r7, r0
   1d868:	05d0      	lsls	r0, r2, #23
   1d86a:	0dc0      	lsrs	r0, r0, #23
   1d86c:	4338      	orrs	r0, r7
   1d86e:	84c8      	strh	r0, [r1, #38]	; 0x26
   1d870:	8830      	ldrh	r0, [r6, #0]
   1d872:	4a20      	ldr	r2, [pc, #128]	; (1d8f4 <PRL_StateTXConstructMessage+0xec>)
   1d874:	4002      	ands	r2, r0
   1d876:	8032      	strh	r2, [r6, #0]
   1d878:	2200      	movs	r2, #0
   1d87a:	8cc8      	ldrh	r0, [r1, #38]	; 0x26
   1d87c:	0bc0      	lsrs	r0, r0, #15
   1d87e:	d035      	beq.n	1d8ec <PRL_StateTXConstructMessage+0xe4>
   1d880:	8d88      	ldrh	r0, [r1, #44]	; 0x2c
   1d882:	1c80      	adds	r0, r0, #2
   1d884:	0883      	lsrs	r3, r0, #2
   1d886:	8830      	ldrh	r0, [r6, #0]
   1d888:	031b      	lsls	r3, r3, #12
   1d88a:	27e0      	movs	r7, #224	; 0xe0
   1d88c:	01ff      	lsls	r7, r7, #7
   1d88e:	401f      	ands	r7, r3
   1d890:	4307      	orrs	r7, r0
   1d892:	8037      	strh	r7, [r6, #0]
   1d894:	8d88      	ldrh	r0, [r1, #44]	; 0x2c
   1d896:	1c80      	adds	r0, r0, #2
   1d898:	0786      	lsls	r6, r0, #30
   1d89a:	0fb6      	lsrs	r6, r6, #30
   1d89c:	d01d      	beq.n	1d8da <PRL_StateTXConstructMessage+0xd2>
   1d89e:	2000      	movs	r0, #0
   1d8a0:	e004      	b.n	1d8ac <PRL_StateTXConstructMessage+0xa4>
   1d8a2:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
   1d8a4:	1859      	adds	r1, r3, r1
   1d8a6:	1861      	adds	r1, r4, r1
   1d8a8:	710a      	strb	r2, [r1, #4]
   1d8aa:	1c40      	adds	r0, r0, #1
   1d8ac:	493d      	ldr	r1, [pc, #244]	; (1d9a4 <.text_38>)
   1d8ae:	00ab      	lsls	r3, r5, #2
   1d8b0:	58cb      	ldr	r3, [r1, r3]
   1d8b2:	b2c1      	uxtb	r1, r0
   1d8b4:	2704      	movs	r7, #4
   1d8b6:	1bbf      	subs	r7, r7, r6
   1d8b8:	42b9      	cmp	r1, r7
   1d8ba:	d3f2      	bcc.n	1d8a2 <PRL_StateTXConstructMessage+0x9a>
   1d8bc:	0018      	movs	r0, r3
   1d8be:	301c      	adds	r0, #28
   1d8c0:	9903      	ldr	r1, [sp, #12]
   1d8c2:	1840      	adds	r0, r0, r1
   1d8c4:	8803      	ldrh	r3, [r0, #0]
   1d8c6:	490b      	ldr	r1, [pc, #44]	; (1d8f4 <PRL_StateTXConstructMessage+0xec>)
   1d8c8:	4019      	ands	r1, r3
   1d8ca:	0b1b      	lsrs	r3, r3, #12
   1d8cc:	1c5b      	adds	r3, r3, #1
   1d8ce:	031b      	lsls	r3, r3, #12
   1d8d0:	26e0      	movs	r6, #224	; 0xe0
   1d8d2:	01f6      	lsls	r6, r6, #7
   1d8d4:	401e      	ands	r6, r3
   1d8d6:	430e      	orrs	r6, r1
   1d8d8:	8006      	strh	r6, [r0, #0]
   1d8da:	9802      	ldr	r0, [sp, #8]
   1d8dc:	6800      	ldr	r0, [r0, #0]
   1d8de:	301c      	adds	r0, #28
   1d8e0:	9903      	ldr	r1, [sp, #12]
   1d8e2:	5a40      	ldrh	r0, [r0, r1]
   1d8e4:	0440      	lsls	r0, r0, #17
   1d8e6:	0f40      	lsrs	r0, r0, #29
   1d8e8:	0083      	lsls	r3, r0, #2
   1d8ea:	1c9b      	adds	r3, r3, #2
   1d8ec:	9802      	ldr	r0, [sp, #8]
   1d8ee:	6800      	ldr	r0, [r0, #0]
   1d8f0:	8582      	strh	r2, [r0, #44]	; 0x2c
   1d8f2:	e00a      	b.n	1d90a <PRL_StateTXConstructMessage+0x102>
   1d8f4:	00008fff 	.word	0x00008fff
   1d8f8:	8830      	ldrh	r0, [r6, #0]
   1d8fa:	22e0      	movs	r2, #224	; 0xe0
   1d8fc:	01d2      	lsls	r2, r2, #7
   1d8fe:	4302      	orrs	r2, r0
   1d900:	8032      	strh	r2, [r6, #0]
   1d902:	8d88      	ldrh	r0, [r1, #44]	; 0x2c
   1d904:	381a      	subs	r0, #26
   1d906:	8588      	strh	r0, [r1, #44]	; 0x2c
   1d908:	231e      	movs	r3, #30
   1d90a:	9802      	ldr	r0, [sp, #8]
   1d90c:	6800      	ldr	r0, [r0, #0]
   1d90e:	8cc0      	ldrh	r0, [r0, #38]	; 0x26
   1d910:	70a0      	strb	r0, [r4, #2]
   1d912:	9802      	ldr	r0, [sp, #8]
   1d914:	6800      	ldr	r0, [r0, #0]
   1d916:	8cc0      	ldrh	r0, [r0, #38]	; 0x26
   1d918:	0a00      	lsrs	r0, r0, #8
   1d91a:	70e0      	strb	r0, [r4, #3]
   1d91c:	9802      	ldr	r0, [sp, #8]
   1d91e:	6801      	ldr	r1, [r0, #0]
   1d920:	9800      	ldr	r0, [sp, #0]
   1d922:	1808      	adds	r0, r1, r0
   1d924:	7c40      	ldrb	r0, [r0, #17]
   1d926:	311c      	adds	r1, #28
   1d928:	9a03      	ldr	r2, [sp, #12]
   1d92a:	1889      	adds	r1, r1, r2
   1d92c:	880e      	ldrh	r6, [r1, #0]
   1d92e:	4abd      	ldr	r2, [pc, #756]	; (1dc24 <.text_40>)
   1d930:	4032      	ands	r2, r6
   1d932:	0246      	lsls	r6, r0, #9
   1d934:	20e0      	movs	r0, #224	; 0xe0
   1d936:	0100      	lsls	r0, r0, #4
   1d938:	4030      	ands	r0, r6
   1d93a:	4310      	orrs	r0, r2
   1d93c:	8008      	strh	r0, [r1, #0]
   1d93e:	7020      	strb	r0, [r4, #0]
   1d940:	9802      	ldr	r0, [sp, #8]
   1d942:	6800      	ldr	r0, [r0, #0]
   1d944:	301c      	adds	r0, #28
   1d946:	9903      	ldr	r1, [sp, #12]
   1d948:	5a40      	ldrh	r0, [r0, r1]
   1d94a:	0a00      	lsrs	r0, r0, #8
   1d94c:	7060      	strb	r0, [r4, #1]
   1d94e:	2009      	movs	r0, #9
   1d950:	9902      	ldr	r1, [sp, #8]
   1d952:	6809      	ldr	r1, [r1, #0]
   1d954:	7108      	strb	r0, [r1, #4]
   1d956:	b29b      	uxth	r3, r3
   1d958:	9300      	str	r3, [sp, #0]
   1d95a:	0023      	movs	r3, r4
   1d95c:	4668      	mov	r0, sp
   1d95e:	7c02      	ldrb	r2, [r0, #16]
   1d960:	0029      	movs	r1, r5
   1d962:	2002      	movs	r0, #2
   1d964:	4e0e      	ldr	r6, [pc, #56]	; (1d9a0 <.text_37>)
   1d966:	6836      	ldr	r6, [r6, #0]
   1d968:	47b0      	blx	r6
   1d96a:	2303      	movs	r3, #3
   1d96c:	9802      	ldr	r0, [sp, #8]
   1d96e:	6800      	ldr	r0, [r0, #0]
   1d970:	301c      	adds	r0, #28
   1d972:	9903      	ldr	r1, [sp, #12]
   1d974:	5a40      	ldrh	r0, [r0, r1]
   1d976:	0980      	lsrs	r0, r0, #6
   1d978:	2103      	movs	r1, #3
   1d97a:	4001      	ands	r1, r0
   1d97c:	2901      	cmp	r1, #1
   1d97e:	d000      	beq.n	1d982 <PRL_StateTXConstructMessage+0x17a>
   1d980:	2302      	movs	r3, #2
   1d982:	0022      	movs	r2, r4
   1d984:	4668      	mov	r0, sp
   1d986:	7c01      	ldrb	r1, [r0, #16]
   1d988:	0028      	movs	r0, r5
   1d98a:	f000 fca1 	bl	1e2d0 <USBPD_TCPM_transmit>
   1d98e:	2800      	cmp	r0, #0
   1d990:	d002      	beq.n	1d998 <PRL_StateTXConstructMessage+0x190>
   1d992:	2010      	movs	r0, #16
   1d994:	4669      	mov	r1, sp
   1d996:	7108      	strb	r0, [r1, #4]
   1d998:	4668      	mov	r0, sp
   1d99a:	7900      	ldrb	r0, [r0, #4]
   1d99c:	b005      	add	sp, #20
   1d99e:	bdf0      	pop	{r4, r5, r6, r7, pc}

0001d9a0 <.text_37>:
   1d9a0:	0002ff74 	.word	0x0002ff74

0001d9a4 <.text_38>:
   1d9a4:	000320ec 	.word	0x000320ec

0001d9a8 <PRL_Received>:
   1d9a8:	b5f3      	push	{r0, r1, r4, r5, r6, r7, lr}
   1d9aa:	b083      	sub	sp, #12
   1d9ac:	48b5      	ldr	r0, [pc, #724]	; (1dc84 <.text_44>)
   1d9ae:	4669      	mov	r1, sp
   1d9b0:	7b09      	ldrb	r1, [r1, #12]
   1d9b2:	0089      	lsls	r1, r1, #2
   1d9b4:	1846      	adds	r6, r0, r1
   1d9b6:	6830      	ldr	r0, [r6, #0]
   1d9b8:	6b81      	ldr	r1, [r0, #56]	; 0x38
   1d9ba:	780a      	ldrb	r2, [r1, #0]
   1d9bc:	7849      	ldrb	r1, [r1, #1]
   1d9be:	0209      	lsls	r1, r1, #8
   1d9c0:	1851      	adds	r1, r2, r1
   1d9c2:	466a      	mov	r2, sp
   1d9c4:	8091      	strh	r1, [r2, #4]
   1d9c6:	4669      	mov	r1, sp
   1d9c8:	7c09      	ldrb	r1, [r1, #16]
   1d9ca:	7241      	strb	r1, [r0, #9]
   1d9cc:	4669      	mov	r1, sp
   1d9ce:	7c09      	ldrb	r1, [r1, #16]
   1d9d0:	9102      	str	r1, [sp, #8]
   1d9d2:	2400      	movs	r4, #0
   1d9d4:	4669      	mov	r1, sp
   1d9d6:	8889      	ldrh	r1, [r1, #4]
   1d9d8:	4ac5      	ldr	r2, [pc, #788]	; (1dcf0 <.text_47>)
   1d9da:	400a      	ands	r2, r1
   1d9dc:	2a0d      	cmp	r2, #13
   1d9de:	d10a      	bne.n	1d9f6 <PRL_Received+0x4e>
   1d9e0:	9a02      	ldr	r2, [sp, #8]
   1d9e2:	1880      	adds	r0, r0, r2
   1d9e4:	7444      	strb	r4, [r0, #17]
   1d9e6:	220f      	movs	r2, #15
   1d9e8:	2103      	movs	r1, #3
   1d9ea:	6830      	ldr	r0, [r6, #0]
   1d9ec:	1d80      	adds	r0, r0, #6
   1d9ee:	f000 fe1c 	bl	1e62a <__aeabi_memset>
   1d9f2:	6831      	ldr	r1, [r6, #0]
   1d9f4:	710c      	strb	r4, [r1, #4]
   1d9f6:	6830      	ldr	r0, [r6, #0]
   1d9f8:	7901      	ldrb	r1, [r0, #4]
   1d9fa:	290a      	cmp	r1, #10
   1d9fc:	d101      	bne.n	1da02 <PRL_Received+0x5a>
   1d9fe:	2106      	movs	r1, #6
   1da00:	7101      	strb	r1, [r0, #4]
   1da02:	6b83      	ldr	r3, [r0, #56]	; 0x38
   1da04:	7898      	ldrb	r0, [r3, #2]
   1da06:	78d9      	ldrb	r1, [r3, #3]
   1da08:	0209      	lsls	r1, r1, #8
   1da0a:	1845      	adds	r5, r0, r1
   1da0c:	4668      	mov	r0, sp
   1da0e:	05e9      	lsls	r1, r5, #23
   1da10:	0dc9      	lsrs	r1, r1, #23
   1da12:	80c1      	strh	r1, [r0, #6]
   1da14:	48cb      	ldr	r0, [pc, #812]	; (1dd44 <.text_49>)
   1da16:	6807      	ldr	r7, [r0, #0]
   1da18:	4668      	mov	r0, sp
   1da1a:	8880      	ldrh	r0, [r0, #4]
   1da1c:	0bc0      	lsrs	r0, r0, #15
   1da1e:	d004      	beq.n	1da2a <PRL_Received+0x82>
   1da20:	0428      	lsls	r0, r5, #16
   1da22:	0fc0      	lsrs	r0, r0, #31
   1da24:	d101      	bne.n	1da2a <PRL_Received+0x82>
   1da26:	1d08      	adds	r0, r1, #4
   1da28:	e005      	b.n	1da36 <PRL_Received+0x8e>
   1da2a:	4668      	mov	r0, sp
   1da2c:	8880      	ldrh	r0, [r0, #4]
   1da2e:	0440      	lsls	r0, r0, #17
   1da30:	0f40      	lsrs	r0, r0, #29
   1da32:	0080      	lsls	r0, r0, #2
   1da34:	1c80      	adds	r0, r0, #2
   1da36:	9000      	str	r0, [sp, #0]
   1da38:	4668      	mov	r0, sp
   1da3a:	7c02      	ldrb	r2, [r0, #16]
   1da3c:	7b01      	ldrb	r1, [r0, #12]
   1da3e:	2001      	movs	r0, #1
   1da40:	47b8      	blx	r7
   1da42:	6830      	ldr	r0, [r6, #0]
   1da44:	1d81      	adds	r1, r0, #6
   1da46:	9a02      	ldr	r2, [sp, #8]
   1da48:	1889      	adds	r1, r1, r2
   1da4a:	9100      	str	r1, [sp, #0]
   1da4c:	4669      	mov	r1, sp
   1da4e:	8889      	ldrh	r1, [r1, #4]
   1da50:	0a49      	lsrs	r1, r1, #9
   1da52:	2707      	movs	r7, #7
   1da54:	9a00      	ldr	r2, [sp, #0]
   1da56:	7812      	ldrb	r2, [r2, #0]
   1da58:	2307      	movs	r3, #7
   1da5a:	400b      	ands	r3, r1
   1da5c:	429a      	cmp	r2, r3
   1da5e:	d100      	bne.n	1da62 <PRL_Received+0xba>
   1da60:	e0dc      	b.n	1dc1c <PRL_Received+0x274>
   1da62:	2007      	movs	r0, #7
   1da64:	4008      	ands	r0, r1
   1da66:	9900      	ldr	r1, [sp, #0]
   1da68:	7008      	strb	r0, [r1, #0]
   1da6a:	6830      	ldr	r0, [r6, #0]
   1da6c:	6b81      	ldr	r1, [r0, #56]	; 0x38
   1da6e:	788a      	ldrb	r2, [r1, #2]
   1da70:	78cb      	ldrb	r3, [r1, #3]
   1da72:	021b      	lsls	r3, r3, #8
   1da74:	18d2      	adds	r2, r2, r3
   1da76:	790b      	ldrb	r3, [r1, #4]
   1da78:	041b      	lsls	r3, r3, #16
   1da7a:	18d2      	adds	r2, r2, r3
   1da7c:	7949      	ldrb	r1, [r1, #5]
   1da7e:	0609      	lsls	r1, r1, #24
   1da80:	1851      	adds	r1, r2, r1
   1da82:	466a      	mov	r2, sp
   1da84:	8892      	ldrh	r2, [r2, #4]
   1da86:	0bd2      	lsrs	r2, r2, #15
   1da88:	d116      	bne.n	1dab8 <PRL_Received+0x110>
   1da8a:	466a      	mov	r2, sp
   1da8c:	8892      	ldrh	r2, [r2, #4]
   1da8e:	0b12      	lsrs	r2, r2, #12
   1da90:	423a      	tst	r2, r7
   1da92:	d011      	beq.n	1dab8 <PRL_Received+0x110>
   1da94:	466a      	mov	r2, sp
   1da96:	8892      	ldrh	r2, [r2, #4]
   1da98:	06d2      	lsls	r2, r2, #27
   1da9a:	0ed2      	lsrs	r2, r2, #27
   1da9c:	2a03      	cmp	r2, #3
   1da9e:	d10b      	bne.n	1dab8 <PRL_Received+0x110>
   1daa0:	0f09      	lsrs	r1, r1, #28
   1daa2:	2908      	cmp	r1, #8
   1daa4:	d001      	beq.n	1daaa <PRL_Received+0x102>
   1daa6:	2900      	cmp	r1, #0
   1daa8:	d106      	bne.n	1dab8 <PRL_Received+0x110>
   1daaa:	2101      	movs	r1, #1
   1daac:	4668      	mov	r0, sp
   1daae:	7b00      	ldrb	r0, [r0, #12]
   1dab0:	f000 fc3b 	bl	1e32a <USBPD_TCPM_Send_BIST_Pattern>
   1dab4:	2301      	movs	r3, #1
   1dab6:	e0a6      	b.n	1dc06 <PRL_Received+0x25e>
   1dab8:	4669      	mov	r1, sp
   1daba:	8889      	ldrh	r1, [r1, #4]
   1dabc:	8541      	strh	r1, [r0, #42]	; 0x2a
   1dabe:	4669      	mov	r1, sp
   1dac0:	8889      	ldrh	r1, [r1, #4]
   1dac2:	0bc9      	lsrs	r1, r1, #15
   1dac4:	d071      	beq.n	1dbaa <PRL_Received+0x202>
   1dac6:	0429      	lsls	r1, r5, #16
   1dac8:	0fc9      	lsrs	r1, r1, #31
   1daca:	d06e      	beq.n	1dbaa <PRL_Received+0x202>
   1dacc:	8505      	strh	r5, [r0, #40]	; 0x28
   1dace:	220f      	movs	r2, #15
   1dad0:	4669      	mov	r1, sp
   1dad2:	8889      	ldrh	r1, [r1, #4]
   1dad4:	0b09      	lsrs	r1, r1, #12
   1dad6:	400f      	ands	r7, r1
   1dad8:	2101      	movs	r1, #1
   1dada:	23f8      	movs	r3, #248	; 0xf8
   1dadc:	01db      	lsls	r3, r3, #7
   1dade:	402b      	ands	r3, r5
   1dae0:	d130      	bne.n	1db44 <PRL_Received+0x19c>
   1dae2:	2f07      	cmp	r7, #7
   1dae4:	d303      	bcc.n	1daee <PRL_Received+0x146>
   1dae6:	466b      	mov	r3, sp
   1dae8:	88db      	ldrh	r3, [r3, #6]
   1daea:	2b1a      	cmp	r3, #26
   1daec:	d81d      	bhi.n	1db2a <PRL_Received+0x182>
   1daee:	0428      	lsls	r0, r5, #16
   1daf0:	0ec0      	lsrs	r0, r0, #27
   1daf2:	4002      	ands	r2, r0
   1daf4:	201a      	movs	r0, #26
   1daf6:	4350      	muls	r0, r2
   1daf8:	e008      	b.n	1db0c <PRL_Received+0x164>
   1dafa:	6831      	ldr	r1, [r6, #0]
   1dafc:	6b8a      	ldr	r2, [r1, #56]	; 0x38
   1dafe:	1d12      	adds	r2, r2, #4
   1db00:	5d12      	ldrb	r2, [r2, r4]
   1db02:	6b49      	ldr	r1, [r1, #52]	; 0x34
   1db04:	1823      	adds	r3, r4, r0
   1db06:	54ca      	strb	r2, [r1, r3]
   1db08:	1c64      	adds	r4, r4, #1
   1db0a:	b2a4      	uxth	r4, r4
   1db0c:	4669      	mov	r1, sp
   1db0e:	8889      	ldrh	r1, [r1, #4]
   1db10:	0449      	lsls	r1, r1, #17
   1db12:	0f49      	lsrs	r1, r1, #29
   1db14:	0089      	lsls	r1, r1, #2
   1db16:	1e89      	subs	r1, r1, #2
   1db18:	428c      	cmp	r4, r1
   1db1a:	d3ee      	bcc.n	1dafa <PRL_Received+0x152>
   1db1c:	4668      	mov	r0, sp
   1db1e:	88c0      	ldrh	r0, [r0, #6]
   1db20:	4281      	cmp	r1, r0
   1db22:	d265      	bcs.n	1dbf0 <PRL_Received+0x248>
   1db24:	6830      	ldr	r0, [r6, #0]
   1db26:	6b00      	ldr	r0, [r0, #48]	; 0x30
   1db28:	e03e      	b.n	1dba8 <PRL_Received+0x200>
   1db2a:	222f      	movs	r2, #47	; 0x2f
   1db2c:	5481      	strb	r1, [r0, r2]
   1db2e:	6830      	ldr	r0, [r6, #0]
   1db30:	6b81      	ldr	r1, [r0, #56]	; 0x38
   1db32:	1d09      	adds	r1, r1, #4
   1db34:	5d09      	ldrb	r1, [r1, r4]
   1db36:	6b40      	ldr	r0, [r0, #52]	; 0x34
   1db38:	5501      	strb	r1, [r0, r4]
   1db3a:	1c64      	adds	r4, r4, #1
   1db3c:	2c1a      	cmp	r4, #26
   1db3e:	d3f6      	bcc.n	1db2e <PRL_Received+0x186>
   1db40:	201a      	movs	r0, #26
   1db42:	e057      	b.n	1dbf4 <PRL_Received+0x24c>
   1db44:	6b03      	ldr	r3, [r0, #48]	; 0x30
   1db46:	881b      	ldrh	r3, [r3, #0]
   1db48:	00bf      	lsls	r7, r7, #2
   1db4a:	19df      	adds	r7, r3, r7
   1db4c:	1ebf      	subs	r7, r7, #2
   1db4e:	9700      	str	r7, [sp, #0]
   1db50:	331a      	adds	r3, #26
   1db52:	27ff      	movs	r7, #255	; 0xff
   1db54:	1dbf      	adds	r7, r7, #6
   1db56:	42bb      	cmp	r3, r7
   1db58:	d228      	bcs.n	1dbac <PRL_Received+0x204>
   1db5a:	9b00      	ldr	r3, [sp, #0]
   1db5c:	466f      	mov	r7, sp
   1db5e:	88ff      	ldrh	r7, [r7, #6]
   1db60:	42bb      	cmp	r3, r7
   1db62:	d223      	bcs.n	1dbac <PRL_Received+0x204>
   1db64:	232f      	movs	r3, #47	; 0x2f
   1db66:	54c1      	strb	r1, [r0, r3]
   1db68:	0428      	lsls	r0, r5, #16
   1db6a:	0ec0      	lsrs	r0, r0, #27
   1db6c:	4002      	ands	r2, r0
   1db6e:	201a      	movs	r0, #26
   1db70:	4350      	muls	r0, r2
   1db72:	e007      	b.n	1db84 <PRL_Received+0x1dc>
   1db74:	6b8a      	ldr	r2, [r1, #56]	; 0x38
   1db76:	1d12      	adds	r2, r2, #4
   1db78:	5d12      	ldrb	r2, [r2, r4]
   1db7a:	6b49      	ldr	r1, [r1, #52]	; 0x34
   1db7c:	1823      	adds	r3, r4, r0
   1db7e:	54ca      	strb	r2, [r1, r3]
   1db80:	1c64      	adds	r4, r4, #1
   1db82:	b2a4      	uxth	r4, r4
   1db84:	6831      	ldr	r1, [r6, #0]
   1db86:	466a      	mov	r2, sp
   1db88:	8892      	ldrh	r2, [r2, #4]
   1db8a:	0452      	lsls	r2, r2, #17
   1db8c:	0f52      	lsrs	r2, r2, #29
   1db8e:	0092      	lsls	r2, r2, #2
   1db90:	1e92      	subs	r2, r2, #2
   1db92:	4294      	cmp	r4, r2
   1db94:	d3ee      	bcc.n	1db74 <PRL_Received+0x1cc>
   1db96:	6b08      	ldr	r0, [r1, #48]	; 0x30
   1db98:	8801      	ldrh	r1, [r0, #0]
   1db9a:	466a      	mov	r2, sp
   1db9c:	8892      	ldrh	r2, [r2, #4]
   1db9e:	0a92      	lsrs	r2, r2, #10
   1dba0:	231c      	movs	r3, #28
   1dba2:	4013      	ands	r3, r2
   1dba4:	1e9a      	subs	r2, r3, #2
   1dba6:	1889      	adds	r1, r1, r2
   1dba8:	8001      	strh	r1, [r0, #0]
   1dbaa:	e02b      	b.n	1dc04 <PRL_Received+0x25c>
   1dbac:	9b00      	ldr	r3, [sp, #0]
   1dbae:	27ff      	movs	r7, #255	; 0xff
   1dbb0:	1dbf      	adds	r7, r7, #6
   1dbb2:	42bb      	cmp	r3, r7
   1dbb4:	d222      	bcs.n	1dbfc <PRL_Received+0x254>
   1dbb6:	466f      	mov	r7, sp
   1dbb8:	88ff      	ldrh	r7, [r7, #6]
   1dbba:	42bb      	cmp	r3, r7
   1dbbc:	d31e      	bcc.n	1dbfc <PRL_Received+0x254>
   1dbbe:	232f      	movs	r3, #47	; 0x2f
   1dbc0:	54c1      	strb	r1, [r0, r3]
   1dbc2:	0428      	lsls	r0, r5, #16
   1dbc4:	0ec0      	lsrs	r0, r0, #27
   1dbc6:	4002      	ands	r2, r0
   1dbc8:	201a      	movs	r0, #26
   1dbca:	4350      	muls	r0, r2
   1dbcc:	e008      	b.n	1dbe0 <PRL_Received+0x238>
   1dbce:	6831      	ldr	r1, [r6, #0]
   1dbd0:	6b8a      	ldr	r2, [r1, #56]	; 0x38
   1dbd2:	1d12      	adds	r2, r2, #4
   1dbd4:	5d12      	ldrb	r2, [r2, r4]
   1dbd6:	6b49      	ldr	r1, [r1, #52]	; 0x34
   1dbd8:	1823      	adds	r3, r4, r0
   1dbda:	54ca      	strb	r2, [r1, r3]
   1dbdc:	1c64      	adds	r4, r4, #1
   1dbde:	b2a4      	uxth	r4, r4
   1dbe0:	4669      	mov	r1, sp
   1dbe2:	8889      	ldrh	r1, [r1, #4]
   1dbe4:	0449      	lsls	r1, r1, #17
   1dbe6:	0f49      	lsrs	r1, r1, #29
   1dbe8:	0089      	lsls	r1, r1, #2
   1dbea:	1e89      	subs	r1, r1, #2
   1dbec:	428c      	cmp	r4, r1
   1dbee:	d3ee      	bcc.n	1dbce <PRL_Received+0x226>
   1dbf0:	4668      	mov	r0, sp
   1dbf2:	88c0      	ldrh	r0, [r0, #6]
   1dbf4:	6831      	ldr	r1, [r6, #0]
   1dbf6:	6b09      	ldr	r1, [r1, #48]	; 0x30
   1dbf8:	8008      	strh	r0, [r1, #0]
   1dbfa:	e003      	b.n	1dc04 <PRL_Received+0x25c>
   1dbfc:	222f      	movs	r2, #47	; 0x2f
   1dbfe:	5484      	strb	r4, [r0, r2]
   1dc00:	6830      	ldr	r0, [r6, #0]
   1dc02:	7104      	strb	r4, [r0, #4]
   1dc04:	2300      	movs	r3, #0
   1dc06:	aa01      	add	r2, sp, #4
   1dc08:	4668      	mov	r0, sp
   1dc0a:	7c01      	ldrb	r1, [r0, #16]
   1dc0c:	7b00      	ldrb	r0, [r0, #12]
   1dc0e:	f7fe fb61 	bl	1c2d4 <PE_PRL_PostReceiveEvent>
   1dc12:	4668      	mov	r0, sp
   1dc14:	7b00      	ldrb	r0, [r0, #12]
   1dc16:	f7fe fb80 	bl	1c31a <PE_PRL_PostReceiveEventComplete>
   1dc1a:	e000      	b.n	1dc1e <PRL_Received+0x276>
   1dc1c:	7684      	strb	r4, [r0, #26]
   1dc1e:	b005      	add	sp, #20
   1dc20:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

0001dc24 <.text_40>:
   1dc24:	0000f1ff 	.word	0x0000f1ff

0001dc28 <PRL_ResetIndicate>:
   1dc28:	b57c      	push	{r2, r3, r4, r5, r6, lr}
   1dc2a:	0004      	movs	r4, r0
   1dc2c:	000d      	movs	r5, r1
   1dc2e:	4815      	ldr	r0, [pc, #84]	; (1dc84 <.text_44>)
   1dc30:	00a1      	lsls	r1, r4, #2
   1dc32:	1846      	adds	r6, r0, r1
   1dc34:	2000      	movs	r0, #0
   1dc36:	6831      	ldr	r1, [r6, #0]
   1dc38:	1949      	adds	r1, r1, r5
   1dc3a:	7448      	strb	r0, [r1, #17]
   1dc3c:	220f      	movs	r2, #15
   1dc3e:	2103      	movs	r1, #3
   1dc40:	6830      	ldr	r0, [r6, #0]
   1dc42:	1d80      	adds	r0, r0, #6
   1dc44:	f000 fcf1 	bl	1e62a <__aeabi_memset>
   1dc48:	2006      	movs	r0, #6
   1dc4a:	6831      	ldr	r1, [r6, #0]
   1dc4c:	7108      	strb	r0, [r1, #4]
   1dc4e:	0020      	movs	r0, r4
   1dc50:	f7ff fdc9 	bl	1d7e6 <USBPD_PRL_DisableRX>
   1dc54:	2000      	movs	r0, #0
   1dc56:	9000      	str	r0, [sp, #0]
   1dc58:	2300      	movs	r3, #0
   1dc5a:	002a      	movs	r2, r5
   1dc5c:	0021      	movs	r1, r4
   1dc5e:	2001      	movs	r0, #1
   1dc60:	4e38      	ldr	r6, [pc, #224]	; (1dd44 <.text_49>)
   1dc62:	6836      	ldr	r6, [r6, #0]
   1dc64:	47b0      	blx	r6
   1dc66:	0029      	movs	r1, r5
   1dc68:	0020      	movs	r0, r4
   1dc6a:	f7fe f941 	bl	1bef0 <PE_PRL_HardResetReceived>
   1dc6e:	bd73      	pop	{r0, r1, r4, r5, r6, pc}

0001dc70 <USBPD_PRL_PowerSinkReset>:
   1dc70:	b580      	push	{r7, lr}
   1dc72:	f7ff fdb2 	bl	1d7da <USBPD_PRL_EnableRX>
   1dc76:	bd01      	pop	{r0, pc}

0001dc78 <PRL_ResetCompleted>:
   1dc78:	2101      	movs	r1, #1
   1dc7a:	4a4c      	ldr	r2, [pc, #304]	; (1ddac <.text_51>)
   1dc7c:	0080      	lsls	r0, r0, #2
   1dc7e:	5810      	ldr	r0, [r2, r0]
   1dc80:	7541      	strb	r1, [r0, #21]
   1dc82:	4770      	bx	lr

0001dc84 <.text_44>:
   1dc84:	000320ec 	.word	0x000320ec

0001dc88 <PRL_BistCompleted>:
   1dc88:	b580      	push	{r7, lr}
   1dc8a:	f7fe f95d 	bl	1bf48 <PE_PRL_BistCompleted>
   1dc8e:	bd01      	pop	{r0, pc}

0001dc90 <PRL_TxCompleted>:
   1dc90:	b53e      	push	{r1, r2, r3, r4, r5, lr}
   1dc92:	4a46      	ldr	r2, [pc, #280]	; (1ddac <.text_51>)
   1dc94:	0083      	lsls	r3, r0, #2
   1dc96:	18d4      	adds	r4, r2, r3
   1dc98:	6822      	ldr	r2, [r4, #0]
   1dc9a:	2900      	cmp	r1, #0
   1dc9c:	d105      	bne.n	1dcaa <PRL_TxCompleted+0x1a>
   1dc9e:	2101      	movs	r1, #1
   1dca0:	7953      	ldrb	r3, [r2, #5]
   1dca2:	2b01      	cmp	r3, #1
   1dca4:	d105      	bne.n	1dcb2 <PRL_TxCompleted+0x22>
   1dca6:	7551      	strb	r1, [r2, #21]
   1dca8:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
   1dcaa:	2902      	cmp	r1, #2
   1dcac:	d117      	bne.n	1dcde <PRL_TxCompleted+0x4e>
   1dcae:	200c      	movs	r0, #12
   1dcb0:	e01c      	b.n	1dcec <PRL_TxCompleted+0x5c>
   1dcb2:	bf00      	nop
   1dcb4:	a340      	add	r3, pc, #256	; (adr r3, 1ddb8 <.text_54>)
   1dcb6:	881b      	ldrh	r3, [r3, #0]
   1dcb8:	4d3d      	ldr	r5, [pc, #244]	; (1ddb0 <.text_52>)
   1dcba:	401d      	ands	r5, r3
   1dcbc:	4329      	orrs	r1, r5
   1dcbe:	ab01      	add	r3, sp, #4
   1dcc0:	7019      	strb	r1, [r3, #0]
   1dcc2:	0a09      	lsrs	r1, r1, #8
   1dcc4:	7059      	strb	r1, [r3, #1]
   1dcc6:	2102      	movs	r1, #2
   1dcc8:	9100      	str	r1, [sp, #0]
   1dcca:	7a92      	ldrb	r2, [r2, #10]
   1dccc:	0001      	movs	r1, r0
   1dcce:	2001      	movs	r0, #1
   1dcd0:	4d1c      	ldr	r5, [pc, #112]	; (1dd44 <.text_49>)
   1dcd2:	682d      	ldr	r5, [r5, #0]
   1dcd4:	47a8      	blx	r5
   1dcd6:	200b      	movs	r0, #11
   1dcd8:	6821      	ldr	r1, [r4, #0]
   1dcda:	7108      	strb	r0, [r1, #4]
   1dcdc:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
   1dcde:	2901      	cmp	r1, #1
   1dce0:	d103      	bne.n	1dcea <PRL_TxCompleted+0x5a>
   1dce2:	2008      	movs	r0, #8
   1dce4:	60d0      	str	r0, [r2, #12]
   1dce6:	200a      	movs	r0, #10
   1dce8:	e000      	b.n	1dcec <PRL_TxCompleted+0x5c>
   1dcea:	200d      	movs	r0, #13
   1dcec:	7110      	strb	r0, [r2, #4]
   1dcee:	bd37      	pop	{r0, r1, r2, r4, r5, pc}

0001dcf0 <.text_47>:
   1dcf0:	0000f01f 	.word	0x0000f01f

0001dcf4 <USBPD_PRL_PrepareExtendedTxChunkSending>:
   1dcf4:	b570      	push	{r4, r5, r6, lr}
   1dcf6:	4c2d      	ldr	r4, [pc, #180]	; (1ddac <.text_51>)
   1dcf8:	0080      	lsls	r0, r0, #2
   1dcfa:	5820      	ldr	r0, [r4, r0]
   1dcfc:	2480      	movs	r4, #128	; 0x80
   1dcfe:	0224      	lsls	r4, r4, #8
   1dd00:	8cc5      	ldrh	r5, [r0, #38]	; 0x26
   1dd02:	4e2c      	ldr	r6, [pc, #176]	; (1ddb4 <.text_53>)
   1dd04:	402e      	ands	r6, r5
   1dd06:	02c9      	lsls	r1, r1, #11
   1dd08:	4331      	orrs	r1, r6
   1dd0a:	25fe      	movs	r5, #254	; 0xfe
   1dd0c:	022d      	lsls	r5, r5, #8
   1dd0e:	400d      	ands	r5, r1
   1dd10:	05d1      	lsls	r1, r2, #23
   1dd12:	0dc9      	lsrs	r1, r1, #23
   1dd14:	4329      	orrs	r1, r5
   1dd16:	4321      	orrs	r1, r4
   1dd18:	84c1      	strh	r1, [r0, #38]	; 0x26
   1dd1a:	8b81      	ldrh	r1, [r0, #28]
   1dd1c:	430c      	orrs	r4, r1
   1dd1e:	8384      	strh	r4, [r0, #28]
   1dd20:	4a23      	ldr	r2, [pc, #140]	; (1ddb0 <.text_52>)
   1dd22:	4022      	ands	r2, r4
   1dd24:	212a      	movs	r1, #42	; 0x2a
   1dd26:	5c41      	ldrb	r1, [r0, r1]
   1dd28:	06c9      	lsls	r1, r1, #27
   1dd2a:	0ec9      	lsrs	r1, r1, #27
   1dd2c:	4311      	orrs	r1, r2
   1dd2e:	8381      	strh	r1, [r0, #28]
   1dd30:	7019      	strb	r1, [r3, #0]
   1dd32:	8b81      	ldrh	r1, [r0, #28]
   1dd34:	0a09      	lsrs	r1, r1, #8
   1dd36:	7059      	strb	r1, [r3, #1]
   1dd38:	8cc1      	ldrh	r1, [r0, #38]	; 0x26
   1dd3a:	7099      	strb	r1, [r3, #2]
   1dd3c:	8cc0      	ldrh	r0, [r0, #38]	; 0x26
   1dd3e:	0a00      	lsrs	r0, r0, #8
   1dd40:	70d8      	strb	r0, [r3, #3]
   1dd42:	bd70      	pop	{r4, r5, r6, pc}

0001dd44 <.text_49>:
   1dd44:	0002ff74 	.word	0x0002ff74

0001dd48 <USBPD_PRL_PrepareChunkRequest>:
   1dd48:	b510      	push	{r4, lr}
   1dd4a:	4a18      	ldr	r2, [pc, #96]	; (1ddac <.text_51>)
   1dd4c:	0080      	lsls	r0, r0, #2
   1dd4e:	5810      	ldr	r0, [r2, r0]
   1dd50:	8cc3      	ldrh	r3, [r0, #38]	; 0x26
   1dd52:	2284      	movs	r2, #132	; 0x84
   1dd54:	0212      	lsls	r2, r2, #8
   1dd56:	431a      	orrs	r2, r3
   1dd58:	84c2      	strh	r2, [r0, #38]	; 0x26
   1dd5a:	2386      	movs	r3, #134	; 0x86
   1dd5c:	021b      	lsls	r3, r3, #8
   1dd5e:	4013      	ands	r3, r2
   1dd60:	8d02      	ldrh	r2, [r0, #40]	; 0x28
   1dd62:	0ad2      	lsrs	r2, r2, #11
   1dd64:	1c52      	adds	r2, r2, #1
   1dd66:	02d2      	lsls	r2, r2, #11
   1dd68:	24f0      	movs	r4, #240	; 0xf0
   1dd6a:	01e4      	lsls	r4, r4, #7
   1dd6c:	4014      	ands	r4, r2
   1dd6e:	431c      	orrs	r4, r3
   1dd70:	84c4      	strh	r4, [r0, #38]	; 0x26
   1dd72:	8b83      	ldrh	r3, [r0, #28]
   1dd74:	2280      	movs	r2, #128	; 0x80
   1dd76:	0212      	lsls	r2, r2, #8
   1dd78:	431a      	orrs	r2, r3
   1dd7a:	8382      	strh	r2, [r0, #28]
   1dd7c:	4b0c      	ldr	r3, [pc, #48]	; (1ddb0 <.text_52>)
   1dd7e:	4013      	ands	r3, r2
   1dd80:	222a      	movs	r2, #42	; 0x2a
   1dd82:	5c82      	ldrb	r2, [r0, r2]
   1dd84:	06d2      	lsls	r2, r2, #27
   1dd86:	0ed2      	lsrs	r2, r2, #27
   1dd88:	431a      	orrs	r2, r3
   1dd8a:	8382      	strh	r2, [r0, #28]
   1dd8c:	2306      	movs	r3, #6
   1dd8e:	7103      	strb	r3, [r0, #4]
   1dd90:	700a      	strb	r2, [r1, #0]
   1dd92:	8b82      	ldrh	r2, [r0, #28]
   1dd94:	0a12      	lsrs	r2, r2, #8
   1dd96:	704a      	strb	r2, [r1, #1]
   1dd98:	8cc2      	ldrh	r2, [r0, #38]	; 0x26
   1dd9a:	708a      	strb	r2, [r1, #2]
   1dd9c:	8cc0      	ldrh	r0, [r0, #38]	; 0x26
   1dd9e:	0a00      	lsrs	r0, r0, #8
   1dda0:	70c8      	strb	r0, [r1, #3]
   1dda2:	2000      	movs	r0, #0
   1dda4:	7108      	strb	r0, [r1, #4]
   1dda6:	7148      	strb	r0, [r1, #5]
   1dda8:	bd10      	pop	{r4, pc}
	...

0001ddac <.text_51>:
   1ddac:	000320ec 	.word	0x000320ec

0001ddb0 <.text_52>:
   1ddb0:	0000ffe0 	.word	0x0000ffe0

0001ddb4 <.text_53>:
   1ddb4:	000083ff 	.word	0x000083ff

0001ddb8 <.text_54>:
   1ddb8:	00000000 	.word	0x00000000

0001ddbc <USBPD_TCPM_HWInit>:
   1ddbc:	b5f3      	push	{r0, r1, r4, r5, r6, r7, lr}
   1ddbe:	b081      	sub	sp, #4
   1ddc0:	0004      	movs	r4, r0
   1ddc2:	0015      	movs	r5, r2
   1ddc4:	001e      	movs	r6, r3
   1ddc6:	2808      	cmp	r0, #8
   1ddc8:	d23d      	bcs.n	1de46 <USBPD_TCPM_HWInit+0x8a>
   1ddca:	2024      	movs	r0, #36	; 0x24
   1ddcc:	f000 fc58 	bl	1e680 <malloc>
   1ddd0:	4953      	ldr	r1, [pc, #332]	; (1df20 <.text_11>)
   1ddd2:	00a2      	lsls	r2, r4, #2
   1ddd4:	188c      	adds	r4, r1, r2
   1ddd6:	6060      	str	r0, [r4, #4]
   1ddd8:	2800      	cmp	r0, #0
   1ddda:	d101      	bne.n	1dde0 <USBPD_TCPM_HWInit+0x24>
   1dddc:	2016      	movs	r0, #22
   1ddde:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   1dde0:	9f08      	ldr	r7, [sp, #32]
   1dde2:	9600      	str	r6, [sp, #0]
   1dde4:	002e      	movs	r6, r5
   1dde6:	460d      	mov	r5, r1
   1dde8:	2124      	movs	r1, #36	; 0x24
   1ddea:	f000 fc15 	bl	1e618 <__aeabi_memclr>
   1ddee:	7828      	ldrb	r0, [r5, #0]
   1ddf0:	1c40      	adds	r0, r0, #1
   1ddf2:	7028      	strb	r0, [r5, #0]
   1ddf4:	6860      	ldr	r0, [r4, #4]
   1ddf6:	494b      	ldr	r1, [pc, #300]	; (1df24 <.text_12>)
   1ddf8:	6101      	str	r1, [r0, #16]
   1ddfa:	4669      	mov	r1, sp
   1ddfc:	7a09      	ldrb	r1, [r1, #8]
   1ddfe:	2220      	movs	r2, #32
   1de00:	5481      	strb	r1, [r0, r2]
   1de02:	6860      	ldr	r0, [r4, #4]
   1de04:	9900      	ldr	r1, [sp, #0]
   1de06:	6181      	str	r1, [r0, #24]
   1de08:	61c6      	str	r6, [r0, #28]
   1de0a:	6147      	str	r7, [r0, #20]
   1de0c:	4846      	ldr	r0, [pc, #280]	; (1df28 <.text_13>)
   1de0e:	4947      	ldr	r1, [pc, #284]	; (1df2c <.text_14>)
   1de10:	2201      	movs	r2, #1
   1de12:	4b47      	ldr	r3, [pc, #284]	; (1df30 <.text_15>)
   1de14:	4c47      	ldr	r4, [pc, #284]	; (1df34 <.text_16>)
   1de16:	6825      	ldr	r5, [r4, #0]
   1de18:	401d      	ands	r5, r3
   1de1a:	4e47      	ldr	r6, [pc, #284]	; (1df38 <.text_17>)
   1de1c:	42b5      	cmp	r5, r6
   1de1e:	d004      	beq.n	1de2a <USBPD_TCPM_HWInit+0x6e>
   1de20:	6824      	ldr	r4, [r4, #0]
   1de22:	4023      	ands	r3, r4
   1de24:	4c45      	ldr	r4, [pc, #276]	; (1df3c <.text_18>)
   1de26:	42a3      	cmp	r3, r4
   1de28:	d10f      	bne.n	1de4a <USBPD_TCPM_HWInit+0x8e>
   1de2a:	4b45      	ldr	r3, [pc, #276]	; (1df40 <.text_19>)
   1de2c:	681b      	ldr	r3, [r3, #0]
   1de2e:	2b00      	cmp	r3, #0
   1de30:	d10b      	bne.n	1de4a <USBPD_TCPM_HWInit+0x8e>
   1de32:	4b44      	ldr	r3, [pc, #272]	; (1df44 <.text_20>)
   1de34:	681b      	ldr	r3, [r3, #0]
   1de36:	051b      	lsls	r3, r3, #20
   1de38:	0d1b      	lsrs	r3, r3, #20
   1de3a:	248a      	movs	r4, #138	; 0x8a
   1de3c:	00e4      	lsls	r4, r4, #3
   1de3e:	42a3      	cmp	r3, r4
   1de40:	d103      	bne.n	1de4a <USBPD_TCPM_HWInit+0x8e>
   1de42:	4b41      	ldr	r3, [pc, #260]	; (1df48 <.text_21>)
   1de44:	e002      	b.n	1de4c <USBPD_TCPM_HWInit+0x90>
   1de46:	2002      	movs	r0, #2
   1de48:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   1de4a:	4b40      	ldr	r3, [pc, #256]	; (1df4c <.text_22>)
   1de4c:	689c      	ldr	r4, [r3, #8]
   1de4e:	609a      	str	r2, [r3, #8]
   1de50:	689d      	ldr	r5, [r3, #8]
   1de52:	2d01      	cmp	r5, #1
   1de54:	d0fc      	beq.n	1de50 <USBPD_TCPM_HWInit+0x94>
   1de56:	6019      	str	r1, [r3, #0]
   1de58:	6819      	ldr	r1, [r3, #0]
   1de5a:	6001      	str	r1, [r0, #0]
   1de5c:	609c      	str	r4, [r3, #8]
   1de5e:	6898      	ldr	r0, [r3, #8]
   1de60:	4302      	orrs	r2, r0
   1de62:	609a      	str	r2, [r3, #8]
   1de64:	2000      	movs	r0, #0
   1de66:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

0001de68 <USBPD_TCPM_set_cc>:
   1de68:	b510      	push	{r4, lr}
   1de6a:	4b2d      	ldr	r3, [pc, #180]	; (1df20 <.text_11>)
   1de6c:	0084      	lsls	r4, r0, #2
   1de6e:	191b      	adds	r3, r3, r4
   1de70:	685b      	ldr	r3, [r3, #4]
   1de72:	695b      	ldr	r3, [r3, #20]
   1de74:	69db      	ldr	r3, [r3, #28]
   1de76:	4798      	blx	r3
   1de78:	bd10      	pop	{r4, pc}

0001de7a <USBPD_TCPM_VBUS_GetVoltage>:
   1de7a:	b538      	push	{r3, r4, r5, lr}
   1de7c:	2400      	movs	r4, #0
   1de7e:	4669      	mov	r1, sp
   1de80:	804c      	strh	r4, [r1, #2]
   1de82:	466a      	mov	r2, sp
   1de84:	7014      	strb	r4, [r2, #0]
   1de86:	1c92      	adds	r2, r2, #2
   1de88:	4b25      	ldr	r3, [pc, #148]	; (1df20 <.text_11>)
   1de8a:	0085      	lsls	r5, r0, #2
   1de8c:	195b      	adds	r3, r3, r5
   1de8e:	685b      	ldr	r3, [r3, #4]
   1de90:	695b      	ldr	r3, [r3, #20]
   1de92:	695b      	ldr	r3, [r3, #20]
   1de94:	4798      	blx	r3
   1de96:	4668      	mov	r0, sp
   1de98:	7800      	ldrb	r0, [r0, #0]
   1de9a:	2800      	cmp	r0, #0
   1de9c:	d101      	bne.n	1dea2 <USBPD_TCPM_VBUS_GetVoltage+0x28>
   1de9e:	4668      	mov	r0, sp
   1dea0:	8044      	strh	r4, [r0, #2]
   1dea2:	4668      	mov	r0, sp
   1dea4:	8840      	ldrh	r0, [r0, #2]
   1dea6:	bd32      	pop	{r1, r4, r5, pc}

0001dea8 <USBPD_TCPM_VBUS_IsVsafe0V>:
   1dea8:	b57c      	push	{r2, r3, r4, r5, r6, lr}
   1deaa:	2400      	movs	r4, #0
   1deac:	4669      	mov	r1, sp
   1deae:	804c      	strh	r4, [r1, #2]
   1deb0:	2502      	movs	r5, #2
   1deb2:	466a      	mov	r2, sp
   1deb4:	7014      	strb	r4, [r2, #0]
   1deb6:	1c92      	adds	r2, r2, #2
   1deb8:	4b19      	ldr	r3, [pc, #100]	; (1df20 <.text_11>)
   1deba:	0086      	lsls	r6, r0, #2
   1debc:	199b      	adds	r3, r3, r6
   1debe:	685b      	ldr	r3, [r3, #4]
   1dec0:	695b      	ldr	r3, [r3, #20]
   1dec2:	695b      	ldr	r3, [r3, #20]
   1dec4:	4798      	blx	r3
   1dec6:	4668      	mov	r0, sp
   1dec8:	8840      	ldrh	r0, [r0, #2]
   1deca:	21c8      	movs	r1, #200	; 0xc8
   1decc:	0089      	lsls	r1, r1, #2
   1dece:	4288      	cmp	r0, r1
   1ded0:	da00      	bge.n	1ded4 <USBPD_TCPM_VBUS_IsVsafe0V+0x2c>
   1ded2:	2500      	movs	r5, #0
   1ded4:	0028      	movs	r0, r5
   1ded6:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

0001ded8 <USBPD_TCPM_VBUS_IsVsafe5V>:
   1ded8:	b57c      	push	{r2, r3, r4, r5, r6, lr}
   1deda:	2400      	movs	r4, #0
   1dedc:	4669      	mov	r1, sp
   1dede:	804c      	strh	r4, [r1, #2]
   1dee0:	2502      	movs	r5, #2
   1dee2:	466a      	mov	r2, sp
   1dee4:	7014      	strb	r4, [r2, #0]
   1dee6:	1c92      	adds	r2, r2, #2
   1dee8:	4b0d      	ldr	r3, [pc, #52]	; (1df20 <.text_11>)
   1deea:	0086      	lsls	r6, r0, #2
   1deec:	199b      	adds	r3, r3, r6
   1deee:	685b      	ldr	r3, [r3, #4]
   1def0:	695b      	ldr	r3, [r3, #20]
   1def2:	695b      	ldr	r3, [r3, #20]
   1def4:	4798      	blx	r3
   1def6:	4668      	mov	r0, sp
   1def8:	7800      	ldrb	r0, [r0, #0]
   1defa:	2801      	cmp	r0, #1
   1defc:	d100      	bne.n	1df00 <USBPD_TCPM_VBUS_IsVsafe5V+0x28>
   1defe:	2500      	movs	r5, #0
   1df00:	0028      	movs	r0, r5
   1df02:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

0001df04 <USBPD_TCPM_VBUS_Enable>:
   1df04:	b580      	push	{r7, lr}
   1df06:	2101      	movs	r1, #1
   1df08:	e001      	b.n	1df0e <.text_10>

0001df0a <USBPD_TCPM_VBUS_Disable>:
   1df0a:	b580      	push	{r7, lr}
   1df0c:	2100      	movs	r1, #0

0001df0e <.text_10>:
   1df0e:	4a04      	ldr	r2, [pc, #16]	; (1df20 <.text_11>)
   1df10:	0083      	lsls	r3, r0, #2
   1df12:	18d2      	adds	r2, r2, r3
   1df14:	6852      	ldr	r2, [r2, #4]
   1df16:	6952      	ldr	r2, [r2, #20]
   1df18:	6992      	ldr	r2, [r2, #24]
   1df1a:	4790      	blx	r2
   1df1c:	bd02      	pop	{r1, pc}
	...

0001df20 <.text_11>:
   1df20:	0003210c 	.word	0x0003210c

0001df24 <.text_12>:
   1df24:	0001e5d5 	.word	0x0001e5d5

0001df28 <.text_13>:
   1df28:	0002ff78 	.word	0x0002ff78

0001df2c <.text_14>:
   1df2c:	f407a5c2 	.word	0xf407a5c2

0001df30 <.text_15>:
   1df30:	0000fff0 	.word	0x0000fff0

0001df34 <.text_16>:
   1df34:	e000ed00 	.word	0xe000ed00

0001df38 <.text_17>:
   1df38:	0000c240 	.word	0x0000c240

0001df3c <.text_18>:
   1df3c:	0000c270 	.word	0x0000c270

0001df40 <.text_19>:
   1df40:	e0042000 	.word	0xe0042000

0001df44 <.text_20>:
   1df44:	5c001000 	.word	0x5c001000

0001df48 <.text_21>:
   1df48:	58024c00 	.word	0x58024c00

0001df4c <.text_22>:
   1df4c:	40023000 	.word	0x40023000

0001df50 <USBPD_TCPM_alert>:
   1df50:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
   1df52:	2100      	movs	r1, #0
   1df54:	2700      	movs	r7, #0
   1df56:	466a      	mov	r2, sp
   1df58:	8091      	strh	r1, [r2, #4]
   1df5a:	b2c1      	uxtb	r1, r0
   1df5c:	9102      	str	r1, [sp, #8]
   1df5e:	0404      	lsls	r4, r0, #16
   1df60:	0e24      	lsrs	r4, r4, #24
   1df62:	48c7      	ldr	r0, [pc, #796]	; (1e280 <.text_30>)
   1df64:	00a1      	lsls	r1, r4, #2
   1df66:	1845      	adds	r5, r0, r1
   1df68:	2601      	movs	r6, #1
   1df6a:	9802      	ldr	r0, [sp, #8]
   1df6c:	2802      	cmp	r0, #2
   1df6e:	d100      	bne.n	1df72 <USBPD_TCPM_alert+0x22>
   1df70:	e0fd      	b.n	1e16e <USBPD_TCPM_alert+0x21e>
   1df72:	a901      	add	r1, sp, #4
   1df74:	0020      	movs	r0, r4
   1df76:	686a      	ldr	r2, [r5, #4]
   1df78:	6952      	ldr	r2, [r2, #20]
   1df7a:	6b92      	ldr	r2, [r2, #56]	; 0x38
   1df7c:	4790      	blx	r2
   1df7e:	2800      	cmp	r0, #0
   1df80:	d000      	beq.n	1df84 <USBPD_TCPM_alert+0x34>
   1df82:	e0f9      	b.n	1e178 <USBPD_TCPM_alert+0x228>
   1df84:	4668      	mov	r0, sp
   1df86:	8880      	ldrh	r0, [r0, #4]
   1df88:	0700      	lsls	r0, r0, #28
   1df8a:	d529      	bpl.n	1dfe0 <USBPD_TCPM_alert+0x90>
   1df8c:	2074      	movs	r0, #116	; 0x74
   1df8e:	4669      	mov	r1, sp
   1df90:	80c8      	strh	r0, [r1, #6]
   1df92:	2105      	movs	r1, #5
   1df94:	0020      	movs	r0, r4
   1df96:	686a      	ldr	r2, [r5, #4]
   1df98:	6892      	ldr	r2, [r2, #8]
   1df9a:	6852      	ldr	r2, [r2, #4]
   1df9c:	4790      	blx	r2
   1df9e:	2000      	movs	r0, #0
   1dfa0:	6869      	ldr	r1, [r5, #4]
   1dfa2:	2221      	movs	r2, #33	; 0x21
   1dfa4:	5488      	strb	r0, [r1, r2]
   1dfa6:	6868      	ldr	r0, [r5, #4]
   1dfa8:	69c1      	ldr	r1, [r0, #28]
   1dfaa:	6809      	ldr	r1, [r1, #0]
   1dfac:	0889      	lsrs	r1, r1, #2
   1dfae:	4031      	ands	r1, r6
   1dfb0:	d100      	bne.n	1dfb4 <USBPD_TCPM_alert+0x64>
   1dfb2:	2102      	movs	r1, #2
   1dfb4:	2202      	movs	r2, #2
   1dfb6:	9200      	str	r2, [sp, #0]
   1dfb8:	6803      	ldr	r3, [r0, #0]
   1dfba:	2201      	movs	r2, #1
   1dfbc:	0020      	movs	r0, r4
   1dfbe:	f000 f973 	bl	1e2a8 <USBPD_TCPM_set_rx_state>
   1dfc2:	2800      	cmp	r0, #0
   1dfc4:	d002      	beq.n	1dfcc <USBPD_TCPM_alert+0x7c>
   1dfc6:	0020      	movs	r0, r4
   1dfc8:	f000 fab6 	bl	1e538 <TCPM_Disconnect>
   1dfcc:	a901      	add	r1, sp, #4
   1dfce:	1c89      	adds	r1, r1, #2
   1dfd0:	0020      	movs	r0, r4
   1dfd2:	686a      	ldr	r2, [r5, #4]
   1dfd4:	6952      	ldr	r2, [r2, #20]
   1dfd6:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
   1dfd8:	4790      	blx	r2
   1dfda:	2000      	movs	r0, #0
   1dfdc:	4669      	mov	r1, sp
   1dfde:	8088      	strh	r0, [r1, #4]
   1dfe0:	2070      	movs	r0, #112	; 0x70
   1dfe2:	4669      	mov	r1, sp
   1dfe4:	8889      	ldrh	r1, [r1, #4]
   1dfe6:	4201      	tst	r1, r0
   1dfe8:	d03a      	beq.n	1e060 <USBPD_TCPM_alert+0x110>
   1dfea:	4669      	mov	r1, sp
   1dfec:	80c8      	strh	r0, [r1, #6]
   1dfee:	4668      	mov	r0, sp
   1dff0:	8880      	ldrh	r0, [r0, #4]
   1dff2:	0640      	lsls	r0, r0, #25
   1dff4:	d501      	bpl.n	1dffa <USBPD_TCPM_alert+0xaa>
   1dff6:	2100      	movs	r1, #0
   1dff8:	e006      	b.n	1e008 <USBPD_TCPM_alert+0xb8>
   1dffa:	4668      	mov	r0, sp
   1dffc:	8880      	ldrh	r0, [r0, #4]
   1dffe:	0680      	lsls	r0, r0, #26
   1e000:	d501      	bpl.n	1e006 <USBPD_TCPM_alert+0xb6>
   1e002:	2101      	movs	r1, #1
   1e004:	e000      	b.n	1e008 <USBPD_TCPM_alert+0xb8>
   1e006:	2102      	movs	r1, #2
   1e008:	0020      	movs	r0, r4
   1e00a:	686a      	ldr	r2, [r5, #4]
   1e00c:	6892      	ldr	r2, [r2, #8]
   1e00e:	6912      	ldr	r2, [r2, #16]
   1e010:	4790      	blx	r2
   1e012:	2000      	movs	r0, #0
   1e014:	686a      	ldr	r2, [r5, #4]
   1e016:	7390      	strb	r0, [r2, #14]
   1e018:	4669      	mov	r1, sp
   1e01a:	8889      	ldrh	r1, [r1, #4]
   1e01c:	2250      	movs	r2, #80	; 0x50
   1e01e:	400a      	ands	r2, r1
   1e020:	2a50      	cmp	r2, #80	; 0x50
   1e022:	d114      	bne.n	1e04e <USBPD_TCPM_alert+0xfe>
   1e024:	6869      	ldr	r1, [r5, #4]
   1e026:	2221      	movs	r2, #33	; 0x21
   1e028:	5488      	strb	r0, [r1, r2]
   1e02a:	6868      	ldr	r0, [r5, #4]
   1e02c:	69c1      	ldr	r1, [r0, #28]
   1e02e:	6809      	ldr	r1, [r1, #0]
   1e030:	0889      	lsrs	r1, r1, #2
   1e032:	4031      	ands	r1, r6
   1e034:	d100      	bne.n	1e038 <USBPD_TCPM_alert+0xe8>
   1e036:	2102      	movs	r1, #2
   1e038:	2201      	movs	r2, #1
   1e03a:	9200      	str	r2, [sp, #0]
   1e03c:	6803      	ldr	r3, [r0, #0]
   1e03e:	0020      	movs	r0, r4
   1e040:	f000 f932 	bl	1e2a8 <USBPD_TCPM_set_rx_state>
   1e044:	2800      	cmp	r0, #0
   1e046:	d002      	beq.n	1e04e <USBPD_TCPM_alert+0xfe>
   1e048:	0020      	movs	r0, r4
   1e04a:	f000 fa75 	bl	1e538 <TCPM_Disconnect>
   1e04e:	6868      	ldr	r0, [r5, #4]
   1e050:	6940      	ldr	r0, [r0, #20]
   1e052:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
   1e054:	2a00      	cmp	r2, #0
   1e056:	d003      	beq.n	1e060 <USBPD_TCPM_alert+0x110>
   1e058:	a901      	add	r1, sp, #4
   1e05a:	1c89      	adds	r1, r1, #2
   1e05c:	0020      	movs	r0, r4
   1e05e:	4790      	blx	r2
   1e060:	4668      	mov	r0, sp
   1e062:	8880      	ldrh	r0, [r0, #4]
   1e064:	0740      	lsls	r0, r0, #29
   1e066:	d51e      	bpl.n	1e0a6 <USBPD_TCPM_alert+0x156>
   1e068:	2004      	movs	r0, #4
   1e06a:	4669      	mov	r1, sp
   1e06c:	8048      	strh	r0, [r1, #2]
   1e06e:	6868      	ldr	r0, [r5, #4]
   1e070:	2121      	movs	r1, #33	; 0x21
   1e072:	5c41      	ldrb	r1, [r0, r1]
   1e074:	2900      	cmp	r1, #0
   1e076:	d10d      	bne.n	1e094 <USBPD_TCPM_alert+0x144>
   1e078:	466a      	mov	r2, sp
   1e07a:	6841      	ldr	r1, [r0, #4]
   1e07c:	0020      	movs	r0, r4
   1e07e:	f000 f91e 	bl	1e2be <USBPD_TCPM_get_message>
   1e082:	2800      	cmp	r0, #0
   1e084:	d178      	bne.n	1e178 <USBPD_TCPM_alert+0x228>
   1e086:	4668      	mov	r0, sp
   1e088:	7801      	ldrb	r1, [r0, #0]
   1e08a:	0020      	movs	r0, r4
   1e08c:	686a      	ldr	r2, [r5, #4]
   1e08e:	6892      	ldr	r2, [r2, #8]
   1e090:	6812      	ldr	r2, [r2, #0]
   1e092:	4790      	blx	r2
   1e094:	6868      	ldr	r0, [r5, #4]
   1e096:	6940      	ldr	r0, [r0, #20]
   1e098:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
   1e09a:	2a00      	cmp	r2, #0
   1e09c:	d003      	beq.n	1e0a6 <USBPD_TCPM_alert+0x156>
   1e09e:	a900      	add	r1, sp, #0
   1e0a0:	1c89      	adds	r1, r1, #2
   1e0a2:	0020      	movs	r0, r4
   1e0a4:	4790      	blx	r2
   1e0a6:	4668      	mov	r0, sp
   1e0a8:	8880      	ldrh	r0, [r0, #4]
   1e0aa:	0500      	lsls	r0, r0, #20
   1e0ac:	d514      	bpl.n	1e0d8 <USBPD_TCPM_alert+0x188>
   1e0ae:	6868      	ldr	r0, [r5, #4]
   1e0b0:	69c0      	ldr	r0, [r0, #28]
   1e0b2:	6800      	ldr	r0, [r0, #0]
   1e0b4:	0880      	lsrs	r0, r0, #2
   1e0b6:	4030      	ands	r0, r6
   1e0b8:	d001      	beq.n	1e0be <USBPD_TCPM_alert+0x16e>
   1e0ba:	2101      	movs	r1, #1
   1e0bc:	e000      	b.n	1e0c0 <USBPD_TCPM_alert+0x170>
   1e0be:	2102      	movs	r1, #2
   1e0c0:	2000      	movs	r0, #0
   1e0c2:	9000      	str	r0, [sp, #0]
   1e0c4:	2300      	movs	r3, #0
   1e0c6:	2200      	movs	r2, #0
   1e0c8:	0020      	movs	r0, r4
   1e0ca:	f000 f8ed 	bl	1e2a8 <USBPD_TCPM_set_rx_state>
   1e0ce:	2800      	cmp	r0, #0
   1e0d0:	d152      	bne.n	1e178 <USBPD_TCPM_alert+0x228>
   1e0d2:	0020      	movs	r0, r4
   1e0d4:	f000 fa30 	bl	1e538 <TCPM_Disconnect>
   1e0d8:	4668      	mov	r0, sp
   1e0da:	8880      	ldrh	r0, [r0, #4]
   1e0dc:	0780      	lsls	r0, r0, #30
   1e0de:	d537      	bpl.n	1e150 <USBPD_TCPM_alert+0x200>
   1e0e0:	2000      	movs	r0, #0
   1e0e2:	4669      	mov	r1, sp
   1e0e4:	7188      	strb	r0, [r1, #6]
   1e0e6:	a901      	add	r1, sp, #4
   1e0e8:	1c89      	adds	r1, r1, #2
   1e0ea:	0020      	movs	r0, r4
   1e0ec:	686a      	ldr	r2, [r5, #4]
   1e0ee:	6952      	ldr	r2, [r2, #20]
   1e0f0:	6892      	ldr	r2, [r2, #8]
   1e0f2:	4790      	blx	r2
   1e0f4:	686a      	ldr	r2, [r5, #4]
   1e0f6:	4668      	mov	r0, sp
   1e0f8:	7980      	ldrb	r0, [r0, #6]
   1e0fa:	0740      	lsls	r0, r0, #29
   1e0fc:	d41a      	bmi.n	1e134 <USBPD_TCPM_alert+0x1e4>
   1e0fe:	0020      	movs	r0, r4
   1e100:	6911      	ldr	r1, [r2, #16]
   1e102:	4788      	blx	r1
   1e104:	2800      	cmp	r0, #0
   1e106:	d123      	bne.n	1e150 <USBPD_TCPM_alert+0x200>
   1e108:	6868      	ldr	r0, [r5, #4]
   1e10a:	69c0      	ldr	r0, [r0, #28]
   1e10c:	6800      	ldr	r0, [r0, #0]
   1e10e:	0880      	lsrs	r0, r0, #2
   1e110:	4030      	ands	r0, r6
   1e112:	d001      	beq.n	1e118 <USBPD_TCPM_alert+0x1c8>
   1e114:	2101      	movs	r1, #1
   1e116:	e000      	b.n	1e11a <USBPD_TCPM_alert+0x1ca>
   1e118:	2102      	movs	r1, #2
   1e11a:	2000      	movs	r0, #0
   1e11c:	9000      	str	r0, [sp, #0]
   1e11e:	2300      	movs	r3, #0
   1e120:	2200      	movs	r2, #0
   1e122:	0020      	movs	r0, r4
   1e124:	f000 f8c0 	bl	1e2a8 <USBPD_TCPM_set_rx_state>
   1e128:	2800      	cmp	r0, #0
   1e12a:	d15a      	bne.n	1e1e2 <USBPD_TCPM_alert+0x292>
   1e12c:	0020      	movs	r0, r4
   1e12e:	f000 fa03 	bl	1e538 <TCPM_Disconnect>
   1e132:	e00d      	b.n	1e150 <USBPD_TCPM_alert+0x200>
   1e134:	69d0      	ldr	r0, [r2, #28]
   1e136:	6800      	ldr	r0, [r0, #0]
   1e138:	0880      	lsrs	r0, r0, #2
   1e13a:	4030      	ands	r0, r6
   1e13c:	d001      	beq.n	1e142 <USBPD_TCPM_alert+0x1f2>
   1e13e:	2101      	movs	r1, #1
   1e140:	e000      	b.n	1e144 <USBPD_TCPM_alert+0x1f4>
   1e142:	2102      	movs	r1, #2
   1e144:	9600      	str	r6, [sp, #0]
   1e146:	6813      	ldr	r3, [r2, #0]
   1e148:	2201      	movs	r2, #1
   1e14a:	0020      	movs	r0, r4
   1e14c:	f000 f8ac 	bl	1e2a8 <USBPD_TCPM_set_rx_state>
   1e150:	4668      	mov	r0, sp
   1e152:	8880      	ldrh	r0, [r0, #4]
   1e154:	07c0      	lsls	r0, r0, #31
   1e156:	d404      	bmi.n	1e162 <USBPD_TCPM_alert+0x212>
   1e158:	9802      	ldr	r0, [sp, #8]
   1e15a:	2801      	cmp	r0, #1
   1e15c:	d001      	beq.n	1e162 <USBPD_TCPM_alert+0x212>
   1e15e:	2802      	cmp	r0, #2
   1e160:	d110      	bne.n	1e184 <USBPD_TCPM_alert+0x234>
   1e162:	0020      	movs	r0, r4
   1e164:	6869      	ldr	r1, [r5, #4]
   1e166:	6909      	ldr	r1, [r1, #16]
   1e168:	4788      	blx	r1
   1e16a:	2800      	cmp	r0, #0
   1e16c:	d10a      	bne.n	1e184 <USBPD_TCPM_alert+0x234>
   1e16e:	0020      	movs	r0, r4
   1e170:	f000 f93c 	bl	1e3ec <TCPM_CheckConnection>
   1e174:	2810      	cmp	r0, #16
   1e176:	d101      	bne.n	1e17c <USBPD_TCPM_alert+0x22c>
   1e178:	2710      	movs	r7, #16
   1e17a:	e032      	b.n	1e1e2 <USBPD_TCPM_alert+0x292>
   1e17c:	6868      	ldr	r0, [r5, #4]
   1e17e:	7b40      	ldrb	r0, [r0, #13]
   1e180:	2800      	cmp	r0, #0
   1e182:	d02e      	beq.n	1e1e2 <USBPD_TCPM_alert+0x292>
   1e184:	4668      	mov	r0, sp
   1e186:	8880      	ldrh	r0, [r0, #4]
   1e188:	0580      	lsls	r0, r0, #22
   1e18a:	d52a      	bpl.n	1e1e2 <USBPD_TCPM_alert+0x292>
   1e18c:	2000      	movs	r0, #0
   1e18e:	4669      	mov	r1, sp
   1e190:	7188      	strb	r0, [r1, #6]
   1e192:	a901      	add	r1, sp, #4
   1e194:	1c89      	adds	r1, r1, #2
   1e196:	0020      	movs	r0, r4
   1e198:	686a      	ldr	r2, [r5, #4]
   1e19a:	6952      	ldr	r2, [r2, #20]
   1e19c:	68d2      	ldr	r2, [r2, #12]
   1e19e:	4790      	blx	r2
   1e1a0:	4668      	mov	r0, sp
   1e1a2:	7980      	ldrb	r0, [r0, #6]
   1e1a4:	07c0      	lsls	r0, r0, #31
   1e1a6:	d505      	bpl.n	1e1b4 <USBPD_TCPM_alert+0x264>
   1e1a8:	2100      	movs	r1, #0
   1e1aa:	0020      	movs	r0, r4
   1e1ac:	686a      	ldr	r2, [r5, #4]
   1e1ae:	6952      	ldr	r2, [r2, #20]
   1e1b0:	6912      	ldr	r2, [r2, #16]
   1e1b2:	4790      	blx	r2
   1e1b4:	4668      	mov	r0, sp
   1e1b6:	7980      	ldrb	r0, [r0, #6]
   1e1b8:	0600      	lsls	r0, r0, #24
   1e1ba:	d512      	bpl.n	1e1e2 <USBPD_TCPM_alert+0x292>
   1e1bc:	6868      	ldr	r0, [r5, #4]
   1e1be:	69c0      	ldr	r0, [r0, #28]
   1e1c0:	6800      	ldr	r0, [r0, #0]
   1e1c2:	0880      	lsrs	r0, r0, #2
   1e1c4:	4030      	ands	r0, r6
   1e1c6:	d001      	beq.n	1e1cc <USBPD_TCPM_alert+0x27c>
   1e1c8:	2101      	movs	r1, #1
   1e1ca:	e000      	b.n	1e1ce <USBPD_TCPM_alert+0x27e>
   1e1cc:	2102      	movs	r1, #2
   1e1ce:	2000      	movs	r0, #0
   1e1d0:	9000      	str	r0, [sp, #0]
   1e1d2:	2300      	movs	r3, #0
   1e1d4:	2200      	movs	r2, #0
   1e1d6:	0020      	movs	r0, r4
   1e1d8:	f000 f866 	bl	1e2a8 <USBPD_TCPM_set_rx_state>
   1e1dc:	0020      	movs	r0, r4
   1e1de:	f000 f9ab 	bl	1e538 <TCPM_Disconnect>
   1e1e2:	a901      	add	r1, sp, #4
   1e1e4:	0020      	movs	r0, r4
   1e1e6:	686a      	ldr	r2, [r5, #4]
   1e1e8:	6952      	ldr	r2, [r2, #20]
   1e1ea:	6b92      	ldr	r2, [r2, #56]	; 0x38
   1e1ec:	4790      	blx	r2
   1e1ee:	4668      	mov	r0, sp
   1e1f0:	8880      	ldrh	r0, [r0, #4]
   1e1f2:	2800      	cmp	r0, #0
   1e1f4:	d000      	beq.n	1e1f8 <USBPD_TCPM_alert+0x2a8>
   1e1f6:	e6c5      	b.n	1df84 <USBPD_TCPM_alert+0x34>
   1e1f8:	0038      	movs	r0, r7
   1e1fa:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

0001e1fc <USBPD_PHY_Init>:
   1e1fc:	b570      	push	{r4, r5, r6, lr}
   1e1fe:	4c20      	ldr	r4, [pc, #128]	; (1e280 <.text_30>)
   1e200:	0085      	lsls	r5, r0, #2
   1e202:	1964      	adds	r4, r4, r5
   1e204:	6866      	ldr	r6, [r4, #4]
   1e206:	7b35      	ldrb	r5, [r6, #12]
   1e208:	2d00      	cmp	r5, #0
   1e20a:	d10b      	bne.n	1e224 <USBPD_PHY_Init+0x28>
   1e20c:	9d04      	ldr	r5, [sp, #16]
   1e20e:	6072      	str	r2, [r6, #4]
   1e210:	60b1      	str	r1, [r6, #8]
   1e212:	2101      	movs	r1, #1
   1e214:	7331      	strb	r1, [r6, #12]
   1e216:	2100      	movs	r1, #0
   1e218:	6862      	ldr	r2, [r4, #4]
   1e21a:	7351      	strb	r1, [r2, #13]
   1e21c:	6862      	ldr	r2, [r4, #4]
   1e21e:	7391      	strb	r1, [r2, #14]
   1e220:	6861      	ldr	r1, [r4, #4]
   1e222:	600d      	str	r5, [r1, #0]
   1e224:	0019      	movs	r1, r3
   1e226:	6864      	ldr	r4, [r4, #4]
   1e228:	6923      	ldr	r3, [r4, #16]
   1e22a:	2220      	movs	r2, #32
   1e22c:	5ca2      	ldrb	r2, [r4, r2]
   1e22e:	6964      	ldr	r4, [r4, #20]
   1e230:	6824      	ldr	r4, [r4, #0]
   1e232:	47a0      	blx	r4
   1e234:	bd70      	pop	{r4, r5, r6, pc}

0001e236 <USBPD_PHY_Reset>:
   1e236:	4770      	bx	lr

0001e238 <USBPD_PHY_SOPSupported>:
   1e238:	b580      	push	{r7, lr}
   1e23a:	4a11      	ldr	r2, [pc, #68]	; (1e280 <.text_30>)
   1e23c:	0083      	lsls	r3, r0, #2
   1e23e:	18d2      	adds	r2, r2, r3
   1e240:	6852      	ldr	r2, [r2, #4]
   1e242:	6011      	str	r1, [r2, #0]
   1e244:	6952      	ldr	r2, [r2, #20]
   1e246:	6b12      	ldr	r2, [r2, #48]	; 0x30
   1e248:	4790      	blx	r2
   1e24a:	bd01      	pop	{r0, pc}

0001e24c <USBPD_TCPM_DeInit>:
   1e24c:	490c      	ldr	r1, [pc, #48]	; (1e280 <.text_30>)
   1e24e:	0080      	lsls	r0, r0, #2
   1e250:	1808      	adds	r0, r1, r0
   1e252:	6840      	ldr	r0, [r0, #4]
   1e254:	2100      	movs	r1, #0
   1e256:	7301      	strb	r1, [r0, #12]
   1e258:	4770      	bx	lr

0001e25a <USBPD_TCPM_get_cc>:
   1e25a:	b510      	push	{r4, lr}
   1e25c:	4b08      	ldr	r3, [pc, #32]	; (1e280 <.text_30>)
   1e25e:	0084      	lsls	r4, r0, #2
   1e260:	191b      	adds	r3, r3, r4
   1e262:	685b      	ldr	r3, [r3, #4]
   1e264:	695b      	ldr	r3, [r3, #20]
   1e266:	685b      	ldr	r3, [r3, #4]
   1e268:	4798      	blx	r3
   1e26a:	bd10      	pop	{r4, pc}

0001e26c <USBPD_TCPM_set_polarity>:
   1e26c:	b580      	push	{r7, lr}
   1e26e:	b2c9      	uxtb	r1, r1
   1e270:	4ab0      	ldr	r2, [pc, #704]	; (1e534 <.text_49>)
   1e272:	0083      	lsls	r3, r0, #2
   1e274:	18d2      	adds	r2, r2, r3
   1e276:	6852      	ldr	r2, [r2, #4]
   1e278:	6952      	ldr	r2, [r2, #20]
   1e27a:	6a12      	ldr	r2, [r2, #32]
   1e27c:	4790      	blx	r2
   1e27e:	bd02      	pop	{r1, pc}

0001e280 <.text_30>:
   1e280:	0003210c 	.word	0x0003210c

0001e284 <USBPD_TCPM_set_vconn>:
   1e284:	b580      	push	{r7, lr}
   1e286:	4aab      	ldr	r2, [pc, #684]	; (1e534 <.text_49>)
   1e288:	0083      	lsls	r3, r0, #2
   1e28a:	18d2      	adds	r2, r2, r3
   1e28c:	6852      	ldr	r2, [r2, #4]
   1e28e:	6952      	ldr	r2, [r2, #20]
   1e290:	6a52      	ldr	r2, [r2, #36]	; 0x24
   1e292:	4790      	blx	r2
   1e294:	bd02      	pop	{r1, pc}

0001e296 <USBPD_TCPM_set_msg_header>:
   1e296:	b538      	push	{r3, r4, r5, lr}
   1e298:	4ca6      	ldr	r4, [pc, #664]	; (1e534 <.text_49>)
   1e29a:	0085      	lsls	r5, r0, #2
   1e29c:	1964      	adds	r4, r4, r5
   1e29e:	6864      	ldr	r4, [r4, #4]
   1e2a0:	6964      	ldr	r4, [r4, #20]
   1e2a2:	6aa4      	ldr	r4, [r4, #40]	; 0x28
   1e2a4:	47a0      	blx	r4
   1e2a6:	bd32      	pop	{r1, r4, r5, pc}

0001e2a8 <USBPD_TCPM_set_rx_state>:
   1e2a8:	b538      	push	{r3, r4, r5, lr}
   1e2aa:	9c04      	ldr	r4, [sp, #16]
   1e2ac:	9400      	str	r4, [sp, #0]
   1e2ae:	4ca1      	ldr	r4, [pc, #644]	; (1e534 <.text_49>)
   1e2b0:	0085      	lsls	r5, r0, #2
   1e2b2:	1964      	adds	r4, r4, r5
   1e2b4:	6864      	ldr	r4, [r4, #4]
   1e2b6:	6964      	ldr	r4, [r4, #20]
   1e2b8:	6ae4      	ldr	r4, [r4, #44]	; 0x2c
   1e2ba:	47a0      	blx	r4
   1e2bc:	bd32      	pop	{r1, r4, r5, pc}

0001e2be <USBPD_TCPM_get_message>:
   1e2be:	b510      	push	{r4, lr}
   1e2c0:	4b9c      	ldr	r3, [pc, #624]	; (1e534 <.text_49>)
   1e2c2:	0084      	lsls	r4, r0, #2
   1e2c4:	191b      	adds	r3, r3, r4
   1e2c6:	685b      	ldr	r3, [r3, #4]
   1e2c8:	695b      	ldr	r3, [r3, #20]
   1e2ca:	6b5b      	ldr	r3, [r3, #52]	; 0x34
   1e2cc:	4798      	blx	r3
   1e2ce:	bd10      	pop	{r4, pc}

0001e2d0 <USBPD_TCPM_transmit>:
   1e2d0:	b538      	push	{r3, r4, r5, lr}
   1e2d2:	4c98      	ldr	r4, [pc, #608]	; (1e534 <.text_49>)
   1e2d4:	0085      	lsls	r5, r0, #2
   1e2d6:	1964      	adds	r4, r4, r5
   1e2d8:	2905      	cmp	r1, #5
   1e2da:	d008      	beq.n	1e2ee <USBPD_TCPM_transmit+0x1e>
   1e2dc:	2906      	cmp	r1, #6
   1e2de:	d006      	beq.n	1e2ee <USBPD_TCPM_transmit+0x1e>
   1e2e0:	9300      	str	r3, [sp, #0]
   1e2e2:	1c93      	adds	r3, r2, #2
   1e2e4:	7815      	ldrb	r5, [r2, #0]
   1e2e6:	7852      	ldrb	r2, [r2, #1]
   1e2e8:	0212      	lsls	r2, r2, #8
   1e2ea:	432a      	orrs	r2, r5
   1e2ec:	e002      	b.n	1e2f4 <USBPD_TCPM_transmit+0x24>
   1e2ee:	9300      	str	r3, [sp, #0]
   1e2f0:	2300      	movs	r3, #0
   1e2f2:	2200      	movs	r2, #0
   1e2f4:	e007      	b.n	1e306 <.text_37>

0001e2f6 <USBPD_PHY_ResetRequest>:
   1e2f6:	b538      	push	{r3, r4, r5, lr}
   1e2f8:	4a3b      	ldr	r2, [pc, #236]	; (1e3e8 <.text_47>)
   1e2fa:	0083      	lsls	r3, r0, #2
   1e2fc:	18d4      	adds	r4, r2, r3
   1e2fe:	2203      	movs	r2, #3
   1e300:	9200      	str	r2, [sp, #0]
   1e302:	2300      	movs	r3, #0
   1e304:	2200      	movs	r2, #0

0001e306 <.text_37>:
   1e306:	6865      	ldr	r5, [r4, #4]
   1e308:	696d      	ldr	r5, [r5, #20]
   1e30a:	6c2d      	ldr	r5, [r5, #64]	; 0x40
   1e30c:	47a8      	blx	r5
   1e30e:	2101      	movs	r1, #1
   1e310:	6862      	ldr	r2, [r4, #4]
   1e312:	7391      	strb	r1, [r2, #14]
   1e314:	bd32      	pop	{r1, r4, r5, pc}

0001e316 <USBPD_PHY_Send_BIST_Pattern>:
   1e316:	b538      	push	{r3, r4, r5, lr}
   1e318:	4986      	ldr	r1, [pc, #536]	; (1e534 <.text_49>)
   1e31a:	0082      	lsls	r2, r0, #2
   1e31c:	188c      	adds	r4, r1, r2
   1e31e:	2103      	movs	r1, #3
   1e320:	9100      	str	r1, [sp, #0]
   1e322:	2300      	movs	r3, #0
   1e324:	2200      	movs	r2, #0
   1e326:	2107      	movs	r1, #7
   1e328:	e7ed      	b.n	1e306 <.text_37>

0001e32a <USBPD_TCPM_Send_BIST_Pattern>:
   1e32a:	b51c      	push	{r2, r3, r4, lr}
   1e32c:	0002      	movs	r2, r0
   1e32e:	2010      	movs	r0, #16
   1e330:	4b80      	ldr	r3, [pc, #512]	; (1e534 <.text_49>)
   1e332:	0094      	lsls	r4, r2, #2
   1e334:	191c      	adds	r4, r3, r4
   1e336:	6863      	ldr	r3, [r4, #4]
   1e338:	695b      	ldr	r3, [r3, #20]
   1e33a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   1e33c:	2b00      	cmp	r3, #0
   1e33e:	d001      	beq.n	1e344 <USBPD_TCPM_Send_BIST_Pattern+0x1a>
   1e340:	0010      	movs	r0, r2
   1e342:	4798      	blx	r3
   1e344:	2101      	movs	r1, #1
   1e346:	6862      	ldr	r2, [r4, #4]
   1e348:	2321      	movs	r3, #33	; 0x21
   1e34a:	54d1      	strb	r1, [r2, r3]
   1e34c:	bd16      	pop	{r1, r2, r4, pc}

0001e34e <USBPD_PHY_SetResistor_SinkTxNG>:
   1e34e:	4979      	ldr	r1, [pc, #484]	; (1e534 <.text_49>)
   1e350:	0082      	lsls	r2, r0, #2
   1e352:	1889      	adds	r1, r1, r2
   1e354:	6849      	ldr	r1, [r1, #4]
   1e356:	6949      	ldr	r1, [r1, #20]
   1e358:	6c89      	ldr	r1, [r1, #72]	; 0x48
   1e35a:	2900      	cmp	r1, #0
   1e35c:	d100      	bne.n	1e360 <USBPD_PHY_SetResistor_SinkTxNG+0x12>
   1e35e:	4770      	bx	lr
   1e360:	b580      	push	{r7, lr}
   1e362:	4788      	blx	r1
   1e364:	bd01      	pop	{r0, pc}

0001e366 <USBPD_PHY_SetResistor_SinkTxOK>:
   1e366:	4973      	ldr	r1, [pc, #460]	; (1e534 <.text_49>)
   1e368:	0082      	lsls	r2, r0, #2
   1e36a:	1889      	adds	r1, r1, r2
   1e36c:	6849      	ldr	r1, [r1, #4]
   1e36e:	6949      	ldr	r1, [r1, #20]
   1e370:	6cc9      	ldr	r1, [r1, #76]	; 0x4c
   1e372:	2900      	cmp	r1, #0
   1e374:	d100      	bne.n	1e378 <USBPD_PHY_SetResistor_SinkTxOK+0x12>
   1e376:	4770      	bx	lr
   1e378:	b580      	push	{r7, lr}
   1e37a:	4788      	blx	r1
   1e37c:	bd01      	pop	{r0, pc}

0001e37e <USBPD_PHY_IsResistor_SinkTxOk>:
   1e37e:	0001      	movs	r1, r0
   1e380:	2010      	movs	r0, #16
   1e382:	4a6c      	ldr	r2, [pc, #432]	; (1e534 <.text_49>)
   1e384:	008b      	lsls	r3, r1, #2
   1e386:	18d2      	adds	r2, r2, r3
   1e388:	6852      	ldr	r2, [r2, #4]
   1e38a:	6952      	ldr	r2, [r2, #20]
   1e38c:	6d12      	ldr	r2, [r2, #80]	; 0x50
   1e38e:	2a00      	cmp	r2, #0
   1e390:	d100      	bne.n	1e394 <USBPD_PHY_IsResistor_SinkTxOk+0x16>
   1e392:	4770      	bx	lr
   1e394:	b580      	push	{r7, lr}
   1e396:	0008      	movs	r0, r1
   1e398:	4790      	blx	r2
   1e39a:	bd02      	pop	{r1, pc}

0001e39c <USBPD_PHY_FastRoleSwapSignalling>:
   1e39c:	4770      	bx	lr

0001e39e <USBPD_PHY_EnableRX>:
   1e39e:	4965      	ldr	r1, [pc, #404]	; (1e534 <.text_49>)
   1e3a0:	0082      	lsls	r2, r0, #2
   1e3a2:	1889      	adds	r1, r1, r2
   1e3a4:	6849      	ldr	r1, [r1, #4]
   1e3a6:	6949      	ldr	r1, [r1, #20]
   1e3a8:	6d49      	ldr	r1, [r1, #84]	; 0x54
   1e3aa:	2900      	cmp	r1, #0
   1e3ac:	d100      	bne.n	1e3b0 <USBPD_PHY_EnableRX+0x12>
   1e3ae:	4770      	bx	lr
   1e3b0:	b580      	push	{r7, lr}
   1e3b2:	4788      	blx	r1
   1e3b4:	bd01      	pop	{r0, pc}

0001e3b6 <USBPD_PHY_DisableRX>:
   1e3b6:	495f      	ldr	r1, [pc, #380]	; (1e534 <.text_49>)
   1e3b8:	0082      	lsls	r2, r0, #2
   1e3ba:	1889      	adds	r1, r1, r2
   1e3bc:	6849      	ldr	r1, [r1, #4]
   1e3be:	6949      	ldr	r1, [r1, #20]
   1e3c0:	6d89      	ldr	r1, [r1, #88]	; 0x58
   1e3c2:	2900      	cmp	r1, #0
   1e3c4:	d100      	bne.n	1e3c8 <USBPD_PHY_DisableRX+0x12>
   1e3c6:	4770      	bx	lr
   1e3c8:	b580      	push	{r7, lr}
   1e3ca:	4788      	blx	r1
   1e3cc:	bd01      	pop	{r0, pc}

0001e3ce <USBPD_TCPM_CADDetection>:
   1e3ce:	4a59      	ldr	r2, [pc, #356]	; (1e534 <.text_49>)
   1e3d0:	0083      	lsls	r3, r0, #2
   1e3d2:	18d2      	adds	r2, r2, r3
   1e3d4:	6852      	ldr	r2, [r2, #4]
   1e3d6:	6952      	ldr	r2, [r2, #20]
   1e3d8:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
   1e3da:	2a00      	cmp	r2, #0
   1e3dc:	d100      	bne.n	1e3e0 <USBPD_TCPM_CADDetection+0x12>
   1e3de:	4770      	bx	lr
   1e3e0:	b580      	push	{r7, lr}
   1e3e2:	4790      	blx	r2
   1e3e4:	bd01      	pop	{r0, pc}
	...

0001e3e8 <.text_47>:
   1e3e8:	0003210c 	.word	0x0003210c

0001e3ec <TCPM_CheckConnection>:
   1e3ec:	b5f1      	push	{r0, r4, r5, r6, r7, lr}
   1e3ee:	b086      	sub	sp, #24
   1e3f0:	2000      	movs	r0, #0
   1e3f2:	9005      	str	r0, [sp, #20]
   1e3f4:	9004      	str	r0, [sp, #16]
   1e3f6:	2010      	movs	r0, #16
   1e3f8:	4669      	mov	r1, sp
   1e3fa:	7108      	strb	r0, [r1, #4]
   1e3fc:	484d      	ldr	r0, [pc, #308]	; (1e534 <.text_49>)
   1e3fe:	7e09      	ldrb	r1, [r1, #24]
   1e400:	0089      	lsls	r1, r1, #2
   1e402:	1840      	adds	r0, r0, r1
   1e404:	9002      	str	r0, [sp, #8]
   1e406:	4668      	mov	r0, sp
   1e408:	7e00      	ldrb	r0, [r0, #24]
   1e40a:	9003      	str	r0, [sp, #12]
   1e40c:	2502      	movs	r5, #2
   1e40e:	2401      	movs	r4, #1
   1e410:	aa04      	add	r2, sp, #16
   1e412:	a905      	add	r1, sp, #20
   1e414:	f7ff ff21 	bl	1e25a <USBPD_TCPM_get_cc>
   1e418:	2800      	cmp	r0, #0
   1e41a:	d015      	beq.n	1e448 <TCPM_CheckConnection+0x5c>
   1e41c:	2003      	movs	r0, #3
   1e41e:	4669      	mov	r1, sp
   1e420:	7108      	strb	r0, [r1, #4]
   1e422:	9802      	ldr	r0, [sp, #8]
   1e424:	6840      	ldr	r0, [r0, #4]
   1e426:	7b41      	ldrb	r1, [r0, #13]
   1e428:	2901      	cmp	r1, #1
   1e42a:	d156      	bne.n	1e4da <TCPM_CheckConnection+0xee>
   1e42c:	69c0      	ldr	r0, [r0, #28]
   1e42e:	6800      	ldr	r0, [r0, #0]
   1e430:	0880      	lsrs	r0, r0, #2
   1e432:	4020      	ands	r0, r4
   1e434:	d100      	bne.n	1e438 <TCPM_CheckConnection+0x4c>
   1e436:	2102      	movs	r1, #2
   1e438:	2000      	movs	r0, #0
   1e43a:	9000      	str	r0, [sp, #0]
   1e43c:	2300      	movs	r3, #0
   1e43e:	2200      	movs	r2, #0
   1e440:	9803      	ldr	r0, [sp, #12]
   1e442:	f7ff ff31 	bl	1e2a8 <USBPD_TCPM_set_rx_state>
   1e446:	e057      	b.n	1e4f8 <TCPM_CheckConnection+0x10c>
   1e448:	9802      	ldr	r0, [sp, #8]
   1e44a:	6840      	ldr	r0, [r0, #4]
   1e44c:	9905      	ldr	r1, [sp, #20]
   1e44e:	9a04      	ldr	r2, [sp, #16]
   1e450:	430a      	orrs	r2, r1
   1e452:	d112      	bne.n	1e47a <TCPM_CheckConnection+0x8e>
   1e454:	69c0      	ldr	r0, [r0, #28]
   1e456:	6800      	ldr	r0, [r0, #0]
   1e458:	0880      	lsrs	r0, r0, #2
   1e45a:	4020      	ands	r0, r4
   1e45c:	d001      	beq.n	1e462 <TCPM_CheckConnection+0x76>
   1e45e:	2101      	movs	r1, #1
   1e460:	e000      	b.n	1e464 <TCPM_CheckConnection+0x78>
   1e462:	2102      	movs	r1, #2
   1e464:	2000      	movs	r0, #0
   1e466:	9000      	str	r0, [sp, #0]
   1e468:	2300      	movs	r3, #0
   1e46a:	9803      	ldr	r0, [sp, #12]
   1e46c:	f7ff ff1c 	bl	1e2a8 <USBPD_TCPM_set_rx_state>
   1e470:	4668      	mov	r0, sp
   1e472:	7e00      	ldrb	r0, [r0, #24]
   1e474:	f000 f860 	bl	1e538 <TCPM_Disconnect>
   1e478:	e055      	b.n	1e526 <TCPM_CheckConnection+0x13a>
   1e47a:	7b40      	ldrb	r0, [r0, #13]
   1e47c:	2800      	cmp	r0, #0
   1e47e:	d152      	bne.n	1e526 <TCPM_CheckConnection+0x13a>
   1e480:	2700      	movs	r7, #0
   1e482:	2100      	movs	r1, #0
   1e484:	2602      	movs	r6, #2
   1e486:	9805      	ldr	r0, [sp, #20]
   1e488:	2800      	cmp	r0, #0
   1e48a:	d02b      	beq.n	1e4e4 <TCPM_CheckConnection+0xf8>
   1e48c:	1e40      	subs	r0, r0, #1
   1e48e:	d028      	beq.n	1e4e2 <TCPM_CheckConnection+0xf6>
   1e490:	1e40      	subs	r0, r0, #1
   1e492:	d003      	beq.n	1e49c <TCPM_CheckConnection+0xb0>
   1e494:	1ec0      	subs	r0, r0, #3
   1e496:	2802      	cmp	r0, #2
   1e498:	d901      	bls.n	1e49e <TCPM_CheckConnection+0xb2>
   1e49a:	e02d      	b.n	1e4f8 <TCPM_CheckConnection+0x10c>
   1e49c:	2601      	movs	r6, #1
   1e49e:	9804      	ldr	r0, [sp, #16]
   1e4a0:	2800      	cmp	r0, #0
   1e4a2:	d119      	bne.n	1e4d8 <TCPM_CheckConnection+0xec>
   1e4a4:	2501      	movs	r5, #1
   1e4a6:	9803      	ldr	r0, [sp, #12]
   1e4a8:	f7ff fee0 	bl	1e26c <USBPD_TCPM_set_polarity>
   1e4ac:	2000      	movs	r0, #0
   1e4ae:	9000      	str	r0, [sp, #0]
   1e4b0:	9802      	ldr	r0, [sp, #8]
   1e4b2:	6840      	ldr	r0, [r0, #4]
   1e4b4:	6803      	ldr	r3, [r0, #0]
   1e4b6:	2201      	movs	r2, #1
   1e4b8:	0031      	movs	r1, r6
   1e4ba:	9803      	ldr	r0, [sp, #12]
   1e4bc:	f7ff fef4 	bl	1e2a8 <USBPD_TCPM_set_rx_state>
   1e4c0:	2800      	cmp	r0, #0
   1e4c2:	d130      	bne.n	1e526 <TCPM_CheckConnection+0x13a>
   1e4c4:	9802      	ldr	r0, [sp, #8]
   1e4c6:	6840      	ldr	r0, [r0, #4]
   1e4c8:	69c1      	ldr	r1, [r0, #28]
   1e4ca:	680a      	ldr	r2, [r1, #0]
   1e4cc:	2e01      	cmp	r6, #1
   1e4ce:	d118      	bne.n	1e502 <TCPM_CheckConnection+0x116>
   1e4d0:	2304      	movs	r3, #4
   1e4d2:	4313      	orrs	r3, r2
   1e4d4:	600b      	str	r3, [r1, #0]
   1e4d6:	e017      	b.n	1e508 <TCPM_CheckConnection+0x11c>
   1e4d8:	2801      	cmp	r0, #1
   1e4da:	d127      	bne.n	1e52c <TCPM_CheckConnection+0x140>
   1e4dc:	2501      	movs	r5, #1
   1e4de:	2701      	movs	r7, #1
   1e4e0:	e7e1      	b.n	1e4a6 <TCPM_CheckConnection+0xba>
   1e4e2:	2701      	movs	r7, #1
   1e4e4:	9804      	ldr	r0, [sp, #16]
   1e4e6:	1e80      	subs	r0, r0, #2
   1e4e8:	d003      	beq.n	1e4f2 <TCPM_CheckConnection+0x106>
   1e4ea:	1ec0      	subs	r0, r0, #3
   1e4ec:	2802      	cmp	r0, #2
   1e4ee:	d901      	bls.n	1e4f4 <TCPM_CheckConnection+0x108>
   1e4f0:	e01c      	b.n	1e52c <TCPM_CheckConnection+0x140>
   1e4f2:	2601      	movs	r6, #1
   1e4f4:	2101      	movs	r1, #1
   1e4f6:	e7d6      	b.n	1e4a6 <TCPM_CheckConnection+0xba>
   1e4f8:	4668      	mov	r0, sp
   1e4fa:	7e00      	ldrb	r0, [r0, #24]
   1e4fc:	f000 f81c 	bl	1e538 <TCPM_Disconnect>
   1e500:	e014      	b.n	1e52c <TCPM_CheckConnection+0x140>
   1e502:	2304      	movs	r3, #4
   1e504:	439a      	bics	r2, r3
   1e506:	600a      	str	r2, [r1, #0]
   1e508:	6980      	ldr	r0, [r0, #24]
   1e50a:	6803      	ldr	r3, [r0, #0]
   1e50c:	2f00      	cmp	r7, #0
   1e50e:	d102      	bne.n	1e516 <TCPM_CheckConnection+0x12a>
   1e510:	002a      	movs	r2, r5
   1e512:	2102      	movs	r1, #2
   1e514:	e001      	b.n	1e51a <TCPM_CheckConnection+0x12e>
   1e516:	002a      	movs	r2, r5
   1e518:	2104      	movs	r1, #4
   1e51a:	4668      	mov	r0, sp
   1e51c:	7e00      	ldrb	r0, [r0, #24]
   1e51e:	4798      	blx	r3
   1e520:	9802      	ldr	r0, [sp, #8]
   1e522:	6840      	ldr	r0, [r0, #4]
   1e524:	7344      	strb	r4, [r0, #13]
   1e526:	2000      	movs	r0, #0
   1e528:	4669      	mov	r1, sp
   1e52a:	7108      	strb	r0, [r1, #4]
   1e52c:	4668      	mov	r0, sp
   1e52e:	7900      	ldrb	r0, [r0, #4]
   1e530:	b007      	add	sp, #28
   1e532:	bdf0      	pop	{r4, r5, r6, r7, pc}

0001e534 <.text_49>:
   1e534:	0003210c 	.word	0x0003210c

0001e538 <TCPM_Disconnect>:
   1e538:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1e53a:	0005      	movs	r5, r0
   1e53c:	482a      	ldr	r0, [pc, #168]	; (1e5e8 <.text_52>)
   1e53e:	4669      	mov	r1, sp
   1e540:	8008      	strh	r0, [r1, #0]
   1e542:	2100      	movs	r1, #0
   1e544:	0028      	movs	r0, r5
   1e546:	f7ff fef0 	bl	1e32a <USBPD_TCPM_Send_BIST_Pattern>
   1e54a:	4828      	ldr	r0, [pc, #160]	; (1e5ec <.text_53>)
   1e54c:	4928      	ldr	r1, [pc, #160]	; (1e5f0 <.text_54>)
   1e54e:	2201      	movs	r2, #1
   1e550:	4b28      	ldr	r3, [pc, #160]	; (1e5f4 <.text_55>)
   1e552:	4c29      	ldr	r4, [pc, #164]	; (1e5f8 <.text_56>)
   1e554:	6826      	ldr	r6, [r4, #0]
   1e556:	401e      	ands	r6, r3
   1e558:	4f28      	ldr	r7, [pc, #160]	; (1e5fc <.text_57>)
   1e55a:	42be      	cmp	r6, r7
   1e55c:	d004      	beq.n	1e568 <TCPM_Disconnect+0x30>
   1e55e:	6824      	ldr	r4, [r4, #0]
   1e560:	4023      	ands	r3, r4
   1e562:	4c27      	ldr	r4, [pc, #156]	; (1e600 <.text_58>)
   1e564:	42a3      	cmp	r3, r4
   1e566:	d10d      	bne.n	1e584 <TCPM_Disconnect+0x4c>
   1e568:	4b26      	ldr	r3, [pc, #152]	; (1e604 <.text_59>)
   1e56a:	681b      	ldr	r3, [r3, #0]
   1e56c:	2b00      	cmp	r3, #0
   1e56e:	d109      	bne.n	1e584 <TCPM_Disconnect+0x4c>
   1e570:	4b25      	ldr	r3, [pc, #148]	; (1e608 <.text_60>)
   1e572:	681b      	ldr	r3, [r3, #0]
   1e574:	051b      	lsls	r3, r3, #20
   1e576:	0d1b      	lsrs	r3, r3, #20
   1e578:	248a      	movs	r4, #138	; 0x8a
   1e57a:	00e4      	lsls	r4, r4, #3
   1e57c:	42a3      	cmp	r3, r4
   1e57e:	d101      	bne.n	1e584 <TCPM_Disconnect+0x4c>
   1e580:	4b22      	ldr	r3, [pc, #136]	; (1e60c <.text_61>)
   1e582:	e000      	b.n	1e586 <TCPM_Disconnect+0x4e>
   1e584:	4b22      	ldr	r3, [pc, #136]	; (1e610 <.text_62>)
   1e586:	689c      	ldr	r4, [r3, #8]
   1e588:	609a      	str	r2, [r3, #8]
   1e58a:	689e      	ldr	r6, [r3, #8]
   1e58c:	2e01      	cmp	r6, #1
   1e58e:	d0fc      	beq.n	1e58a <TCPM_Disconnect+0x52>
   1e590:	6019      	str	r1, [r3, #0]
   1e592:	6819      	ldr	r1, [r3, #0]
   1e594:	6001      	str	r1, [r0, #0]
   1e596:	609c      	str	r4, [r3, #8]
   1e598:	6898      	ldr	r0, [r3, #8]
   1e59a:	4302      	orrs	r2, r0
   1e59c:	609a      	str	r2, [r3, #8]
   1e59e:	481d      	ldr	r0, [pc, #116]	; (1e614 <.text_63>)
   1e5a0:	00a9      	lsls	r1, r5, #2
   1e5a2:	1844      	adds	r4, r0, r1
   1e5a4:	2200      	movs	r2, #0
   1e5a6:	2101      	movs	r1, #1
   1e5a8:	0028      	movs	r0, r5
   1e5aa:	6863      	ldr	r3, [r4, #4]
   1e5ac:	699b      	ldr	r3, [r3, #24]
   1e5ae:	681b      	ldr	r3, [r3, #0]
   1e5b0:	4798      	blx	r3
   1e5b2:	2000      	movs	r0, #0
   1e5b4:	6862      	ldr	r2, [r4, #4]
   1e5b6:	7350      	strb	r0, [r2, #13]
   1e5b8:	6862      	ldr	r2, [r4, #4]
   1e5ba:	7390      	strb	r0, [r2, #14]
   1e5bc:	6861      	ldr	r1, [r4, #4]
   1e5be:	2221      	movs	r2, #33	; 0x21
   1e5c0:	5488      	strb	r0, [r1, r2]
   1e5c2:	6860      	ldr	r0, [r4, #4]
   1e5c4:	6940      	ldr	r0, [r0, #20]
   1e5c6:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
   1e5c8:	2a00      	cmp	r2, #0
   1e5ca:	d002      	beq.n	1e5d2 <TCPM_Disconnect+0x9a>
   1e5cc:	4669      	mov	r1, sp
   1e5ce:	0028      	movs	r0, r5
   1e5d0:	4790      	blx	r2
   1e5d2:	bdf1      	pop	{r0, r4, r5, r6, r7, pc}

0001e5d4 <TCPM_PortIsDoingSwap>:
   1e5d4:	490f      	ldr	r1, [pc, #60]	; (1e614 <.text_63>)
   1e5d6:	0080      	lsls	r0, r0, #2
   1e5d8:	1808      	adds	r0, r1, r0
   1e5da:	6840      	ldr	r0, [r0, #4]
   1e5dc:	69c0      	ldr	r0, [r0, #28]
   1e5de:	6800      	ldr	r0, [r0, #0]
   1e5e0:	06c1      	lsls	r1, r0, #27
   1e5e2:	0fc8      	lsrs	r0, r1, #31
   1e5e4:	4770      	bx	lr
	...

0001e5e8 <.text_52>:
   1e5e8:	00008fff 	.word	0x00008fff

0001e5ec <.text_53>:
   1e5ec:	0002ff78 	.word	0x0002ff78

0001e5f0 <.text_54>:
   1e5f0:	f407a5c2 	.word	0xf407a5c2

0001e5f4 <.text_55>:
   1e5f4:	0000fff0 	.word	0x0000fff0

0001e5f8 <.text_56>:
   1e5f8:	e000ed00 	.word	0xe000ed00

0001e5fc <.text_57>:
   1e5fc:	0000c240 	.word	0x0000c240

0001e600 <.text_58>:
   1e600:	0000c270 	.word	0x0000c270

0001e604 <.text_59>:
   1e604:	e0042000 	.word	0xe0042000

0001e608 <.text_60>:
   1e608:	5c001000 	.word	0x5c001000

0001e60c <.text_61>:
   1e60c:	58024c00 	.word	0x58024c00

0001e610 <.text_62>:
   1e610:	40023000 	.word	0x40023000

0001e614 <.text_63>:
   1e614:	0003210c 	.word	0x0003210c

0001e618 <__aeabi_memclr>:
   1e618:	b510      	push	{r4, lr}
   1e61a:	2200      	movs	r2, #0
   1e61c:	f000 f805 	bl	1e62a <__aeabi_memset>
   1e620:	bd10      	pop	{r4, pc}

0001e622 <__aeabi_memcpy>:
   1e622:	b510      	push	{r4, lr}
   1e624:	f000 f836 	bl	1e694 <memcpy>
   1e628:	bd10      	pop	{r4, pc}

0001e62a <__aeabi_memset>:
   1e62a:	0013      	movs	r3, r2
   1e62c:	b510      	push	{r4, lr}
   1e62e:	000a      	movs	r2, r1
   1e630:	0019      	movs	r1, r3
   1e632:	f000 f838 	bl	1e6a6 <memset>
   1e636:	bd10      	pop	{r4, pc}

0001e638 <__libc_init_array>:
   1e638:	b570      	push	{r4, r5, r6, lr}
   1e63a:	2600      	movs	r6, #0
   1e63c:	4d0c      	ldr	r5, [pc, #48]	; (1e670 <__libc_init_array+0x38>)
   1e63e:	4c0d      	ldr	r4, [pc, #52]	; (1e674 <__libc_init_array+0x3c>)
   1e640:	1b64      	subs	r4, r4, r5
   1e642:	10a4      	asrs	r4, r4, #2
   1e644:	42a6      	cmp	r6, r4
   1e646:	d109      	bne.n	1e65c <__libc_init_array+0x24>
   1e648:	2600      	movs	r6, #0
   1e64a:	f7e9 fcd9 	bl	8000 <_init>
   1e64e:	4d0a      	ldr	r5, [pc, #40]	; (1e678 <__libc_init_array+0x40>)
   1e650:	4c0a      	ldr	r4, [pc, #40]	; (1e67c <__libc_init_array+0x44>)
   1e652:	1b64      	subs	r4, r4, r5
   1e654:	10a4      	asrs	r4, r4, #2
   1e656:	42a6      	cmp	r6, r4
   1e658:	d105      	bne.n	1e666 <__libc_init_array+0x2e>
   1e65a:	bd70      	pop	{r4, r5, r6, pc}
   1e65c:	00b3      	lsls	r3, r6, #2
   1e65e:	58eb      	ldr	r3, [r5, r3]
   1e660:	4798      	blx	r3
   1e662:	3601      	adds	r6, #1
   1e664:	e7ee      	b.n	1e644 <__libc_init_array+0xc>
   1e666:	00b3      	lsls	r3, r6, #2
   1e668:	58eb      	ldr	r3, [r5, r3]
   1e66a:	4798      	blx	r3
   1e66c:	3601      	adds	r6, #1
   1e66e:	e7f2      	b.n	1e656 <__libc_init_array+0x1e>
   1e670:	0002fe18 	.word	0x0002fe18
   1e674:	0002fe18 	.word	0x0002fe18
   1e678:	0002fe18 	.word	0x0002fe18
   1e67c:	0002fe1c 	.word	0x0002fe1c

0001e680 <malloc>:
   1e680:	b510      	push	{r4, lr}
   1e682:	4b03      	ldr	r3, [pc, #12]	; (1e690 <malloc+0x10>)
   1e684:	0001      	movs	r1, r0
   1e686:	6818      	ldr	r0, [r3, #0]
   1e688:	f000 f860 	bl	1e74c <_malloc_r>
   1e68c:	bd10      	pop	{r4, pc}
   1e68e:	46c0      	nop			; (mov r8, r8)
   1e690:	0002ff7c 	.word	0x0002ff7c

0001e694 <memcpy>:
   1e694:	2300      	movs	r3, #0
   1e696:	b510      	push	{r4, lr}
   1e698:	429a      	cmp	r2, r3
   1e69a:	d100      	bne.n	1e69e <memcpy+0xa>
   1e69c:	bd10      	pop	{r4, pc}
   1e69e:	5ccc      	ldrb	r4, [r1, r3]
   1e6a0:	54c4      	strb	r4, [r0, r3]
   1e6a2:	3301      	adds	r3, #1
   1e6a4:	e7f8      	b.n	1e698 <memcpy+0x4>

0001e6a6 <memset>:
   1e6a6:	0003      	movs	r3, r0
   1e6a8:	1812      	adds	r2, r2, r0
   1e6aa:	4293      	cmp	r3, r2
   1e6ac:	d100      	bne.n	1e6b0 <memset+0xa>
   1e6ae:	4770      	bx	lr
   1e6b0:	7019      	strb	r1, [r3, #0]
   1e6b2:	3301      	adds	r3, #1
   1e6b4:	e7f9      	b.n	1e6aa <memset+0x4>
	...

0001e6b8 <_free_r>:
   1e6b8:	b570      	push	{r4, r5, r6, lr}
   1e6ba:	0005      	movs	r5, r0
   1e6bc:	2900      	cmp	r1, #0
   1e6be:	d010      	beq.n	1e6e2 <_free_r+0x2a>
   1e6c0:	1f0c      	subs	r4, r1, #4
   1e6c2:	6823      	ldr	r3, [r4, #0]
   1e6c4:	2b00      	cmp	r3, #0
   1e6c6:	da00      	bge.n	1e6ca <_free_r+0x12>
   1e6c8:	18e4      	adds	r4, r4, r3
   1e6ca:	0028      	movs	r0, r5
   1e6cc:	f000 f8d5 	bl	1e87a <__malloc_lock>
   1e6d0:	4a1d      	ldr	r2, [pc, #116]	; (1e748 <_free_r+0x90>)
   1e6d2:	6813      	ldr	r3, [r2, #0]
   1e6d4:	2b00      	cmp	r3, #0
   1e6d6:	d105      	bne.n	1e6e4 <_free_r+0x2c>
   1e6d8:	6063      	str	r3, [r4, #4]
   1e6da:	6014      	str	r4, [r2, #0]
   1e6dc:	0028      	movs	r0, r5
   1e6de:	f000 f8cd 	bl	1e87c <__malloc_unlock>
   1e6e2:	bd70      	pop	{r4, r5, r6, pc}
   1e6e4:	42a3      	cmp	r3, r4
   1e6e6:	d909      	bls.n	1e6fc <_free_r+0x44>
   1e6e8:	6821      	ldr	r1, [r4, #0]
   1e6ea:	1860      	adds	r0, r4, r1
   1e6ec:	4283      	cmp	r3, r0
   1e6ee:	d1f3      	bne.n	1e6d8 <_free_r+0x20>
   1e6f0:	6818      	ldr	r0, [r3, #0]
   1e6f2:	685b      	ldr	r3, [r3, #4]
   1e6f4:	1841      	adds	r1, r0, r1
   1e6f6:	6021      	str	r1, [r4, #0]
   1e6f8:	e7ee      	b.n	1e6d8 <_free_r+0x20>
   1e6fa:	0013      	movs	r3, r2
   1e6fc:	685a      	ldr	r2, [r3, #4]
   1e6fe:	2a00      	cmp	r2, #0
   1e700:	d001      	beq.n	1e706 <_free_r+0x4e>
   1e702:	42a2      	cmp	r2, r4
   1e704:	d9f9      	bls.n	1e6fa <_free_r+0x42>
   1e706:	6819      	ldr	r1, [r3, #0]
   1e708:	1858      	adds	r0, r3, r1
   1e70a:	42a0      	cmp	r0, r4
   1e70c:	d10b      	bne.n	1e726 <_free_r+0x6e>
   1e70e:	6820      	ldr	r0, [r4, #0]
   1e710:	1809      	adds	r1, r1, r0
   1e712:	1858      	adds	r0, r3, r1
   1e714:	6019      	str	r1, [r3, #0]
   1e716:	4282      	cmp	r2, r0
   1e718:	d1e0      	bne.n	1e6dc <_free_r+0x24>
   1e71a:	6810      	ldr	r0, [r2, #0]
   1e71c:	6852      	ldr	r2, [r2, #4]
   1e71e:	1841      	adds	r1, r0, r1
   1e720:	6019      	str	r1, [r3, #0]
   1e722:	605a      	str	r2, [r3, #4]
   1e724:	e7da      	b.n	1e6dc <_free_r+0x24>
   1e726:	42a0      	cmp	r0, r4
   1e728:	d902      	bls.n	1e730 <_free_r+0x78>
   1e72a:	230c      	movs	r3, #12
   1e72c:	602b      	str	r3, [r5, #0]
   1e72e:	e7d5      	b.n	1e6dc <_free_r+0x24>
   1e730:	6821      	ldr	r1, [r4, #0]
   1e732:	1860      	adds	r0, r4, r1
   1e734:	4282      	cmp	r2, r0
   1e736:	d103      	bne.n	1e740 <_free_r+0x88>
   1e738:	6810      	ldr	r0, [r2, #0]
   1e73a:	6852      	ldr	r2, [r2, #4]
   1e73c:	1841      	adds	r1, r0, r1
   1e73e:	6021      	str	r1, [r4, #0]
   1e740:	6062      	str	r2, [r4, #4]
   1e742:	605c      	str	r4, [r3, #4]
   1e744:	e7ca      	b.n	1e6dc <_free_r+0x24>
   1e746:	46c0      	nop			; (mov r8, r8)
   1e748:	00032130 	.word	0x00032130

0001e74c <_malloc_r>:
   1e74c:	2303      	movs	r3, #3
   1e74e:	b570      	push	{r4, r5, r6, lr}
   1e750:	1ccd      	adds	r5, r1, #3
   1e752:	439d      	bics	r5, r3
   1e754:	3508      	adds	r5, #8
   1e756:	0006      	movs	r6, r0
   1e758:	2d0c      	cmp	r5, #12
   1e75a:	d21e      	bcs.n	1e79a <_malloc_r+0x4e>
   1e75c:	250c      	movs	r5, #12
   1e75e:	42a9      	cmp	r1, r5
   1e760:	d81d      	bhi.n	1e79e <_malloc_r+0x52>
   1e762:	0030      	movs	r0, r6
   1e764:	f000 f889 	bl	1e87a <__malloc_lock>
   1e768:	4a25      	ldr	r2, [pc, #148]	; (1e800 <_malloc_r+0xb4>)
   1e76a:	6814      	ldr	r4, [r2, #0]
   1e76c:	0021      	movs	r1, r4
   1e76e:	2900      	cmp	r1, #0
   1e770:	d119      	bne.n	1e7a6 <_malloc_r+0x5a>
   1e772:	4c24      	ldr	r4, [pc, #144]	; (1e804 <_malloc_r+0xb8>)
   1e774:	6823      	ldr	r3, [r4, #0]
   1e776:	2b00      	cmp	r3, #0
   1e778:	d103      	bne.n	1e782 <_malloc_r+0x36>
   1e77a:	0030      	movs	r0, r6
   1e77c:	f000 f844 	bl	1e808 <_sbrk_r>
   1e780:	6020      	str	r0, [r4, #0]
   1e782:	0029      	movs	r1, r5
   1e784:	0030      	movs	r0, r6
   1e786:	f000 f83f 	bl	1e808 <_sbrk_r>
   1e78a:	1c43      	adds	r3, r0, #1
   1e78c:	d12b      	bne.n	1e7e6 <_malloc_r+0x9a>
   1e78e:	230c      	movs	r3, #12
   1e790:	0030      	movs	r0, r6
   1e792:	6033      	str	r3, [r6, #0]
   1e794:	f000 f872 	bl	1e87c <__malloc_unlock>
   1e798:	e003      	b.n	1e7a2 <_malloc_r+0x56>
   1e79a:	2d00      	cmp	r5, #0
   1e79c:	dadf      	bge.n	1e75e <_malloc_r+0x12>
   1e79e:	230c      	movs	r3, #12
   1e7a0:	6033      	str	r3, [r6, #0]
   1e7a2:	2000      	movs	r0, #0
   1e7a4:	bd70      	pop	{r4, r5, r6, pc}
   1e7a6:	680b      	ldr	r3, [r1, #0]
   1e7a8:	1b5b      	subs	r3, r3, r5
   1e7aa:	d419      	bmi.n	1e7e0 <_malloc_r+0x94>
   1e7ac:	2b0b      	cmp	r3, #11
   1e7ae:	d903      	bls.n	1e7b8 <_malloc_r+0x6c>
   1e7b0:	600b      	str	r3, [r1, #0]
   1e7b2:	18cc      	adds	r4, r1, r3
   1e7b4:	6025      	str	r5, [r4, #0]
   1e7b6:	e003      	b.n	1e7c0 <_malloc_r+0x74>
   1e7b8:	684b      	ldr	r3, [r1, #4]
   1e7ba:	428c      	cmp	r4, r1
   1e7bc:	d10d      	bne.n	1e7da <_malloc_r+0x8e>
   1e7be:	6013      	str	r3, [r2, #0]
   1e7c0:	0030      	movs	r0, r6
   1e7c2:	f000 f85b 	bl	1e87c <__malloc_unlock>
   1e7c6:	0020      	movs	r0, r4
   1e7c8:	2207      	movs	r2, #7
   1e7ca:	300b      	adds	r0, #11
   1e7cc:	1d23      	adds	r3, r4, #4
   1e7ce:	4390      	bics	r0, r2
   1e7d0:	1ac3      	subs	r3, r0, r3
   1e7d2:	d0e7      	beq.n	1e7a4 <_malloc_r+0x58>
   1e7d4:	425a      	negs	r2, r3
   1e7d6:	50e2      	str	r2, [r4, r3]
   1e7d8:	e7e4      	b.n	1e7a4 <_malloc_r+0x58>
   1e7da:	6063      	str	r3, [r4, #4]
   1e7dc:	000c      	movs	r4, r1
   1e7de:	e7ef      	b.n	1e7c0 <_malloc_r+0x74>
   1e7e0:	000c      	movs	r4, r1
   1e7e2:	6849      	ldr	r1, [r1, #4]
   1e7e4:	e7c3      	b.n	1e76e <_malloc_r+0x22>
   1e7e6:	2303      	movs	r3, #3
   1e7e8:	1cc4      	adds	r4, r0, #3
   1e7ea:	439c      	bics	r4, r3
   1e7ec:	42a0      	cmp	r0, r4
   1e7ee:	d0e1      	beq.n	1e7b4 <_malloc_r+0x68>
   1e7f0:	1a21      	subs	r1, r4, r0
   1e7f2:	0030      	movs	r0, r6
   1e7f4:	f000 f808 	bl	1e808 <_sbrk_r>
   1e7f8:	1c43      	adds	r3, r0, #1
   1e7fa:	d1db      	bne.n	1e7b4 <_malloc_r+0x68>
   1e7fc:	e7c7      	b.n	1e78e <_malloc_r+0x42>
   1e7fe:	46c0      	nop			; (mov r8, r8)
   1e800:	00032130 	.word	0x00032130
   1e804:	00032134 	.word	0x00032134

0001e808 <_sbrk_r>:
   1e808:	2300      	movs	r3, #0
   1e80a:	b570      	push	{r4, r5, r6, lr}
   1e80c:	4c06      	ldr	r4, [pc, #24]	; (1e828 <_sbrk_r+0x20>)
   1e80e:	0005      	movs	r5, r0
   1e810:	0008      	movs	r0, r1
   1e812:	6023      	str	r3, [r4, #0]
   1e814:	f000 fccc 	bl	1f1b0 <_sbrk>
   1e818:	1c43      	adds	r3, r0, #1
   1e81a:	d103      	bne.n	1e824 <_sbrk_r+0x1c>
   1e81c:	6823      	ldr	r3, [r4, #0]
   1e81e:	2b00      	cmp	r3, #0
   1e820:	d000      	beq.n	1e824 <_sbrk_r+0x1c>
   1e822:	602b      	str	r3, [r5, #0]
   1e824:	bd70      	pop	{r4, r5, r6, pc}
   1e826:	46c0      	nop			; (mov r8, r8)
   1e828:	00032480 	.word	0x00032480

0001e82c <siprintf>:
   1e82c:	b40e      	push	{r1, r2, r3}
   1e82e:	b500      	push	{lr}
   1e830:	490b      	ldr	r1, [pc, #44]	; (1e860 <siprintf+0x34>)
   1e832:	b09c      	sub	sp, #112	; 0x70
   1e834:	ab1d      	add	r3, sp, #116	; 0x74
   1e836:	9002      	str	r0, [sp, #8]
   1e838:	9006      	str	r0, [sp, #24]
   1e83a:	9107      	str	r1, [sp, #28]
   1e83c:	9104      	str	r1, [sp, #16]
   1e83e:	4809      	ldr	r0, [pc, #36]	; (1e864 <siprintf+0x38>)
   1e840:	4909      	ldr	r1, [pc, #36]	; (1e868 <siprintf+0x3c>)
   1e842:	cb04      	ldmia	r3!, {r2}
   1e844:	9105      	str	r1, [sp, #20]
   1e846:	6800      	ldr	r0, [r0, #0]
   1e848:	a902      	add	r1, sp, #8
   1e84a:	9301      	str	r3, [sp, #4]
   1e84c:	f000 f87a 	bl	1e944 <_svfiprintf_r>
   1e850:	2300      	movs	r3, #0
   1e852:	9a02      	ldr	r2, [sp, #8]
   1e854:	7013      	strb	r3, [r2, #0]
   1e856:	b01c      	add	sp, #112	; 0x70
   1e858:	bc08      	pop	{r3}
   1e85a:	b003      	add	sp, #12
   1e85c:	4718      	bx	r3
   1e85e:	46c0      	nop			; (mov r8, r8)
   1e860:	7fffffff 	.word	0x7fffffff
   1e864:	0002ff7c 	.word	0x0002ff7c
   1e868:	ffff0208 	.word	0xffff0208

0001e86c <strlen>:
   1e86c:	2300      	movs	r3, #0
   1e86e:	5cc2      	ldrb	r2, [r0, r3]
   1e870:	3301      	adds	r3, #1
   1e872:	2a00      	cmp	r2, #0
   1e874:	d1fb      	bne.n	1e86e <strlen+0x2>
   1e876:	1e58      	subs	r0, r3, #1
   1e878:	4770      	bx	lr

0001e87a <__malloc_lock>:
   1e87a:	4770      	bx	lr

0001e87c <__malloc_unlock>:
   1e87c:	4770      	bx	lr
	...

0001e880 <__ssputs_r>:
   1e880:	b5f0      	push	{r4, r5, r6, r7, lr}
   1e882:	688e      	ldr	r6, [r1, #8]
   1e884:	b085      	sub	sp, #20
   1e886:	0007      	movs	r7, r0
   1e888:	000c      	movs	r4, r1
   1e88a:	9203      	str	r2, [sp, #12]
   1e88c:	9301      	str	r3, [sp, #4]
   1e88e:	429e      	cmp	r6, r3
   1e890:	d83c      	bhi.n	1e90c <__ssputs_r+0x8c>
   1e892:	2390      	movs	r3, #144	; 0x90
   1e894:	898a      	ldrh	r2, [r1, #12]
   1e896:	00db      	lsls	r3, r3, #3
   1e898:	421a      	tst	r2, r3
   1e89a:	d034      	beq.n	1e906 <__ssputs_r+0x86>
   1e89c:	2503      	movs	r5, #3
   1e89e:	6909      	ldr	r1, [r1, #16]
   1e8a0:	6823      	ldr	r3, [r4, #0]
   1e8a2:	1a5b      	subs	r3, r3, r1
   1e8a4:	9302      	str	r3, [sp, #8]
   1e8a6:	6963      	ldr	r3, [r4, #20]
   1e8a8:	9802      	ldr	r0, [sp, #8]
   1e8aa:	435d      	muls	r5, r3
   1e8ac:	0feb      	lsrs	r3, r5, #31
   1e8ae:	195d      	adds	r5, r3, r5
   1e8b0:	9b01      	ldr	r3, [sp, #4]
   1e8b2:	106d      	asrs	r5, r5, #1
   1e8b4:	3301      	adds	r3, #1
   1e8b6:	181b      	adds	r3, r3, r0
   1e8b8:	42ab      	cmp	r3, r5
   1e8ba:	d900      	bls.n	1e8be <__ssputs_r+0x3e>
   1e8bc:	001d      	movs	r5, r3
   1e8be:	0553      	lsls	r3, r2, #21
   1e8c0:	d532      	bpl.n	1e928 <__ssputs_r+0xa8>
   1e8c2:	0029      	movs	r1, r5
   1e8c4:	0038      	movs	r0, r7
   1e8c6:	f7ff ff41 	bl	1e74c <_malloc_r>
   1e8ca:	1e06      	subs	r6, r0, #0
   1e8cc:	d109      	bne.n	1e8e2 <__ssputs_r+0x62>
   1e8ce:	230c      	movs	r3, #12
   1e8d0:	603b      	str	r3, [r7, #0]
   1e8d2:	2340      	movs	r3, #64	; 0x40
   1e8d4:	2001      	movs	r0, #1
   1e8d6:	89a2      	ldrh	r2, [r4, #12]
   1e8d8:	4240      	negs	r0, r0
   1e8da:	4313      	orrs	r3, r2
   1e8dc:	81a3      	strh	r3, [r4, #12]
   1e8de:	b005      	add	sp, #20
   1e8e0:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1e8e2:	9a02      	ldr	r2, [sp, #8]
   1e8e4:	6921      	ldr	r1, [r4, #16]
   1e8e6:	f7ff fed5 	bl	1e694 <memcpy>
   1e8ea:	89a3      	ldrh	r3, [r4, #12]
   1e8ec:	4a14      	ldr	r2, [pc, #80]	; (1e940 <__ssputs_r+0xc0>)
   1e8ee:	401a      	ands	r2, r3
   1e8f0:	2380      	movs	r3, #128	; 0x80
   1e8f2:	4313      	orrs	r3, r2
   1e8f4:	81a3      	strh	r3, [r4, #12]
   1e8f6:	9b02      	ldr	r3, [sp, #8]
   1e8f8:	6126      	str	r6, [r4, #16]
   1e8fa:	18f6      	adds	r6, r6, r3
   1e8fc:	6026      	str	r6, [r4, #0]
   1e8fe:	6165      	str	r5, [r4, #20]
   1e900:	9e01      	ldr	r6, [sp, #4]
   1e902:	1aed      	subs	r5, r5, r3
   1e904:	60a5      	str	r5, [r4, #8]
   1e906:	9b01      	ldr	r3, [sp, #4]
   1e908:	429e      	cmp	r6, r3
   1e90a:	d900      	bls.n	1e90e <__ssputs_r+0x8e>
   1e90c:	9e01      	ldr	r6, [sp, #4]
   1e90e:	0032      	movs	r2, r6
   1e910:	9903      	ldr	r1, [sp, #12]
   1e912:	6820      	ldr	r0, [r4, #0]
   1e914:	f000 fa95 	bl	1ee42 <memmove>
   1e918:	68a3      	ldr	r3, [r4, #8]
   1e91a:	2000      	movs	r0, #0
   1e91c:	1b9b      	subs	r3, r3, r6
   1e91e:	60a3      	str	r3, [r4, #8]
   1e920:	6823      	ldr	r3, [r4, #0]
   1e922:	199e      	adds	r6, r3, r6
   1e924:	6026      	str	r6, [r4, #0]
   1e926:	e7da      	b.n	1e8de <__ssputs_r+0x5e>
   1e928:	002a      	movs	r2, r5
   1e92a:	0038      	movs	r0, r7
   1e92c:	f000 fa9c 	bl	1ee68 <_realloc_r>
   1e930:	1e06      	subs	r6, r0, #0
   1e932:	d1e0      	bne.n	1e8f6 <__ssputs_r+0x76>
   1e934:	6921      	ldr	r1, [r4, #16]
   1e936:	0038      	movs	r0, r7
   1e938:	f7ff febe 	bl	1e6b8 <_free_r>
   1e93c:	e7c7      	b.n	1e8ce <__ssputs_r+0x4e>
   1e93e:	46c0      	nop			; (mov r8, r8)
   1e940:	fffffb7f 	.word	0xfffffb7f

0001e944 <_svfiprintf_r>:
   1e944:	b5f0      	push	{r4, r5, r6, r7, lr}
   1e946:	b0a1      	sub	sp, #132	; 0x84
   1e948:	9003      	str	r0, [sp, #12]
   1e94a:	001d      	movs	r5, r3
   1e94c:	898b      	ldrh	r3, [r1, #12]
   1e94e:	000f      	movs	r7, r1
   1e950:	0016      	movs	r6, r2
   1e952:	061b      	lsls	r3, r3, #24
   1e954:	d511      	bpl.n	1e97a <_svfiprintf_r+0x36>
   1e956:	690b      	ldr	r3, [r1, #16]
   1e958:	2b00      	cmp	r3, #0
   1e95a:	d10e      	bne.n	1e97a <_svfiprintf_r+0x36>
   1e95c:	2140      	movs	r1, #64	; 0x40
   1e95e:	f7ff fef5 	bl	1e74c <_malloc_r>
   1e962:	6038      	str	r0, [r7, #0]
   1e964:	6138      	str	r0, [r7, #16]
   1e966:	2800      	cmp	r0, #0
   1e968:	d105      	bne.n	1e976 <_svfiprintf_r+0x32>
   1e96a:	230c      	movs	r3, #12
   1e96c:	9a03      	ldr	r2, [sp, #12]
   1e96e:	3801      	subs	r0, #1
   1e970:	6013      	str	r3, [r2, #0]
   1e972:	b021      	add	sp, #132	; 0x84
   1e974:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1e976:	2340      	movs	r3, #64	; 0x40
   1e978:	617b      	str	r3, [r7, #20]
   1e97a:	2300      	movs	r3, #0
   1e97c:	ac08      	add	r4, sp, #32
   1e97e:	6163      	str	r3, [r4, #20]
   1e980:	3320      	adds	r3, #32
   1e982:	7663      	strb	r3, [r4, #25]
   1e984:	3310      	adds	r3, #16
   1e986:	76a3      	strb	r3, [r4, #26]
   1e988:	9507      	str	r5, [sp, #28]
   1e98a:	0035      	movs	r5, r6
   1e98c:	782b      	ldrb	r3, [r5, #0]
   1e98e:	2b00      	cmp	r3, #0
   1e990:	d001      	beq.n	1e996 <_svfiprintf_r+0x52>
   1e992:	2b25      	cmp	r3, #37	; 0x25
   1e994:	d146      	bne.n	1ea24 <_svfiprintf_r+0xe0>
   1e996:	1bab      	subs	r3, r5, r6
   1e998:	9305      	str	r3, [sp, #20]
   1e99a:	d00c      	beq.n	1e9b6 <_svfiprintf_r+0x72>
   1e99c:	0032      	movs	r2, r6
   1e99e:	0039      	movs	r1, r7
   1e9a0:	9803      	ldr	r0, [sp, #12]
   1e9a2:	f7ff ff6d 	bl	1e880 <__ssputs_r>
   1e9a6:	1c43      	adds	r3, r0, #1
   1e9a8:	d100      	bne.n	1e9ac <_svfiprintf_r+0x68>
   1e9aa:	e0ae      	b.n	1eb0a <_svfiprintf_r+0x1c6>
   1e9ac:	6962      	ldr	r2, [r4, #20]
   1e9ae:	9b05      	ldr	r3, [sp, #20]
   1e9b0:	4694      	mov	ip, r2
   1e9b2:	4463      	add	r3, ip
   1e9b4:	6163      	str	r3, [r4, #20]
   1e9b6:	782b      	ldrb	r3, [r5, #0]
   1e9b8:	2b00      	cmp	r3, #0
   1e9ba:	d100      	bne.n	1e9be <_svfiprintf_r+0x7a>
   1e9bc:	e0a5      	b.n	1eb0a <_svfiprintf_r+0x1c6>
   1e9be:	2201      	movs	r2, #1
   1e9c0:	2300      	movs	r3, #0
   1e9c2:	4252      	negs	r2, r2
   1e9c4:	6062      	str	r2, [r4, #4]
   1e9c6:	a904      	add	r1, sp, #16
   1e9c8:	3254      	adds	r2, #84	; 0x54
   1e9ca:	1852      	adds	r2, r2, r1
   1e9cc:	1c6e      	adds	r6, r5, #1
   1e9ce:	6023      	str	r3, [r4, #0]
   1e9d0:	60e3      	str	r3, [r4, #12]
   1e9d2:	60a3      	str	r3, [r4, #8]
   1e9d4:	7013      	strb	r3, [r2, #0]
   1e9d6:	65a3      	str	r3, [r4, #88]	; 0x58
   1e9d8:	7831      	ldrb	r1, [r6, #0]
   1e9da:	2205      	movs	r2, #5
   1e9dc:	4853      	ldr	r0, [pc, #332]	; (1eb2c <_svfiprintf_r+0x1e8>)
   1e9de:	f000 fa25 	bl	1ee2c <memchr>
   1e9e2:	1c75      	adds	r5, r6, #1
   1e9e4:	2800      	cmp	r0, #0
   1e9e6:	d11f      	bne.n	1ea28 <_svfiprintf_r+0xe4>
   1e9e8:	6822      	ldr	r2, [r4, #0]
   1e9ea:	06d3      	lsls	r3, r2, #27
   1e9ec:	d504      	bpl.n	1e9f8 <_svfiprintf_r+0xb4>
   1e9ee:	2353      	movs	r3, #83	; 0x53
   1e9f0:	a904      	add	r1, sp, #16
   1e9f2:	185b      	adds	r3, r3, r1
   1e9f4:	2120      	movs	r1, #32
   1e9f6:	7019      	strb	r1, [r3, #0]
   1e9f8:	0713      	lsls	r3, r2, #28
   1e9fa:	d504      	bpl.n	1ea06 <_svfiprintf_r+0xc2>
   1e9fc:	2353      	movs	r3, #83	; 0x53
   1e9fe:	a904      	add	r1, sp, #16
   1ea00:	185b      	adds	r3, r3, r1
   1ea02:	212b      	movs	r1, #43	; 0x2b
   1ea04:	7019      	strb	r1, [r3, #0]
   1ea06:	7833      	ldrb	r3, [r6, #0]
   1ea08:	2b2a      	cmp	r3, #42	; 0x2a
   1ea0a:	d016      	beq.n	1ea3a <_svfiprintf_r+0xf6>
   1ea0c:	0035      	movs	r5, r6
   1ea0e:	2100      	movs	r1, #0
   1ea10:	200a      	movs	r0, #10
   1ea12:	68e3      	ldr	r3, [r4, #12]
   1ea14:	782a      	ldrb	r2, [r5, #0]
   1ea16:	1c6e      	adds	r6, r5, #1
   1ea18:	3a30      	subs	r2, #48	; 0x30
   1ea1a:	2a09      	cmp	r2, #9
   1ea1c:	d94e      	bls.n	1eabc <_svfiprintf_r+0x178>
   1ea1e:	2900      	cmp	r1, #0
   1ea20:	d018      	beq.n	1ea54 <_svfiprintf_r+0x110>
   1ea22:	e010      	b.n	1ea46 <_svfiprintf_r+0x102>
   1ea24:	3501      	adds	r5, #1
   1ea26:	e7b1      	b.n	1e98c <_svfiprintf_r+0x48>
   1ea28:	4b40      	ldr	r3, [pc, #256]	; (1eb2c <_svfiprintf_r+0x1e8>)
   1ea2a:	6822      	ldr	r2, [r4, #0]
   1ea2c:	1ac0      	subs	r0, r0, r3
   1ea2e:	2301      	movs	r3, #1
   1ea30:	4083      	lsls	r3, r0
   1ea32:	4313      	orrs	r3, r2
   1ea34:	6023      	str	r3, [r4, #0]
   1ea36:	002e      	movs	r6, r5
   1ea38:	e7ce      	b.n	1e9d8 <_svfiprintf_r+0x94>
   1ea3a:	9b07      	ldr	r3, [sp, #28]
   1ea3c:	1d19      	adds	r1, r3, #4
   1ea3e:	681b      	ldr	r3, [r3, #0]
   1ea40:	9107      	str	r1, [sp, #28]
   1ea42:	2b00      	cmp	r3, #0
   1ea44:	db01      	blt.n	1ea4a <_svfiprintf_r+0x106>
   1ea46:	930b      	str	r3, [sp, #44]	; 0x2c
   1ea48:	e004      	b.n	1ea54 <_svfiprintf_r+0x110>
   1ea4a:	425b      	negs	r3, r3
   1ea4c:	60e3      	str	r3, [r4, #12]
   1ea4e:	2302      	movs	r3, #2
   1ea50:	4313      	orrs	r3, r2
   1ea52:	6023      	str	r3, [r4, #0]
   1ea54:	782b      	ldrb	r3, [r5, #0]
   1ea56:	2b2e      	cmp	r3, #46	; 0x2e
   1ea58:	d10a      	bne.n	1ea70 <_svfiprintf_r+0x12c>
   1ea5a:	786b      	ldrb	r3, [r5, #1]
   1ea5c:	2b2a      	cmp	r3, #42	; 0x2a
   1ea5e:	d135      	bne.n	1eacc <_svfiprintf_r+0x188>
   1ea60:	9b07      	ldr	r3, [sp, #28]
   1ea62:	3502      	adds	r5, #2
   1ea64:	1d1a      	adds	r2, r3, #4
   1ea66:	681b      	ldr	r3, [r3, #0]
   1ea68:	9207      	str	r2, [sp, #28]
   1ea6a:	2b00      	cmp	r3, #0
   1ea6c:	db2b      	blt.n	1eac6 <_svfiprintf_r+0x182>
   1ea6e:	9309      	str	r3, [sp, #36]	; 0x24
   1ea70:	4e2f      	ldr	r6, [pc, #188]	; (1eb30 <_svfiprintf_r+0x1ec>)
   1ea72:	7829      	ldrb	r1, [r5, #0]
   1ea74:	2203      	movs	r2, #3
   1ea76:	0030      	movs	r0, r6
   1ea78:	f000 f9d8 	bl	1ee2c <memchr>
   1ea7c:	2800      	cmp	r0, #0
   1ea7e:	d006      	beq.n	1ea8e <_svfiprintf_r+0x14a>
   1ea80:	2340      	movs	r3, #64	; 0x40
   1ea82:	1b80      	subs	r0, r0, r6
   1ea84:	4083      	lsls	r3, r0
   1ea86:	6822      	ldr	r2, [r4, #0]
   1ea88:	3501      	adds	r5, #1
   1ea8a:	4313      	orrs	r3, r2
   1ea8c:	6023      	str	r3, [r4, #0]
   1ea8e:	7829      	ldrb	r1, [r5, #0]
   1ea90:	2206      	movs	r2, #6
   1ea92:	4828      	ldr	r0, [pc, #160]	; (1eb34 <_svfiprintf_r+0x1f0>)
   1ea94:	1c6e      	adds	r6, r5, #1
   1ea96:	7621      	strb	r1, [r4, #24]
   1ea98:	f000 f9c8 	bl	1ee2c <memchr>
   1ea9c:	2800      	cmp	r0, #0
   1ea9e:	d03c      	beq.n	1eb1a <_svfiprintf_r+0x1d6>
   1eaa0:	4b25      	ldr	r3, [pc, #148]	; (1eb38 <_svfiprintf_r+0x1f4>)
   1eaa2:	2b00      	cmp	r3, #0
   1eaa4:	d125      	bne.n	1eaf2 <_svfiprintf_r+0x1ae>
   1eaa6:	2207      	movs	r2, #7
   1eaa8:	9b07      	ldr	r3, [sp, #28]
   1eaaa:	3307      	adds	r3, #7
   1eaac:	4393      	bics	r3, r2
   1eaae:	3308      	adds	r3, #8
   1eab0:	9307      	str	r3, [sp, #28]
   1eab2:	6963      	ldr	r3, [r4, #20]
   1eab4:	9a04      	ldr	r2, [sp, #16]
   1eab6:	189b      	adds	r3, r3, r2
   1eab8:	6163      	str	r3, [r4, #20]
   1eaba:	e766      	b.n	1e98a <_svfiprintf_r+0x46>
   1eabc:	4343      	muls	r3, r0
   1eabe:	2101      	movs	r1, #1
   1eac0:	189b      	adds	r3, r3, r2
   1eac2:	0035      	movs	r5, r6
   1eac4:	e7a6      	b.n	1ea14 <_svfiprintf_r+0xd0>
   1eac6:	2301      	movs	r3, #1
   1eac8:	425b      	negs	r3, r3
   1eaca:	e7d0      	b.n	1ea6e <_svfiprintf_r+0x12a>
   1eacc:	2300      	movs	r3, #0
   1eace:	200a      	movs	r0, #10
   1ead0:	001a      	movs	r2, r3
   1ead2:	3501      	adds	r5, #1
   1ead4:	6063      	str	r3, [r4, #4]
   1ead6:	7829      	ldrb	r1, [r5, #0]
   1ead8:	1c6e      	adds	r6, r5, #1
   1eada:	3930      	subs	r1, #48	; 0x30
   1eadc:	2909      	cmp	r1, #9
   1eade:	d903      	bls.n	1eae8 <_svfiprintf_r+0x1a4>
   1eae0:	2b00      	cmp	r3, #0
   1eae2:	d0c5      	beq.n	1ea70 <_svfiprintf_r+0x12c>
   1eae4:	9209      	str	r2, [sp, #36]	; 0x24
   1eae6:	e7c3      	b.n	1ea70 <_svfiprintf_r+0x12c>
   1eae8:	4342      	muls	r2, r0
   1eaea:	2301      	movs	r3, #1
   1eaec:	1852      	adds	r2, r2, r1
   1eaee:	0035      	movs	r5, r6
   1eaf0:	e7f1      	b.n	1ead6 <_svfiprintf_r+0x192>
   1eaf2:	ab07      	add	r3, sp, #28
   1eaf4:	9300      	str	r3, [sp, #0]
   1eaf6:	003a      	movs	r2, r7
   1eaf8:	4b10      	ldr	r3, [pc, #64]	; (1eb3c <_svfiprintf_r+0x1f8>)
   1eafa:	0021      	movs	r1, r4
   1eafc:	9803      	ldr	r0, [sp, #12]
   1eafe:	e000      	b.n	1eb02 <_svfiprintf_r+0x1be>
   1eb00:	bf00      	nop
   1eb02:	9004      	str	r0, [sp, #16]
   1eb04:	9b04      	ldr	r3, [sp, #16]
   1eb06:	3301      	adds	r3, #1
   1eb08:	d1d3      	bne.n	1eab2 <_svfiprintf_r+0x16e>
   1eb0a:	89bb      	ldrh	r3, [r7, #12]
   1eb0c:	980d      	ldr	r0, [sp, #52]	; 0x34
   1eb0e:	065b      	lsls	r3, r3, #25
   1eb10:	d400      	bmi.n	1eb14 <_svfiprintf_r+0x1d0>
   1eb12:	e72e      	b.n	1e972 <_svfiprintf_r+0x2e>
   1eb14:	2001      	movs	r0, #1
   1eb16:	4240      	negs	r0, r0
   1eb18:	e72b      	b.n	1e972 <_svfiprintf_r+0x2e>
   1eb1a:	ab07      	add	r3, sp, #28
   1eb1c:	9300      	str	r3, [sp, #0]
   1eb1e:	003a      	movs	r2, r7
   1eb20:	4b06      	ldr	r3, [pc, #24]	; (1eb3c <_svfiprintf_r+0x1f8>)
   1eb22:	0021      	movs	r1, r4
   1eb24:	9803      	ldr	r0, [sp, #12]
   1eb26:	f000 f879 	bl	1ec1c <_printf_i>
   1eb2a:	e7ea      	b.n	1eb02 <_svfiprintf_r+0x1be>
   1eb2c:	0001fdd8 	.word	0x0001fdd8
   1eb30:	0001fdde 	.word	0x0001fdde
   1eb34:	0001fde2 	.word	0x0001fde2
   1eb38:	00000000 	.word	0x00000000
   1eb3c:	0001e881 	.word	0x0001e881

0001eb40 <_printf_common>:
   1eb40:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   1eb42:	0015      	movs	r5, r2
   1eb44:	9301      	str	r3, [sp, #4]
   1eb46:	688a      	ldr	r2, [r1, #8]
   1eb48:	690b      	ldr	r3, [r1, #16]
   1eb4a:	9000      	str	r0, [sp, #0]
   1eb4c:	000c      	movs	r4, r1
   1eb4e:	4293      	cmp	r3, r2
   1eb50:	da00      	bge.n	1eb54 <_printf_common+0x14>
   1eb52:	0013      	movs	r3, r2
   1eb54:	0022      	movs	r2, r4
   1eb56:	602b      	str	r3, [r5, #0]
   1eb58:	3243      	adds	r2, #67	; 0x43
   1eb5a:	7812      	ldrb	r2, [r2, #0]
   1eb5c:	2a00      	cmp	r2, #0
   1eb5e:	d001      	beq.n	1eb64 <_printf_common+0x24>
   1eb60:	3301      	adds	r3, #1
   1eb62:	602b      	str	r3, [r5, #0]
   1eb64:	6823      	ldr	r3, [r4, #0]
   1eb66:	069b      	lsls	r3, r3, #26
   1eb68:	d502      	bpl.n	1eb70 <_printf_common+0x30>
   1eb6a:	682b      	ldr	r3, [r5, #0]
   1eb6c:	3302      	adds	r3, #2
   1eb6e:	602b      	str	r3, [r5, #0]
   1eb70:	2706      	movs	r7, #6
   1eb72:	6823      	ldr	r3, [r4, #0]
   1eb74:	401f      	ands	r7, r3
   1eb76:	d027      	beq.n	1ebc8 <_printf_common+0x88>
   1eb78:	0023      	movs	r3, r4
   1eb7a:	3343      	adds	r3, #67	; 0x43
   1eb7c:	781b      	ldrb	r3, [r3, #0]
   1eb7e:	1e5a      	subs	r2, r3, #1
   1eb80:	4193      	sbcs	r3, r2
   1eb82:	6822      	ldr	r2, [r4, #0]
   1eb84:	0692      	lsls	r2, r2, #26
   1eb86:	d430      	bmi.n	1ebea <_printf_common+0xaa>
   1eb88:	0022      	movs	r2, r4
   1eb8a:	9901      	ldr	r1, [sp, #4]
   1eb8c:	3243      	adds	r2, #67	; 0x43
   1eb8e:	9800      	ldr	r0, [sp, #0]
   1eb90:	9e08      	ldr	r6, [sp, #32]
   1eb92:	47b0      	blx	r6
   1eb94:	1c43      	adds	r3, r0, #1
   1eb96:	d025      	beq.n	1ebe4 <_printf_common+0xa4>
   1eb98:	2306      	movs	r3, #6
   1eb9a:	6820      	ldr	r0, [r4, #0]
   1eb9c:	682a      	ldr	r2, [r5, #0]
   1eb9e:	68e1      	ldr	r1, [r4, #12]
   1eba0:	4003      	ands	r3, r0
   1eba2:	2500      	movs	r5, #0
   1eba4:	2b04      	cmp	r3, #4
   1eba6:	d103      	bne.n	1ebb0 <_printf_common+0x70>
   1eba8:	1a8d      	subs	r5, r1, r2
   1ebaa:	43eb      	mvns	r3, r5
   1ebac:	17db      	asrs	r3, r3, #31
   1ebae:	401d      	ands	r5, r3
   1ebb0:	68a3      	ldr	r3, [r4, #8]
   1ebb2:	6922      	ldr	r2, [r4, #16]
   1ebb4:	4293      	cmp	r3, r2
   1ebb6:	dd01      	ble.n	1ebbc <_printf_common+0x7c>
   1ebb8:	1a9b      	subs	r3, r3, r2
   1ebba:	18ed      	adds	r5, r5, r3
   1ebbc:	2700      	movs	r7, #0
   1ebbe:	42bd      	cmp	r5, r7
   1ebc0:	d120      	bne.n	1ec04 <_printf_common+0xc4>
   1ebc2:	2000      	movs	r0, #0
   1ebc4:	e010      	b.n	1ebe8 <_printf_common+0xa8>
   1ebc6:	3701      	adds	r7, #1
   1ebc8:	68e3      	ldr	r3, [r4, #12]
   1ebca:	682a      	ldr	r2, [r5, #0]
   1ebcc:	1a9b      	subs	r3, r3, r2
   1ebce:	42bb      	cmp	r3, r7
   1ebd0:	ddd2      	ble.n	1eb78 <_printf_common+0x38>
   1ebd2:	0022      	movs	r2, r4
   1ebd4:	2301      	movs	r3, #1
   1ebd6:	3219      	adds	r2, #25
   1ebd8:	9901      	ldr	r1, [sp, #4]
   1ebda:	9800      	ldr	r0, [sp, #0]
   1ebdc:	9e08      	ldr	r6, [sp, #32]
   1ebde:	47b0      	blx	r6
   1ebe0:	1c43      	adds	r3, r0, #1
   1ebe2:	d1f0      	bne.n	1ebc6 <_printf_common+0x86>
   1ebe4:	2001      	movs	r0, #1
   1ebe6:	4240      	negs	r0, r0
   1ebe8:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   1ebea:	2030      	movs	r0, #48	; 0x30
   1ebec:	18e1      	adds	r1, r4, r3
   1ebee:	3143      	adds	r1, #67	; 0x43
   1ebf0:	7008      	strb	r0, [r1, #0]
   1ebf2:	0021      	movs	r1, r4
   1ebf4:	1c5a      	adds	r2, r3, #1
   1ebf6:	3145      	adds	r1, #69	; 0x45
   1ebf8:	7809      	ldrb	r1, [r1, #0]
   1ebfa:	18a2      	adds	r2, r4, r2
   1ebfc:	3243      	adds	r2, #67	; 0x43
   1ebfe:	3302      	adds	r3, #2
   1ec00:	7011      	strb	r1, [r2, #0]
   1ec02:	e7c1      	b.n	1eb88 <_printf_common+0x48>
   1ec04:	0022      	movs	r2, r4
   1ec06:	2301      	movs	r3, #1
   1ec08:	321a      	adds	r2, #26
   1ec0a:	9901      	ldr	r1, [sp, #4]
   1ec0c:	9800      	ldr	r0, [sp, #0]
   1ec0e:	9e08      	ldr	r6, [sp, #32]
   1ec10:	47b0      	blx	r6
   1ec12:	1c43      	adds	r3, r0, #1
   1ec14:	d0e6      	beq.n	1ebe4 <_printf_common+0xa4>
   1ec16:	3701      	adds	r7, #1
   1ec18:	e7d1      	b.n	1ebbe <_printf_common+0x7e>
	...

0001ec1c <_printf_i>:
   1ec1c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1ec1e:	b089      	sub	sp, #36	; 0x24
   1ec20:	9204      	str	r2, [sp, #16]
   1ec22:	000a      	movs	r2, r1
   1ec24:	3243      	adds	r2, #67	; 0x43
   1ec26:	9305      	str	r3, [sp, #20]
   1ec28:	9003      	str	r0, [sp, #12]
   1ec2a:	9202      	str	r2, [sp, #8]
   1ec2c:	7e0a      	ldrb	r2, [r1, #24]
   1ec2e:	000c      	movs	r4, r1
   1ec30:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1ec32:	2a6e      	cmp	r2, #110	; 0x6e
   1ec34:	d100      	bne.n	1ec38 <_printf_i+0x1c>
   1ec36:	e086      	b.n	1ed46 <_printf_i+0x12a>
   1ec38:	d81f      	bhi.n	1ec7a <_printf_i+0x5e>
   1ec3a:	2a63      	cmp	r2, #99	; 0x63
   1ec3c:	d033      	beq.n	1eca6 <_printf_i+0x8a>
   1ec3e:	d808      	bhi.n	1ec52 <_printf_i+0x36>
   1ec40:	2a00      	cmp	r2, #0
   1ec42:	d100      	bne.n	1ec46 <_printf_i+0x2a>
   1ec44:	e08c      	b.n	1ed60 <_printf_i+0x144>
   1ec46:	2a58      	cmp	r2, #88	; 0x58
   1ec48:	d04d      	beq.n	1ece6 <_printf_i+0xca>
   1ec4a:	0025      	movs	r5, r4
   1ec4c:	3542      	adds	r5, #66	; 0x42
   1ec4e:	702a      	strb	r2, [r5, #0]
   1ec50:	e030      	b.n	1ecb4 <_printf_i+0x98>
   1ec52:	2a64      	cmp	r2, #100	; 0x64
   1ec54:	d001      	beq.n	1ec5a <_printf_i+0x3e>
   1ec56:	2a69      	cmp	r2, #105	; 0x69
   1ec58:	d1f7      	bne.n	1ec4a <_printf_i+0x2e>
   1ec5a:	6819      	ldr	r1, [r3, #0]
   1ec5c:	6825      	ldr	r5, [r4, #0]
   1ec5e:	1d0a      	adds	r2, r1, #4
   1ec60:	0628      	lsls	r0, r5, #24
   1ec62:	d529      	bpl.n	1ecb8 <_printf_i+0x9c>
   1ec64:	6808      	ldr	r0, [r1, #0]
   1ec66:	601a      	str	r2, [r3, #0]
   1ec68:	2800      	cmp	r0, #0
   1ec6a:	da03      	bge.n	1ec74 <_printf_i+0x58>
   1ec6c:	232d      	movs	r3, #45	; 0x2d
   1ec6e:	9a02      	ldr	r2, [sp, #8]
   1ec70:	4240      	negs	r0, r0
   1ec72:	7013      	strb	r3, [r2, #0]
   1ec74:	4e6b      	ldr	r6, [pc, #428]	; (1ee24 <_printf_i+0x208>)
   1ec76:	270a      	movs	r7, #10
   1ec78:	e04f      	b.n	1ed1a <_printf_i+0xfe>
   1ec7a:	2a73      	cmp	r2, #115	; 0x73
   1ec7c:	d074      	beq.n	1ed68 <_printf_i+0x14c>
   1ec7e:	d808      	bhi.n	1ec92 <_printf_i+0x76>
   1ec80:	2a6f      	cmp	r2, #111	; 0x6f
   1ec82:	d01f      	beq.n	1ecc4 <_printf_i+0xa8>
   1ec84:	2a70      	cmp	r2, #112	; 0x70
   1ec86:	d1e0      	bne.n	1ec4a <_printf_i+0x2e>
   1ec88:	2220      	movs	r2, #32
   1ec8a:	6809      	ldr	r1, [r1, #0]
   1ec8c:	430a      	orrs	r2, r1
   1ec8e:	6022      	str	r2, [r4, #0]
   1ec90:	e003      	b.n	1ec9a <_printf_i+0x7e>
   1ec92:	2a75      	cmp	r2, #117	; 0x75
   1ec94:	d016      	beq.n	1ecc4 <_printf_i+0xa8>
   1ec96:	2a78      	cmp	r2, #120	; 0x78
   1ec98:	d1d7      	bne.n	1ec4a <_printf_i+0x2e>
   1ec9a:	0022      	movs	r2, r4
   1ec9c:	2178      	movs	r1, #120	; 0x78
   1ec9e:	3245      	adds	r2, #69	; 0x45
   1eca0:	7011      	strb	r1, [r2, #0]
   1eca2:	4e61      	ldr	r6, [pc, #388]	; (1ee28 <_printf_i+0x20c>)
   1eca4:	e022      	b.n	1ecec <_printf_i+0xd0>
   1eca6:	0025      	movs	r5, r4
   1eca8:	681a      	ldr	r2, [r3, #0]
   1ecaa:	3542      	adds	r5, #66	; 0x42
   1ecac:	1d11      	adds	r1, r2, #4
   1ecae:	6019      	str	r1, [r3, #0]
   1ecb0:	6813      	ldr	r3, [r2, #0]
   1ecb2:	702b      	strb	r3, [r5, #0]
   1ecb4:	2301      	movs	r3, #1
   1ecb6:	e065      	b.n	1ed84 <_printf_i+0x168>
   1ecb8:	6808      	ldr	r0, [r1, #0]
   1ecba:	601a      	str	r2, [r3, #0]
   1ecbc:	0669      	lsls	r1, r5, #25
   1ecbe:	d5d3      	bpl.n	1ec68 <_printf_i+0x4c>
   1ecc0:	b200      	sxth	r0, r0
   1ecc2:	e7d1      	b.n	1ec68 <_printf_i+0x4c>
   1ecc4:	6819      	ldr	r1, [r3, #0]
   1ecc6:	6825      	ldr	r5, [r4, #0]
   1ecc8:	1d08      	adds	r0, r1, #4
   1ecca:	6018      	str	r0, [r3, #0]
   1eccc:	6808      	ldr	r0, [r1, #0]
   1ecce:	062e      	lsls	r6, r5, #24
   1ecd0:	d505      	bpl.n	1ecde <_printf_i+0xc2>
   1ecd2:	4e54      	ldr	r6, [pc, #336]	; (1ee24 <_printf_i+0x208>)
   1ecd4:	2708      	movs	r7, #8
   1ecd6:	2a6f      	cmp	r2, #111	; 0x6f
   1ecd8:	d01b      	beq.n	1ed12 <_printf_i+0xf6>
   1ecda:	270a      	movs	r7, #10
   1ecdc:	e019      	b.n	1ed12 <_printf_i+0xf6>
   1ecde:	066d      	lsls	r5, r5, #25
   1ece0:	d5f7      	bpl.n	1ecd2 <_printf_i+0xb6>
   1ece2:	b280      	uxth	r0, r0
   1ece4:	e7f5      	b.n	1ecd2 <_printf_i+0xb6>
   1ece6:	3145      	adds	r1, #69	; 0x45
   1ece8:	4e4e      	ldr	r6, [pc, #312]	; (1ee24 <_printf_i+0x208>)
   1ecea:	700a      	strb	r2, [r1, #0]
   1ecec:	6818      	ldr	r0, [r3, #0]
   1ecee:	6822      	ldr	r2, [r4, #0]
   1ecf0:	1d01      	adds	r1, r0, #4
   1ecf2:	6800      	ldr	r0, [r0, #0]
   1ecf4:	6019      	str	r1, [r3, #0]
   1ecf6:	0615      	lsls	r5, r2, #24
   1ecf8:	d521      	bpl.n	1ed3e <_printf_i+0x122>
   1ecfa:	07d3      	lsls	r3, r2, #31
   1ecfc:	d502      	bpl.n	1ed04 <_printf_i+0xe8>
   1ecfe:	2320      	movs	r3, #32
   1ed00:	431a      	orrs	r2, r3
   1ed02:	6022      	str	r2, [r4, #0]
   1ed04:	2710      	movs	r7, #16
   1ed06:	2800      	cmp	r0, #0
   1ed08:	d103      	bne.n	1ed12 <_printf_i+0xf6>
   1ed0a:	2320      	movs	r3, #32
   1ed0c:	6822      	ldr	r2, [r4, #0]
   1ed0e:	439a      	bics	r2, r3
   1ed10:	6022      	str	r2, [r4, #0]
   1ed12:	0023      	movs	r3, r4
   1ed14:	2200      	movs	r2, #0
   1ed16:	3343      	adds	r3, #67	; 0x43
   1ed18:	701a      	strb	r2, [r3, #0]
   1ed1a:	6863      	ldr	r3, [r4, #4]
   1ed1c:	60a3      	str	r3, [r4, #8]
   1ed1e:	2b00      	cmp	r3, #0
   1ed20:	db58      	blt.n	1edd4 <_printf_i+0x1b8>
   1ed22:	2204      	movs	r2, #4
   1ed24:	6821      	ldr	r1, [r4, #0]
   1ed26:	4391      	bics	r1, r2
   1ed28:	6021      	str	r1, [r4, #0]
   1ed2a:	2800      	cmp	r0, #0
   1ed2c:	d154      	bne.n	1edd8 <_printf_i+0x1bc>
   1ed2e:	9d02      	ldr	r5, [sp, #8]
   1ed30:	2b00      	cmp	r3, #0
   1ed32:	d05a      	beq.n	1edea <_printf_i+0x1ce>
   1ed34:	0025      	movs	r5, r4
   1ed36:	7833      	ldrb	r3, [r6, #0]
   1ed38:	3542      	adds	r5, #66	; 0x42
   1ed3a:	702b      	strb	r3, [r5, #0]
   1ed3c:	e055      	b.n	1edea <_printf_i+0x1ce>
   1ed3e:	0655      	lsls	r5, r2, #25
   1ed40:	d5db      	bpl.n	1ecfa <_printf_i+0xde>
   1ed42:	b280      	uxth	r0, r0
   1ed44:	e7d9      	b.n	1ecfa <_printf_i+0xde>
   1ed46:	681a      	ldr	r2, [r3, #0]
   1ed48:	680d      	ldr	r5, [r1, #0]
   1ed4a:	1d10      	adds	r0, r2, #4
   1ed4c:	6949      	ldr	r1, [r1, #20]
   1ed4e:	6018      	str	r0, [r3, #0]
   1ed50:	6813      	ldr	r3, [r2, #0]
   1ed52:	062e      	lsls	r6, r5, #24
   1ed54:	d501      	bpl.n	1ed5a <_printf_i+0x13e>
   1ed56:	6019      	str	r1, [r3, #0]
   1ed58:	e002      	b.n	1ed60 <_printf_i+0x144>
   1ed5a:	066d      	lsls	r5, r5, #25
   1ed5c:	d5fb      	bpl.n	1ed56 <_printf_i+0x13a>
   1ed5e:	8019      	strh	r1, [r3, #0]
   1ed60:	2300      	movs	r3, #0
   1ed62:	9d02      	ldr	r5, [sp, #8]
   1ed64:	6123      	str	r3, [r4, #16]
   1ed66:	e04f      	b.n	1ee08 <_printf_i+0x1ec>
   1ed68:	681a      	ldr	r2, [r3, #0]
   1ed6a:	1d11      	adds	r1, r2, #4
   1ed6c:	6019      	str	r1, [r3, #0]
   1ed6e:	6815      	ldr	r5, [r2, #0]
   1ed70:	2100      	movs	r1, #0
   1ed72:	6862      	ldr	r2, [r4, #4]
   1ed74:	0028      	movs	r0, r5
   1ed76:	f000 f859 	bl	1ee2c <memchr>
   1ed7a:	2800      	cmp	r0, #0
   1ed7c:	d001      	beq.n	1ed82 <_printf_i+0x166>
   1ed7e:	1b40      	subs	r0, r0, r5
   1ed80:	6060      	str	r0, [r4, #4]
   1ed82:	6863      	ldr	r3, [r4, #4]
   1ed84:	6123      	str	r3, [r4, #16]
   1ed86:	2300      	movs	r3, #0
   1ed88:	9a02      	ldr	r2, [sp, #8]
   1ed8a:	7013      	strb	r3, [r2, #0]
   1ed8c:	e03c      	b.n	1ee08 <_printf_i+0x1ec>
   1ed8e:	6923      	ldr	r3, [r4, #16]
   1ed90:	002a      	movs	r2, r5
   1ed92:	9904      	ldr	r1, [sp, #16]
   1ed94:	9803      	ldr	r0, [sp, #12]
   1ed96:	9d05      	ldr	r5, [sp, #20]
   1ed98:	47a8      	blx	r5
   1ed9a:	1c43      	adds	r3, r0, #1
   1ed9c:	d03e      	beq.n	1ee1c <_printf_i+0x200>
   1ed9e:	6823      	ldr	r3, [r4, #0]
   1eda0:	079b      	lsls	r3, r3, #30
   1eda2:	d415      	bmi.n	1edd0 <_printf_i+0x1b4>
   1eda4:	9b07      	ldr	r3, [sp, #28]
   1eda6:	68e0      	ldr	r0, [r4, #12]
   1eda8:	4298      	cmp	r0, r3
   1edaa:	da39      	bge.n	1ee20 <_printf_i+0x204>
   1edac:	0018      	movs	r0, r3
   1edae:	e037      	b.n	1ee20 <_printf_i+0x204>
   1edb0:	0022      	movs	r2, r4
   1edb2:	2301      	movs	r3, #1
   1edb4:	3219      	adds	r2, #25
   1edb6:	9904      	ldr	r1, [sp, #16]
   1edb8:	9803      	ldr	r0, [sp, #12]
   1edba:	9e05      	ldr	r6, [sp, #20]
   1edbc:	47b0      	blx	r6
   1edbe:	1c43      	adds	r3, r0, #1
   1edc0:	d02c      	beq.n	1ee1c <_printf_i+0x200>
   1edc2:	3501      	adds	r5, #1
   1edc4:	68e3      	ldr	r3, [r4, #12]
   1edc6:	9a07      	ldr	r2, [sp, #28]
   1edc8:	1a9b      	subs	r3, r3, r2
   1edca:	42ab      	cmp	r3, r5
   1edcc:	dcf0      	bgt.n	1edb0 <_printf_i+0x194>
   1edce:	e7e9      	b.n	1eda4 <_printf_i+0x188>
   1edd0:	2500      	movs	r5, #0
   1edd2:	e7f7      	b.n	1edc4 <_printf_i+0x1a8>
   1edd4:	2800      	cmp	r0, #0
   1edd6:	d0ad      	beq.n	1ed34 <_printf_i+0x118>
   1edd8:	9d02      	ldr	r5, [sp, #8]
   1edda:	0039      	movs	r1, r7
   1eddc:	f000 f8f8 	bl	1efd0 <__aeabi_uidivmod>
   1ede0:	5c73      	ldrb	r3, [r6, r1]
   1ede2:	3d01      	subs	r5, #1
   1ede4:	702b      	strb	r3, [r5, #0]
   1ede6:	2800      	cmp	r0, #0
   1ede8:	d1f7      	bne.n	1edda <_printf_i+0x1be>
   1edea:	2f08      	cmp	r7, #8
   1edec:	d109      	bne.n	1ee02 <_printf_i+0x1e6>
   1edee:	6823      	ldr	r3, [r4, #0]
   1edf0:	07db      	lsls	r3, r3, #31
   1edf2:	d506      	bpl.n	1ee02 <_printf_i+0x1e6>
   1edf4:	6863      	ldr	r3, [r4, #4]
   1edf6:	6922      	ldr	r2, [r4, #16]
   1edf8:	4293      	cmp	r3, r2
   1edfa:	dc02      	bgt.n	1ee02 <_printf_i+0x1e6>
   1edfc:	2330      	movs	r3, #48	; 0x30
   1edfe:	3d01      	subs	r5, #1
   1ee00:	702b      	strb	r3, [r5, #0]
   1ee02:	9b02      	ldr	r3, [sp, #8]
   1ee04:	1b5b      	subs	r3, r3, r5
   1ee06:	6123      	str	r3, [r4, #16]
   1ee08:	9b05      	ldr	r3, [sp, #20]
   1ee0a:	aa07      	add	r2, sp, #28
   1ee0c:	9300      	str	r3, [sp, #0]
   1ee0e:	0021      	movs	r1, r4
   1ee10:	9b04      	ldr	r3, [sp, #16]
   1ee12:	9803      	ldr	r0, [sp, #12]
   1ee14:	f7ff fe94 	bl	1eb40 <_printf_common>
   1ee18:	1c43      	adds	r3, r0, #1
   1ee1a:	d1b8      	bne.n	1ed8e <_printf_i+0x172>
   1ee1c:	2001      	movs	r0, #1
   1ee1e:	4240      	negs	r0, r0
   1ee20:	b009      	add	sp, #36	; 0x24
   1ee22:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1ee24:	0001fde9 	.word	0x0001fde9
   1ee28:	0001fdfa 	.word	0x0001fdfa

0001ee2c <memchr>:
   1ee2c:	b2c9      	uxtb	r1, r1
   1ee2e:	1882      	adds	r2, r0, r2
   1ee30:	4290      	cmp	r0, r2
   1ee32:	d101      	bne.n	1ee38 <memchr+0xc>
   1ee34:	2000      	movs	r0, #0
   1ee36:	4770      	bx	lr
   1ee38:	7803      	ldrb	r3, [r0, #0]
   1ee3a:	428b      	cmp	r3, r1
   1ee3c:	d0fb      	beq.n	1ee36 <memchr+0xa>
   1ee3e:	3001      	adds	r0, #1
   1ee40:	e7f6      	b.n	1ee30 <memchr+0x4>

0001ee42 <memmove>:
   1ee42:	b510      	push	{r4, lr}
   1ee44:	4288      	cmp	r0, r1
   1ee46:	d902      	bls.n	1ee4e <memmove+0xc>
   1ee48:	188b      	adds	r3, r1, r2
   1ee4a:	4298      	cmp	r0, r3
   1ee4c:	d303      	bcc.n	1ee56 <memmove+0x14>
   1ee4e:	2300      	movs	r3, #0
   1ee50:	e007      	b.n	1ee62 <memmove+0x20>
   1ee52:	5c8b      	ldrb	r3, [r1, r2]
   1ee54:	5483      	strb	r3, [r0, r2]
   1ee56:	3a01      	subs	r2, #1
   1ee58:	d2fb      	bcs.n	1ee52 <memmove+0x10>
   1ee5a:	bd10      	pop	{r4, pc}
   1ee5c:	5ccc      	ldrb	r4, [r1, r3]
   1ee5e:	54c4      	strb	r4, [r0, r3]
   1ee60:	3301      	adds	r3, #1
   1ee62:	429a      	cmp	r2, r3
   1ee64:	d1fa      	bne.n	1ee5c <memmove+0x1a>
   1ee66:	e7f8      	b.n	1ee5a <memmove+0x18>

0001ee68 <_realloc_r>:
   1ee68:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1ee6a:	0007      	movs	r7, r0
   1ee6c:	000d      	movs	r5, r1
   1ee6e:	0016      	movs	r6, r2
   1ee70:	2900      	cmp	r1, #0
   1ee72:	d105      	bne.n	1ee80 <_realloc_r+0x18>
   1ee74:	0011      	movs	r1, r2
   1ee76:	f7ff fc69 	bl	1e74c <_malloc_r>
   1ee7a:	0004      	movs	r4, r0
   1ee7c:	0020      	movs	r0, r4
   1ee7e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1ee80:	2a00      	cmp	r2, #0
   1ee82:	d103      	bne.n	1ee8c <_realloc_r+0x24>
   1ee84:	f7ff fc18 	bl	1e6b8 <_free_r>
   1ee88:	0034      	movs	r4, r6
   1ee8a:	e7f7      	b.n	1ee7c <_realloc_r+0x14>
   1ee8c:	f000 f812 	bl	1eeb4 <_malloc_usable_size_r>
   1ee90:	002c      	movs	r4, r5
   1ee92:	42b0      	cmp	r0, r6
   1ee94:	d2f2      	bcs.n	1ee7c <_realloc_r+0x14>
   1ee96:	0031      	movs	r1, r6
   1ee98:	0038      	movs	r0, r7
   1ee9a:	f7ff fc57 	bl	1e74c <_malloc_r>
   1ee9e:	1e04      	subs	r4, r0, #0
   1eea0:	d0ec      	beq.n	1ee7c <_realloc_r+0x14>
   1eea2:	0029      	movs	r1, r5
   1eea4:	0032      	movs	r2, r6
   1eea6:	f7ff fbf5 	bl	1e694 <memcpy>
   1eeaa:	0029      	movs	r1, r5
   1eeac:	0038      	movs	r0, r7
   1eeae:	f7ff fc03 	bl	1e6b8 <_free_r>
   1eeb2:	e7e3      	b.n	1ee7c <_realloc_r+0x14>

0001eeb4 <_malloc_usable_size_r>:
   1eeb4:	1f0b      	subs	r3, r1, #4
   1eeb6:	681b      	ldr	r3, [r3, #0]
   1eeb8:	1f18      	subs	r0, r3, #4
   1eeba:	2b00      	cmp	r3, #0
   1eebc:	da01      	bge.n	1eec2 <_malloc_usable_size_r+0xe>
   1eebe:	580b      	ldr	r3, [r1, r0]
   1eec0:	18c0      	adds	r0, r0, r3
   1eec2:	4770      	bx	lr

0001eec4 <__udivsi3>:
   1eec4:	2200      	movs	r2, #0
   1eec6:	0843      	lsrs	r3, r0, #1
   1eec8:	428b      	cmp	r3, r1
   1eeca:	d374      	bcc.n	1efb6 <__udivsi3+0xf2>
   1eecc:	0903      	lsrs	r3, r0, #4
   1eece:	428b      	cmp	r3, r1
   1eed0:	d35f      	bcc.n	1ef92 <__udivsi3+0xce>
   1eed2:	0a03      	lsrs	r3, r0, #8
   1eed4:	428b      	cmp	r3, r1
   1eed6:	d344      	bcc.n	1ef62 <__udivsi3+0x9e>
   1eed8:	0b03      	lsrs	r3, r0, #12
   1eeda:	428b      	cmp	r3, r1
   1eedc:	d328      	bcc.n	1ef30 <__udivsi3+0x6c>
   1eede:	0c03      	lsrs	r3, r0, #16
   1eee0:	428b      	cmp	r3, r1
   1eee2:	d30d      	bcc.n	1ef00 <__udivsi3+0x3c>
   1eee4:	22ff      	movs	r2, #255	; 0xff
   1eee6:	0209      	lsls	r1, r1, #8
   1eee8:	ba12      	rev	r2, r2
   1eeea:	0c03      	lsrs	r3, r0, #16
   1eeec:	428b      	cmp	r3, r1
   1eeee:	d302      	bcc.n	1eef6 <__udivsi3+0x32>
   1eef0:	1212      	asrs	r2, r2, #8
   1eef2:	0209      	lsls	r1, r1, #8
   1eef4:	d065      	beq.n	1efc2 <__udivsi3+0xfe>
   1eef6:	0b03      	lsrs	r3, r0, #12
   1eef8:	428b      	cmp	r3, r1
   1eefa:	d319      	bcc.n	1ef30 <__udivsi3+0x6c>
   1eefc:	e000      	b.n	1ef00 <__udivsi3+0x3c>
   1eefe:	0a09      	lsrs	r1, r1, #8
   1ef00:	0bc3      	lsrs	r3, r0, #15
   1ef02:	428b      	cmp	r3, r1
   1ef04:	d301      	bcc.n	1ef0a <__udivsi3+0x46>
   1ef06:	03cb      	lsls	r3, r1, #15
   1ef08:	1ac0      	subs	r0, r0, r3
   1ef0a:	4152      	adcs	r2, r2
   1ef0c:	0b83      	lsrs	r3, r0, #14
   1ef0e:	428b      	cmp	r3, r1
   1ef10:	d301      	bcc.n	1ef16 <__udivsi3+0x52>
   1ef12:	038b      	lsls	r3, r1, #14
   1ef14:	1ac0      	subs	r0, r0, r3
   1ef16:	4152      	adcs	r2, r2
   1ef18:	0b43      	lsrs	r3, r0, #13
   1ef1a:	428b      	cmp	r3, r1
   1ef1c:	d301      	bcc.n	1ef22 <__udivsi3+0x5e>
   1ef1e:	034b      	lsls	r3, r1, #13
   1ef20:	1ac0      	subs	r0, r0, r3
   1ef22:	4152      	adcs	r2, r2
   1ef24:	0b03      	lsrs	r3, r0, #12
   1ef26:	428b      	cmp	r3, r1
   1ef28:	d301      	bcc.n	1ef2e <__udivsi3+0x6a>
   1ef2a:	030b      	lsls	r3, r1, #12
   1ef2c:	1ac0      	subs	r0, r0, r3
   1ef2e:	4152      	adcs	r2, r2
   1ef30:	0ac3      	lsrs	r3, r0, #11
   1ef32:	428b      	cmp	r3, r1
   1ef34:	d301      	bcc.n	1ef3a <__udivsi3+0x76>
   1ef36:	02cb      	lsls	r3, r1, #11
   1ef38:	1ac0      	subs	r0, r0, r3
   1ef3a:	4152      	adcs	r2, r2
   1ef3c:	0a83      	lsrs	r3, r0, #10
   1ef3e:	428b      	cmp	r3, r1
   1ef40:	d301      	bcc.n	1ef46 <__udivsi3+0x82>
   1ef42:	028b      	lsls	r3, r1, #10
   1ef44:	1ac0      	subs	r0, r0, r3
   1ef46:	4152      	adcs	r2, r2
   1ef48:	0a43      	lsrs	r3, r0, #9
   1ef4a:	428b      	cmp	r3, r1
   1ef4c:	d301      	bcc.n	1ef52 <__udivsi3+0x8e>
   1ef4e:	024b      	lsls	r3, r1, #9
   1ef50:	1ac0      	subs	r0, r0, r3
   1ef52:	4152      	adcs	r2, r2
   1ef54:	0a03      	lsrs	r3, r0, #8
   1ef56:	428b      	cmp	r3, r1
   1ef58:	d301      	bcc.n	1ef5e <__udivsi3+0x9a>
   1ef5a:	020b      	lsls	r3, r1, #8
   1ef5c:	1ac0      	subs	r0, r0, r3
   1ef5e:	4152      	adcs	r2, r2
   1ef60:	d2cd      	bcs.n	1eefe <__udivsi3+0x3a>
   1ef62:	09c3      	lsrs	r3, r0, #7
   1ef64:	428b      	cmp	r3, r1
   1ef66:	d301      	bcc.n	1ef6c <__udivsi3+0xa8>
   1ef68:	01cb      	lsls	r3, r1, #7
   1ef6a:	1ac0      	subs	r0, r0, r3
   1ef6c:	4152      	adcs	r2, r2
   1ef6e:	0983      	lsrs	r3, r0, #6
   1ef70:	428b      	cmp	r3, r1
   1ef72:	d301      	bcc.n	1ef78 <__udivsi3+0xb4>
   1ef74:	018b      	lsls	r3, r1, #6
   1ef76:	1ac0      	subs	r0, r0, r3
   1ef78:	4152      	adcs	r2, r2
   1ef7a:	0943      	lsrs	r3, r0, #5
   1ef7c:	428b      	cmp	r3, r1
   1ef7e:	d301      	bcc.n	1ef84 <__udivsi3+0xc0>
   1ef80:	014b      	lsls	r3, r1, #5
   1ef82:	1ac0      	subs	r0, r0, r3
   1ef84:	4152      	adcs	r2, r2
   1ef86:	0903      	lsrs	r3, r0, #4
   1ef88:	428b      	cmp	r3, r1
   1ef8a:	d301      	bcc.n	1ef90 <__udivsi3+0xcc>
   1ef8c:	010b      	lsls	r3, r1, #4
   1ef8e:	1ac0      	subs	r0, r0, r3
   1ef90:	4152      	adcs	r2, r2
   1ef92:	08c3      	lsrs	r3, r0, #3
   1ef94:	428b      	cmp	r3, r1
   1ef96:	d301      	bcc.n	1ef9c <__udivsi3+0xd8>
   1ef98:	00cb      	lsls	r3, r1, #3
   1ef9a:	1ac0      	subs	r0, r0, r3
   1ef9c:	4152      	adcs	r2, r2
   1ef9e:	0883      	lsrs	r3, r0, #2
   1efa0:	428b      	cmp	r3, r1
   1efa2:	d301      	bcc.n	1efa8 <__udivsi3+0xe4>
   1efa4:	008b      	lsls	r3, r1, #2
   1efa6:	1ac0      	subs	r0, r0, r3
   1efa8:	4152      	adcs	r2, r2
   1efaa:	0843      	lsrs	r3, r0, #1
   1efac:	428b      	cmp	r3, r1
   1efae:	d301      	bcc.n	1efb4 <__udivsi3+0xf0>
   1efb0:	004b      	lsls	r3, r1, #1
   1efb2:	1ac0      	subs	r0, r0, r3
   1efb4:	4152      	adcs	r2, r2
   1efb6:	1a41      	subs	r1, r0, r1
   1efb8:	d200      	bcs.n	1efbc <__udivsi3+0xf8>
   1efba:	4601      	mov	r1, r0
   1efbc:	4152      	adcs	r2, r2
   1efbe:	4610      	mov	r0, r2
   1efc0:	4770      	bx	lr
   1efc2:	e7ff      	b.n	1efc4 <__udivsi3+0x100>
   1efc4:	b501      	push	{r0, lr}
   1efc6:	2000      	movs	r0, #0
   1efc8:	f000 f8f0 	bl	1f1ac <__aeabi_idiv0>
   1efcc:	bd02      	pop	{r1, pc}
   1efce:	46c0      	nop			; (mov r8, r8)

0001efd0 <__aeabi_uidivmod>:
   1efd0:	2900      	cmp	r1, #0
   1efd2:	d0f7      	beq.n	1efc4 <__udivsi3+0x100>
   1efd4:	e776      	b.n	1eec4 <__udivsi3>
   1efd6:	4770      	bx	lr

0001efd8 <__divsi3>:
   1efd8:	4603      	mov	r3, r0
   1efda:	430b      	orrs	r3, r1
   1efdc:	d47f      	bmi.n	1f0de <__divsi3+0x106>
   1efde:	2200      	movs	r2, #0
   1efe0:	0843      	lsrs	r3, r0, #1
   1efe2:	428b      	cmp	r3, r1
   1efe4:	d374      	bcc.n	1f0d0 <__divsi3+0xf8>
   1efe6:	0903      	lsrs	r3, r0, #4
   1efe8:	428b      	cmp	r3, r1
   1efea:	d35f      	bcc.n	1f0ac <__divsi3+0xd4>
   1efec:	0a03      	lsrs	r3, r0, #8
   1efee:	428b      	cmp	r3, r1
   1eff0:	d344      	bcc.n	1f07c <__divsi3+0xa4>
   1eff2:	0b03      	lsrs	r3, r0, #12
   1eff4:	428b      	cmp	r3, r1
   1eff6:	d328      	bcc.n	1f04a <__divsi3+0x72>
   1eff8:	0c03      	lsrs	r3, r0, #16
   1effa:	428b      	cmp	r3, r1
   1effc:	d30d      	bcc.n	1f01a <__divsi3+0x42>
   1effe:	22ff      	movs	r2, #255	; 0xff
   1f000:	0209      	lsls	r1, r1, #8
   1f002:	ba12      	rev	r2, r2
   1f004:	0c03      	lsrs	r3, r0, #16
   1f006:	428b      	cmp	r3, r1
   1f008:	d302      	bcc.n	1f010 <__divsi3+0x38>
   1f00a:	1212      	asrs	r2, r2, #8
   1f00c:	0209      	lsls	r1, r1, #8
   1f00e:	d065      	beq.n	1f0dc <__divsi3+0x104>
   1f010:	0b03      	lsrs	r3, r0, #12
   1f012:	428b      	cmp	r3, r1
   1f014:	d319      	bcc.n	1f04a <__divsi3+0x72>
   1f016:	e000      	b.n	1f01a <__divsi3+0x42>
   1f018:	0a09      	lsrs	r1, r1, #8
   1f01a:	0bc3      	lsrs	r3, r0, #15
   1f01c:	428b      	cmp	r3, r1
   1f01e:	d301      	bcc.n	1f024 <__divsi3+0x4c>
   1f020:	03cb      	lsls	r3, r1, #15
   1f022:	1ac0      	subs	r0, r0, r3
   1f024:	4152      	adcs	r2, r2
   1f026:	0b83      	lsrs	r3, r0, #14
   1f028:	428b      	cmp	r3, r1
   1f02a:	d301      	bcc.n	1f030 <__divsi3+0x58>
   1f02c:	038b      	lsls	r3, r1, #14
   1f02e:	1ac0      	subs	r0, r0, r3
   1f030:	4152      	adcs	r2, r2
   1f032:	0b43      	lsrs	r3, r0, #13
   1f034:	428b      	cmp	r3, r1
   1f036:	d301      	bcc.n	1f03c <__divsi3+0x64>
   1f038:	034b      	lsls	r3, r1, #13
   1f03a:	1ac0      	subs	r0, r0, r3
   1f03c:	4152      	adcs	r2, r2
   1f03e:	0b03      	lsrs	r3, r0, #12
   1f040:	428b      	cmp	r3, r1
   1f042:	d301      	bcc.n	1f048 <__divsi3+0x70>
   1f044:	030b      	lsls	r3, r1, #12
   1f046:	1ac0      	subs	r0, r0, r3
   1f048:	4152      	adcs	r2, r2
   1f04a:	0ac3      	lsrs	r3, r0, #11
   1f04c:	428b      	cmp	r3, r1
   1f04e:	d301      	bcc.n	1f054 <__divsi3+0x7c>
   1f050:	02cb      	lsls	r3, r1, #11
   1f052:	1ac0      	subs	r0, r0, r3
   1f054:	4152      	adcs	r2, r2
   1f056:	0a83      	lsrs	r3, r0, #10
   1f058:	428b      	cmp	r3, r1
   1f05a:	d301      	bcc.n	1f060 <__divsi3+0x88>
   1f05c:	028b      	lsls	r3, r1, #10
   1f05e:	1ac0      	subs	r0, r0, r3
   1f060:	4152      	adcs	r2, r2
   1f062:	0a43      	lsrs	r3, r0, #9
   1f064:	428b      	cmp	r3, r1
   1f066:	d301      	bcc.n	1f06c <__divsi3+0x94>
   1f068:	024b      	lsls	r3, r1, #9
   1f06a:	1ac0      	subs	r0, r0, r3
   1f06c:	4152      	adcs	r2, r2
   1f06e:	0a03      	lsrs	r3, r0, #8
   1f070:	428b      	cmp	r3, r1
   1f072:	d301      	bcc.n	1f078 <__divsi3+0xa0>
   1f074:	020b      	lsls	r3, r1, #8
   1f076:	1ac0      	subs	r0, r0, r3
   1f078:	4152      	adcs	r2, r2
   1f07a:	d2cd      	bcs.n	1f018 <__divsi3+0x40>
   1f07c:	09c3      	lsrs	r3, r0, #7
   1f07e:	428b      	cmp	r3, r1
   1f080:	d301      	bcc.n	1f086 <__divsi3+0xae>
   1f082:	01cb      	lsls	r3, r1, #7
   1f084:	1ac0      	subs	r0, r0, r3
   1f086:	4152      	adcs	r2, r2
   1f088:	0983      	lsrs	r3, r0, #6
   1f08a:	428b      	cmp	r3, r1
   1f08c:	d301      	bcc.n	1f092 <__divsi3+0xba>
   1f08e:	018b      	lsls	r3, r1, #6
   1f090:	1ac0      	subs	r0, r0, r3
   1f092:	4152      	adcs	r2, r2
   1f094:	0943      	lsrs	r3, r0, #5
   1f096:	428b      	cmp	r3, r1
   1f098:	d301      	bcc.n	1f09e <__divsi3+0xc6>
   1f09a:	014b      	lsls	r3, r1, #5
   1f09c:	1ac0      	subs	r0, r0, r3
   1f09e:	4152      	adcs	r2, r2
   1f0a0:	0903      	lsrs	r3, r0, #4
   1f0a2:	428b      	cmp	r3, r1
   1f0a4:	d301      	bcc.n	1f0aa <__divsi3+0xd2>
   1f0a6:	010b      	lsls	r3, r1, #4
   1f0a8:	1ac0      	subs	r0, r0, r3
   1f0aa:	4152      	adcs	r2, r2
   1f0ac:	08c3      	lsrs	r3, r0, #3
   1f0ae:	428b      	cmp	r3, r1
   1f0b0:	d301      	bcc.n	1f0b6 <__divsi3+0xde>
   1f0b2:	00cb      	lsls	r3, r1, #3
   1f0b4:	1ac0      	subs	r0, r0, r3
   1f0b6:	4152      	adcs	r2, r2
   1f0b8:	0883      	lsrs	r3, r0, #2
   1f0ba:	428b      	cmp	r3, r1
   1f0bc:	d301      	bcc.n	1f0c2 <__divsi3+0xea>
   1f0be:	008b      	lsls	r3, r1, #2
   1f0c0:	1ac0      	subs	r0, r0, r3
   1f0c2:	4152      	adcs	r2, r2
   1f0c4:	0843      	lsrs	r3, r0, #1
   1f0c6:	428b      	cmp	r3, r1
   1f0c8:	d301      	bcc.n	1f0ce <__divsi3+0xf6>
   1f0ca:	004b      	lsls	r3, r1, #1
   1f0cc:	1ac0      	subs	r0, r0, r3
   1f0ce:	4152      	adcs	r2, r2
   1f0d0:	1a41      	subs	r1, r0, r1
   1f0d2:	d200      	bcs.n	1f0d6 <__divsi3+0xfe>
   1f0d4:	4601      	mov	r1, r0
   1f0d6:	4152      	adcs	r2, r2
   1f0d8:	4610      	mov	r0, r2
   1f0da:	4770      	bx	lr
   1f0dc:	e05d      	b.n	1f19a <__divsi3+0x1c2>
   1f0de:	0fca      	lsrs	r2, r1, #31
   1f0e0:	d000      	beq.n	1f0e4 <__divsi3+0x10c>
   1f0e2:	4249      	negs	r1, r1
   1f0e4:	1003      	asrs	r3, r0, #32
   1f0e6:	d300      	bcc.n	1f0ea <__divsi3+0x112>
   1f0e8:	4240      	negs	r0, r0
   1f0ea:	4053      	eors	r3, r2
   1f0ec:	2200      	movs	r2, #0
   1f0ee:	469c      	mov	ip, r3
   1f0f0:	0903      	lsrs	r3, r0, #4
   1f0f2:	428b      	cmp	r3, r1
   1f0f4:	d32d      	bcc.n	1f152 <__divsi3+0x17a>
   1f0f6:	0a03      	lsrs	r3, r0, #8
   1f0f8:	428b      	cmp	r3, r1
   1f0fa:	d312      	bcc.n	1f122 <__divsi3+0x14a>
   1f0fc:	22fc      	movs	r2, #252	; 0xfc
   1f0fe:	0189      	lsls	r1, r1, #6
   1f100:	ba12      	rev	r2, r2
   1f102:	0a03      	lsrs	r3, r0, #8
   1f104:	428b      	cmp	r3, r1
   1f106:	d30c      	bcc.n	1f122 <__divsi3+0x14a>
   1f108:	0189      	lsls	r1, r1, #6
   1f10a:	1192      	asrs	r2, r2, #6
   1f10c:	428b      	cmp	r3, r1
   1f10e:	d308      	bcc.n	1f122 <__divsi3+0x14a>
   1f110:	0189      	lsls	r1, r1, #6
   1f112:	1192      	asrs	r2, r2, #6
   1f114:	428b      	cmp	r3, r1
   1f116:	d304      	bcc.n	1f122 <__divsi3+0x14a>
   1f118:	0189      	lsls	r1, r1, #6
   1f11a:	d03a      	beq.n	1f192 <__divsi3+0x1ba>
   1f11c:	1192      	asrs	r2, r2, #6
   1f11e:	e000      	b.n	1f122 <__divsi3+0x14a>
   1f120:	0989      	lsrs	r1, r1, #6
   1f122:	09c3      	lsrs	r3, r0, #7
   1f124:	428b      	cmp	r3, r1
   1f126:	d301      	bcc.n	1f12c <__divsi3+0x154>
   1f128:	01cb      	lsls	r3, r1, #7
   1f12a:	1ac0      	subs	r0, r0, r3
   1f12c:	4152      	adcs	r2, r2
   1f12e:	0983      	lsrs	r3, r0, #6
   1f130:	428b      	cmp	r3, r1
   1f132:	d301      	bcc.n	1f138 <__divsi3+0x160>
   1f134:	018b      	lsls	r3, r1, #6
   1f136:	1ac0      	subs	r0, r0, r3
   1f138:	4152      	adcs	r2, r2
   1f13a:	0943      	lsrs	r3, r0, #5
   1f13c:	428b      	cmp	r3, r1
   1f13e:	d301      	bcc.n	1f144 <__divsi3+0x16c>
   1f140:	014b      	lsls	r3, r1, #5
   1f142:	1ac0      	subs	r0, r0, r3
   1f144:	4152      	adcs	r2, r2
   1f146:	0903      	lsrs	r3, r0, #4
   1f148:	428b      	cmp	r3, r1
   1f14a:	d301      	bcc.n	1f150 <__divsi3+0x178>
   1f14c:	010b      	lsls	r3, r1, #4
   1f14e:	1ac0      	subs	r0, r0, r3
   1f150:	4152      	adcs	r2, r2
   1f152:	08c3      	lsrs	r3, r0, #3
   1f154:	428b      	cmp	r3, r1
   1f156:	d301      	bcc.n	1f15c <__divsi3+0x184>
   1f158:	00cb      	lsls	r3, r1, #3
   1f15a:	1ac0      	subs	r0, r0, r3
   1f15c:	4152      	adcs	r2, r2
   1f15e:	0883      	lsrs	r3, r0, #2
   1f160:	428b      	cmp	r3, r1
   1f162:	d301      	bcc.n	1f168 <__divsi3+0x190>
   1f164:	008b      	lsls	r3, r1, #2
   1f166:	1ac0      	subs	r0, r0, r3
   1f168:	4152      	adcs	r2, r2
   1f16a:	d2d9      	bcs.n	1f120 <__divsi3+0x148>
   1f16c:	0843      	lsrs	r3, r0, #1
   1f16e:	428b      	cmp	r3, r1
   1f170:	d301      	bcc.n	1f176 <__divsi3+0x19e>
   1f172:	004b      	lsls	r3, r1, #1
   1f174:	1ac0      	subs	r0, r0, r3
   1f176:	4152      	adcs	r2, r2
   1f178:	1a41      	subs	r1, r0, r1
   1f17a:	d200      	bcs.n	1f17e <__divsi3+0x1a6>
   1f17c:	4601      	mov	r1, r0
   1f17e:	4663      	mov	r3, ip
   1f180:	4152      	adcs	r2, r2
   1f182:	105b      	asrs	r3, r3, #1
   1f184:	4610      	mov	r0, r2
   1f186:	d301      	bcc.n	1f18c <__divsi3+0x1b4>
   1f188:	4240      	negs	r0, r0
   1f18a:	2b00      	cmp	r3, #0
   1f18c:	d500      	bpl.n	1f190 <__divsi3+0x1b8>
   1f18e:	4249      	negs	r1, r1
   1f190:	4770      	bx	lr
   1f192:	4663      	mov	r3, ip
   1f194:	105b      	asrs	r3, r3, #1
   1f196:	d300      	bcc.n	1f19a <__divsi3+0x1c2>
   1f198:	4240      	negs	r0, r0
   1f19a:	b501      	push	{r0, lr}
   1f19c:	2000      	movs	r0, #0
   1f19e:	f000 f805 	bl	1f1ac <__aeabi_idiv0>
   1f1a2:	bd02      	pop	{r1, pc}

0001f1a4 <__aeabi_idivmod>:
   1f1a4:	2900      	cmp	r1, #0
   1f1a6:	d0f8      	beq.n	1f19a <__divsi3+0x1c2>
   1f1a8:	e716      	b.n	1efd8 <__divsi3>
   1f1aa:	4770      	bx	lr

0001f1ac <__aeabi_idiv0>:
   1f1ac:	4770      	bx	lr
   1f1ae:	46c0      	nop			; (mov r8, r8)

0001f1b0 <_sbrk>:
   1f1b0:	4b05      	ldr	r3, [pc, #20]	; (1f1c8 <_sbrk+0x18>)
   1f1b2:	0002      	movs	r2, r0
   1f1b4:	6819      	ldr	r1, [r3, #0]
   1f1b6:	2900      	cmp	r1, #0
   1f1b8:	d101      	bne.n	1f1be <_sbrk+0xe>
   1f1ba:	4904      	ldr	r1, [pc, #16]	; (1f1cc <_sbrk+0x1c>)
   1f1bc:	6019      	str	r1, [r3, #0]
   1f1be:	6818      	ldr	r0, [r3, #0]
   1f1c0:	1882      	adds	r2, r0, r2
   1f1c2:	601a      	str	r2, [r3, #0]
   1f1c4:	4770      	bx	lr
   1f1c6:	46c0      	nop			; (mov r8, r8)
   1f1c8:	00032138 	.word	0x00032138
   1f1cc:	00032484 	.word	0x00032484

0001f1d0 <_exit>:
   1f1d0:	e7fe      	b.n	1f1d0 <_exit>

Disassembly of section .fini:

0001f1d4 <_fini>:
   1f1d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1f1d6:	46c0      	nop			; (mov r8, r8)
   1f1d8:	bcf8      	pop	{r3, r4, r5, r6, r7}
   1f1da:	bc08      	pop	{r3}
   1f1dc:	469e      	mov	lr, r3
   1f1de:	4770      	bx	lr
